!function(g){var I={};function C(n){if(I[n])return I[n].exports;var c=I[n]={i:n,l:!1,exports:{}};return g[n].call(c.exports,c,c.exports,C),c.l=!0,c.exports}C.m=g,C.c=I,C.d=function(g,I,n){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(C.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var c in g)C.d(n,c,function(I){return g[I]}.bind(null,c));return n},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="/dist/",C(C.s=19)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "l", function() { return /* reexport */ shared_esm_bundler["M" /* toDisplayString */]; });\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ Fragment; });\n__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ createBlock; });\n__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ createCommentVNode; });\n__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ createTextVNode; });\n__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ createVNode; });\n__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ h; });\n__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ openBlock; });\n__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ renderList; });\n__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ renderSlot; });\n__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ resolveComponent; });\n__webpack_require__.d(__webpack_exports__, "o", function() { return /* reexport */ withCtx; });\n__webpack_require__.d(__webpack_exports__, "p", function() { return /* reexport */ withDirectives; });\n__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ runtime_dom_esm_bundler_createApp; });\n__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ vModelText; });\n__webpack_require__.d(__webpack_exports__, "n", function() { return /* reexport */ vShow; });\n__webpack_require__.d(__webpack_exports__, "q", function() { return /* reexport */ withKeys; });\n__webpack_require__.d(__webpack_exports__, "r", function() { return /* reexport */ withModifiers; });\n\n// UNUSED EXPORTS: customRef, isProxy, isReactive, isReadonly, isRef, markRaw, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, camelize, capitalize, toHandlerKey, BaseTransition, Comment, KeepAlive, Static, Suspense, Teleport, Text, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, computed, createHydrationRenderer, createRenderer, createSlots, createStaticVNode, defineAsyncComponent, defineComponent, defineEmit, defineProps, devtools, getCurrentInstance, getTransitionRawChildren, handleError, initCustomFormatter, inject, isRuntimeOnly, isVNode, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, resolveDirective, resolveDynamicComponent, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useContext, useSSRContext, useTransitionState, version, warn, watch, watchEffect, withScopeId, Transition, TransitionGroup, createSSRApp, hydrate, render, useCssModule, useCssVars, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, compile\n\n// NAMESPACE OBJECT: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\nvar runtime_dom_esm_bundler_namespaceObject = {};\n__webpack_require__.r(runtime_dom_esm_bundler_namespaceObject);\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "customRef", function() { return customRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isProxy", function() { return isProxy; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isReactive", function() { return isReactive; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isReadonly", function() { return reactivity_esm_bundler_isReadonly; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isRef", function() { return isRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "markRaw", function() { return markRaw; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "proxyRefs", function() { return proxyRefs; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "reactive", function() { return reactive; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "readonly", function() { return readonly; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "ref", function() { return reactivity_esm_bundler_ref; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "shallowReactive", function() { return shallowReactive; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "shallowReadonly", function() { return shallowReadonly; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "shallowRef", function() { return shallowRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toRaw", function() { return toRaw; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toRef", function() { return toRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toRefs", function() { return toRefs; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "triggerRef", function() { return triggerRef; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "unref", function() { return unref; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "camelize", function() { return shared_esm_bundler["f" /* camelize */]; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "capitalize", function() { return shared_esm_bundler["g" /* capitalize */]; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toDisplayString", function() { return shared_esm_bundler["M" /* toDisplayString */]; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toHandlerKey", function() { return shared_esm_bundler["N" /* toHandlerKey */]; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "BaseTransition", function() { return BaseTransition; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Comment", function() { return Comment; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Fragment", function() { return Fragment; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "KeepAlive", function() { return KeepAlive; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Static", function() { return Static; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Suspense", function() { return Suspense; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Teleport", function() { return Teleport; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Text", function() { return Text; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "callWithAsyncErrorHandling", function() { return callWithAsyncErrorHandling; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "callWithErrorHandling", function() { return callWithErrorHandling; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "cloneVNode", function() { return cloneVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "computed", function() { return runtime_core_esm_bundler_computed; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createBlock", function() { return createBlock; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createCommentVNode", function() { return createCommentVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createHydrationRenderer", function() { return createHydrationRenderer; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createRenderer", function() { return createRenderer; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createSlots", function() { return createSlots; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createStaticVNode", function() { return createStaticVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createTextVNode", function() { return createTextVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createVNode", function() { return createVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "defineAsyncComponent", function() { return defineAsyncComponent; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "defineComponent", function() { return defineComponent; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "defineEmit", function() { return defineEmit; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "defineProps", function() { return defineProps; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "devtools", function() { return devtools; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "getCurrentInstance", function() { return getCurrentInstance; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "getTransitionRawChildren", function() { return getTransitionRawChildren; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "h", function() { return h; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "handleError", function() { return handleError; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "initCustomFormatter", function() { return initCustomFormatter; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "inject", function() { return inject; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isRuntimeOnly", function() { return isRuntimeOnly; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "isVNode", function() { return isVNode; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "mergeProps", function() { return mergeProps; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "nextTick", function() { return nextTick; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onActivated", function() { return onActivated; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onBeforeMount", function() { return onBeforeMount; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onBeforeUnmount", function() { return onBeforeUnmount; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onBeforeUpdate", function() { return onBeforeUpdate; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onDeactivated", function() { return onDeactivated; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onErrorCaptured", function() { return onErrorCaptured; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onMounted", function() { return onMounted; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onRenderTracked", function() { return onRenderTracked; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onRenderTriggered", function() { return onRenderTriggered; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onUnmounted", function() { return onUnmounted; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "onUpdated", function() { return onUpdated; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "openBlock", function() { return openBlock; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "popScopeId", function() { return popScopeId; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "provide", function() { return provide; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "pushScopeId", function() { return pushScopeId; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "queuePostFlushCb", function() { return queuePostFlushCb; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "registerRuntimeCompiler", function() { return registerRuntimeCompiler; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "renderList", function() { return renderList; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "renderSlot", function() { return renderSlot; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "resolveComponent", function() { return resolveComponent; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "resolveDirective", function() { return resolveDirective; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "resolveDynamicComponent", function() { return resolveDynamicComponent; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "resolveTransitionHooks", function() { return resolveTransitionHooks; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "setBlockTracking", function() { return setBlockTracking; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "setDevtoolsHook", function() { return setDevtoolsHook; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "setTransitionHooks", function() { return setTransitionHooks; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "ssrContextKey", function() { return ssrContextKey; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "ssrUtils", function() { return ssrUtils; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "toHandlers", function() { return toHandlers; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "transformVNodeArgs", function() { return transformVNodeArgs; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useContext", function() { return useContext; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useSSRContext", function() { return useSSRContext; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useTransitionState", function() { return useTransitionState; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "version", function() { return version; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "warn", function() { return warn; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "watch", function() { return watch; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "watchEffect", function() { return watchEffect; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withCtx", function() { return withCtx; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withDirectives", function() { return withDirectives; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withScopeId", function() { return withScopeId; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "Transition", function() { return Transition; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "TransitionGroup", function() { return TransitionGroup; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createApp", function() { return runtime_dom_esm_bundler_createApp; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "createSSRApp", function() { return createSSRApp; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "hydrate", function() { return runtime_dom_esm_bundler_hydrate; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "render", function() { return runtime_dom_esm_bundler_render; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useCssModule", function() { return useCssModule; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "useCssVars", function() { return useCssVars; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelCheckbox", function() { return vModelCheckbox; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelDynamic", function() { return vModelDynamic; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelRadio", function() { return vModelRadio; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelSelect", function() { return vModelSelect; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vModelText", function() { return vModelText; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "vShow", function() { return vShow; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withKeys", function() { return withKeys; });\n__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, "withModifiers", function() { return withModifiers; });\n\n// EXTERNAL MODULE: ./node_modules/@vue/shared/dist/shared.esm-bundler.js\nvar shared_esm_bundler = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol(( false) ? undefined : \'\');\r\nconst MAP_KEY_ITERATE_KEY = Symbol(( false) ? undefined : \'\');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction reactivity_esm_bundler_effect(fn, options = shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        reactivity_esm_bundler_cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            reactivity_esm_bundler_cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction reactivity_esm_bundler_cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if (false) {}\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === "clear" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === \'length\' && Object(shared_esm_bundler["o" /* isArray */])(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === \'length\' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case "add" /* ADD */:\r\n                if (!Object(shared_esm_bundler["o" /* isArray */])(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (Object(shared_esm_bundler["t" /* isMap */])(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (Object(shared_esm_bundler["s" /* isIntegerKey */])(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get(\'length\'));\r\n                }\r\n                break;\r\n            case "delete" /* DELETE */:\r\n                if (!Object(shared_esm_bundler["o" /* isArray */])(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (Object(shared_esm_bundler["t" /* isMap */])(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case "set" /* SET */:\r\n                if (Object(shared_esm_bundler["t" /* isMap */])(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if (false) {}\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(shared_esm_bundler["D" /* isSymbol */]));\r\nconst reactivity_esm_bundler_get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n[\'includes\', \'indexOf\', \'lastIndexOf\'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, "get" /* GET */, i + \'\');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn\'t work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n[\'push\', \'pop\', \'shift\', \'unshift\', \'splice\'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === "__v_isReactive" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === "__v_isReadonly" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === "__v_raw" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = Object(shared_esm_bundler["o" /* isArray */])(target);\r\n        if (!isReadonly && targetIsArray && Object(shared_esm_bundler["l" /* hasOwn */])(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (Object(shared_esm_bundler["D" /* isSymbol */])(key)\r\n            ? builtInSymbols.has(key)\r\n            : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, "get" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !Object(shared_esm_bundler["s" /* isIntegerKey */])(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (Object(shared_esm_bundler["v" /* isObject */])(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst reactivity_esm_bundler_set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!Object(shared_esm_bundler["o" /* isArray */])(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = Object(shared_esm_bundler["o" /* isArray */])(target) && Object(shared_esm_bundler["s" /* isIntegerKey */])(key)\r\n            ? Number(key) < target.length\r\n            : Object(shared_esm_bundler["l" /* hasOwn */])(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don\'t trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, "add" /* ADD */, key, value);\r\n            }\r\n            else if (Object(shared_esm_bundler["k" /* hasChanged */])(value, oldValue)) {\r\n                trigger(target, "set" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = Object(shared_esm_bundler["l" /* hasOwn */])(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction reactivity_esm_bundler_has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!Object(shared_esm_bundler["D" /* isSymbol */])(key) || !builtInSymbols.has(key)) {\r\n        track(target, "has" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, "iterate" /* ITERATE */, Object(shared_esm_bundler["o" /* isArray */])(target) ? \'length\' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get: reactivity_esm_bundler_get,\r\n    set: reactivity_esm_bundler_set,\r\n    deleteProperty,\r\n    has: reactivity_esm_bundler_has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((false)) {}\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((false)) {}\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = Object(shared_esm_bundler["i" /* extend */])({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = Object(shared_esm_bundler["i" /* extend */])({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => Object(shared_esm_bundler["v" /* isObject */])(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => Object(shared_esm_bundler["v" /* isObject */])(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target["__v_raw" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, "get" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, "get" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this["__v_raw" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, "has" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target["__v_raw" /* RAW */];\r\n    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, \'size\', target);\r\n}\r\nfunction reactivity_esm_bundler_add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, "add" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((false)) {}\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, "add" /* ADD */, key, value);\r\n    }\r\n    else if (Object(shared_esm_bundler["k" /* hasChanged */])(value, oldValue)) {\r\n        trigger(target, "set" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((false)) {}\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = ( false)\r\n        ? undefined\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed["__v_raw" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this["__v_raw" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = Object(shared_esm_bundler["t" /* isMap */])(rawTarget);\r\n        const isPair = method === \'entries\' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === \'keys\' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((false)) {}\r\n        return type === "delete" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add: reactivity_esm_bundler_add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add: reactivity_esm_bundler_add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod("add" /* ADD */),\r\n    set: createReadonlyMethod("set" /* SET */),\r\n    delete: createReadonlyMethod("delete" /* DELETE */),\r\n    clear: createReadonlyMethod("clear" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = [\'keys\', \'values\', \'entries\', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === "__v_isReactive" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === "__v_isReadonly" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === "__v_raw" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(Object(shared_esm_bundler["l" /* hasOwn */])(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = Object(shared_esm_bundler["P" /* toRawType */])(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case \'Object\':\r\n        case \'Array\':\r\n            return 1 /* COMMON */;\r\n        case \'Map\':\r\n        case \'Set\':\r\n        case \'WeakMap\':\r\n        case \'WeakSet\':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(Object(shared_esm_bundler["P" /* toRawType */])(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target["__v_isReadonly" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!Object(shared_esm_bundler["v" /* isObject */])(target)) {\r\n        if ((false)) {}\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target["__v_raw" /* RAW */] &&\r\n        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (reactivity_esm_bundler_isReadonly(value)) {\r\n        return isReactive(value["__v_raw" /* RAW */]);\r\n    }\r\n    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);\r\n}\r\nfunction reactivity_esm_bundler_isReadonly(value) {\r\n    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || reactivity_esm_bundler_isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed["__v_raw" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    Object(shared_esm_bundler["h" /* def */])(value, "__v_skip" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => Object(shared_esm_bundler["v" /* isObject */])(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction reactivity_esm_bundler_ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass reactivity_esm_bundler_RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), "get" /* GET */, \'value\');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (Object(shared_esm_bundler["k" /* hasChanged */])(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), "set" /* SET */, \'value\', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new reactivity_esm_bundler_RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), "set" /* SET */, \'value\', ( false) ? undefined : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, "get" /* GET */, \'value\'), () => trigger(this, "set" /* SET */, \'value\'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if (false) {}\r\n    const ret = Object(shared_esm_bundler["o" /* isArray */])(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = reactivity_esm_bundler_effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), "set" /* SET */, \'value\');\r\n                }\r\n            }\r\n        });\r\n        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        if (this._dirty) {\r\n            this._value = this.effect();\r\n            this._dirty = false;\r\n        }\r\n        track(toRaw(this), "get" /* GET */, \'value\');\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction reactivity_esm_bundler_computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = ( false)\r\n            ? undefined\r\n            : shared_esm_bundler["d" /* NOOP */];\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, Object(shared_esm_bundler["p" /* isFunction */])(getterOrOptions) || !getterOrOptions.set);\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\n\n\n\n\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(\'\'),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join(\'\\n\'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can\'t just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (Object(shared_esm_bundler["C" /* isString */])(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === \'number\' ||\r\n        typeof value === \'boolean\' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    ["bc" /* BEFORE_CREATE */]: \'beforeCreate hook\',\r\n    ["c" /* CREATED */]: \'created hook\',\r\n    ["bm" /* BEFORE_MOUNT */]: \'beforeMount hook\',\r\n    ["m" /* MOUNTED */]: \'mounted hook\',\r\n    ["bu" /* BEFORE_UPDATE */]: \'beforeUpdate hook\',\r\n    ["u" /* UPDATED */]: \'updated\',\r\n    ["bum" /* BEFORE_UNMOUNT */]: \'beforeUnmount hook\',\r\n    ["um" /* UNMOUNTED */]: \'unmounted hook\',\r\n    ["a" /* ACTIVATED */]: \'activated hook\',\r\n    ["da" /* DEACTIVATED */]: \'deactivated hook\',\r\n    ["ec" /* ERROR_CAPTURED */]: \'errorCaptured hook\',\r\n    ["rtc" /* RENDER_TRACKED */]: \'renderTracked hook\',\r\n    ["rtg" /* RENDER_TRIGGERED */]: \'renderTriggered hook\',\r\n    [0 /* SETUP_FUNCTION */]: \'setup function\',\r\n    [1 /* RENDER_FUNCTION */]: \'render function\',\r\n    [2 /* WATCH_GETTER */]: \'watcher getter\',\r\n    [3 /* WATCH_CALLBACK */]: \'watcher callback\',\r\n    [4 /* WATCH_CLEANUP */]: \'watcher cleanup function\',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: \'native event handler\',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: \'component event handler\',\r\n    [7 /* VNODE_HOOK */]: \'vnode hook\',\r\n    [8 /* DIRECTIVE_HOOK */]: \'directive hook\',\r\n    [9 /* TRANSITION_HOOK */]: \'transition hook\',\r\n    [10 /* APP_ERROR_HANDLER */]: \'app errorHandler\',\r\n    [11 /* APP_WARN_HANDLER */]: \'app warnHandler\',\r\n    [12 /* FUNCTION_REF */]: \'ref function\',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: \'async component loader\',\r\n    [14 /* SCHEDULER */]: \'scheduler flush. This is likely a Vue internals bug. \' +\r\n        \'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next\'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && Object(shared_esm_bundler["x" /* isPromise */])(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = ( false) ? undefined : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((false)) {}\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job\'s id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(job) {\r\n    // the start index should be `flushIndex + 1`\r\n    let start = flushIndex + 1;\r\n    let end = queue.length;\r\n    const jobId = getId(job);\r\n    while (start < end) {\r\n        const middle = (start + end) >>> 1;\r\n        const middleJobId = getId(queue[middle]);\r\n        middleJobId < jobId ? (start = middle + 1) : (end = middle);\r\n    }\r\n    return start;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user\'s responsibility to\r\n    // ensure it doesn\'t end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        const pos = findInsertionIndex(job);\r\n        if (pos > -1) {\r\n            queue.splice(pos, 0, job);\r\n        }\r\n        else {\r\n            queue.push(job);\r\n        }\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction invalidateJob(job) {\r\n    const i = queue.indexOf(job);\r\n    if (i > -1) {\r\n        queue.splice(i, 1);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!Object(shared_esm_bundler["o" /* isArray */])(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((false)) {}\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((false)) {}\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((false)) {}\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((false)) {}\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((false)) {}\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component\'s update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((false)) {}\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\n\n/* eslint-disable no-restricted-globals */\r\nlet isHmrUpdating = false;\r\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((false)) {}\r\nconst map = new Map();\r\nfunction registerHMR(instance) {\r\n    const id = instance.type.__hmrId;\r\n    let record = map.get(id);\r\n    if (!record) {\r\n        createRecord(id, instance.type);\r\n        record = map.get(id);\r\n    }\r\n    record.instances.add(instance);\r\n}\r\nfunction unregisterHMR(instance) {\r\n    map.get(instance.type.__hmrId).instances.delete(instance);\r\n}\r\nfunction createRecord(id, component) {\r\n    if (!component) {\r\n        warn(`HMR API usage is out of date.\\n` +\r\n            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +\r\n            `dependency that handles Vue SFC compilation.`);\r\n        component = {};\r\n    }\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        component: isClassComponent(component) ? component.__vccOpts : component,\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    if (newRender)\r\n        record.component.render = newRender;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record.instances).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        // this flag forces child components with slot content to update\r\n        isHmrUpdating = true;\r\n        instance.update();\r\n        isHmrUpdating = false;\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    const { component, instances } = record;\r\n    if (!hmrDirtyComponents.has(component)) {\r\n        // 1. Update existing comp definition to match new one\r\n        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n        Object(shared_esm_bundler["i" /* extend */])(component, newComp);\r\n        for (const key in component) {\r\n            if (!(key in newComp)) {\r\n                delete component[key];\r\n            }\r\n        }\r\n        // 2. Mark component dirty. This forces the renderer to replace the component\r\n        // on patch.\r\n        hmrDirtyComponents.add(component);\r\n        // 3. Make sure to unmark the component after the reload.\r\n        queuePostFlushCb(() => {\r\n            hmrDirtyComponents.delete(component);\r\n        });\r\n    }\r\n    Array.from(instances).forEach(instance => {\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don\'t end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== \'undefined\') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn(\'[HMR] Root or manually mounted instance modified. Full reload required.\');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\n\nlet devtools;\r\nfunction setDevtoolsHook(hook) {\r\n    devtools = hook;\r\n}\r\nfunction devtoolsInitApp(app, version) {\r\n    // TODO queue if devtools is undefined\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit("app:init" /* APP_INIT */, app, version, {\r\n        Fragment,\r\n        Text,\r\n        Comment,\r\n        Static\r\n    });\r\n}\r\nfunction devtoolsUnmountApp(app) {\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit("app:unmount" /* APP_UNMOUNT */, app);\r\n}\r\nconst devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);\r\nconst devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);\r\nconst devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);\r\nfunction createDevtoolsComponentHook(hook) {\r\n    return (component) => {\r\n        if (!devtools)\r\n            return;\r\n        devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);\r\n    };\r\n}\r\nfunction devtoolsComponentEmit(component, event, params) {\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\r\n}\n\nfunction runtime_core_esm_bundler_emit(instance, event, ...rawArgs) {\r\n    const props = instance.vnode.props || shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n    if ((false)) {}\r\n    let args = rawArgs;\r\n    const isModelListener = event.startsWith(\'update:\');\r\n    // for v-model update:xxx events, apply modifiers on args\r\n    const modelArg = isModelListener && event.slice(7);\r\n    if (modelArg && modelArg in props) {\r\n        const modifiersKey = `${modelArg === \'modelValue\' ? \'model\' : modelArg}Modifiers`;\r\n        const { number, trim } = props[modifiersKey] || shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        if (trim) {\r\n            args = rawArgs.map(a => a.trim());\r\n        }\r\n        else if (number) {\r\n            args = rawArgs.map(shared_esm_bundler["O" /* toNumber */]);\r\n        }\r\n    }\r\n    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n        devtoolsComponentEmit(instance, event, args);\r\n    }\r\n    if ((false)) {}\r\n    // convert handler name to camelCase. See issue #2249\r\n    let handlerName = Object(shared_esm_bundler["N" /* toHandlerKey */])(Object(shared_esm_bundler["f" /* camelize */])(event));\r\n    let handler = props[handlerName];\r\n    // for v-model update:xxx events, also trigger kebab-case equivalent\r\n    // for props passed via kebab-case\r\n    if (!handler && isModelListener) {\r\n        handlerName = Object(shared_esm_bundler["N" /* toHandlerKey */])(Object(shared_esm_bundler["m" /* hyphenate */])(event));\r\n        handler = props[handlerName];\r\n    }\r\n    if (handler) {\r\n        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n    const onceHandler = props[handlerName + `Once`];\r\n    if (onceHandler) {\r\n        if (!instance.emitted) {\r\n            (instance.emitted = {})[handlerName] = true;\r\n        }\r\n        else if (instance.emitted[handlerName]) {\r\n            return;\r\n        }\r\n        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n}\r\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__emits !== undefined) {\r\n        return comp.__emits;\r\n    }\r\n    const raw = comp.emits;\r\n    let normalized = {};\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !Object(shared_esm_bundler["p" /* isFunction */])(comp)) {\r\n        const extendEmits = (raw) => {\r\n            hasExtends = true;\r\n            Object(shared_esm_bundler["i" /* extend */])(normalized, normalizeEmitsOptions(raw, appContext, true));\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendEmits);\r\n        }\r\n        if (comp.extends) {\r\n            extendEmits(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendEmits);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__emits = null);\r\n    }\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(raw)) {\r\n        raw.forEach(key => (normalized[key] = null));\r\n    }\r\n    else {\r\n        Object(shared_esm_bundler["i" /* extend */])(normalized, raw);\r\n    }\r\n    return (comp.__emits = normalized);\r\n}\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nfunction isEmitListener(options, key) {\r\n    if (!options || !Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n        return false;\r\n    }\r\n    key = key.slice(2).replace(/Once$/, \'\');\r\n    return (Object(shared_esm_bundler["l" /* hasOwn */])(options, key[0].toLowerCase() + key.slice(1)) ||\r\n        Object(shared_esm_bundler["l" /* hasOwn */])(options, Object(shared_esm_bundler["m" /* hyphenate */])(key)) ||\r\n        Object(shared_esm_bundler["l" /* hasOwn */])(options, key));\r\n}\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nfunction setCurrentRenderingInstance(instance) {\r\n    currentRenderingInstance = instance;\r\n}\r\n/**\r\n * dev only flag to track whether $attrs was used during render.\r\n * If $attrs was used during render then the warning for failed attrs\r\n * fallthrough can be suppressed.\r\n */\r\nlet accessedAttrs = false;\r\nfunction markAttrsAccessed() {\r\n    accessedAttrs = true;\r\n}\r\nfunction renderComponentRoot(instance) {\r\n    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx } = instance;\r\n    let result;\r\n    currentRenderingInstance = instance;\r\n    if ((false)) {}\r\n    try {\r\n        let fallthroughAttrs;\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            // withProxy is a proxy with a different `has` trap only for\r\n            // runtime-compiled render functions using `with` block.\r\n            const proxyToUse = withProxy || proxy;\r\n            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\r\n            fallthroughAttrs = attrs;\r\n        }\r\n        else {\r\n            // functional\r\n            const render = Component;\r\n            // in dev, mark attrs accessed if optional props (attrs === props)\r\n            if (false) {}\r\n            result = normalizeVNode(render.length > 1\r\n                ? render(props, ( false)\r\n                    ? undefined\r\n                    : { attrs, slots, emit })\r\n                : render(props, null /* we know it doesn\'t need it */));\r\n            fallthroughAttrs = Component.props\r\n                ? attrs\r\n                : getFunctionalFallthrough(attrs);\r\n        }\r\n        // attr merging\r\n        // in dev mode, comments are preserved, and it\'s possible for a template\r\n        // to have comments along side the root element which makes it a fragment\r\n        let root = result;\r\n        let setRoot = undefined;\r\n        if (false /* DEV_ROOT_FRAGMENT */) {}\r\n        if (Component.inheritAttrs !== false && fallthroughAttrs) {\r\n            const keys = Object.keys(fallthroughAttrs);\r\n            const { shapeFlag } = root;\r\n            if (keys.length) {\r\n                if (shapeFlag & 1 /* ELEMENT */ ||\r\n                    shapeFlag & 6 /* COMPONENT */) {\r\n                    if (propsOptions && keys.some(shared_esm_bundler["u" /* isModelListener */])) {\r\n                        // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n                        // prop, it indicates this component expects to handle v-model and\r\n                        // it should not fallthrough.\r\n                        // related: #1543, #1643, #1989\r\n                        fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\r\n                    }\r\n                    root = cloneVNode(root, fallthroughAttrs);\r\n                }\r\n                else if (false) {}\r\n            }\r\n        }\r\n        // inherit directives\r\n        if (vnode.dirs) {\r\n            if (false) {}\r\n            root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\r\n        }\r\n        // inherit transition data\r\n        if (vnode.transition) {\r\n            if (false) {}\r\n            root.transition = vnode.transition;\r\n        }\r\n        if (false) {}\r\n        else {\r\n            result = root;\r\n        }\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, 1 /* RENDER_FUNCTION */);\r\n        result = createVNode(Comment);\r\n    }\r\n    currentRenderingInstance = null;\r\n    return result;\r\n}\r\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\r\nconst getChildRoot = (vnode) => {\r\n    const rawChildren = vnode.children;\r\n    const dynamicChildren = vnode.dynamicChildren;\r\n    const childRoot = filterSingleRoot(rawChildren);\r\n    if (!childRoot) {\r\n        return [vnode, undefined];\r\n    }\r\n    const index = rawChildren.indexOf(childRoot);\r\n    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\r\n    const setRoot = (updatedRoot) => {\r\n        rawChildren[index] = updatedRoot;\r\n        if (dynamicChildren) {\r\n            if (dynamicIndex > -1) {\r\n                dynamicChildren[dynamicIndex] = updatedRoot;\r\n            }\r\n            else if (updatedRoot.patchFlag > 0) {\r\n                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\r\n            }\r\n        }\r\n    };\r\n    return [normalizeVNode(childRoot), setRoot];\r\n};\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === \'v-if\') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\nconst getFunctionalFallthrough = (attrs) => {\r\n    let res;\r\n    for (const key in attrs) {\r\n        if (key === \'class\' || key === \'style\' || Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n            (res || (res = {}))[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst filterModelListeners = (attrs, props) => {\r\n    const res = {};\r\n    for (const key in attrs) {\r\n        if (!Object(shared_esm_bundler["u" /* isModelListener */])(key) || !(key.slice(9) in props)) {\r\n            res[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst isElementRoot = (vnode) => {\r\n    return (vnode.shapeFlag & 6 /* COMPONENT */ ||\r\n        vnode.shapeFlag & 1 /* ELEMENT */ ||\r\n        vnode.type === Comment // potential v-if branch switch\r\n    );\r\n};\r\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\r\n    const { props: prevProps, children: prevChildren, component } = prevVNode;\r\n    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\r\n    const emits = component.emitsOptions;\r\n    // Parent component\'s render function was hot-updated. Since this may have\r\n    // caused the child component\'s slots content to have changed, we need to\r\n    // force the child to update as well.\r\n    if (false) {}\r\n    // force child update for runtime directive or transition on component vnode.\r\n    if (nextVNode.dirs || nextVNode.transition) {\r\n        return true;\r\n    }\r\n    if (optimized && patchFlag >= 0) {\r\n        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n            // slot content that references values that might have changed,\r\n            // e.g. in a v-for\r\n            return true;\r\n        }\r\n        if (patchFlag & 16 /* FULL_PROPS */) {\r\n            if (!prevProps) {\r\n                return !!nextProps;\r\n            }\r\n            // presence of this flag indicates props are always non-null\r\n            return hasPropsChanged(prevProps, nextProps, emits);\r\n        }\r\n        else if (patchFlag & 8 /* PROPS */) {\r\n            const dynamicProps = nextVNode.dynamicProps;\r\n            for (let i = 0; i < dynamicProps.length; i++) {\r\n                const key = dynamicProps[i];\r\n                if (nextProps[key] !== prevProps[key] &&\r\n                    !isEmitListener(emits, key)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // this path is only taken by manually written render functions\r\n        // so presence of any children leads to a forced update\r\n        if (prevChildren || nextChildren) {\r\n            if (!nextChildren || !nextChildren.$stable) {\r\n                return true;\r\n            }\r\n        }\r\n        if (prevProps === nextProps) {\r\n            return false;\r\n        }\r\n        if (!prevProps) {\r\n            return !!nextProps;\r\n        }\r\n        if (!nextProps) {\r\n            return true;\r\n        }\r\n        return hasPropsChanged(prevProps, nextProps, emits);\r\n    }\r\n    return false;\r\n}\r\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\r\n    const nextKeys = Object.keys(nextProps);\r\n    if (nextKeys.length !== Object.keys(prevProps).length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < nextKeys.length; i++) {\r\n        const key = nextKeys[i];\r\n        if (nextProps[key] !== prevProps[key] &&\r\n            !isEmitListener(emitsOptions, key)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction updateHOCHostEl({ vnode, parent }, el // HostNode\r\n) {\r\n    while (parent && parent.subTree === vnode) {\r\n        (vnode = parent.vnode).el = el;\r\n        parent = parent.parent;\r\n    }\r\n}\n\nconst isSuspense = (type) => type.__isSuspense;\r\n// Suspense exposes a component-like API, and is treated like a component\r\n// in the compiler, but internally it\'s a special built-in type that hooks\r\n// directly into the renderer.\r\nconst SuspenseImpl = {\r\n    // In order to make Suspense tree-shakable, we need to avoid importing it\r\n    // directly in the renderer. The renderer checks for the __isSuspense flag\r\n    // on a vnode\'s type and calls the `process` method, passing in renderer\r\n    // internals.\r\n    __isSuspense: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, \r\n    // platform-specific impl passed from renderer\r\n    rendererInternals) {\r\n        if (n1 == null) {\r\n            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);\r\n        }\r\n        else {\r\n            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, rendererInternals);\r\n        }\r\n    },\r\n    hydrate: hydrateSuspense,\r\n    create: createSuspenseBoundary\r\n};\r\n// Force-casted public typing for h and TSX props inference\r\nconst Suspense = (SuspenseImpl\r\n    );\r\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {\r\n    const { p: patch, o: { createElement } } = rendererInternals;\r\n    const hiddenContainer = createElement(\'div\');\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals));\r\n    // start mounting the content subtree in an off-dom container\r\n    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG);\r\n    // now check if we have encountered any async deps\r\n    if (suspense.deps > 0) {\r\n        // has async\r\n        // mount the fallback tree\r\n        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n        isSVG);\r\n        setActiveBranch(suspense, vnode.ssFallback);\r\n    }\r\n    else {\r\n        // Suspense has no async deps. Just resolve.\r\n        suspense.resolve();\r\n    }\r\n}\r\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, { p: patch, um: unmount, o: { createElement } }) {\r\n    const suspense = (n2.suspense = n1.suspense);\r\n    suspense.vnode = n2;\r\n    n2.el = n1.el;\r\n    const newBranch = n2.ssContent;\r\n    const newFallback = n2.ssFallback;\r\n    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\r\n    if (pendingBranch) {\r\n        suspense.pendingBranch = newBranch;\r\n        if (isSameVNodeType(newBranch, pendingBranch)) {\r\n            // same root type but content may have changed.\r\n            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\r\n            if (suspense.deps <= 0) {\r\n                suspense.resolve();\r\n            }\r\n            else if (isInFallback) {\r\n                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG);\r\n                setActiveBranch(suspense, newFallback);\r\n            }\r\n        }\r\n        else {\r\n            // toggled before pending tree is resolved\r\n            suspense.pendingId++;\r\n            if (isHydrating) {\r\n                // if toggled before hydration is finished, the current DOM tree is\r\n                // no longer valid. set it as the active branch so it will be unmounted\r\n                // when resolved\r\n                suspense.isHydrating = false;\r\n                suspense.activeBranch = pendingBranch;\r\n            }\r\n            else {\r\n                unmount(pendingBranch, parentComponent, suspense);\r\n            }\r\n            // increment pending ID. this is used to invalidate async callbacks\r\n            // reset suspense state\r\n            suspense.deps = 0;\r\n            // discard effects from pending branch\r\n            suspense.effects.length = 0;\r\n            // discard previous container\r\n            suspense.hiddenContainer = createElement(\'div\');\r\n            if (isInFallback) {\r\n                // already in fallback state\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n                else {\r\n                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                    isSVG);\r\n                    setActiveBranch(suspense, newFallback);\r\n                }\r\n            }\r\n            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n                // toggled "back" to current active branch\r\n                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG);\r\n                // force resolve\r\n                suspense.resolve(true);\r\n            }\r\n            else {\r\n                // switched to a 3rd branch\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n            // root did not change, just normal patch\r\n            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG);\r\n            setActiveBranch(suspense, newBranch);\r\n        }\r\n        else {\r\n            // root node toggled\r\n            // invoke @pending event\r\n            const onPending = n2.props && n2.props.onPending;\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(onPending)) {\r\n                onPending();\r\n            }\r\n            // mount pending branch in off-dom container\r\n            suspense.pendingBranch = newBranch;\r\n            suspense.pendingId++;\r\n            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\r\n            if (suspense.deps <= 0) {\r\n                // incoming branch has no async deps, resolve now.\r\n                suspense.resolve();\r\n            }\r\n            else {\r\n                const { timeout, pendingId } = suspense;\r\n                if (timeout > 0) {\r\n                    setTimeout(() => {\r\n                        if (suspense.pendingId === pendingId) {\r\n                            suspense.fallback(newFallback);\r\n                        }\r\n                    }, timeout);\r\n                }\r\n                else if (timeout === 0) {\r\n                    suspense.fallback(newFallback);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nlet hasWarned = false;\r\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals, isHydrating = false) {\r\n    /* istanbul ignore if */\r\n    if (false) {}\r\n    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\r\n    const timeout = Object(shared_esm_bundler["O" /* toNumber */])(vnode.props && vnode.props.timeout);\r\n    const suspense = {\r\n        vnode,\r\n        parent,\r\n        parentComponent,\r\n        isSVG,\r\n        container,\r\n        hiddenContainer,\r\n        anchor,\r\n        deps: 0,\r\n        pendingId: 0,\r\n        timeout: typeof timeout === \'number\' ? timeout : -1,\r\n        activeBranch: null,\r\n        pendingBranch: null,\r\n        isInFallback: true,\r\n        isHydrating,\r\n        isUnmounted: false,\r\n        effects: [],\r\n        resolve(resume = false) {\r\n            if ((false)) {}\r\n            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\r\n            if (suspense.isHydrating) {\r\n                suspense.isHydrating = false;\r\n            }\r\n            else if (!resume) {\r\n                const delayEnter = activeBranch &&\r\n                    pendingBranch.transition &&\r\n                    pendingBranch.transition.mode === \'out-in\';\r\n                if (delayEnter) {\r\n                    activeBranch.transition.afterLeave = () => {\r\n                        if (pendingId === suspense.pendingId) {\r\n                            move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                        }\r\n                    };\r\n                }\r\n                // this is initial anchor on mount\r\n                let { anchor } = suspense;\r\n                // unmount current active tree\r\n                if (activeBranch) {\r\n                    // if the fallback tree was mounted, it may have been moved\r\n                    // as part of a parent suspense. get the latest anchor for insertion\r\n                    anchor = next(activeBranch);\r\n                    unmount(activeBranch, parentComponent, suspense, true);\r\n                }\r\n                if (!delayEnter) {\r\n                    // move content from off-dom container to actual container\r\n                    move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                }\r\n            }\r\n            setActiveBranch(suspense, pendingBranch);\r\n            suspense.pendingBranch = null;\r\n            suspense.isInFallback = false;\r\n            // flush buffered effects\r\n            // check if there is a pending parent suspense\r\n            let parent = suspense.parent;\r\n            let hasUnresolvedAncestor = false;\r\n            while (parent) {\r\n                if (parent.pendingBranch) {\r\n                    // found a pending parent suspense, merge buffered post jobs\r\n                    // into that parent\r\n                    parent.effects.push(...effects);\r\n                    hasUnresolvedAncestor = true;\r\n                    break;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n            // no pending parent suspense, flush all jobs\r\n            if (!hasUnresolvedAncestor) {\r\n                queuePostFlushCb(effects);\r\n            }\r\n            suspense.effects = [];\r\n            // invoke @resolve event\r\n            const onResolve = vnode.props && vnode.props.onResolve;\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(onResolve)) {\r\n                onResolve();\r\n            }\r\n        },\r\n        fallback(fallbackVNode) {\r\n            if (!suspense.pendingBranch) {\r\n                return;\r\n            }\r\n            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;\r\n            // invoke @fallback event\r\n            const onFallback = vnode.props && vnode.props.onFallback;\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(onFallback)) {\r\n                onFallback();\r\n            }\r\n            const anchor = next(activeBranch);\r\n            const mountFallback = () => {\r\n                if (!suspense.isInFallback) {\r\n                    return;\r\n                }\r\n                // mount the fallback tree\r\n                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG);\r\n                setActiveBranch(suspense, fallbackVNode);\r\n            };\r\n            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === \'out-in\';\r\n            if (delayEnter) {\r\n                activeBranch.transition.afterLeave = mountFallback;\r\n            }\r\n            // unmount current active branch\r\n            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\r\n            true // shouldRemove\r\n            );\r\n            suspense.isInFallback = true;\r\n            if (!delayEnter) {\r\n                mountFallback();\r\n            }\r\n        },\r\n        move(container, anchor, type) {\r\n            suspense.activeBranch &&\r\n                move(suspense.activeBranch, container, anchor, type);\r\n            suspense.container = container;\r\n        },\r\n        next() {\r\n            return suspense.activeBranch && next(suspense.activeBranch);\r\n        },\r\n        registerDep(instance, setupRenderEffect) {\r\n            const isInPendingSuspense = !!suspense.pendingBranch;\r\n            if (isInPendingSuspense) {\r\n                suspense.deps++;\r\n            }\r\n            const hydratedEl = instance.vnode.el;\r\n            instance\r\n                .asyncDep.catch(err => {\r\n                handleError(err, instance, 0 /* SETUP_FUNCTION */);\r\n            })\r\n                .then(asyncSetupResult => {\r\n                // retry when the setup() promise resolves.\r\n                // component may have been unmounted before resolve.\r\n                if (instance.isUnmounted ||\r\n                    suspense.isUnmounted ||\r\n                    suspense.pendingId !== instance.suspenseId) {\r\n                    return;\r\n                }\r\n                // retry from this component\r\n                instance.asyncResolved = true;\r\n                const { vnode } = instance;\r\n                if ((false)) {}\r\n                handleSetupResult(instance, asyncSetupResult);\r\n                if (hydratedEl) {\r\n                    // vnode may have been replaced if an update happened before the\r\n                    // async dep is resolved.\r\n                    vnode.el = hydratedEl;\r\n                }\r\n                const placeholder = !hydratedEl && instance.subTree.el;\r\n                setupRenderEffect(instance, vnode, \r\n                // component may have been moved before resolve.\r\n                // if this is not a hydration, instance.subTree will be the comment\r\n                // placeholder.\r\n                parentNode(hydratedEl || instance.subTree.el), \r\n                // anchor will not be used if this is hydration, so only need to\r\n                // consider the comment placeholder case.\r\n                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\r\n                if (placeholder) {\r\n                    remove(placeholder);\r\n                }\r\n                updateHOCHostEl(instance, vnode.el);\r\n                if ((false)) {}\r\n                // only decrease deps count if suspense is not already resolved\r\n                if (isInPendingSuspense && --suspense.deps === 0) {\r\n                    suspense.resolve();\r\n                }\r\n            });\r\n        },\r\n        unmount(parentSuspense, doRemove) {\r\n            suspense.isUnmounted = true;\r\n            if (suspense.activeBranch) {\r\n                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n            if (suspense.pendingBranch) {\r\n                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n        }\r\n    };\r\n    return suspense;\r\n}\r\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, optimized, rendererInternals, hydrateNode) {\r\n    /* eslint-disable no-restricted-globals */\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement(\'div\'), null, isSVG, optimized, rendererInternals, true /* hydrating */));\r\n    // there are two possible scenarios for server-rendered suspense:\r\n    // - success: ssr content should be fully resolved\r\n    // - failure: ssr content should be the fallback branch.\r\n    // however, on the client we don\'t really know if it has failed or not\r\n    // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n    // need to construct a suspense boundary first\r\n    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, optimized);\r\n    if (suspense.deps === 0) {\r\n        suspense.resolve();\r\n    }\r\n    return result;\r\n    /* eslint-enable no-restricted-globals */\r\n}\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(s)) {\r\n        s = s();\r\n    }\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if (false) {}\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\nfunction setActiveBranch(suspense, branch) {\r\n    suspense.activeBranch = branch;\r\n    const { vnode, parentComponent } = suspense;\r\n    const el = (vnode.el = branch.el);\r\n    // in case suspense is the root node of a component,\r\n    // recursively update the HOC el\r\n    if (parentComponent && parentComponent.subTree === vnode) {\r\n        parentComponent.vnode.el = el;\r\n        updateHOCHostEl(parentComponent, el);\r\n    }\r\n}\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * @private\r\n */\r\nfunction renderSlot(slots, name, props = {}, \r\n// this is not a user-facing function, so the fallback is always generated by\r\n// the compiler and guaranteed to be a function returning an array\r\nfallback) {\r\n    let slot = slots[name];\r\n    if (false) {}\r\n    // a compiled slot disables block tracking by default to avoid manual\r\n    // invocation interfering with template-based block tracking, but in\r\n    // `renderSlot` we can be sure that it\'s template-based so we can force\r\n    // enable it.\r\n    isRenderingCompiledSlot++;\r\n    openBlock();\r\n    const validSlotContent = slot && ensureValidVNode(slot(props));\r\n    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */\r\n        ? 64 /* STABLE_FRAGMENT */\r\n        : -2 /* BAIL */);\r\n    isRenderingCompiledSlot--;\r\n    return rendered;\r\n}\r\nfunction ensureValidVNode(vnodes) {\r\n    return vnodes.some(child => {\r\n        if (!isVNode(child))\r\n            return true;\r\n        if (child.type === Comment)\r\n            return false;\r\n        if (child.type === Fragment &&\r\n            !ensureValidVNode(child.children))\r\n            return false;\r\n        return true;\r\n    })\r\n        ? vnodes\r\n        : null;\r\n}\n\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance) {\r\n    if (!ctx)\r\n        return fn;\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we need to push a null block to\r\n        // avoid that. This isn\'t necessary if rendering a compiled `<slot>`.\r\n        if (!isRenderingCompiledSlot) {\r\n            openBlock(true /* null block that disables tracking */);\r\n        }\r\n        const owner = currentRenderingInstance;\r\n        setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(owner);\r\n        if (!isRenderingCompiledSlot) {\r\n            closeBlock();\r\n        }\r\n        return res;\r\n    };\r\n    renderFnWithContext._c = true;\r\n    return renderFnWithContext;\r\n}\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\nconst scopeIdStack = [];\r\n/**\r\n * @private\r\n */\r\nfunction pushScopeId(id) {\r\n    scopeIdStack.push((currentScopeId = id));\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    scopeIdStack.pop();\r\n    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction withScopeId(id) {\r\n    return ((fn) => withCtx(function () {\r\n        pushScopeId(id);\r\n        const res = fn.apply(this, arguments);\r\n        popScopeId();\r\n        return res;\r\n    }));\r\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\r\nisSSR = false) {\r\n    const props = {};\r\n    const attrs = {};\r\n    Object(shared_esm_bundler["h" /* def */])(attrs, InternalObjectKey, 1);\r\n    setFullProps(instance, rawProps, props, attrs);\r\n    // validation\r\n    if ((false)) {}\r\n    if (isStateful) {\r\n        // stateful\r\n        instance.props = isSSR ? props : shallowReactive(props);\r\n    }\r\n    else {\r\n        if (!instance.type.props) {\r\n            // functional w/ optional props, props === attrs\r\n            instance.props = attrs;\r\n        }\r\n        else {\r\n            // functional w/ declared props\r\n            instance.props = props;\r\n        }\r\n    }\r\n    instance.attrs = attrs;\r\n}\r\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\r\n    const { props, attrs, vnode: { patchFlag } } = instance;\r\n    const rawCurrentProps = toRaw(props);\r\n    const [options] = instance.propsOptions;\r\n    if (\r\n    // always force full diff in dev\r\n    // - #1942 if hmr is enabled with sfc component\r\n    // - vite#872 non-sfc component used by sfc component\r\n     true &&\r\n        (optimized || patchFlag > 0) &&\r\n        !(patchFlag & 16 /* FULL_PROPS */)) {\r\n        if (patchFlag & 8 /* PROPS */) {\r\n            // Compiler-generated props & no keys change, just set the updated\r\n            // the props.\r\n            const propsToUpdate = instance.vnode.dynamicProps;\r\n            for (let i = 0; i < propsToUpdate.length; i++) {\r\n                const key = propsToUpdate[i];\r\n                // PROPS flag guarantees rawProps to be non-null\r\n                const value = rawProps[key];\r\n                if (options) {\r\n                    // attr / props separation was done on init and will be consistent\r\n                    // in this code path, so just check if attrs have it.\r\n                    if (Object(shared_esm_bundler["l" /* hasOwn */])(attrs, key)) {\r\n                        attrs[key] = value;\r\n                    }\r\n                    else {\r\n                        const camelizedKey = Object(shared_esm_bundler["f" /* camelize */])(key);\r\n                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance);\r\n                    }\r\n                }\r\n                else {\r\n                    attrs[key] = value;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // full props update.\r\n        setFullProps(instance, rawProps, props, attrs);\r\n        // in case of dynamic props, check if we need to delete keys from\r\n        // the props object\r\n        let kebabKey;\r\n        for (const key in rawCurrentProps) {\r\n            if (!rawProps ||\r\n                // for camelCase\r\n                (!Object(shared_esm_bundler["l" /* hasOwn */])(rawProps, key) &&\r\n                    // it\'s possible the original props was passed in as kebab-case\r\n                    // and converted to camelCase (#955)\r\n                    ((kebabKey = Object(shared_esm_bundler["m" /* hyphenate */])(key)) === key || !Object(shared_esm_bundler["l" /* hasOwn */])(rawProps, kebabKey)))) {\r\n                if (options) {\r\n                    if (rawPrevProps &&\r\n                        // for camelCase\r\n                        (rawPrevProps[key] !== undefined ||\r\n                            // for kebab-case\r\n                            rawPrevProps[kebabKey] !== undefined)) {\r\n                        props[key] = resolvePropValue(options, rawProps || shared_esm_bundler["b" /* EMPTY_OBJ */], key, undefined, instance);\r\n                    }\r\n                }\r\n                else {\r\n                    delete props[key];\r\n                }\r\n            }\r\n        }\r\n        // in the case of functional component w/o props declaration, props and\r\n        // attrs point to the same object so it should already have been updated.\r\n        if (attrs !== rawCurrentProps) {\r\n            for (const key in attrs) {\r\n                if (!rawProps || !Object(shared_esm_bundler["l" /* hasOwn */])(rawProps, key)) {\r\n                    delete attrs[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // trigger updates for $attrs in case it\'s used in component slots\r\n    trigger(instance, "set" /* SET */, \'$attrs\');\r\n    if (false) {}\r\n}\r\nfunction setFullProps(instance, rawProps, props, attrs) {\r\n    const [options, needCastKeys] = instance.propsOptions;\r\n    if (rawProps) {\r\n        for (const key in rawProps) {\r\n            const value = rawProps[key];\r\n            // key, ref are reserved and never passed down\r\n            if (Object(shared_esm_bundler["y" /* isReservedProp */])(key)) {\r\n                continue;\r\n            }\r\n            // prop option names are camelized during normalization, so to support\r\n            // kebab -> camel conversion here we need to camelize the key.\r\n            let camelKey;\r\n            if (options && Object(shared_esm_bundler["l" /* hasOwn */])(options, (camelKey = Object(shared_esm_bundler["f" /* camelize */])(key)))) {\r\n                props[camelKey] = value;\r\n            }\r\n            else if (!isEmitListener(instance.emitsOptions, key)) {\r\n                // Any non-declared (either as a prop or an emitted event) props are put\r\n                // into a separate `attrs` object for spreading. Make sure to preserve\r\n                // original key casing\r\n                attrs[key] = value;\r\n            }\r\n        }\r\n    }\r\n    if (needCastKeys) {\r\n        const rawCurrentProps = toRaw(props);\r\n        for (let i = 0; i < needCastKeys.length; i++) {\r\n            const key = needCastKeys[i];\r\n            props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);\r\n        }\r\n    }\r\n}\r\nfunction resolvePropValue(options, props, key, value, instance) {\r\n    const opt = options[key];\r\n    if (opt != null) {\r\n        const hasDefault = Object(shared_esm_bundler["l" /* hasOwn */])(opt, \'default\');\r\n        // default values\r\n        if (hasDefault && value === undefined) {\r\n            const defaultValue = opt.default;\r\n            if (opt.type !== Function && Object(shared_esm_bundler["p" /* isFunction */])(defaultValue)) {\r\n                setCurrentInstance(instance);\r\n                value = defaultValue(props);\r\n                setCurrentInstance(null);\r\n            }\r\n            else {\r\n                value = defaultValue;\r\n            }\r\n        }\r\n        // boolean casting\r\n        if (opt[0 /* shouldCast */]) {\r\n            if (!Object(shared_esm_bundler["l" /* hasOwn */])(props, key) && !hasDefault) {\r\n                value = false;\r\n            }\r\n            else if (opt[1 /* shouldCastTrue */] &&\r\n                (value === \'\' || value === Object(shared_esm_bundler["m" /* hyphenate */])(key))) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__props) {\r\n        return comp.__props;\r\n    }\r\n    const raw = comp.props;\r\n    const normalized = {};\r\n    const needCastKeys = [];\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !Object(shared_esm_bundler["p" /* isFunction */])(comp)) {\r\n        const extendProps = (raw) => {\r\n            hasExtends = true;\r\n            const [props, keys] = normalizePropsOptions(raw, appContext, true);\r\n            Object(shared_esm_bundler["i" /* extend */])(normalized, props);\r\n            if (keys)\r\n                needCastKeys.push(...keys);\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendProps);\r\n        }\r\n        if (comp.extends) {\r\n            extendProps(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendProps);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__props = shared_esm_bundler["a" /* EMPTY_ARR */]);\r\n    }\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(raw)) {\r\n        for (let i = 0; i < raw.length; i++) {\r\n            if (false) {}\r\n            const normalizedKey = Object(shared_esm_bundler["f" /* camelize */])(raw[i]);\r\n            if (validatePropName(normalizedKey)) {\r\n                normalized[normalizedKey] = shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n            }\r\n        }\r\n    }\r\n    else if (raw) {\r\n        if (false) {}\r\n        for (const key in raw) {\r\n            const normalizedKey = Object(shared_esm_bundler["f" /* camelize */])(key);\r\n            if (validatePropName(normalizedKey)) {\r\n                const opt = raw[key];\r\n                const prop = (normalized[normalizedKey] =\r\n                    Object(shared_esm_bundler["o" /* isArray */])(opt) || Object(shared_esm_bundler["p" /* isFunction */])(opt) ? { type: opt } : opt);\r\n                if (prop) {\r\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                    const stringIndex = getTypeIndex(String, prop.type);\r\n                    prop[0 /* shouldCast */] = booleanIndex > -1;\r\n                    prop[1 /* shouldCastTrue */] =\r\n                        stringIndex < 0 || booleanIndex < stringIndex;\r\n                    // if the prop needs boolean casting or default value\r\n                    if (booleanIndex > -1 || Object(shared_esm_bundler["l" /* hasOwn */])(prop, \'default\')) {\r\n                        needCastKeys.push(normalizedKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (comp.__props = [normalized, needCastKeys]);\r\n}\r\nfunction validatePropName(key) {\r\n    if (key[0] !== \'$\') {\r\n        return true;\r\n    }\r\n    else if ((false)) {}\r\n    return false;\r\n}\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor) {\r\n    const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n    return match ? match[1] : \'\';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(expectedTypes)) {\r\n        for (let i = 0, len = expectedTypes.length; i < len; i++) {\r\n            if (isSameType(expectedTypes[i], type)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProps(props, instance) {\r\n    const rawValues = toRaw(props);\r\n    const options = instance.propsOptions[0];\r\n    for (const key in options) {\r\n        let opt = options[key];\r\n        if (opt == null)\r\n            continue;\r\n        validateProp(key, rawValues[key], opt, !Object(shared_esm_bundler["l" /* hasOwn */])(rawValues, key));\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProp(name, value, prop, isAbsent) {\r\n    const { type, required, validator } = prop;\r\n    // required!\r\n    if (required && isAbsent) {\r\n        warn(\'Missing required prop: "\' + name + \'"\');\r\n        return;\r\n    }\r\n    // missing but optional\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    // type check\r\n    if (type != null && type !== true) {\r\n        let isValid = false;\r\n        const types = Object(shared_esm_bundler["o" /* isArray */])(type) ? type : [type];\r\n        const expectedTypes = [];\r\n        // value is valid as long as one of the specified types match\r\n        for (let i = 0; i < types.length && !isValid; i++) {\r\n            const { valid, expectedType } = assertType(value, types[i]);\r\n            expectedTypes.push(expectedType || \'\');\r\n            isValid = valid;\r\n        }\r\n        if (!isValid) {\r\n            warn(getInvalidTypeMessage(name, value, expectedTypes));\r\n            return;\r\n        }\r\n    }\r\n    // custom validator\r\n    if (validator && !validator(value)) {\r\n        warn(\'Invalid prop: custom validator check failed for prop "\' + name + \'".\');\r\n    }\r\n}\r\nconst isSimpleType = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'String,Number,Boolean,Function,Symbol,BigInt\');\r\n/**\r\n * dev only\r\n */\r\nfunction assertType(value, type) {\r\n    let valid;\r\n    const expectedType = getType(type);\r\n    if (isSimpleType(expectedType)) {\r\n        const t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === \'object\') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === \'Object\') {\r\n        valid = Object(shared_esm_bundler["v" /* isObject */])(value);\r\n    }\r\n    else if (expectedType === \'Array\') {\r\n        valid = Object(shared_esm_bundler["o" /* isArray */])(value);\r\n    }\r\n    else {\r\n        valid = value instanceof type;\r\n    }\r\n    return {\r\n        valid,\r\n        expectedType\r\n    };\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    let message = `Invalid prop: type check failed for prop "${name}".` +\r\n        ` Expected ${expectedTypes.map(shared_esm_bundler["g" /* capitalize */]).join(\', \')}`;\r\n    const expectedType = expectedTypes[0];\r\n    const receivedType = Object(shared_esm_bundler["P" /* toRawType */])(value);\r\n    const expectedValue = styleValue(value, expectedType);\r\n    const receivedValue = styleValue(value, receivedType);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        !runtime_core_esm_bundler_isBoolean(expectedType, receivedType)) {\r\n        message += ` with value ${expectedValue}`;\r\n    }\r\n    message += `, got ${receivedType} `;\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += `with value ${receivedValue}.`;\r\n    }\r\n    return message;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction styleValue(value, type) {\r\n    if (type === \'String\') {\r\n        return `"${value}"`;\r\n    }\r\n    else if (type === \'Number\') {\r\n        return `${Number(value)}`;\r\n    }\r\n    else {\r\n        return `${value}`;\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isExplicable(type) {\r\n    const explicitTypes = [\'string\', \'number\', \'boolean\'];\r\n    return explicitTypes.some(elem => type.toLowerCase() === elem);\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction runtime_core_esm_bundler_isBoolean(...args) {\r\n    return args.some(elem => elem.toLowerCase() === \'boolean\');\r\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\r\n    if (target) {\r\n        const hooks = target[type] || (target[type] = []);\r\n        // cache the error handling wrapper for injected hooks so the same hook\r\n        // can be properly deduped by the scheduler. "__weh" stands for "with error\r\n        // handling".\r\n        const wrappedHook = hook.__weh ||\r\n            (hook.__weh = (...args) => {\r\n                if (target.isUnmounted) {\r\n                    return;\r\n                }\r\n                // disable tracking inside all lifecycle hooks\r\n                // since they can potentially be called inside effects.\r\n                pauseTracking();\r\n                // Set currentInstance during hook invocation.\r\n                // This assumes the hook does not synchronously trigger other hooks, which\r\n                // can only be false when the user does something really funky.\r\n                setCurrentInstance(target);\r\n                const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n                setCurrentInstance(null);\r\n                resetTracking();\r\n                return res;\r\n            });\r\n        if (prepend) {\r\n            hooks.unshift(wrappedHook);\r\n        }\r\n        else {\r\n            hooks.push(wrappedHook);\r\n        }\r\n        return wrappedHook;\r\n    }\r\n    else if ((false)) {}\r\n}\r\nconst createHook = (lifecycle) => (hook, target = currentInstance) => \r\n// post-create lifecycle registrations are noops during SSR\r\n!isInSSRComponentSetup && injectHook(lifecycle, hook, target);\r\nconst onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);\r\nconst onMounted = createHook("m" /* MOUNTED */);\r\nconst onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);\r\nconst onUpdated = createHook("u" /* UPDATED */);\r\nconst onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);\r\nconst onUnmounted = createHook("um" /* UNMOUNTED */);\r\nconst onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);\r\nconst onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);\r\nconst onErrorCaptured = (hook, target = currentInstance) => {\r\n    injectHook("ec" /* ERROR_CAPTURED */, hook, target);\r\n};\n\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if (false) {}\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared_esm_bundler["b" /* EMPTY_OBJ */], instance = currentInstance) {\r\n    if (false) {}\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (Object(shared_esm_bundler["o" /* isArray */])(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (Object(shared_esm_bundler["p" /* isFunction */])(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */, [\r\n                    instance && instance.proxy\r\n                ]);\r\n            }\r\n            else {\r\n                ( false) && false;\r\n            }\r\n        });\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */, [\r\n                instance && instance.proxy\r\n            ]);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = shared_esm_bundler["d" /* NOOP */];\r\n        ( false) && false;\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = Object(shared_esm_bundler["o" /* isArray */])(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || Object(shared_esm_bundler["k" /* hasChanged */])(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it\'s changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === \'sync\') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === \'post\') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: \'pre\'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with \'pre\' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = reactivity_esm_bundler_effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === \'post\') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            Object(shared_esm_bundler["L" /* remove */])(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = Object(shared_esm_bundler["C" /* isString */])(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!Object(shared_esm_bundler["v" /* isObject */])(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (Object(shared_esm_bundler["o" /* isArray */])(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["A" /* isSet */])(value) || Object(shared_esm_bundler["t" /* isMap */])(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\n\nfunction useTransitionState() {\r\n    const state = {\r\n        isMounted: false,\r\n        isLeaving: false,\r\n        isUnmounting: false,\r\n        leavingVNodes: new Map()\r\n    };\r\n    onMounted(() => {\r\n        state.isMounted = true;\r\n    });\r\n    onBeforeUnmount(() => {\r\n        state.isUnmounting = true;\r\n    });\r\n    return state;\r\n}\r\nconst TransitionHookValidator = [Function, Array];\r\nconst BaseTransitionImpl = {\r\n    name: `BaseTransition`,\r\n    props: {\r\n        mode: String,\r\n        appear: Boolean,\r\n        persisted: Boolean,\r\n        // enter\r\n        onBeforeEnter: TransitionHookValidator,\r\n        onEnter: TransitionHookValidator,\r\n        onAfterEnter: TransitionHookValidator,\r\n        onEnterCancelled: TransitionHookValidator,\r\n        // leave\r\n        onBeforeLeave: TransitionHookValidator,\r\n        onLeave: TransitionHookValidator,\r\n        onAfterLeave: TransitionHookValidator,\r\n        onLeaveCancelled: TransitionHookValidator,\r\n        // appear\r\n        onBeforeAppear: TransitionHookValidator,\r\n        onAppear: TransitionHookValidator,\r\n        onAfterAppear: TransitionHookValidator,\r\n        onAppearCancelled: TransitionHookValidator\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevTransitionKey;\r\n        return () => {\r\n            const children = slots.default && getTransitionRawChildren(slots.default(), true);\r\n            if (!children || !children.length) {\r\n                return;\r\n            }\r\n            // warn multiple elements\r\n            if (false) {}\r\n            // there\'s no need to track reactivity for these props so use the raw\r\n            // props for a bit better perf\r\n            const rawProps = toRaw(props);\r\n            const { mode } = rawProps;\r\n            // check mode\r\n            if (false) {}\r\n            // at this point children has a guaranteed length of 1.\r\n            const child = children[0];\r\n            if (state.isLeaving) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            // in the case of <transition><keep-alive/></transition>, we need to\r\n            // compare the type of the kept-alive children.\r\n            const innerChild = getKeepAliveChild(child);\r\n            if (!innerChild) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\r\n            setTransitionHooks(innerChild, enterHooks);\r\n            const oldChild = instance.subTree;\r\n            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\r\n            let transitionKeyChanged = false;\r\n            const { getTransitionKey } = innerChild.type;\r\n            if (getTransitionKey) {\r\n                const key = getTransitionKey();\r\n                if (prevTransitionKey === undefined) {\r\n                    prevTransitionKey = key;\r\n                }\r\n                else if (key !== prevTransitionKey) {\r\n                    prevTransitionKey = key;\r\n                    transitionKeyChanged = true;\r\n                }\r\n            }\r\n            // handle mode\r\n            if (oldInnerChild &&\r\n                oldInnerChild.type !== Comment &&\r\n                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\r\n                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\r\n                // update old tree\'s hooks in case of dynamic transition\r\n                setTransitionHooks(oldInnerChild, leavingHooks);\r\n                // switching between different views\r\n                if (mode === \'out-in\') {\r\n                    state.isLeaving = true;\r\n                    // return placeholder node and queue update when leave finishes\r\n                    leavingHooks.afterLeave = () => {\r\n                        state.isLeaving = false;\r\n                        instance.update();\r\n                    };\r\n                    return emptyPlaceholder(child);\r\n                }\r\n                else if (mode === \'in-out\') {\r\n                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\r\n                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\r\n                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\r\n                        // early removal callback\r\n                        el._leaveCb = () => {\r\n                            earlyRemove();\r\n                            el._leaveCb = undefined;\r\n                            delete enterHooks.delayedLeave;\r\n                        };\r\n                        enterHooks.delayedLeave = delayedLeave;\r\n                    };\r\n                }\r\n            }\r\n            return child;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst BaseTransition = BaseTransitionImpl;\r\nfunction getLeavingNodesForType(state, vnode) {\r\n    const { leavingVNodes } = state;\r\n    let leavingVNodesCache = leavingVNodes.get(vnode.type);\r\n    if (!leavingVNodesCache) {\r\n        leavingVNodesCache = Object.create(null);\r\n        leavingVNodes.set(vnode.type, leavingVNodesCache);\r\n    }\r\n    return leavingVNodesCache;\r\n}\r\n// The transition hooks are attached to the vnode as vnode.transition\r\n// and will be called at appropriate timing in the renderer.\r\nfunction resolveTransitionHooks(vnode, props, state, instance) {\r\n    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\r\n    const key = String(vnode.key);\r\n    const leavingVNodesCache = getLeavingNodesForType(state, vnode);\r\n    const callHook = (hook, args) => {\r\n        hook &&\r\n            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);\r\n    };\r\n    const hooks = {\r\n        mode,\r\n        persisted,\r\n        beforeEnter(el) {\r\n            let hook = onBeforeEnter;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onBeforeAppear || onBeforeEnter;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            // for same element (v-show)\r\n            if (el._leaveCb) {\r\n                el._leaveCb(true /* cancelled */);\r\n            }\r\n            // for toggled element with same key (v-if)\r\n            const leavingVNode = leavingVNodesCache[key];\r\n            if (leavingVNode &&\r\n                isSameVNodeType(vnode, leavingVNode) &&\r\n                leavingVNode.el._leaveCb) {\r\n                // force early removal (not cancelled)\r\n                leavingVNode.el._leaveCb();\r\n            }\r\n            callHook(hook, [el]);\r\n        },\r\n        enter(el) {\r\n            let hook = onEnter;\r\n            let afterHook = onAfterEnter;\r\n            let cancelHook = onEnterCancelled;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onAppear || onEnter;\r\n                    afterHook = onAfterAppear || onAfterEnter;\r\n                    cancelHook = onAppearCancelled || onEnterCancelled;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            let called = false;\r\n            const done = (el._enterCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                if (cancelled) {\r\n                    callHook(cancelHook, [el]);\r\n                }\r\n                else {\r\n                    callHook(afterHook, [el]);\r\n                }\r\n                if (hooks.delayedLeave) {\r\n                    hooks.delayedLeave();\r\n                }\r\n                el._enterCb = undefined;\r\n            });\r\n            if (hook) {\r\n                hook(el, done);\r\n                if (hook.length <= 1) {\r\n                    done();\r\n                }\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        leave(el, remove) {\r\n            const key = String(vnode.key);\r\n            if (el._enterCb) {\r\n                el._enterCb(true /* cancelled */);\r\n            }\r\n            if (state.isUnmounting) {\r\n                return remove();\r\n            }\r\n            callHook(onBeforeLeave, [el]);\r\n            let called = false;\r\n            const done = (el._leaveCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                remove();\r\n                if (cancelled) {\r\n                    callHook(onLeaveCancelled, [el]);\r\n                }\r\n                else {\r\n                    callHook(onAfterLeave, [el]);\r\n                }\r\n                el._leaveCb = undefined;\r\n                if (leavingVNodesCache[key] === vnode) {\r\n                    delete leavingVNodesCache[key];\r\n                }\r\n            });\r\n            leavingVNodesCache[key] = vnode;\r\n            if (onLeave) {\r\n                onLeave(el, done);\r\n                if (onLeave.length <= 1) {\r\n                    done();\r\n                }\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        clone(vnode) {\r\n            return resolveTransitionHooks(vnode, props, state, instance);\r\n        }\r\n    };\r\n    return hooks;\r\n}\r\n// the placeholder really only handles one special case: KeepAlive\r\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\r\n// placeholder with empty content to avoid the KeepAlive instance from being\r\n// unmounted.\r\nfunction emptyPlaceholder(vnode) {\r\n    if (isKeepAlive(vnode)) {\r\n        vnode = cloneVNode(vnode);\r\n        vnode.children = null;\r\n        return vnode;\r\n    }\r\n}\r\nfunction getKeepAliveChild(vnode) {\r\n    return isKeepAlive(vnode)\r\n        ? vnode.children\r\n            ? vnode.children[0]\r\n            : undefined\r\n        : vnode;\r\n}\r\nfunction setTransitionHooks(vnode, hooks) {\r\n    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {\r\n        setTransitionHooks(vnode.component.subTree, hooks);\r\n    }\r\n    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        vnode.ssContent.transition = hooks.clone(vnode.ssContent);\r\n        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\r\n    }\r\n    else {\r\n        vnode.transition = hooks;\r\n    }\r\n}\r\nfunction getTransitionRawChildren(children, keepComment = false) {\r\n    let ret = [];\r\n    let keyedFragmentCount = 0;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        // handle fragment children case, e.g. v-for\r\n        if (child.type === Fragment) {\r\n            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)\r\n                keyedFragmentCount++;\r\n            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));\r\n        }\r\n        // comment placeholders should be skipped, e.g. v-if\r\n        else if (keepComment || child.type !== Comment) {\r\n            ret.push(child);\r\n        }\r\n    }\r\n    // #1126 if a transition children list contains multiple sub fragments, these\r\n    // fragments will be merged into a flat children array. Since each v-for\r\n    // fragment may contain different static bindings inside, we need to de-op\r\n    // these children to force full diffs to ensure correct behavior.\r\n    if (keyedFragmentCount > 1) {\r\n        for (let i = 0; i < ret.length; i++) {\r\n            ret[i].patchFlag = -2 /* BAIL */;\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\r\nconst KeepAliveImpl = {\r\n    name: `KeepAlive`,\r\n    // Marker for special handling inside the renderer. We are not using a ===\r\n    // check directly on KeepAlive in the renderer, because importing it directly\r\n    // would prevent it from being tree-shaken.\r\n    __isKeepAlive: true,\r\n    props: {\r\n        include: [String, RegExp, Array],\r\n        exclude: [String, RegExp, Array],\r\n        max: [String, Number]\r\n    },\r\n    setup(props, { slots }) {\r\n        const cache = new Map();\r\n        const keys = new Set();\r\n        let current = null;\r\n        const instance = getCurrentInstance();\r\n        const parentSuspense = instance.suspense;\r\n        // KeepAlive communicates with the instantiated renderer via the\r\n        // ctx where the renderer passes in its internals,\r\n        // and the KeepAlive instance exposes activate/deactivate implementations.\r\n        // The whole point of this is to avoid importing KeepAlive directly in the\r\n        // renderer to facilitate tree-shaking.\r\n        const sharedContext = instance.ctx;\r\n        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\r\n        const storageContainer = createElement(\'div\');\r\n        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\r\n            const instance = vnode.component;\r\n            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);\r\n            // in case props have changed\r\n            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized);\r\n            queuePostRenderEffect(() => {\r\n                instance.isDeactivated = false;\r\n                if (instance.a) {\r\n                    Object(shared_esm_bundler["n" /* invokeArrayFns */])(instance.a);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n            }, parentSuspense);\r\n        };\r\n        sharedContext.deactivate = (vnode) => {\r\n            const instance = vnode.component;\r\n            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);\r\n            queuePostRenderEffect(() => {\r\n                if (instance.da) {\r\n                    Object(shared_esm_bundler["n" /* invokeArrayFns */])(instance.da);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n                instance.isDeactivated = true;\r\n            }, parentSuspense);\r\n        };\r\n        function unmount(vnode) {\r\n            // reset the shapeFlag so it can be properly unmounted\r\n            resetShapeFlag(vnode);\r\n            _unmount(vnode, instance, parentSuspense);\r\n        }\r\n        function pruneCache(filter) {\r\n            cache.forEach((vnode, key) => {\r\n                const name = getComponentName(vnode.type);\r\n                if (name && (!filter || !filter(name))) {\r\n                    pruneCacheEntry(key);\r\n                }\r\n            });\r\n        }\r\n        function pruneCacheEntry(key) {\r\n            const cached = cache.get(key);\r\n            if (!current || cached.type !== current.type) {\r\n                unmount(cached);\r\n            }\r\n            else if (current) {\r\n                // current active instance should no longer be kept-alive.\r\n                // we can\'t unmount it now but it might be later, so reset its flag now.\r\n                resetShapeFlag(current);\r\n            }\r\n            cache.delete(key);\r\n            keys.delete(key);\r\n        }\r\n        // prune cache on include/exclude prop change\r\n        watch(() => [props.include, props.exclude], ([include, exclude]) => {\r\n            include && pruneCache(name => runtime_core_esm_bundler_matches(include, name));\r\n            exclude && pruneCache(name => !runtime_core_esm_bundler_matches(exclude, name));\r\n        }, \r\n        // prune post-render after `current` has been updated\r\n        { flush: \'post\', deep: true });\r\n        // cache sub tree after render\r\n        let pendingCacheKey = null;\r\n        const cacheSubtree = () => {\r\n            // fix #1621, the pendingCacheKey could be 0\r\n            if (pendingCacheKey != null) {\r\n                cache.set(pendingCacheKey, getInnerChild(instance.subTree));\r\n            }\r\n        };\r\n        onMounted(cacheSubtree);\r\n        onUpdated(cacheSubtree);\r\n        onBeforeUnmount(() => {\r\n            cache.forEach(cached => {\r\n                const { subTree, suspense } = instance;\r\n                const vnode = getInnerChild(subTree);\r\n                if (cached.type === vnode.type) {\r\n                    // current instance will be unmounted as part of keep-alive\'s unmount\r\n                    resetShapeFlag(vnode);\r\n                    // but invoke its deactivated hook here\r\n                    const da = vnode.component.da;\r\n                    da && queuePostRenderEffect(da, suspense);\r\n                    return;\r\n                }\r\n                unmount(cached);\r\n            });\r\n        });\r\n        return () => {\r\n            pendingCacheKey = null;\r\n            if (!slots.default) {\r\n                return null;\r\n            }\r\n            const children = slots.default();\r\n            const rawVNode = children[0];\r\n            if (children.length > 1) {\r\n                if ((false)) {}\r\n                current = null;\r\n                return children;\r\n            }\r\n            else if (!isVNode(rawVNode) ||\r\n                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&\r\n                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {\r\n                current = null;\r\n                return rawVNode;\r\n            }\r\n            let vnode = getInnerChild(rawVNode);\r\n            const comp = vnode.type;\r\n            const name = getComponentName(comp);\r\n            const { include, exclude, max } = props;\r\n            if ((include && (!name || !runtime_core_esm_bundler_matches(include, name))) ||\r\n                (exclude && name && runtime_core_esm_bundler_matches(exclude, name))) {\r\n                current = vnode;\r\n                return rawVNode;\r\n            }\r\n            const key = vnode.key == null ? comp : vnode.key;\r\n            const cachedVNode = cache.get(key);\r\n            // clone vnode if it\'s reused because we are going to mutate it\r\n            if (vnode.el) {\r\n                vnode = cloneVNode(vnode);\r\n                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {\r\n                    rawVNode.ssContent = vnode;\r\n                }\r\n            }\r\n            // #1513 it\'s possible for the returned vnode to be cloned due to attr\r\n            // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n            // that is mounted. Instead of caching it directly, we store the pending\r\n            // key and cache `instance.subTree` (the normalized vnode) in\r\n            // beforeMount/beforeUpdate hooks.\r\n            pendingCacheKey = key;\r\n            if (cachedVNode) {\r\n                // copy over mounted state\r\n                vnode.el = cachedVNode.el;\r\n                vnode.component = cachedVNode.component;\r\n                if (vnode.transition) {\r\n                    // recursively update transition hooks on subTree\r\n                    setTransitionHooks(vnode, vnode.transition);\r\n                }\r\n                // avoid vnode being mounted as fresh\r\n                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;\r\n                // make this key the freshest\r\n                keys.delete(key);\r\n                keys.add(key);\r\n            }\r\n            else {\r\n                keys.add(key);\r\n                // prune oldest entry\r\n                if (max && keys.size > parseInt(max, 10)) {\r\n                    pruneCacheEntry(keys.values().next().value);\r\n                }\r\n            }\r\n            // avoid vnode being unmounted\r\n            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n            current = vnode;\r\n            return rawVNode;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst KeepAlive = KeepAliveImpl;\r\nfunction runtime_core_esm_bundler_matches(pattern, name) {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(pattern)) {\r\n        return pattern.some((p) => runtime_core_esm_bundler_matches(p, name));\r\n    }\r\n    else if (Object(shared_esm_bundler["C" /* isString */])(pattern)) {\r\n        return pattern.split(\',\').indexOf(name) > -1;\r\n    }\r\n    else if (pattern.test) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction onActivated(hook, target) {\r\n    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);\r\n}\r\nfunction onDeactivated(hook, target) {\r\n    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);\r\n}\r\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\r\n    // cache the deactivate branch check wrapper for injected hooks so the same\r\n    // hook can be properly deduped by the scheduler. "__wdc" stands for "with\r\n    // deactivation check".\r\n    const wrappedHook = hook.__wdc ||\r\n        (hook.__wdc = () => {\r\n            // only fire the hook if the target instance is NOT in a deactivated branch.\r\n            let current = target;\r\n            while (current) {\r\n                if (current.isDeactivated) {\r\n                    return;\r\n                }\r\n                current = current.parent;\r\n            }\r\n            hook();\r\n        });\r\n    injectHook(type, wrappedHook, target);\r\n    // In addition to registering it on the target instance, we walk up the parent\r\n    // chain and register it on all ancestor instances that are keep-alive roots.\r\n    // This avoids the need to walk the entire component tree when invoking these\r\n    // hooks, and more importantly, avoids the need to track child components in\r\n    // arrays.\r\n    if (target) {\r\n        let current = target.parent;\r\n        while (current && current.parent) {\r\n            if (isKeepAlive(current.parent.vnode)) {\r\n                injectToKeepAliveRoot(wrappedHook, type, target, current);\r\n            }\r\n            current = current.parent;\r\n        }\r\n    }\r\n}\r\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\r\n    // injectHook wraps the original for error handling, so make sure to remove\r\n    // the wrapped version.\r\n    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\r\n    onUnmounted(() => {\r\n        Object(shared_esm_bundler["L" /* remove */])(keepAliveRoot[type], injected);\r\n    }, target);\r\n}\r\nfunction resetShapeFlag(vnode) {\r\n    let shapeFlag = vnode.shapeFlag;\r\n    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n    }\r\n    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;\r\n    }\r\n    vnode.shapeFlag = shapeFlag;\r\n}\r\nfunction getInnerChild(vnode) {\r\n    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;\r\n}\n\nconst isInternalKey = (key) => key[0] === \'_\' || key === \'$stable\';\r\nconst normalizeSlotValue = (value) => Object(shared_esm_bundler["o" /* isArray */])(value)\r\n    ? value.map(normalizeVNode)\r\n    : [normalizeVNode(value)];\r\nconst normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {\r\n    if (false) {}\r\n    return normalizeSlotValue(rawSlot(props));\r\n}, ctx);\r\nconst normalizeObjectSlots = (rawSlots, slots) => {\r\n    const ctx = rawSlots._ctx;\r\n    for (const key in rawSlots) {\r\n        if (isInternalKey(key))\r\n            continue;\r\n        const value = rawSlots[key];\r\n        if (Object(shared_esm_bundler["p" /* isFunction */])(value)) {\r\n            slots[key] = normalizeSlot(key, value, ctx);\r\n        }\r\n        else if (value != null) {\r\n            if ((false)) {}\r\n            const normalized = normalizeSlotValue(value);\r\n            slots[key] = () => normalized;\r\n        }\r\n    }\r\n};\r\nconst normalizeVNodeSlots = (instance, children) => {\r\n    if (false) {}\r\n    const normalized = normalizeSlotValue(children);\r\n    instance.slots.default = () => normalized;\r\n};\r\nconst initSlots = (instance, children) => {\r\n    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            instance.slots = children;\r\n            // make compiler marker non-enumerable\r\n            Object(shared_esm_bundler["h" /* def */])(children, \'_\', type);\r\n        }\r\n        else {\r\n            normalizeObjectSlots(children, (instance.slots = {}));\r\n        }\r\n    }\r\n    else {\r\n        instance.slots = {};\r\n        if (children) {\r\n            normalizeVNodeSlots(instance, children);\r\n        }\r\n    }\r\n    Object(shared_esm_bundler["h" /* def */])(instance.slots, InternalObjectKey, 1);\r\n};\r\nconst updateSlots = (instance, children) => {\r\n    const { vnode, slots } = instance;\r\n    let needDeletionCheck = true;\r\n    let deletionComparisonTarget = shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            // compiled slots.\r\n            if (false) {}\r\n            else if (type === 1 /* STABLE */) {\r\n                // compiled AND stable.\r\n                // no need to update, and skip stale slots removal.\r\n                needDeletionCheck = false;\r\n            }\r\n            else {\r\n                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n                // normalization.\r\n                Object(shared_esm_bundler["i" /* extend */])(slots, children);\r\n            }\r\n        }\r\n        else {\r\n            needDeletionCheck = !children.$stable;\r\n            normalizeObjectSlots(children, slots);\r\n        }\r\n        deletionComparisonTarget = children;\r\n    }\r\n    else if (children) {\r\n        // non slot object children (direct value) passed to a component\r\n        normalizeVNodeSlots(instance, children);\r\n        deletionComparisonTarget = { default: 1 };\r\n    }\r\n    // delete stale slots\r\n    if (needDeletionCheck) {\r\n        for (const key in slots) {\r\n            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\r\n                delete slots[key];\r\n            }\r\n        }\r\n    }\r\n};\n\n/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent(\'comp\')\r\nconst foo = resolveDirective(\'foo\')\r\nconst bar = resolveDirective(\'bar\')\r\n\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\nconst isBuiltInDirective = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text\');\r\nfunction validateDirectiveName(name) {\r\n    if (isBuiltInDirective(name)) {\r\n        warn(\'Do not use built-in directive ids as custom directive id: \' + name);\r\n    }\r\n}\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nfunction withDirectives(vnode, directives) {\r\n    const internalInstance = currentRenderingInstance;\r\n    if (internalInstance === null) {\r\n        ( false) && false;\r\n        return vnode;\r\n    }\r\n    const instance = internalInstance.proxy;\r\n    const bindings = vnode.dirs || (vnode.dirs = []);\r\n    for (let i = 0; i < directives.length; i++) {\r\n        let [dir, value, arg, modifiers = shared_esm_bundler["b" /* EMPTY_OBJ */]] = directives[i];\r\n        if (Object(shared_esm_bundler["p" /* isFunction */])(dir)) {\r\n            dir = {\r\n                mounted: dir,\r\n                updated: dir\r\n            };\r\n        }\r\n        bindings.push({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: void 0,\r\n            arg,\r\n            modifiers\r\n        });\r\n    }\r\n    return vnode;\r\n}\r\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\r\n    const bindings = vnode.dirs;\r\n    const oldBindings = prevVNode && prevVNode.dirs;\r\n    for (let i = 0; i < bindings.length; i++) {\r\n        const binding = bindings[i];\r\n        if (oldBindings) {\r\n            binding.oldValue = oldBindings[i].value;\r\n        }\r\n        const hook = binding.dir[name];\r\n        if (hook) {\r\n            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [\r\n                vnode.el,\r\n                binding,\r\n                vnode,\r\n                prevVNode\r\n            ]);\r\n        }\r\n    }\r\n}\n\nfunction createAppContext() {\r\n    return {\r\n        app: null,\r\n        config: {\r\n            isNativeTag: shared_esm_bundler["c" /* NO */],\r\n            performance: false,\r\n            globalProperties: {},\r\n            optionMergeStrategies: {},\r\n            isCustomElement: shared_esm_bundler["c" /* NO */],\r\n            errorHandler: undefined,\r\n            warnHandler: undefined\r\n        },\r\n        mixins: [],\r\n        components: {},\r\n        directives: {},\r\n        provides: Object.create(null)\r\n    };\r\n}\r\nlet runtime_core_esm_bundler_uid = 0;\r\nfunction createAppAPI(render, hydrate) {\r\n    return function createApp(rootComponent, rootProps = null) {\r\n        if (rootProps != null && !Object(shared_esm_bundler["v" /* isObject */])(rootProps)) {\r\n            ( false) && false;\r\n            rootProps = null;\r\n        }\r\n        const context = createAppContext();\r\n        const installedPlugins = new Set();\r\n        let isMounted = false;\r\n        const app = (context.app = {\r\n            _uid: runtime_core_esm_bundler_uid++,\r\n            _component: rootComponent,\r\n            _props: rootProps,\r\n            _container: null,\r\n            _context: context,\r\n            version,\r\n            get config() {\r\n                return context.config;\r\n            },\r\n            set config(v) {\r\n                if ((false)) {}\r\n            },\r\n            use(plugin, ...options) {\r\n                if (installedPlugins.has(plugin)) {\r\n                    ( false) && false;\r\n                }\r\n                else if (plugin && Object(shared_esm_bundler["p" /* isFunction */])(plugin.install)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin.install(app, ...options);\r\n                }\r\n                else if (Object(shared_esm_bundler["p" /* isFunction */])(plugin)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin(app, ...options);\r\n                }\r\n                else if ((false)) {}\r\n                return app;\r\n            },\r\n            mixin(mixin) {\r\n                if (__VUE_OPTIONS_API__) {\r\n                    if (!context.mixins.includes(mixin)) {\r\n                        context.mixins.push(mixin);\r\n                        // global mixin with props/emits de-optimizes props/emits\r\n                        // normalization caching.\r\n                        if (mixin.props || mixin.emits) {\r\n                            context.deopt = true;\r\n                        }\r\n                    }\r\n                    else if ((false)) {}\r\n                }\r\n                else if ((false)) {}\r\n                return app;\r\n            },\r\n            component(name, component) {\r\n                if ((false)) {}\r\n                if (!component) {\r\n                    return context.components[name];\r\n                }\r\n                if (false) {}\r\n                context.components[name] = component;\r\n                return app;\r\n            },\r\n            directive(name, directive) {\r\n                if ((false)) {}\r\n                if (!directive) {\r\n                    return context.directives[name];\r\n                }\r\n                if (false) {}\r\n                context.directives[name] = directive;\r\n                return app;\r\n            },\r\n            mount(rootContainer, isHydrate) {\r\n                if (!isMounted) {\r\n                    const vnode = createVNode(rootComponent, rootProps);\r\n                    // store app context on the root VNode.\r\n                    // this will be set on the root instance on initial mount.\r\n                    vnode.appContext = context;\r\n                    // HMR root reload\r\n                    if ((false)) {}\r\n                    if (isHydrate && hydrate) {\r\n                        hydrate(vnode, rootContainer);\r\n                    }\r\n                    else {\r\n                        render(vnode, rootContainer);\r\n                    }\r\n                    isMounted = true;\r\n                    app._container = rootContainer;\r\n                    rootContainer.__vue_app__ = app;\r\n                    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                        devtoolsInitApp(app, version);\r\n                    }\r\n                    return vnode.component.proxy;\r\n                }\r\n                else if ((false)) {}\r\n            },\r\n            unmount() {\r\n                if (isMounted) {\r\n                    render(null, app._container);\r\n                    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                        devtoolsUnmountApp(app);\r\n                    }\r\n                    delete app._container.__vue_app__;\r\n                }\r\n                else if ((false)) {}\r\n            },\r\n            provide(key, value) {\r\n                if (false) {}\r\n                // TypeScript doesn\'t allow symbols as index type\r\n                // https://github.com/Microsoft/TypeScript/issues/24587\r\n                context.provides[key] = value;\r\n                return app;\r\n            }\r\n        });\r\n        return app;\r\n    };\r\n}\n\nlet hasMismatch = false;\r\nconst isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== \'foreignObject\';\r\nconst isComment = (node) => node.nodeType === 8 /* COMMENT */;\r\n// Note: hydration is DOM-specific\r\n// But we have to place it in core due to tight coupling with core - splitting\r\n// it out creates a ton of unnecessary complexity.\r\n// Hydration also depends on some renderer internal logic which needs to be\r\n// passed in via arguments.\r\nfunction createHydrationFunctions(rendererInternals) {\r\n    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\r\n    const hydrate = (vnode, container) => {\r\n        if (false) {}\r\n        hasMismatch = false;\r\n        hydrateNode(container.firstChild, vnode, null, null);\r\n        flushPostFlushCbs();\r\n        if (hasMismatch && !false) {\r\n            // this error should show up in production\r\n            console.error(`Hydration completed but contains mismatches.`);\r\n        }\r\n    };\r\n    const hydrateNode = (node, vnode, parentComponent, parentSuspense, optimized = false) => {\r\n        const isFragmentStart = isComment(node) && node.data === \'[\';\r\n        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, isFragmentStart);\r\n        const { type, ref, shapeFlag } = vnode;\r\n        const domType = node.nodeType;\r\n        vnode.el = node;\r\n        let nextNode = null;\r\n        switch (type) {\r\n            case Text:\r\n                if (domType !== 3 /* TEXT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    if (node.data !== vnode.children) {\r\n                        hasMismatch = true;\r\n                        ( false) &&\r\n                            false;\r\n                        node.data = vnode.children;\r\n                    }\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Comment:\r\n                if (domType !== 8 /* COMMENT */ || isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Static:\r\n                if (domType !== 1 /* ELEMENT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    // determine anchor, adopt content\r\n                    nextNode = node;\r\n                    // if the static vnode has its content stripped during build,\r\n                    // adopt it from the server-rendered HTML.\r\n                    const needToAdoptContent = !vnode.children.length;\r\n                    for (let i = 0; i < vnode.staticCount; i++) {\r\n                        if (needToAdoptContent)\r\n                            vnode.children += nextNode.outerHTML;\r\n                        if (i === vnode.staticCount - 1) {\r\n                            vnode.anchor = nextNode;\r\n                        }\r\n                        nextNode = nextSibling(nextNode);\r\n                    }\r\n                    return nextNode;\r\n                }\r\n                break;\r\n            case Fragment:\r\n                if (!isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, optimized);\r\n                }\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    if (domType !== 1 /* ELEMENT */ ||\r\n                        vnode.type !== node.tagName.toLowerCase()) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, optimized);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    // when setting up the render effect, if the initial vnode already\r\n                    // has .el set, the component will perform hydration instead of mount\r\n                    // on its sub-tree.\r\n                    const container = parentNode(node);\r\n                    const hydrateComponent = () => {\r\n                        mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\r\n                    };\r\n                    // async component\r\n                    const loadAsync = vnode.type.__asyncLoader;\r\n                    if (loadAsync) {\r\n                        loadAsync().then(hydrateComponent);\r\n                    }\r\n                    else {\r\n                        hydrateComponent();\r\n                    }\r\n                    // component may be async, so in the case of fragments we cannot rely\r\n                    // on component\'s rendered output to determine the end of the fragment\r\n                    // instead, we do a lookahead to find the end anchor node.\r\n                    nextNode = isFragmentStart\r\n                        ? locateClosingAsyncAnchor(node)\r\n                        : nextSibling(node);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    if (domType !== 8 /* COMMENT */) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, optimized, rendererInternals, hydrateChildren);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), optimized, rendererInternals, hydrateNode);\r\n                }\r\n                else if ((false)) {}\r\n        }\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, vnode);\r\n        }\r\n        return nextNode;\r\n    };\r\n    const hydrateElement = (el, vnode, parentComponent, parentSuspense, optimized) => {\r\n        optimized = optimized || !!vnode.dynamicChildren;\r\n        const { props, patchFlag, shapeFlag, dirs } = vnode;\r\n        // skip props & children if this is hoisted static nodes\r\n        if (patchFlag !== -1 /* HOISTED */) {\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, \'created\');\r\n            }\r\n            // props\r\n            if (props) {\r\n                if (!optimized ||\r\n                    (patchFlag & 16 /* FULL_PROPS */ ||\r\n                        patchFlag & 32 /* HYDRATE_EVENTS */)) {\r\n                    for (const key in props) {\r\n                        if (!Object(shared_esm_bundler["y" /* isReservedProp */])(key) && Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n                            patchProp(el, key, null, props[key]);\r\n                        }\r\n                    }\r\n                }\r\n                else if (props.onClick) {\r\n                    // Fast path for click listeners (which is most often) to avoid\r\n                    // iterating through props.\r\n                    patchProp(el, \'onClick\', null, props.onClick);\r\n                }\r\n            }\r\n            // vnode / directive hooks\r\n            let vnodeHooks;\r\n            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\r\n                invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, \'beforeMount\');\r\n            }\r\n            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\r\n                queueEffectWithSuspense(() => {\r\n                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n                    dirs && invokeDirectiveHook(vnode, null, parentComponent, \'mounted\');\r\n                }, parentSuspense);\r\n            }\r\n            // children\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&\r\n                // skip if element has innerHTML / textContent\r\n                !(props && (props.innerHTML || props.textContent))) {\r\n                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, optimized);\r\n                let hasWarned = false;\r\n                while (next) {\r\n                    hasMismatch = true;\r\n                    if (false) {}\r\n                    // The SSRed DOM contains more nodes than it should. Remove them.\r\n                    const cur = next;\r\n                    next = next.nextSibling;\r\n                    remove(cur);\r\n                }\r\n            }\r\n            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                if (el.textContent !== vnode.children) {\r\n                    hasMismatch = true;\r\n                    ( false) &&\r\n                        false;\r\n                    el.textContent = vnode.children;\r\n                }\r\n            }\r\n        }\r\n        return el.nextSibling;\r\n    };\r\n    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, optimized) => {\r\n        optimized = optimized || !!parentVNode.dynamicChildren;\r\n        const children = parentVNode.children;\r\n        const l = children.length;\r\n        let hasWarned = false;\r\n        for (let i = 0; i < l; i++) {\r\n            const vnode = optimized\r\n                ? children[i]\r\n                : (children[i] = normalizeVNode(children[i]));\r\n            if (node) {\r\n                node = hydrateNode(node, vnode, parentComponent, parentSuspense, optimized);\r\n            }\r\n            else {\r\n                hasMismatch = true;\r\n                if (false) {}\r\n                // the SSRed DOM didn\'t contain enough nodes. Mount the missing ones.\r\n                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container));\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, optimized) => {\r\n        const container = parentNode(node);\r\n        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, optimized);\r\n        if (next && isComment(next) && next.data === \']\') {\r\n            return nextSibling((vnode.anchor = next));\r\n        }\r\n        else {\r\n            // fragment didn\'t hydrate successfully, since we didn\'t get a end anchor\r\n            // back. This should have led to node/children mismatch warnings.\r\n            hasMismatch = true;\r\n            // since the anchor is missing, we need to create one and insert it\r\n            insert((vnode.anchor = createComment(`]`)), container, next);\r\n            return next;\r\n        }\r\n    };\r\n    const handleMismatch = (node, vnode, parentComponent, parentSuspense, isFragment) => {\r\n        hasMismatch = true;\r\n        ( false) &&\r\n            false;\r\n        vnode.el = null;\r\n        if (isFragment) {\r\n            // remove excessive fragment nodes\r\n            const end = locateClosingAsyncAnchor(node);\r\n            while (true) {\r\n                const next = nextSibling(node);\r\n                if (next && next !== end) {\r\n                    remove(next);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const next = nextSibling(node);\r\n        const container = parentNode(node);\r\n        remove(node);\r\n        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container));\r\n        return next;\r\n    };\r\n    const locateClosingAsyncAnchor = (node) => {\r\n        let match = 0;\r\n        while (node) {\r\n            node = nextSibling(node);\r\n            if (node && isComment(node)) {\r\n                if (node.data === \'[\')\r\n                    match++;\r\n                if (node.data === \']\') {\r\n                    if (match === 0) {\r\n                        return nextSibling(node);\r\n                    }\r\n                    else {\r\n                        match--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    return [hydrate, hydrateNode];\r\n}\n\nlet supported;\r\nlet perf;\r\nfunction startMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        perf.mark(`vue-${type}-${instance.uid}`);\r\n    }\r\n}\r\nfunction endMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        const startTag = `vue-${type}-${instance.uid}`;\r\n        const endTag = startTag + `:end`;\r\n        perf.mark(endTag);\r\n        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\r\n        perf.clearMarks(startTag);\r\n        perf.clearMarks(endTag);\r\n    }\r\n}\r\nfunction isSupported() {\r\n    if (supported !== undefined) {\r\n        return supported;\r\n    }\r\n    /* eslint-disable no-restricted-globals */\r\n    if (typeof window !== \'undefined\' && window.performance) {\r\n        supported = true;\r\n        perf = window.performance;\r\n    }\r\n    else {\r\n        supported = false;\r\n    }\r\n    /* eslint-enable no-restricted-globals */\r\n    return supported;\r\n}\n\n/**\r\n * This is only called in esm-bundler builds.\r\n * It is called when a renderer is created, in `baseCreateRenderer` so that\r\n * importing runtime-core is side-effects free.\r\n *\r\n * istanbul-ignore-next\r\n */\r\nfunction initFeatureFlags() {\r\n    let needWarn = false;\r\n    if (typeof __VUE_OPTIONS_API__ !== \'boolean\') {\r\n        needWarn = true;\r\n        Object(shared_esm_bundler["j" /* getGlobalThis */])().__VUE_OPTIONS_API__ = true;\r\n    }\r\n    if (typeof __VUE_PROD_DEVTOOLS__ !== \'boolean\') {\r\n        needWarn = true;\r\n        Object(shared_esm_bundler["j" /* getGlobalThis */])().__VUE_PROD_DEVTOOLS__ = false;\r\n    }\r\n    if (false) {}\r\n}\n\n// implementation, close to no-op\r\nfunction defineComponent(options) {\r\n    return Object(shared_esm_bundler["p" /* isFunction */])(options) ? { setup: options, name: options.name } : options;\r\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\r\nfunction defineAsyncComponent(source) {\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(source)) {\r\n        source = { loader: source };\r\n    }\r\n    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\r\n    suspensible = true, onError: userOnError } = source;\r\n    let pendingRequest = null;\r\n    let resolvedComp;\r\n    let retries = 0;\r\n    const retry = () => {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    const load = () => {\r\n        let thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest = loader()\r\n                .catch(err => {\r\n                err = err instanceof Error ? err : new Error(String(err));\r\n                if (userOnError) {\r\n                    return new Promise((resolve, reject) => {\r\n                        const userRetry = () => resolve(retry());\r\n                        const userFail = () => reject(err);\r\n                        userOnError(err, userRetry, userFail, retries + 1);\r\n                    });\r\n                }\r\n                else {\r\n                    throw err;\r\n                }\r\n            })\r\n                .then((comp) => {\r\n                if (thisRequest !== pendingRequest && pendingRequest) {\r\n                    return pendingRequest;\r\n                }\r\n                if (false) {}\r\n                // interop module default\r\n                if (comp &&\r\n                    (comp.__esModule || comp[Symbol.toStringTag] === \'Module\')) {\r\n                    comp = comp.default;\r\n                }\r\n                if (false) {}\r\n                resolvedComp = comp;\r\n                return comp;\r\n            })));\r\n    };\r\n    return defineComponent({\r\n        __asyncLoader: load,\r\n        name: \'AsyncComponentWrapper\',\r\n        setup() {\r\n            const instance = currentInstance;\r\n            // already resolved\r\n            if (resolvedComp) {\r\n                return () => createInnerComp(resolvedComp, instance);\r\n            }\r\n            const onError = (err) => {\r\n                pendingRequest = null;\r\n                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\r\n            };\r\n            // suspense-controlled or SSR.\r\n            if ((suspensible && instance.suspense) ||\r\n                (false )) {\r\n                return load()\r\n                    .then(comp => {\r\n                    return () => createInnerComp(comp, instance);\r\n                })\r\n                    .catch(err => {\r\n                    onError(err);\r\n                    return () => errorComponent\r\n                        ? createVNode(errorComponent, {\r\n                            error: err\r\n                        })\r\n                        : null;\r\n                });\r\n            }\r\n            const loaded = reactivity_esm_bundler_ref(false);\r\n            const error = reactivity_esm_bundler_ref();\r\n            const delayed = reactivity_esm_bundler_ref(!!delay);\r\n            if (delay) {\r\n                setTimeout(() => {\r\n                    delayed.value = false;\r\n                }, delay);\r\n            }\r\n            if (timeout != null) {\r\n                setTimeout(() => {\r\n                    if (!loaded.value && !error.value) {\r\n                        const err = new Error(`Async component timed out after ${timeout}ms.`);\r\n                        onError(err);\r\n                        error.value = err;\r\n                    }\r\n                }, timeout);\r\n            }\r\n            load()\r\n                .then(() => {\r\n                loaded.value = true;\r\n            })\r\n                .catch(err => {\r\n                onError(err);\r\n                error.value = err;\r\n            });\r\n            return () => {\r\n                if (loaded.value && resolvedComp) {\r\n                    return createInnerComp(resolvedComp, instance);\r\n                }\r\n                else if (error.value && errorComponent) {\r\n                    return createVNode(errorComponent, {\r\n                        error: error.value\r\n                    });\r\n                }\r\n                else if (loadingComponent && !delayed.value) {\r\n                    return createVNode(loadingComponent);\r\n                }\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction createInnerComp(comp, { vnode: { ref, props, children } }) {\r\n    const vnode = createVNode(comp, props, children);\r\n    // ensure inner component inherits the async wrapper\'s ref owner\r\n    vnode.ref = ref;\r\n    return vnode;\r\n}\n\nconst prodEffectOptions = {\r\n    scheduler: queueJob,\r\n    // #1801, #2043 component render effects should allow recursive updates\r\n    allowRecurse: true\r\n};\r\nfunction createDevEffectOptions(instance) {\r\n    return {\r\n        scheduler: queueJob,\r\n        allowRecurse: true,\r\n        onTrack: instance.rtc ? e => Object(shared_esm_bundler["n" /* invokeArrayFns */])(instance.rtc, e) : void 0,\r\n        onTrigger: instance.rtg ? e => Object(shared_esm_bundler["n" /* invokeArrayFns */])(instance.rtg, e) : void 0\r\n    };\r\n}\r\nconst queuePostRenderEffect = queueEffectWithSuspense\r\n    ;\r\nconst setRef = (rawRef, oldRawRef, parentSuspense, vnode) => {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(rawRef)) {\r\n        rawRef.forEach((r, i) => setRef(r, oldRawRef && (Object(shared_esm_bundler["o" /* isArray */])(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode));\r\n        return;\r\n    }\r\n    let value;\r\n    if (!vnode || isAsyncWrapper(vnode)) {\r\n        value = null;\r\n    }\r\n    else {\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            value = vnode.component.exposed || vnode.component.proxy;\r\n        }\r\n        else {\r\n            value = vnode.el;\r\n        }\r\n    }\r\n    const { i: owner, r: ref } = rawRef;\r\n    if (false) {}\r\n    const oldRef = oldRawRef && oldRawRef.r;\r\n    const refs = owner.refs === shared_esm_bundler["b" /* EMPTY_OBJ */] ? (owner.refs = {}) : owner.refs;\r\n    const setupState = owner.setupState;\r\n    // unset old ref\r\n    if (oldRef != null && oldRef !== ref) {\r\n        if (Object(shared_esm_bundler["C" /* isString */])(oldRef)) {\r\n            refs[oldRef] = null;\r\n            if (Object(shared_esm_bundler["l" /* hasOwn */])(setupState, oldRef)) {\r\n                setupState[oldRef] = null;\r\n            }\r\n        }\r\n        else if (isRef(oldRef)) {\r\n            oldRef.value = null;\r\n        }\r\n    }\r\n    if (Object(shared_esm_bundler["C" /* isString */])(ref)) {\r\n        const doSet = () => {\r\n            refs[ref] = value;\r\n            if (Object(shared_esm_bundler["l" /* hasOwn */])(setupState, ref)) {\r\n                setupState[ref] = value;\r\n            }\r\n        };\r\n        // #1789: for non-null values, set them after render\r\n        // null values means this is unmount and it should not overwrite another\r\n        // ref with the same key\r\n        if (value) {\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (isRef(ref)) {\r\n        const doSet = () => {\r\n            ref.value = value;\r\n        };\r\n        if (value) {\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(ref)) {\r\n        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);\r\n    }\r\n    else if ((false)) {}\r\n};\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nfunction createRenderer(options) {\r\n    return baseCreateRenderer(options);\r\n}\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nfunction createHydrationRenderer(options) {\r\n    return baseCreateRenderer(options, createHydrationFunctions);\r\n}\r\n// implementation\r\nfunction baseCreateRenderer(options, createHydrationFns) {\r\n    // compile-time feature flags check\r\n    {\r\n        initFeatureFlags();\r\n    }\r\n    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n        const target = Object(shared_esm_bundler["j" /* getGlobalThis */])();\r\n        target.__VUE__ = true;\r\n        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\r\n    }\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = shared_esm_bundler["d" /* NOOP */], cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\r\n    // Note: functions inside this closure should use `const xxx = () => {}`\r\n    // style in order to prevent being inlined by minifiers.\r\n    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {\r\n        // patching & not same type, unmount old tree\r\n        if (n1 && !isSameVNodeType(n1, n2)) {\r\n            anchor = getNextHostNode(n1);\r\n            unmount(n1, parentComponent, parentSuspense, true);\r\n            n1 = null;\r\n        }\r\n        if (n2.patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            n2.dynamicChildren = null;\r\n        }\r\n        const { type, ref, shapeFlag } = n2;\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container, anchor);\r\n                break;\r\n            case Comment:\r\n                processCommentNode(n1, n2, container, anchor);\r\n                break;\r\n            case Static:\r\n                if (n1 == null) {\r\n                    mountStaticNode(n2, container, anchor, isSVG);\r\n                }\r\n                else if ((false)) {}\r\n                break;\r\n            case Fragment:\r\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\r\n                }\r\n                else if ((false)) {}\r\n        }\r\n        // set ref\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, n1 && n1.ref, parentSuspense, n2);\r\n        }\r\n    };\r\n    const processText = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n        }\r\n        else {\r\n            const el = (n2.el = n1.el);\r\n            if (n2.children !== n1.children) {\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    };\r\n    const processCommentNode = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateComment(n2.children || \'\')), container, anchor);\r\n        }\r\n        else {\r\n            // there\'s no support for dynamic comments\r\n            n2.el = n1.el;\r\n        }\r\n    };\r\n    const mountStaticNode = (n2, container, anchor, isSVG) => {\r\n        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n    };\r\n    /**\r\n     * Dev / HMR only\r\n     */\r\n    const patchStaticNode = (n1, n2, container, isSVG) => {\r\n        // static nodes are only patched during dev for HMR\r\n        if (n2.children !== n1.children) {\r\n            const anchor = hostNextSibling(n1.anchor);\r\n            // remove existing\r\n            removeStaticNode(n1);\r\n            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n        }\r\n        else {\r\n            n2.el = n1.el;\r\n            n2.anchor = n1.anchor;\r\n        }\r\n    };\r\n    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostInsert(el, container, nextSibling);\r\n            el = next;\r\n        }\r\n        hostInsert(anchor, container, nextSibling);\r\n    };\r\n    const removeStaticNode = ({ el, anchor }) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostRemove(el);\r\n            el = next;\r\n        }\r\n        hostRemove(anchor);\r\n    };\r\n    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        isSVG = isSVG || n2.type === \'svg\';\r\n        if (n1 == null) {\r\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        else {\r\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n    };\r\n    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        let el;\r\n        let vnodeHook;\r\n        const { type, props, shapeFlag, transition, scopeId, patchFlag, dirs } = vnode;\r\n        if ( true &&\r\n            vnode.el &&\r\n            hostCloneNode !== undefined &&\r\n            patchFlag === -1 /* HOISTED */) {\r\n            // If a vnode has non-null el, it means it\'s being reused.\r\n            // Only static vnodes can be reused, so its mounted DOM nodes should be\r\n            // exactly the same, and we can simply do a clone here.\r\n            // only do this in production since cloned trees cannot be HMR updated.\r\n            el = vnode.el = hostCloneNode(vnode.el);\r\n        }\r\n        else {\r\n            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);\r\n            // mount children first, since some props may rely on child content\r\n            // being already rendered, e.g. `<select value>`\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                hostSetElementText(el, vnode.children);\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== \'foreignObject\', optimized || !!vnode.dynamicChildren);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, \'created\');\r\n            }\r\n            // props\r\n            if (props) {\r\n                for (const key in props) {\r\n                    if (!Object(shared_esm_bundler["y" /* isReservedProp */])(key)) {\r\n                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n                if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                }\r\n            }\r\n            // scopeId\r\n            setScopeId(el, scopeId, vnode, parentComponent);\r\n        }\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            Object.defineProperty(el, \'__vnode\', {\r\n                value: vnode,\r\n                enumerable: false\r\n            });\r\n            Object.defineProperty(el, \'__vueParentComponent\', {\r\n                value: parentComponent,\r\n                enumerable: false\r\n            });\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(vnode, null, parentComponent, \'beforeMount\');\r\n        }\r\n        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n        // #1689 For inside suspense + suspense resolved case, just call it\r\n        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n            transition &&\r\n            !transition.persisted;\r\n        if (needCallTransitionHooks) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n        if ((vnodeHook = props && props.onVnodeMounted) ||\r\n            needCallTransitionHooks ||\r\n            dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                needCallTransitionHooks && transition.enter(el);\r\n                dirs && invokeDirectiveHook(vnode, null, parentComponent, \'mounted\');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const setScopeId = (el, scopeId, vnode, parentComponent) => {\r\n        if (scopeId) {\r\n            hostSetScopeId(el, scopeId);\r\n        }\r\n        if (parentComponent) {\r\n            const treeOwnerId = parentComponent.type.__scopeId;\r\n            // vnode\'s own scopeId and the current patched component\'s scopeId is\r\n            // different - this is a slot content node.\r\n            if (treeOwnerId && treeOwnerId !== scopeId) {\r\n                hostSetScopeId(el, treeOwnerId + \'-s\');\r\n            }\r\n            let subTree = parentComponent.subTree;\r\n            if (false) {}\r\n            if (vnode === subTree) {\r\n                setScopeId(el, parentComponent.vnode.scopeId, parentComponent.vnode, parentComponent.parent);\r\n            }\r\n        }\r\n    };\r\n    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            const child = (children[i] = optimized\r\n                ? cloneIfMounted(children[i])\r\n                : normalizeVNode(children[i]));\r\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n    };\r\n    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const el = (n2.el = n1.el);\r\n        let { patchFlag, dynamicChildren, dirs } = n2;\r\n        // #1426 take the old vnode\'s patch flag into account since user may clone a\r\n        // compiler-generated vnode, which de-opts to FULL_PROPS\r\n        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\r\n        const oldProps = n1.props || shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        const newProps = n2.props || shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        let vnodeHook;\r\n        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(n2, n1, parentComponent, \'beforeUpdate\');\r\n        }\r\n        if (false) {}\r\n        if (patchFlag > 0) {\r\n            // the presence of a patchFlag means this element\'s render code was\r\n            // generated by the compiler and can take the fast path.\r\n            // in this path old node and new node are guaranteed to have the same shape\r\n            // (i.e. at the exact same position in the source template)\r\n            if (patchFlag & 16 /* FULL_PROPS */) {\r\n                // element props contain dynamic keys, full diff needed\r\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            else {\r\n                // class\r\n                // this flag is matched when the element has dynamic class bindings.\r\n                if (patchFlag & 2 /* CLASS */) {\r\n                    if (oldProps.class !== newProps.class) {\r\n                        hostPatchProp(el, \'class\', null, newProps.class, isSVG);\r\n                    }\r\n                }\r\n                // style\r\n                // this flag is matched when the element has dynamic style bindings\r\n                if (patchFlag & 4 /* STYLE */) {\r\n                    hostPatchProp(el, \'style\', oldProps.style, newProps.style, isSVG);\r\n                }\r\n                // props\r\n                // This flag is matched when the element has dynamic prop/attr bindings\r\n                // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                // faster iteration.\r\n                // Note dynamic keys like :[foo]="bar" will cause this optimization to\r\n                // bail out and go through a full diff because we need to unset the old key\r\n                if (patchFlag & 8 /* PROPS */) {\r\n                    // if the flag is present then dynamicProps must be non-null\r\n                    const propsToUpdate = n2.dynamicProps;\r\n                    for (let i = 0; i < propsToUpdate.length; i++) {\r\n                        const key = propsToUpdate[i];\r\n                        const prev = oldProps[key];\r\n                        const next = newProps[key];\r\n                        if (next !== prev ||\r\n                            (hostForcePatchProp && hostForcePatchProp(el, key))) {\r\n                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // text\r\n            // This flag is matched when the element has only dynamic text children.\r\n            if (patchFlag & 1 /* TEXT */) {\r\n                if (n1.children !== n2.children) {\r\n                    hostSetElementText(el, n2.children);\r\n                }\r\n            }\r\n        }\r\n        else if (!optimized && dynamicChildren == null) {\r\n            // unoptimized, full diff\r\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        const areChildrenSVG = isSVG && n2.type !== \'foreignObject\';\r\n        if (dynamicChildren) {\r\n            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);\r\n            if (false) {}\r\n        }\r\n        else if (!optimized) {\r\n            // full diff\r\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);\r\n        }\r\n        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n                dirs && invokeDirectiveHook(n2, n1, parentComponent, \'updated\');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    // The fast path for blocks.\r\n    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {\r\n        for (let i = 0; i < newChildren.length; i++) {\r\n            const oldVNode = oldChildren[i];\r\n            const newVNode = newChildren[i];\r\n            // Determine the container (parent element) for the patch.\r\n            const container = \r\n            // - In the case of a Fragment, we need to provide the actual parent\r\n            // of the Fragment itself so it can move its children.\r\n            oldVNode.type === Fragment ||\r\n                // - In the case of different nodes, there is going to be a replacement\r\n                // which also requires the correct parent container\r\n                !isSameVNodeType(oldVNode, newVNode) ||\r\n                // - In the case of a component, it could contain anything.\r\n                oldVNode.shapeFlag & 6 /* COMPONENT */ ||\r\n                oldVNode.shapeFlag & 64 /* TELEPORT */\r\n                ? hostParentNode(oldVNode.el)\r\n                : // In other cases, the parent container is not actually used so we\r\n                    // just pass the block element here to avoid a DOM parentNode call.\r\n                    fallbackContainer;\r\n            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);\r\n        }\r\n    };\r\n    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                // empty string is not valid prop\r\n                if (Object(shared_esm_bundler["y" /* isReservedProp */])(key))\r\n                    continue;\r\n                const next = newProps[key];\r\n                const prev = oldProps[key];\r\n                if (next !== prev ||\r\n                    (hostForcePatchProp && hostForcePatchProp(el, key))) {\r\n                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                }\r\n            }\r\n            if (oldProps !== shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n                for (const key in oldProps) {\r\n                    if (!Object(shared_esm_bundler["y" /* isReservedProp */])(key) && !(key in newProps)) {\r\n                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(\'\'));\r\n        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(\'\'));\r\n        let { patchFlag, dynamicChildren } = n2;\r\n        if (patchFlag > 0) {\r\n            optimized = true;\r\n        }\r\n        if (false) {}\r\n        if (n1 == null) {\r\n            hostInsert(fragmentStartAnchor, container, anchor);\r\n            hostInsert(fragmentEndAnchor, container, anchor);\r\n            // a fragment can only have array children\r\n            // since they are either generated by the compiler, or implicitly created\r\n            // from arrays.\r\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        else {\r\n            if (patchFlag > 0 &&\r\n                patchFlag & 64 /* STABLE_FRAGMENT */ &&\r\n                dynamicChildren &&\r\n                // #2715 the previous fragment could\'ve been a BAILed one as a result\r\n                // of renderSlot() with no valid children\r\n                n1.dynamicChildren) {\r\n                // a stable fragment (template root or <template v-for>) doesn\'t need to\r\n                // patch children order, but it may contain dynamicChildren.\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);\r\n                if (false) {}\r\n                else if (\r\n                // #2080 if the stable fragment has a key, it\'s a <template v-for> that may\r\n                //  get moved around. Make sure all root level vnodes inherit el.\r\n                // #2134 or if it\'s a component root, it may also get moved around\r\n                // as the component is being moved.\r\n                n2.key != null ||\r\n                    (parentComponent && n2 === parentComponent.subTree)) {\r\n                    traverseStaticChildren(n1, n2, true /* shallow */);\r\n                }\r\n            }\r\n            else {\r\n                // keyed / unkeyed, or manual fragments.\r\n                // for keyed & unkeyed, since they are compiler generated from v-for,\r\n                // each child is guaranteed to be a block so the fragment will never\r\n                // have dynamicChildren.\r\n                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n    };\r\n    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        if (n1 == null) {\r\n            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\r\n            }\r\n            else {\r\n                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n        else {\r\n            updateComponent(n1, n2, optimized);\r\n        }\r\n    };\r\n    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\r\n        if (false) {}\r\n        if ((false)) {}\r\n        // inject renderer internals for keepAlive\r\n        if (isKeepAlive(initialVNode)) {\r\n            instance.ctx.renderer = internals;\r\n        }\r\n        // resolve props and slots for setup context\r\n        if ((false)) {}\r\n        setupComponent(instance);\r\n        if ((false)) {}\r\n        // setup() is async. This component relies on async logic to be resolved\r\n        // before proceeding\r\n        if (instance.asyncDep) {\r\n            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\r\n            // Give it a placeholder if this is not hydration\r\n            // TODO handle self-defined fallback\r\n            if (!initialVNode.el) {\r\n                const placeholder = (instance.subTree = createVNode(Comment));\r\n                processCommentNode(null, placeholder, container, anchor);\r\n            }\r\n            return;\r\n        }\r\n        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\r\n        if ((false)) {}\r\n    };\r\n    const updateComponent = (n1, n2, optimized) => {\r\n        const instance = (n2.component = n1.component);\r\n        if (shouldUpdateComponent(n1, n2, optimized)) {\r\n            if (instance.asyncDep &&\r\n                !instance.asyncResolved) {\r\n                // async & still pending - just update props and slots\r\n                // since the component\'s reactive effect for render isn\'t set-up yet\r\n                if ((false)) {}\r\n                updateComponentPreRender(instance, n2, optimized);\r\n                if ((false)) {}\r\n                return;\r\n            }\r\n            else {\r\n                // normal update\r\n                instance.next = n2;\r\n                // in case the child component is also queued, remove it to avoid\r\n                // double updating the same child component in the same flush.\r\n                invalidateJob(instance.update);\r\n                // instance.update is the reactive effect runner.\r\n                instance.update();\r\n            }\r\n        }\r\n        else {\r\n            // no update needed. just copy over properties\r\n            n2.component = n1.component;\r\n            n2.el = n1.el;\r\n            instance.vnode = n2;\r\n        }\r\n    };\r\n    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\r\n        // create reactive effect for rendering\r\n        instance.update = reactivity_esm_bundler_effect(function componentEffect() {\r\n            if (!instance.isMounted) {\r\n                let vnodeHook;\r\n                const { el, props } = initialVNode;\r\n                const { bm, m, parent } = instance;\r\n                // beforeMount hook\r\n                if (bm) {\r\n                    Object(shared_esm_bundler["n" /* invokeArrayFns */])(bm);\r\n                }\r\n                // onVnodeBeforeMount\r\n                if ((vnodeHook = props && props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                }\r\n                // render\r\n                if ((false)) {}\r\n                const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                if ((false)) {}\r\n                if (el && hydrateNode) {\r\n                    if ((false)) {}\r\n                    // vnode has adopted host node - perform hydration instead of mount.\r\n                    hydrateNode(initialVNode.el, subTree, instance, parentSuspense);\r\n                    if ((false)) {}\r\n                }\r\n                else {\r\n                    if ((false)) {}\r\n                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                    if ((false)) {}\r\n                    initialVNode.el = subTree.el;\r\n                }\r\n                // mounted hook\r\n                if (m) {\r\n                    queuePostRenderEffect(m, parentSuspense);\r\n                }\r\n                // onVnodeMounted\r\n                if ((vnodeHook = props && props.onVnodeMounted)) {\r\n                    const scopedInitialVNode = initialVNode;\r\n                    queuePostRenderEffect(() => {\r\n                        invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);\r\n                    }, parentSuspense);\r\n                }\r\n                // activated hook for keep-alive roots.\r\n                // #1742 activated hook must be accessed after first render\r\n                // since the hook may be injected by a child keep-alive\r\n                const { a } = instance;\r\n                if (a &&\r\n                    initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n                    queuePostRenderEffect(a, parentSuspense);\r\n                }\r\n                instance.isMounted = true;\r\n                if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentAdded(instance);\r\n                }\r\n                // #2458: deference mount-only object parameters to prevent memleaks\r\n                initialVNode = container = anchor = null;\r\n            }\r\n            else {\r\n                // updateComponent\r\n                // This is triggered by mutation of component\'s own state (next: null)\r\n                // OR parent calling processComponent (next: VNode)\r\n                let { next, bu, u, parent, vnode } = instance;\r\n                let originNext = next;\r\n                let vnodeHook;\r\n                if ((false)) {}\r\n                if (next) {\r\n                    next.el = vnode.el;\r\n                    updateComponentPreRender(instance, next, optimized);\r\n                }\r\n                else {\r\n                    next = vnode;\r\n                }\r\n                // beforeUpdate hook\r\n                if (bu) {\r\n                    Object(shared_esm_bundler["n" /* invokeArrayFns */])(bu);\r\n                }\r\n                // onVnodeBeforeUpdate\r\n                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n                    invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                }\r\n                // render\r\n                if ((false)) {}\r\n                const nextTree = renderComponentRoot(instance);\r\n                if ((false)) {}\r\n                const prevTree = instance.subTree;\r\n                instance.subTree = nextTree;\r\n                if ((false)) {}\r\n                patch(prevTree, nextTree, \r\n                // parent may have changed if it\'s in a teleport\r\n                hostParentNode(prevTree.el), \r\n                // anchor may have changed if it\'s in a fragment\r\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                if ((false)) {}\r\n                next.el = nextTree.el;\r\n                if (originNext === null) {\r\n                    // self-triggered update. In case of HOC, update parent component\r\n                    // vnode el. HOC is indicated by parent instance\'s subTree pointing\r\n                    // to child component\'s vnode\r\n                    updateHOCHostEl(instance, nextTree.el);\r\n                }\r\n                // updated hook\r\n                if (u) {\r\n                    queuePostRenderEffect(u, parentSuspense);\r\n                }\r\n                // onVnodeUpdated\r\n                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n                    queuePostRenderEffect(() => {\r\n                        invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                    }, parentSuspense);\r\n                }\r\n                if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentUpdated(instance);\r\n                }\r\n                if ((false)) {}\r\n            }\r\n        }, ( false) ? undefined : prodEffectOptions);\r\n    };\r\n    const updateComponentPreRender = (instance, nextVNode, optimized) => {\r\n        nextVNode.component = instance;\r\n        const prevProps = instance.vnode.props;\r\n        instance.vnode = nextVNode;\r\n        instance.next = null;\r\n        updateProps(instance, nextVNode.props, prevProps, optimized);\r\n        updateSlots(instance, nextVNode.children);\r\n        // props update may have triggered pre-flush watchers.\r\n        // flush them before the render update.\r\n        flushPreFlushCbs(undefined, instance.update);\r\n    };\r\n    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {\r\n        const c1 = n1 && n1.children;\r\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n        const c2 = n2.children;\r\n        const { patchFlag, shapeFlag } = n2;\r\n        // fast path\r\n        if (patchFlag > 0) {\r\n            if (patchFlag & 128 /* KEYED_FRAGMENT */) {\r\n                // this could be either fully-keyed or mixed (some keyed some not)\r\n                // presence of patchFlag means children are guaranteed to be arrays\r\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                return;\r\n            }\r\n            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\r\n                // unkeyed\r\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                return;\r\n            }\r\n        }\r\n        // children has 3 possibilities: text, array or no children.\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            // text children fast path\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(c1, parentComponent, parentSuspense);\r\n            }\r\n            if (c2 !== c1) {\r\n                hostSetElementText(container, c2);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                // prev children was array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    // two arrays, cannot assume anything, do full diff\r\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else {\r\n                    // no new children, just unmount old\r\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                }\r\n            }\r\n            else {\r\n                // prev children was text OR null\r\n                // new children is array OR null\r\n                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(container, \'\');\r\n                }\r\n                // mount new if array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        c1 = c1 || shared_esm_bundler["a" /* EMPTY_ARR */];\r\n        c2 = c2 || shared_esm_bundler["a" /* EMPTY_ARR */];\r\n        const oldLength = c1.length;\r\n        const newLength = c2.length;\r\n        const commonLength = Math.min(oldLength, newLength);\r\n        let i;\r\n        for (i = 0; i < commonLength; i++) {\r\n            const nextChild = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        if (oldLength > newLength) {\r\n            // remove old\r\n            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\r\n        }\r\n        else {\r\n            // mount new\r\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);\r\n        }\r\n    };\r\n    // can be all-keyed or mixed\r\n    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        let i = 0;\r\n        const l2 = c2.length;\r\n        let e1 = c1.length - 1; // prev ending index\r\n        let e2 = l2 - 1; // next ending index\r\n        // 1. sync from start\r\n        // (a b) c\r\n        // (a b) d e\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[i];\r\n            const n2 = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 2. sync from end\r\n        // a (b c)\r\n        // d e (b c)\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[e1];\r\n            const n2 = (c2[e2] = optimized\r\n                ? cloneIfMounted(c2[e2])\r\n                : normalizeVNode(c2[e2]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        // 3. common sequence + mount\r\n        // (a b)\r\n        // (a b) c\r\n        // i = 2, e1 = 1, e2 = 2\r\n        // (a b)\r\n        // c (a b)\r\n        // i = 0, e1 = -1, e2 = 0\r\n        if (i > e1) {\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                while (i <= e2) {\r\n                    patch(null, (c2[i] = optimized\r\n                        ? cloneIfMounted(c2[i])\r\n                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // 4. common sequence + unmount\r\n        // (a b) c\r\n        // (a b)\r\n        // i = 2, e1 = 2, e2 = 1\r\n        // a (b c)\r\n        // (b c)\r\n        // i = 0, e1 = 0, e2 = -1\r\n        else if (i > e2) {\r\n            while (i <= e1) {\r\n                unmount(c1[i], parentComponent, parentSuspense, true);\r\n                i++;\r\n            }\r\n        }\r\n        // 5. unknown sequence\r\n        // [i ... e1 + 1]: a b [c d e] f g\r\n        // [i ... e2 + 1]: a b [e d c h] f g\r\n        // i = 2, e1 = 4, e2 = 5\r\n        else {\r\n            const s1 = i; // prev starting index\r\n            const s2 = i; // next starting index\r\n            // 5.1 build key:index map for newChildren\r\n            const keyToNewIndexMap = new Map();\r\n            for (i = s2; i <= e2; i++) {\r\n                const nextChild = (c2[i] = optimized\r\n                    ? cloneIfMounted(c2[i])\r\n                    : normalizeVNode(c2[i]));\r\n                if (nextChild.key != null) {\r\n                    if (false) {}\r\n                    keyToNewIndexMap.set(nextChild.key, i);\r\n                }\r\n            }\r\n            // 5.2 loop through old children left to be patched and try to patch\r\n            // matching nodes & remove nodes that are no longer present\r\n            let j;\r\n            let patched = 0;\r\n            const toBePatched = e2 - s2 + 1;\r\n            let moved = false;\r\n            // used to track whether any node has moved\r\n            let maxNewIndexSoFar = 0;\r\n            // works as Map<newIndex, oldIndex>\r\n            // Note that oldIndex is offset by +1\r\n            // and oldIndex = 0 is a special value indicating the new node has\r\n            // no corresponding old node.\r\n            // used for determining longest stable subsequence\r\n            const newIndexToOldIndexMap = new Array(toBePatched);\r\n            for (i = 0; i < toBePatched; i++)\r\n                newIndexToOldIndexMap[i] = 0;\r\n            for (i = s1; i <= e1; i++) {\r\n                const prevChild = c1[i];\r\n                if (patched >= toBePatched) {\r\n                    // all new children have been patched so this can only be a removal\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key != null) {\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    // key-less node, try to locate a key-less node of the same type\r\n                    for (j = s2; j <= e2; j++) {\r\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                            isSameVNodeType(prevChild, c2[j])) {\r\n                            newIndex = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex === undefined) {\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                }\r\n                else {\r\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n                    patched++;\r\n                }\r\n            }\r\n            // 5.3 move and mount\r\n            // generate longest stable subsequence only when nodes have moved\r\n            const increasingNewIndexSequence = moved\r\n                ? getSequence(newIndexToOldIndexMap)\r\n                : shared_esm_bundler["a" /* EMPTY_ARR */];\r\n            j = increasingNewIndexSequence.length - 1;\r\n            // looping backwards so that we can use last patched node as anchor\r\n            for (i = toBePatched - 1; i >= 0; i--) {\r\n                const nextIndex = s2 + i;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\r\n                if (newIndexToOldIndexMap[i] === 0) {\r\n                    // mount new\r\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);\r\n                }\r\n                else if (moved) {\r\n                    // move if:\r\n                    // There is no stable subsequence (e.g. a reverse)\r\n                    // OR current node is not among the stable sequence\r\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                        move(nextChild, container, anchor, 2 /* REORDER */);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\r\n        const { el, type, transition, children, shapeFlag } = vnode;\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            move(vnode.component.subTree, container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 128 /* SUSPENSE */) {\r\n            vnode.suspense.move(container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type.move(vnode, container, anchor, internals);\r\n            return;\r\n        }\r\n        if (type === Fragment) {\r\n            hostInsert(el, container, anchor);\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, anchor, moveType);\r\n            }\r\n            hostInsert(vnode.anchor, container, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            moveStaticNode(vnode, container, anchor);\r\n            return;\r\n        }\r\n        // single nodes\r\n        const needTransition = moveType !== 2 /* REORDER */ &&\r\n            shapeFlag & 1 /* ELEMENT */ &&\r\n            transition;\r\n        if (needTransition) {\r\n            if (moveType === 0 /* ENTER */) {\r\n                transition.beforeEnter(el);\r\n                hostInsert(el, container, anchor);\r\n                queuePostRenderEffect(() => transition.enter(el), parentSuspense);\r\n            }\r\n            else {\r\n                const { leave, delayLeave, afterLeave } = transition;\r\n                const remove = () => hostInsert(el, container, anchor);\r\n                const performLeave = () => {\r\n                    leave(el, () => {\r\n                        remove();\r\n                        afterLeave && afterLeave();\r\n                    });\r\n                };\r\n                if (delayLeave) {\r\n                    delayLeave(el, remove, performLeave);\r\n                }\r\n                else {\r\n                    performLeave();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            hostInsert(el, container, anchor);\r\n        }\r\n    };\r\n    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\r\n        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\r\n        // unset ref\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, null);\r\n        }\r\n        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n            parentComponent.ctx.deactivate(vnode);\r\n            return;\r\n        }\r\n        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\r\n        let vnodeHook;\r\n        if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n        }\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            unmountComponent(vnode.component, parentSuspense, doRemove);\r\n        }\r\n        else {\r\n            if (shapeFlag & 128 /* SUSPENSE */) {\r\n                vnode.suspense.unmount(parentSuspense, doRemove);\r\n                return;\r\n            }\r\n            if (shouldInvokeDirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, \'beforeUnmount\');\r\n            }\r\n            if (dynamicChildren &&\r\n                // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n                (type !== Fragment ||\r\n                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\r\n                // fast path for block nodes: only need to unmount dynamic children.\r\n                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\r\n            }\r\n            else if ((type === Fragment &&\r\n                (patchFlag & 128 /* KEYED_FRAGMENT */ ||\r\n                    patchFlag & 256 /* UNKEYED_FRAGMENT */)) ||\r\n                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {\r\n                unmountChildren(children, parentComponent, parentSuspense);\r\n            }\r\n            // an unmounted teleport should always remove its children if not disabled\r\n            if (shapeFlag & 64 /* TELEPORT */ &&\r\n                (doRemove || !isTeleportDisabled(vnode.props))) {\r\n                vnode.type.remove(vnode, internals);\r\n            }\r\n            if (doRemove) {\r\n                remove(vnode);\r\n            }\r\n        }\r\n        if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                shouldInvokeDirs &&\r\n                    invokeDirectiveHook(vnode, null, parentComponent, \'unmounted\');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const remove = vnode => {\r\n        const { type, el, anchor, transition } = vnode;\r\n        if (type === Fragment) {\r\n            removeFragment(el, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            removeStaticNode(vnode);\r\n            return;\r\n        }\r\n        const performRemove = () => {\r\n            hostRemove(el);\r\n            if (transition && !transition.persisted && transition.afterLeave) {\r\n                transition.afterLeave();\r\n            }\r\n        };\r\n        if (vnode.shapeFlag & 1 /* ELEMENT */ &&\r\n            transition &&\r\n            !transition.persisted) {\r\n            const { leave, delayLeave } = transition;\r\n            const performLeave = () => leave(el, performRemove);\r\n            if (delayLeave) {\r\n                delayLeave(vnode.el, performRemove, performLeave);\r\n            }\r\n            else {\r\n                performLeave();\r\n            }\r\n        }\r\n        else {\r\n            performRemove();\r\n        }\r\n    };\r\n    const removeFragment = (cur, end) => {\r\n        // For fragments, directly remove all contained DOM nodes.\r\n        // (fragment child nodes cannot have transition)\r\n        let next;\r\n        while (cur !== end) {\r\n            next = hostNextSibling(cur);\r\n            hostRemove(cur);\r\n            cur = next;\r\n        }\r\n        hostRemove(end);\r\n    };\r\n    const unmountComponent = (instance, parentSuspense, doRemove) => {\r\n        if (false) {}\r\n        const { bum, effects, update, subTree, um } = instance;\r\n        // beforeUnmount hook\r\n        if (bum) {\r\n            Object(shared_esm_bundler["n" /* invokeArrayFns */])(bum);\r\n        }\r\n        if (effects) {\r\n            for (let i = 0; i < effects.length; i++) {\r\n                stop(effects[i]);\r\n            }\r\n        }\r\n        // update may be null if a component is unmounted before its async\r\n        // setup has resolved.\r\n        if (update) {\r\n            stop(update);\r\n            unmount(subTree, instance, parentSuspense, doRemove);\r\n        }\r\n        // unmounted hook\r\n        if (um) {\r\n            queuePostRenderEffect(um, parentSuspense);\r\n        }\r\n        queuePostRenderEffect(() => {\r\n            instance.isUnmounted = true;\r\n        }, parentSuspense);\r\n        // A component with async dep inside a pending suspense is unmounted before\r\n        // its async dep resolves. This should remove the dep from the suspense, and\r\n        // cause the suspense to resolve immediately if that was the last dep.\r\n        if (parentSuspense &&\r\n            parentSuspense.pendingBranch &&\r\n            !parentSuspense.isUnmounted &&\r\n            instance.asyncDep &&\r\n            !instance.asyncResolved &&\r\n            instance.suspenseId === parentSuspense.pendingId) {\r\n            parentSuspense.deps--;\r\n            if (parentSuspense.deps === 0) {\r\n                parentSuspense.resolve();\r\n            }\r\n        }\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            devtoolsComponentRemoved(instance);\r\n        }\r\n    };\r\n    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\r\n        }\r\n    };\r\n    const getNextHostNode = vnode => {\r\n        if (vnode.shapeFlag & 6 /* COMPONENT */) {\r\n            return getNextHostNode(vnode.component.subTree);\r\n        }\r\n        if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n            return vnode.suspense.next();\r\n        }\r\n        return hostNextSibling((vnode.anchor || vnode.el));\r\n    };\r\n    const render = (vnode, container) => {\r\n        if (vnode == null) {\r\n            if (container._vnode) {\r\n                unmount(container._vnode, null, null, true);\r\n            }\r\n        }\r\n        else {\r\n            patch(container._vnode || null, vnode, container);\r\n        }\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n    };\r\n    const internals = {\r\n        p: patch,\r\n        um: unmount,\r\n        m: move,\r\n        r: remove,\r\n        mt: mountComponent,\r\n        mc: mountChildren,\r\n        pc: patchChildren,\r\n        pbc: patchBlockChildren,\r\n        n: getNextHostNode,\r\n        o: options\r\n    };\r\n    let hydrate;\r\n    let hydrateNode;\r\n    if (createHydrationFns) {\r\n        [hydrate, hydrateNode] = createHydrationFns(internals);\r\n    }\r\n    return {\r\n        render,\r\n        hydrate,\r\n        createApp: createAppAPI(render, hydrate)\r\n    };\r\n}\r\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\r\n    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\r\n        vnode,\r\n        prevVNode\r\n    ]);\r\n}\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always moved so that need inherit el form previous nodes\r\n * to ensure correct moved position.\r\n */\r\nfunction traverseStaticChildren(n1, n2, shallow = false) {\r\n    const ch1 = n1.children;\r\n    const ch2 = n2.children;\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(ch1) && Object(shared_esm_bundler["o" /* isArray */])(ch2)) {\r\n        for (let i = 0; i < ch1.length; i++) {\r\n            // this is only called in the optimized path so array children are\r\n            // guaranteed to be vnodes\r\n            const c1 = ch1[i];\r\n            let c2 = ch2[i];\r\n            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\r\n                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\r\n                    c2 = ch2[i] = cloneIfMounted(ch2[i]);\r\n                    c2.el = c1.el;\r\n                }\r\n                if (!shallow)\r\n                    traverseStaticChildren(c1, c2);\r\n            }\r\n            // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n            // would have received .el during block patch)\r\n            if (false) {}\r\n        }\r\n    }\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr) {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        const arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = ((u + v) / 2) | 0;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === \'\');\r\nconst isTargetSVG = (target) => typeof SVGElement !== \'undefined\' && target instanceof SVGElement;\r\nconst resolveTarget = (props, select) => {\r\n    const targetSelector = props && props.to;\r\n    if (Object(shared_esm_bundler["C" /* isString */])(targetSelector)) {\r\n        if (!select) {\r\n            ( false) &&\r\n                false;\r\n            return null;\r\n        }\r\n        else {\r\n            const target = select(targetSelector);\r\n            if (!target) {\r\n                ( false) &&\r\n                    false;\r\n            }\r\n            return target;\r\n        }\r\n    }\r\n    else {\r\n        if (false) {}\r\n        return targetSelector;\r\n    }\r\n};\r\nconst TeleportImpl = {\r\n    __isTeleport: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals) {\r\n        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\r\n        const disabled = isTeleportDisabled(n2.props);\r\n        const { shapeFlag, children } = n2;\r\n        if (n1 == null) {\r\n            // insert anchors in the main view\r\n            const placeholder = (n2.el = ( false)\r\n                ? undefined\r\n                : createText(\'\'));\r\n            const mainAnchor = (n2.anchor = ( false)\r\n                ? undefined\r\n                : createText(\'\'));\r\n            insert(placeholder, container, anchor);\r\n            insert(mainAnchor, container, anchor);\r\n            const target = (n2.target = resolveTarget(n2.props, querySelector));\r\n            const targetAnchor = (n2.targetAnchor = createText(\'\'));\r\n            if (target) {\r\n                insert(targetAnchor, target);\r\n                // #2652 we could be teleporting from a non-SVG tree into an SVG tree\r\n                isSVG = isSVG || isTargetSVG(target);\r\n            }\r\n            else if (false) {}\r\n            const mount = (container, anchor) => {\r\n                // Teleport *always* has Array children. This is enforced in both the\r\n                // compiler and vnode children normalization.\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n            };\r\n            if (disabled) {\r\n                mount(container, mainAnchor);\r\n            }\r\n            else if (target) {\r\n                mount(target, targetAnchor);\r\n            }\r\n        }\r\n        else {\r\n            // update content\r\n            n2.el = n1.el;\r\n            const mainAnchor = (n2.anchor = n1.anchor);\r\n            const target = (n2.target = n1.target);\r\n            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\r\n            const wasDisabled = isTeleportDisabled(n1.props);\r\n            const currentContainer = wasDisabled ? container : target;\r\n            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\r\n            isSVG = isSVG || isTargetSVG(target);\r\n            if (n2.dynamicChildren) {\r\n                // fast path when the teleport happens to be a block root\r\n                patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG);\r\n                // even in block tree mode we need to make sure all root-level nodes\r\n                // in the teleport inherit previous DOM references so that they can\r\n                // be moved in future patches.\r\n                traverseStaticChildren(n1, n2, true);\r\n            }\r\n            else if (!optimized) {\r\n                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            if (disabled) {\r\n                if (!wasDisabled) {\r\n                    // enabled -> disabled\r\n                    // move into main container\r\n                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n            else {\r\n                // target changed\r\n                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\r\n                    if (nextTarget) {\r\n                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);\r\n                    }\r\n                    else if ((false)) {}\r\n                }\r\n                else if (wasDisabled) {\r\n                    // disabled -> enabled\r\n                    // move into teleport target\r\n                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    remove(vnode, { r: remove, o: { remove: hostRemove } }) {\r\n        const { shapeFlag, children, anchor } = vnode;\r\n        hostRemove(anchor);\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                remove(children[i]);\r\n            }\r\n        }\r\n    },\r\n    move: moveTeleport,\r\n    hydrate: hydrateTeleport\r\n};\r\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {\r\n    // move target anchor if this is a target change.\r\n    if (moveType === 0 /* TARGET_CHANGE */) {\r\n        insert(vnode.targetAnchor, container, parentAnchor);\r\n    }\r\n    const { el, anchor, shapeFlag, children, props } = vnode;\r\n    const isReorder = moveType === 2 /* REORDER */;\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(el, container, parentAnchor);\r\n    }\r\n    // if this is a re-order and teleport is enabled (content is in target)\r\n    // do not move children. So the opposite is: only move children if this\r\n    // is not a reorder, or the teleport is disabled\r\n    if (!isReorder || isTeleportDisabled(props)) {\r\n        // Teleport has either Array children or no children.\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, parentAnchor, 2 /* REORDER */);\r\n            }\r\n        }\r\n    }\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(anchor, container, parentAnchor);\r\n    }\r\n}\r\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\r\n    const target = (vnode.target = resolveTarget(vnode.props, querySelector));\r\n    if (target) {\r\n        // if multiple teleports rendered to the same target element, we need to\r\n        // pick up from where the last teleport finished instead of the first node\r\n        const targetNode = target._lpa || target.firstChild;\r\n        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            if (isTeleportDisabled(vnode.props)) {\r\n                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, optimized);\r\n                vnode.targetAnchor = targetNode;\r\n            }\r\n            else {\r\n                vnode.anchor = nextSibling(node);\r\n                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, optimized);\r\n            }\r\n            target._lpa =\r\n                vnode.targetAnchor && nextSibling(vnode.targetAnchor);\r\n        }\r\n    }\r\n    return vnode.anchor && nextSibling(vnode.anchor);\r\n}\r\n// Force-casted public typing for h and TSX props inference\r\nconst Teleport = TeleportImpl;\n\nconst COMPONENTS = \'components\';\r\nconst DIRECTIVES = \'directives\';\r\n/**\r\n * @private\r\n */\r\nfunction resolveComponent(name) {\r\n    return resolveAsset(COMPONENTS, name) || name;\r\n}\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n/**\r\n * @private\r\n */\r\nfunction resolveDynamicComponent(component) {\r\n    if (Object(shared_esm_bundler["C" /* isString */])(component)) {\r\n        return resolveAsset(COMPONENTS, component, false) || component;\r\n    }\r\n    else {\r\n        // invalid types will fallthrough to createVNode and raise warning\r\n        return (component || NULL_DYNAMIC_COMPONENT);\r\n    }\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction resolveDirective(name) {\r\n    return resolveAsset(DIRECTIVES, name);\r\n}\r\n// implementation\r\nfunction resolveAsset(type, name, warnMissing = true) {\r\n    const instance = currentRenderingInstance || currentInstance;\r\n    if (instance) {\r\n        const Component = instance.type;\r\n        // self name has highest priority\r\n        if (type === COMPONENTS) {\r\n            // special self referencing call generated by compiler\r\n            // inferred from SFC filename\r\n            if (name === `_self`) {\r\n                return Component;\r\n            }\r\n            const selfName = getComponentName(Component);\r\n            if (selfName &&\r\n                (selfName === name ||\r\n                    selfName === Object(shared_esm_bundler["f" /* camelize */])(name) ||\r\n                    selfName === Object(shared_esm_bundler["g" /* capitalize */])(Object(shared_esm_bundler["f" /* camelize */])(name)))) {\r\n                return Component;\r\n            }\r\n        }\r\n        const res = \r\n        // local registration\r\n        // check instance[type] first for components with mixin or extends.\r\n        resolve(instance[type] || Component[type], name) ||\r\n            // global registration\r\n            resolve(instance.appContext[type], name);\r\n        if (false) {}\r\n        return res;\r\n    }\r\n    else if ((false)) {}\r\n}\r\nfunction resolve(registry, name) {\r\n    return (registry &&\r\n        (registry[name] ||\r\n            registry[Object(shared_esm_bundler["f" /* camelize */])(name)] ||\r\n            registry[Object(shared_esm_bundler["g" /* capitalize */])(Object(shared_esm_bundler["f" /* camelize */])(name))]));\r\n}\n\nconst Fragment = Symbol(( false) ? undefined : undefined);\r\nconst Text = Symbol(( false) ? undefined : undefined);\r\nconst Comment = Symbol(( false) ? undefined : undefined);\r\nconst Static = Symbol(( false) ? undefined : undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock(\'div\', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet runtime_core_esm_bundler_shouldTrack = 1;\r\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\r\nfunction setBlockTracking(value) {\r\n    runtime_core_esm_bundler_shouldTrack += value;\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren = currentBlock || shared_esm_bundler["a" /* EMPTY_ARR */];\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if (runtime_core_esm_bundler_shouldTrack > 0 && currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nfunction isSameVNodeType(n1, n2) {\r\n    if (false) {}\r\n    return n1.type === n2.type && n1.key === n2.key;\r\n}\r\nlet vnodeArgsTransformer;\r\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\r\nfunction transformVNodeArgs(transformer) {\r\n    vnodeArgsTransformer = transformer;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(vnodeArgsTransformer\r\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n        : args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? Object(shared_esm_bundler["C" /* isString */])(ref) || isRef(ref) || Object(shared_esm_bundler["p" /* isFunction */])(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = (( false)\r\n    ? undefined\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if (false) {}\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is="vnode"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = Object(shared_esm_bundler["i" /* extend */])({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !Object(shared_esm_bundler["C" /* isString */])(klass)) {\r\n            props.class = Object(shared_esm_bundler["I" /* normalizeClass */])(klass);\r\n        }\r\n        if (Object(shared_esm_bundler["v" /* isObject */])(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !Object(shared_esm_bundler["o" /* isArray */])(style)) {\r\n                style = Object(shared_esm_bundler["i" /* extend */])({}, style);\r\n            }\r\n            props.style = Object(shared_esm_bundler["J" /* normalizeStyle */])(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = Object(shared_esm_bundler["C" /* isString */])(type)\r\n        ? 1 /* ELEMENT */\r\n        : isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : Object(shared_esm_bundler["v" /* isObject */])(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : Object(shared_esm_bundler["p" /* isFunction */])(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if (false) {}\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        ["__v_skip" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if (false) {}\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if (shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (runtime_core_esm_bundler_shouldTrack > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn\'t need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag, children } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        ["__v_skip" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is="vnode" ref="extra"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? Object(shared_esm_bundler["o" /* isArray */])(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children:  false\r\n            ? undefined\r\n            : children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn\'t affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * Dev only, for HMR of hoisted vnodes reused in v-for\r\n * https://github.com/vitejs/vite/issues/2022\r\n */\r\nfunction deepCloneVNode(vnode) {\r\n    const cloned = cloneVNode(vnode);\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(vnode.children)) {\r\n        cloned.children = vnode.children.map(deepCloneVNode);\r\n    }\r\n    return cloned;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = \' \', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createStaticVNode(content, numberOfNodes) {\r\n    // A static vnode can contain multiple stringified elements, and the number\r\n    // of elements is necessary for hydration.\r\n    const vnode = createVNode(Static, null, content);\r\n    vnode.staticCount = numberOfNodes;\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createCommentVNode(text = \'\', \r\n// when used as the v-else branch, the comment node must be created as a\r\n// block to ensure correct updates.\r\nasBlock = false) {\r\n    return asBlock\r\n        ? (openBlock(), createBlock(Comment, null, text))\r\n        : createVNode(Comment, null, text);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === \'boolean\') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (Object(shared_esm_bundler["o" /* isArray */])(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === \'object\') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\n// optimized normalization for template-compiled render fns\r\nfunction cloneIfMounted(child) {\r\n    return child.el === null ? child : cloneVNode(child);\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (Object(shared_esm_bundler["o" /* isArray */])(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === \'object\') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent\'s slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = Object(shared_esm_bundler["i" /* extend */])({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === \'class\') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = Object(shared_esm_bundler["I" /* normalizeClass */])([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === \'style\') {\r\n                ret.style = Object(shared_esm_bundler["J" /* normalizeStyle */])([ret.style, toMerge.style]);\r\n            }\r\n            else if (Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== \'\') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if ((false)) {}\r\n    }\r\n    else {\r\n        let provides = currentInstance.provides;\r\n        // by default an instance inherits its parent\'s provides object\r\n        // but when it needs to provide values of its own, it creates its\r\n        // own provides object using parent provides object as prototype.\r\n        // this way in `inject` we can simply look up injections from direct\r\n        // parent and let the prototype chain do the work.\r\n        const parentProvides = currentInstance.parent && currentInstance.parent.provides;\r\n        if (parentProvides === provides) {\r\n            provides = currentInstance.provides = Object.create(parentProvides);\r\n        }\r\n        // TS doesn\'t allow symbol as index type\r\n        provides[key] = value;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    const instance = currentInstance || currentRenderingInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext\'s `provides` if the intance is at root\r\n        const provides = instance.parent == null\r\n            ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n            : instance.parent.provides;\r\n        if (provides && key in provides) {\r\n            // TS doesn\'t allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && Object(shared_esm_bundler["p" /* isFunction */])(defaultValue)\r\n                ? defaultValue()\r\n                : defaultValue;\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n    else if ((false)) {}\r\n}\n\nfunction createDuplicateChecker() {\r\n    const cache = Object.create(null);\r\n    return (type, key) => {\r\n        if (cache[key]) {\r\n            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);\r\n        }\r\n        else {\r\n            cache[key] = type;\r\n        }\r\n    };\r\n}\r\nlet isInBeforeCreate = false;\r\nfunction applyOptions(instance, options, deferredData = [], deferredWatch = [], deferredProvide = [], asMixin = false) {\r\n    const { \r\n    // composition\r\n    mixins, extends: extendsOptions, \r\n    // state\r\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n    // assets\r\n    components, directives, \r\n    // lifecycle\r\n    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, \r\n    // public API\r\n    expose } = options;\r\n    const publicThis = instance.proxy;\r\n    const ctx = instance.ctx;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (asMixin && render && instance.render === shared_esm_bundler["d" /* NOOP */]) {\r\n        instance.render = render;\r\n    }\r\n    // applyOptions is called non-as-mixin once per instance\r\n    if (!asMixin) {\r\n        isInBeforeCreate = true;\r\n        callSyncHook(\'beforeCreate\', "bc" /* BEFORE_CREATE */, options, instance, globalMixins);\r\n        isInBeforeCreate = false;\r\n        // global mixins are applied first\r\n        applyMixins(instance, globalMixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    // extending a base component...\r\n    if (extendsOptions) {\r\n        applyOptions(instance, extendsOptions, deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n    // local mixins\r\n    if (mixins) {\r\n        applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    const checkDuplicateProperties = ( false) ? undefined : null;\r\n    if ((false)) {}\r\n    // options initialization order (to be consistent with Vue 2):\r\n    // - props (already done outside of this function)\r\n    // - inject\r\n    // - methods\r\n    // - data (deferred since it relies on `this` access)\r\n    // - computed\r\n    // - watch (deferred since it relies on `this` access)\r\n    if (injectOptions) {\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(injectOptions)) {\r\n            for (let i = 0; i < injectOptions.length; i++) {\r\n                const key = injectOptions[i];\r\n                ctx[key] = inject(key);\r\n                if ((false)) {}\r\n            }\r\n        }\r\n        else {\r\n            for (const key in injectOptions) {\r\n                const opt = injectOptions[key];\r\n                if (Object(shared_esm_bundler["v" /* isObject */])(opt)) {\r\n                    ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);\r\n                }\r\n                else {\r\n                    ctx[key] = inject(opt);\r\n                }\r\n                if ((false)) {}\r\n            }\r\n        }\r\n    }\r\n    if (methods) {\r\n        for (const key in methods) {\r\n            const methodHandler = methods[key];\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(methodHandler)) {\r\n                // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,\r\n                // and those are read-only but reconfigurable, so it needs to be redefined here\r\n                if ((false)) {}\r\n                else {\r\n                    ctx[key] = methodHandler.bind(publicThis);\r\n                }\r\n                if ((false)) {}\r\n            }\r\n            else if ((false)) {}\r\n        }\r\n    }\r\n    if (!asMixin) {\r\n        if (deferredData.length) {\r\n            deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));\r\n        }\r\n        if (dataOptions) {\r\n            // @ts-ignore dataOptions is not fully type safe\r\n            resolveData(instance, dataOptions, publicThis);\r\n        }\r\n        if ((false)) {}\r\n    }\r\n    else if (dataOptions) {\r\n        deferredData.push(dataOptions);\r\n    }\r\n    if (computedOptions) {\r\n        for (const key in computedOptions) {\r\n            const opt = computedOptions[key];\r\n            const get = Object(shared_esm_bundler["p" /* isFunction */])(opt)\r\n                ? opt.bind(publicThis, publicThis)\r\n                : Object(shared_esm_bundler["p" /* isFunction */])(opt.get)\r\n                    ? opt.get.bind(publicThis, publicThis)\r\n                    : shared_esm_bundler["d" /* NOOP */];\r\n            if (false) {}\r\n            const set = !Object(shared_esm_bundler["p" /* isFunction */])(opt) && Object(shared_esm_bundler["p" /* isFunction */])(opt.set)\r\n                ? opt.set.bind(publicThis)\r\n                : ( false)\r\n                    ? undefined\r\n                    : shared_esm_bundler["d" /* NOOP */];\r\n            const c = runtime_core_esm_bundler_computed({\r\n                get,\r\n                set\r\n            });\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => c.value,\r\n                set: v => (c.value = v)\r\n            });\r\n            if ((false)) {}\r\n        }\r\n    }\r\n    if (watchOptions) {\r\n        deferredWatch.push(watchOptions);\r\n    }\r\n    if (!asMixin && deferredWatch.length) {\r\n        deferredWatch.forEach(watchOptions => {\r\n            for (const key in watchOptions) {\r\n                createWatcher(watchOptions[key], ctx, publicThis, key);\r\n            }\r\n        });\r\n    }\r\n    if (provideOptions) {\r\n        deferredProvide.push(provideOptions);\r\n    }\r\n    if (!asMixin && deferredProvide.length) {\r\n        deferredProvide.forEach(provideOptions => {\r\n            const provides = Object(shared_esm_bundler["p" /* isFunction */])(provideOptions)\r\n                ? provideOptions.call(publicThis)\r\n                : provideOptions;\r\n            Reflect.ownKeys(provides).forEach(key => {\r\n                provide(key, provides[key]);\r\n            });\r\n        });\r\n    }\r\n    // asset options.\r\n    // To reduce memory usage, only components with mixins or extends will have\r\n    // resolved asset registry attached to instance.\r\n    if (asMixin) {\r\n        if (components) {\r\n            Object(shared_esm_bundler["i" /* extend */])(instance.components ||\r\n                (instance.components = Object(shared_esm_bundler["i" /* extend */])({}, instance.type.components)), components);\r\n        }\r\n        if (directives) {\r\n            Object(shared_esm_bundler["i" /* extend */])(instance.directives ||\r\n                (instance.directives = Object(shared_esm_bundler["i" /* extend */])({}, instance.type.directives)), directives);\r\n        }\r\n    }\r\n    // lifecycle options\r\n    if (!asMixin) {\r\n        callSyncHook(\'created\', "c" /* CREATED */, options, instance, globalMixins);\r\n    }\r\n    if (beforeMount) {\r\n        onBeforeMount(beforeMount.bind(publicThis));\r\n    }\r\n    if (mounted) {\r\n        onMounted(mounted.bind(publicThis));\r\n    }\r\n    if (beforeUpdate) {\r\n        onBeforeUpdate(beforeUpdate.bind(publicThis));\r\n    }\r\n    if (updated) {\r\n        onUpdated(updated.bind(publicThis));\r\n    }\r\n    if (activated) {\r\n        onActivated(activated.bind(publicThis));\r\n    }\r\n    if (deactivated) {\r\n        onDeactivated(deactivated.bind(publicThis));\r\n    }\r\n    if (errorCaptured) {\r\n        onErrorCaptured(errorCaptured.bind(publicThis));\r\n    }\r\n    if (renderTracked) {\r\n        onRenderTracked(renderTracked.bind(publicThis));\r\n    }\r\n    if (renderTriggered) {\r\n        onRenderTriggered(renderTriggered.bind(publicThis));\r\n    }\r\n    if (false) {}\r\n    if (beforeUnmount) {\r\n        onBeforeUnmount(beforeUnmount.bind(publicThis));\r\n    }\r\n    if (false) {}\r\n    if (unmounted) {\r\n        onUnmounted(unmounted.bind(publicThis));\r\n    }\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(expose)) {\r\n        if (!asMixin) {\r\n            if (expose.length) {\r\n                const exposed = instance.exposed || (instance.exposed = proxyRefs({}));\r\n                expose.forEach(key => {\r\n                    exposed[key] = toRef(publicThis, key);\r\n                });\r\n            }\r\n            else if (!instance.exposed) {\r\n                instance.exposed = shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n            }\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n}\r\nfunction callSyncHook(name, type, options, instance, globalMixins) {\r\n    callHookFromMixins(name, type, globalMixins, instance);\r\n    const { extends: base, mixins } = options;\r\n    if (base) {\r\n        callHookFromExtends(name, type, base, instance);\r\n    }\r\n    if (mixins) {\r\n        callHookFromMixins(name, type, mixins, instance);\r\n    }\r\n    const selfHook = options[name];\r\n    if (selfHook) {\r\n        callWithAsyncErrorHandling(selfHook.bind(instance.proxy), instance, type);\r\n    }\r\n}\r\nfunction callHookFromExtends(name, type, base, instance) {\r\n    if (base.extends) {\r\n        callHookFromExtends(name, type, base.extends, instance);\r\n    }\r\n    const baseHook = base[name];\r\n    if (baseHook) {\r\n        callWithAsyncErrorHandling(baseHook.bind(instance.proxy), instance, type);\r\n    }\r\n}\r\nfunction callHookFromMixins(name, type, mixins, instance) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        const chainedMixins = mixins[i].mixins;\r\n        if (chainedMixins) {\r\n            callHookFromMixins(name, type, chainedMixins, instance);\r\n        }\r\n        const fn = mixins[i][name];\r\n        if (fn) {\r\n            callWithAsyncErrorHandling(fn.bind(instance.proxy), instance, type);\r\n        }\r\n    }\r\n}\r\nfunction applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        applyOptions(instance, mixins[i], deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n}\r\nfunction resolveData(instance, dataFn, publicThis) {\r\n    if (false) {}\r\n    const data = dataFn.call(publicThis, publicThis);\r\n    if (false) {}\r\n    if (!Object(shared_esm_bundler["v" /* isObject */])(data)) {\r\n        ( false) && false;\r\n    }\r\n    else if (instance.data === shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n        instance.data = reactive(data);\r\n    }\r\n    else {\r\n        // existing data: this is a mixin or extends.\r\n        Object(shared_esm_bundler["i" /* extend */])(instance.data, data);\r\n    }\r\n}\r\nfunction createWatcher(raw, ctx, publicThis, key) {\r\n    const getter = key.includes(\'.\')\r\n        ? createPathGetter(publicThis, key)\r\n        : () => publicThis[key];\r\n    if (Object(shared_esm_bundler["C" /* isString */])(raw)) {\r\n        const handler = ctx[raw];\r\n        if (Object(shared_esm_bundler["p" /* isFunction */])(handler)) {\r\n            watch(getter, handler);\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n    else if (Object(shared_esm_bundler["p" /* isFunction */])(raw)) {\r\n        watch(getter, raw.bind(publicThis));\r\n    }\r\n    else if (Object(shared_esm_bundler["v" /* isObject */])(raw)) {\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(raw)) {\r\n            raw.forEach(r => createWatcher(r, ctx, publicThis, key));\r\n        }\r\n        else {\r\n            const handler = Object(shared_esm_bundler["p" /* isFunction */])(raw.handler)\r\n                ? raw.handler.bind(publicThis)\r\n                : ctx[raw.handler];\r\n            if (Object(shared_esm_bundler["p" /* isFunction */])(handler)) {\r\n                watch(getter, handler, raw);\r\n            }\r\n            else if ((false)) {}\r\n        }\r\n    }\r\n    else if ((false)) {}\r\n}\r\nfunction createPathGetter(ctx, path) {\r\n    const segments = path.split(\'.\');\r\n    return () => {\r\n        let cur = ctx;\r\n        for (let i = 0; i < segments.length && cur; i++) {\r\n            cur = cur[segments[i]];\r\n        }\r\n        return cur;\r\n    };\r\n}\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && Object(shared_esm_bundler["l" /* hasOwn */])(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => {\r\n    if (!i)\r\n        return null;\r\n    if (isStatefulComponent(i))\r\n        return i.exposed ? i.exposed : i.proxy;\r\n    return getPublicInstance(i.parent);\r\n};\r\nconst publicPropertiesMap = Object(shared_esm_bundler["i" /* extend */])(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => (( false) ? undefined : i.props),\r\n    $attrs: i => (( false) ? undefined : i.attrs),\r\n    $slots: i => (( false) ? undefined : i.slots),\r\n    $refs: i => (( false) ? undefined : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : shared_esm_bundler["d" /* NOOP */])\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === "__v_skip" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if (false) {}\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It\'s much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== \'$\') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                Object(shared_esm_bundler["l" /* hasOwn */])(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === \'$attrs\') {\r\n                track(instance, "get" /* GET */, key);\r\n                ( false) && false;\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            Object(shared_esm_bundler["l" /* hasOwn */])(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if (false) {}\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (Object(shared_esm_bundler["l" /* hasOwn */])(instance.props, key)) {\r\n            ( false) &&\r\n                false;\r\n            return false;\r\n        }\r\n        if (key[0] === \'$\' && key.slice(1) in instance) {\r\n            ( false) &&\r\n                false;\r\n            return false;\r\n        }\r\n        else {\r\n            if (false) {}\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(data, key)) ||\r\n            (setupState !== shared_esm_bundler["b" /* EMPTY_OBJ */] && Object(shared_esm_bundler["l" /* hasOwn */])(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && Object(shared_esm_bundler["l" /* hasOwn */])(normalizedProps, key)) ||\r\n            Object(shared_esm_bundler["l" /* hasOwn */])(ctx, key) ||\r\n            Object(shared_esm_bundler["l" /* hasOwn */])(publicPropertiesMap, key) ||\r\n            Object(shared_esm_bundler["l" /* hasOwn */])(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif (false) {}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = Object(shared_esm_bundler["i" /* extend */])({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== \'_\' && !Object(shared_esm_bundler["q" /* isGloballyWhitelisted */])(key);\r\n        if (false) {}\r\n        return has;\r\n    }\r\n});\r\n// In dev mode, the proxy target exposes the same properties as seen on `this`\r\n// for easier console inspection. In prod mode it will be an empty object so\r\n// these properties definitions can be skipped.\r\nfunction createRenderContext(instance) {\r\n    const target = {};\r\n    // expose internal instance for proxy handlers\r\n    Object.defineProperty(target, `_`, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        get: () => instance\r\n    });\r\n    // expose public properties\r\n    Object.keys(publicPropertiesMap).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => publicPropertiesMap[key](instance),\r\n            // intercepted by the proxy so no need for implementation,\r\n            // but needed to prevent set errors\r\n            set: shared_esm_bundler["d" /* NOOP */]\r\n        });\r\n    });\r\n    // expose global properties\r\n    const { globalProperties } = instance.appContext.config;\r\n    Object.keys(globalProperties).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => globalProperties[key],\r\n            set: shared_esm_bundler["d" /* NOOP */]\r\n        });\r\n    });\r\n    return target;\r\n}\r\n// dev only\r\nfunction exposePropsOnRenderContext(instance) {\r\n    const { ctx, propsOptions: [propsOptions] } = instance;\r\n    if (propsOptions) {\r\n        Object.keys(propsOptions).forEach(key => {\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => instance.props[key],\r\n                set: shared_esm_bundler["d" /* NOOP */]\r\n            });\r\n        });\r\n    }\r\n}\r\n// dev only\r\nfunction exposeSetupStateOnRenderContext(instance) {\r\n    const { ctx, setupState } = instance;\r\n    Object.keys(toRaw(setupState)).forEach(key => {\r\n        if (key[0] === \'$\' || key[0] === \'_\') {\r\n            warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +\r\n                `which are reserved prefixes for Vue internals.`);\r\n            return;\r\n        }\r\n        Object.defineProperty(ctx, key, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => setupState[key],\r\n            set: shared_esm_bundler["d" /* NOOP */]\r\n        });\r\n    });\r\n}\n\nconst emptyAppContext = createAppContext();\r\nlet uid$1 = 0;\r\nfunction createComponentInstance(vnode, parent, suspense) {\r\n    const type = vnode.type;\r\n    // inherit parent app context - or - if root, adopt from root vnode\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n    const instance = {\r\n        uid: uid$1++,\r\n        vnode,\r\n        type,\r\n        parent,\r\n        appContext,\r\n        root: null,\r\n        next: null,\r\n        subTree: null,\r\n        update: null,\r\n        render: null,\r\n        proxy: null,\r\n        exposed: null,\r\n        withProxy: null,\r\n        effects: null,\r\n        provides: parent ? parent.provides : Object.create(appContext.provides),\r\n        accessCache: null,\r\n        renderCache: [],\r\n        // local resovled assets\r\n        components: null,\r\n        directives: null,\r\n        // resolved props and emits options\r\n        propsOptions: normalizePropsOptions(type, appContext),\r\n        emitsOptions: normalizeEmitsOptions(type, appContext),\r\n        // emit\r\n        emit: null,\r\n        emitted: null,\r\n        // state\r\n        ctx: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        data: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        props: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        attrs: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        slots: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        refs: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        setupState: shared_esm_bundler["b" /* EMPTY_OBJ */],\r\n        setupContext: null,\r\n        // suspense related\r\n        suspense,\r\n        suspenseId: suspense ? suspense.pendingId : 0,\r\n        asyncDep: null,\r\n        asyncResolved: false,\r\n        // lifecycle hooks\r\n        // not using enums here because it results in computed properties\r\n        isMounted: false,\r\n        isUnmounted: false,\r\n        isDeactivated: false,\r\n        bc: null,\r\n        c: null,\r\n        bm: null,\r\n        m: null,\r\n        bu: null,\r\n        u: null,\r\n        um: null,\r\n        bum: null,\r\n        da: null,\r\n        a: null,\r\n        rtg: null,\r\n        rtc: null,\r\n        ec: null\r\n    };\r\n    if ((false)) {}\r\n    else {\r\n        instance.ctx = { _: instance };\r\n    }\r\n    instance.root = parent ? parent.root : instance;\r\n    instance.emit = runtime_core_esm_bundler_emit.bind(null, instance);\r\n    return instance;\r\n}\r\nlet currentInstance = null;\r\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\r\nconst setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n};\r\nconst isBuiltInTag = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'slot,component\');\r\nfunction validateComponentName(name, config) {\r\n    const appIsNativeTag = config.isNativeTag || shared_esm_bundler["c" /* NO */];\r\n    if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n        warn(\'Do not use built-in or reserved HTML elements as component id: \' + name);\r\n    }\r\n}\r\nfunction isStatefulComponent(instance) {\r\n    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n}\r\nlet isInSSRComponentSetup = false;\r\nfunction setupComponent(instance, isSSR = false) {\r\n    isInSSRComponentSetup = isSSR;\r\n    const { props, children } = instance.vnode;\r\n    const isStateful = isStatefulComponent(instance);\r\n    initProps(instance, props, isStateful, isSSR);\r\n    initSlots(instance, children);\r\n    const setupResult = isStateful\r\n        ? setupStatefulComponent(instance, isSSR)\r\n        : undefined;\r\n    isInSSRComponentSetup = false;\r\n    return setupResult;\r\n}\r\nfunction setupStatefulComponent(instance, isSSR) {\r\n    const Component = instance.type;\r\n    if ((false)) {}\r\n    // 0. create render proxy property access cache\r\n    instance.accessCache = Object.create(null);\r\n    // 1. create public instance / render proxy\r\n    // also mark it raw so it\'s never observed\r\n    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\r\n    if ((false)) {}\r\n    // 2. call setup()\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        const setupContext = (instance.setupContext =\r\n            setup.length > 1 ? createSetupContext(instance) : null);\r\n        currentInstance = instance;\r\n        pauseTracking();\r\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( false) ? undefined : instance.props, setupContext]);\r\n        resetTracking();\r\n        currentInstance = null;\r\n        if (Object(shared_esm_bundler["x" /* isPromise */])(setupResult)) {\r\n            if (isSSR) {\r\n                // return the promise so server-renderer can wait on it\r\n                return setupResult.then((resolvedResult) => {\r\n                    handleSetupResult(instance, resolvedResult);\r\n                });\r\n            }\r\n            else {\r\n                // async setup returned Promise.\r\n                // bail here and wait for re-entry.\r\n                instance.asyncDep = setupResult;\r\n            }\r\n        }\r\n        else {\r\n            handleSetupResult(instance, setupResult);\r\n        }\r\n    }\r\n    else {\r\n        finishComponentSetup(instance);\r\n    }\r\n}\r\nfunction handleSetupResult(instance, setupResult, isSSR) {\r\n    if (Object(shared_esm_bundler["p" /* isFunction */])(setupResult)) {\r\n        // setup returned an inline render function\r\n        {\r\n            instance.render = setupResult;\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["v" /* isObject */])(setupResult)) {\r\n        if (false) {}\r\n        // setup returned bindings.\r\n        // assuming a render function compiled from template is present.\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            instance.devtoolsRawSetupState = setupResult;\r\n        }\r\n        instance.setupState = proxyRefs(setupResult);\r\n        if ((false)) {}\r\n    }\r\n    else if (false) {}\r\n    finishComponentSetup(instance);\r\n}\r\nlet compile;\r\n// dev only\r\nconst isRuntimeOnly = () => !compile;\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nfunction registerRuntimeCompiler(_compile) {\r\n    compile = _compile;\r\n}\r\nfunction finishComponentSetup(instance, isSSR) {\r\n    const Component = instance.type;\r\n    // template / render function normalization\r\n    if (!instance.render) {\r\n        // could be set from setup()\r\n        if (compile && Component.template && !Component.render) {\r\n            if ((false)) {}\r\n            Component.render = compile(Component.template, {\r\n                isCustomElement: instance.appContext.config.isCustomElement,\r\n                delimiters: Component.delimiters\r\n            });\r\n            if ((false)) {}\r\n        }\r\n        instance.render = (Component.render || shared_esm_bundler["d" /* NOOP */]);\r\n        // for runtime-compiled render functions using `with` blocks, the render\r\n        // proxy used needs a different `has` handler which is more performant and\r\n        // also only allows a whitelist of globals to fallthrough.\r\n        if (instance.render._rc) {\r\n            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\r\n        }\r\n    }\r\n    // support for 2.x options\r\n    if (__VUE_OPTIONS_API__) {\r\n        currentInstance = instance;\r\n        pauseTracking();\r\n        applyOptions(instance, Component);\r\n        resetTracking();\r\n        currentInstance = null;\r\n    }\r\n    // warn missing template/render\r\n    if (false) {}\r\n}\r\nconst attrHandlers = {\r\n    get: (target, key) => {\r\n        if ((false)) {}\r\n        return target[key];\r\n    },\r\n    set: () => {\r\n        warn(`setupContext.attrs is readonly.`);\r\n        return false;\r\n    },\r\n    deleteProperty: () => {\r\n        warn(`setupContext.attrs is readonly.`);\r\n        return false;\r\n    }\r\n};\r\nfunction createSetupContext(instance) {\r\n    const expose = exposed => {\r\n        if (false) {}\r\n        instance.exposed = proxyRefs(exposed);\r\n    };\r\n    if ((false)) {}\r\n    else {\r\n        return {\r\n            attrs: instance.attrs,\r\n            slots: instance.slots,\r\n            emit: instance.emit,\r\n            expose\r\n        };\r\n    }\r\n}\r\n// record effects created during a component\'s setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, \'\');\r\nfunction getComponentName(Component) {\r\n    return Object(shared_esm_bundler["p" /* isFunction */])(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = getComponentName(Component);\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return Object(shared_esm_bundler["p" /* isFunction */])(value) && \'__vccOpts\' in value;\r\n}\n\nfunction runtime_core_esm_bundler_computed(getterOrOptions) {\r\n    const c = reactivity_esm_bundler_computed(getterOrOptions);\r\n    recordInstanceBoundEffect(c.effect);\r\n    return c;\r\n}\n\n// implementation\r\nfunction defineProps() {\r\n    if ((false)) {}\r\n    return null;\r\n}\r\n// implementation\r\nfunction defineEmit() {\r\n    if ((false)) {}\r\n    return null;\r\n}\r\nfunction useContext() {\r\n    const i = getCurrentInstance();\r\n    if (false) {}\r\n    return i.setupContext || (i.setupContext = createSetupContext(i));\r\n}\n\n// Actual implementation\r\nfunction h(type, propsOrChildren, children) {\r\n    const l = arguments.length;\r\n    if (l === 2) {\r\n        if (Object(shared_esm_bundler["v" /* isObject */])(propsOrChildren) && !Object(shared_esm_bundler["o" /* isArray */])(propsOrChildren)) {\r\n            // single vnode without props\r\n            if (isVNode(propsOrChildren)) {\r\n                return createVNode(type, null, [propsOrChildren]);\r\n            }\r\n            // props without children\r\n            return createVNode(type, propsOrChildren);\r\n        }\r\n        else {\r\n            // omit props\r\n            return createVNode(type, null, propsOrChildren);\r\n        }\r\n    }\r\n    else {\r\n        if (l > 3) {\r\n            children = Array.prototype.slice.call(arguments, 2);\r\n        }\r\n        else if (l === 3 && isVNode(children)) {\r\n            children = [children];\r\n        }\r\n        return createVNode(type, propsOrChildren, children);\r\n    }\r\n}\n\nconst ssrContextKey = Symbol(( false) ? undefined : ``);\r\nconst useSSRContext = () => {\r\n    {\r\n        const ctx = inject(ssrContextKey);\r\n        if (!ctx) {\r\n            warn(`Server rendering context not provided. Make sure to only call ` +\r\n                `useSSRContext() conditionally in the server build.`);\r\n        }\r\n        return ctx;\r\n    }\r\n};\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (true) {\r\n        return;\r\n    }\r\n    const vueStyle = { style: \'color:#3ba776\' };\r\n    const numberStyle = { style: \'color:#0b1bc9\' };\r\n    const stringStyle = { style: \'color:#b62e24\' };\r\n    const keywordStyle = { style: \'color:#9d288c\' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!Object(shared_esm_bundler["v" /* isObject */])(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return [\'div\', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    \'div\',\r\n                    {},\r\n                    [\'span\', vueStyle, genRefFlag(obj)],\r\n                    \'<\',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    \'div\',\r\n                    {},\r\n                    [\'span\', vueStyle, \'Reactive\'],\r\n                    \'<\',\r\n                    formatValue(obj),\r\n                    `>${reactivity_esm_bundler_isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (reactivity_esm_bundler_isReadonly(obj)) {\r\n                return [\r\n                    \'div\',\r\n                    {},\r\n                    [\'span\', vueStyle, \'Readonly\'],\r\n                    \'<\',\r\n                    formatValue(obj),\r\n                    \'>\'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    \'div\',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock(\'props\', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n            blocks.push(createInstanceBlock(\'setup\', instance.setupState));\r\n        }\r\n        if (instance.data !== shared_esm_bundler["b" /* EMPTY_OBJ */]) {\r\n            blocks.push(createInstanceBlock(\'data\', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, \'computed\');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock(\'computed\', computed));\r\n        }\r\n        const injected = extractKeys(instance, \'inject\');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock(\'injected\', injected));\r\n        }\r\n        blocks.push([\r\n            \'div\',\r\n            {},\r\n            [\r\n                \'span\',\r\n                {\r\n                    style: keywordStyle.style + \';opacity:0.66\'\r\n                },\r\n                \'$ (internal): \'\r\n            ],\r\n            [\'object\', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = Object(shared_esm_bundler["i" /* extend */])({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return [\'span\', {}];\r\n        }\r\n        return [\r\n            \'div\',\r\n            { style: \'line-height:1.25em;margin-bottom:0.6em\' },\r\n            [\r\n                \'div\',\r\n                {\r\n                    style: \'color:#476582\'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                \'div\',\r\n                {\r\n                    style: \'padding-left:1.25em\'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        \'div\',\r\n                        {},\r\n                        [\'span\', keywordStyle, key + \': \'],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === \'number\') {\r\n            return [\'span\', numberStyle, v];\r\n        }\r\n        else if (typeof v === \'string\') {\r\n            return [\'span\', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === \'boolean\') {\r\n            return [\'span\', keywordStyle, v];\r\n        }\r\n        else if (Object(shared_esm_bundler["v" /* isObject */])(v)) {\r\n            return [\'object\', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return [\'span\', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (Object(shared_esm_bundler["p" /* isFunction */])(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((Object(shared_esm_bundler["o" /* isArray */])(opts) && opts.includes(key)) ||\r\n            (Object(shared_esm_bundler["v" /* isObject */])(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\n/**\r\n * Actual implementation\r\n */\r\nfunction renderList(source, renderItem) {\r\n    let ret;\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(source) || Object(shared_esm_bundler["C" /* isString */])(source)) {\r\n        ret = new Array(source.length);\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            ret[i] = renderItem(source[i], i);\r\n        }\r\n    }\r\n    else if (typeof source === \'number\') {\r\n        if (false) {}\r\n        ret = new Array(source);\r\n        for (let i = 0; i < source; i++) {\r\n            ret[i] = renderItem(i + 1, i);\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["v" /* isObject */])(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            ret = Array.from(source, renderItem);\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            ret = new Array(keys.length);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                ret[i] = renderItem(source[key], key, i);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        ret = [];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * For prefixing keys in v-on="obj" with "on"\r\n * @private\r\n */\r\nfunction toHandlers(obj) {\r\n    const ret = {};\r\n    if (false) {}\r\n    for (const key in obj) {\r\n        ret[Object(shared_esm_bundler["N" /* toHandlerKey */])(key)] = obj[key];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Compiler runtime helper for creating dynamic slots object\r\n * @private\r\n */\r\nfunction createSlots(slots, dynamicSlots) {\r\n    for (let i = 0; i < dynamicSlots.length; i++) {\r\n        const slot = dynamicSlots[i];\r\n        // array of dynamic slot generated by <template v-for="..." #[...]>\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(slot)) {\r\n            for (let j = 0; j < slot.length; j++) {\r\n                slots[slot[j].name] = slot[j].fn;\r\n            }\r\n        }\r\n        else if (slot) {\r\n            // conditional single slot generated by <template v-if="..." #foo>\r\n            slots[slot.name] = slot.fn;\r\n        }\r\n    }\r\n    return slots;\r\n}\n\n// Core API ------------------------------------------------------------------\r\nconst version = "3.0.7";\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\r\n * @internal\r\n */\r\nconst ssrUtils = (null);\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\n\n\n\n\nconst svgNS = \'http://www.w3.org/2000/svg\';\r\nconst doc = (typeof document !== \'undefined\' ? document : null);\r\nlet tempContainer;\r\nlet tempSVGContainer;\r\nconst nodeOps = {\r\n    insert: (child, parent, anchor) => {\r\n        parent.insertBefore(child, anchor || null);\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: (tag, isSVG, is) => isSVG\r\n        ? doc.createElementNS(svgNS, tag)\r\n        : doc.createElement(tag, is ? { is } : undefined),\r\n    createText: text => doc.createTextNode(text),\r\n    createComment: text => doc.createComment(text),\r\n    setText: (node, text) => {\r\n        node.nodeValue = text;\r\n    },\r\n    setElementText: (el, text) => {\r\n        el.textContent = text;\r\n    },\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => doc.querySelector(selector),\r\n    setScopeId(el, id) {\r\n        el.setAttribute(id, \'\');\r\n    },\r\n    cloneNode(el) {\r\n        return el.cloneNode(true);\r\n    },\r\n    // __UNSAFE__\r\n    // Reason: innerHTML.\r\n    // Static content here can only come from compiled templates.\r\n    // As long as the user only uses trusted templates, this is safe.\r\n    insertStaticContent(content, parent, anchor, isSVG) {\r\n        const temp = isSVG\r\n            ? tempSVGContainer ||\r\n                (tempSVGContainer = doc.createElementNS(svgNS, \'svg\'))\r\n            : tempContainer || (tempContainer = doc.createElement(\'div\'));\r\n        temp.innerHTML = content;\r\n        const first = temp.firstChild;\r\n        let node = first;\r\n        let last = node;\r\n        while (node) {\r\n            last = node;\r\n            nodeOps.insert(node, parent, anchor);\r\n            node = temp.firstChild;\r\n        }\r\n        return [first, last];\r\n    }\r\n};\n\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding [\'staticClass\', dynamic]\r\nfunction patchClass(el, value, isSVG) {\r\n    if (value == null) {\r\n        value = \'\';\r\n    }\r\n    if (isSVG) {\r\n        el.setAttribute(\'class\', value);\r\n    }\r\n    else {\r\n        // directly setting className should be faster than setAttribute in theory\r\n        // if this is an element during a transition, take the temporary transition\r\n        // classes into account.\r\n        const transitionClasses = el._vtc;\r\n        if (transitionClasses) {\r\n            value = (value\r\n                ? [value, ...transitionClasses]\r\n                : [...transitionClasses]).join(\' \');\r\n        }\r\n        el.className = value;\r\n    }\r\n}\n\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style;\r\n    if (!next) {\r\n        el.removeAttribute(\'style\');\r\n    }\r\n    else if (Object(shared_esm_bundler["C" /* isString */])(next)) {\r\n        if (prev !== next) {\r\n            const current = style.display;\r\n            style.cssText = next;\r\n            // indicates that the `display` of the element is controlled by `v-show`,\r\n            // so we always keep the current `display` value regardless of the `style` value,\r\n            // thus handing over control to `v-show`.\r\n            if (\'_vod\' in el) {\r\n                style.display = current;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (const key in next) {\r\n            setStyle(style, key, next[key]);\r\n        }\r\n        if (prev && !Object(shared_esm_bundler["C" /* isString */])(prev)) {\r\n            for (const key in prev) {\r\n                if (next[key] == null) {\r\n                    setStyle(style, key, \'\');\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nconst importantRE = /\\s*!important$/;\r\nfunction setStyle(style, name, val) {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(val)) {\r\n        val.forEach(v => setStyle(style, name, v));\r\n    }\r\n    else {\r\n        if (name.startsWith(\'--\')) {\r\n            // custom property definition\r\n            style.setProperty(name, val);\r\n        }\r\n        else {\r\n            const prefixed = autoPrefix(style, name);\r\n            if (importantRE.test(val)) {\r\n                // !important\r\n                style.setProperty(Object(shared_esm_bundler["m" /* hyphenate */])(prefixed), val.replace(importantRE, \'\'), \'important\');\r\n            }\r\n            else {\r\n                style[prefixed] = val;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst prefixes = [\'Webkit\', \'Moz\', \'ms\'];\r\nconst prefixCache = {};\r\nfunction autoPrefix(style, rawName) {\r\n    const cached = prefixCache[rawName];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    let name = Object(shared_esm_bundler["f" /* camelize */])(rawName);\r\n    if (name !== \'filter\' && name in style) {\r\n        return (prefixCache[rawName] = name);\r\n    }\r\n    name = Object(shared_esm_bundler["g" /* capitalize */])(name);\r\n    for (let i = 0; i < prefixes.length; i++) {\r\n        const prefixed = prefixes[i] + name;\r\n        if (prefixed in style) {\r\n            return (prefixCache[rawName] = prefixed);\r\n        }\r\n    }\r\n    return rawName;\r\n}\n\nconst xlinkNS = \'http://www.w3.org/1999/xlink\';\r\nfunction patchAttr(el, key, value, isSVG) {\r\n    if (isSVG && key.startsWith(\'xlink:\')) {\r\n        if (value == null) {\r\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        // note we are only checking boolean attributes that don\'t have a\r\n        // corresponding dom prop of the same name here.\r\n        const isBoolean = Object(shared_esm_bundler["B" /* isSpecialBooleanAttr */])(key);\r\n        if (value == null || (isBoolean && value === false)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, isBoolean ? \'\' : value);\r\n        }\r\n    }\r\n}\n\n// __UNSAFE__\r\n// functions. The user is responsible for using them with only trusted content.\r\nfunction patchDOMProp(el, key, value, \r\n// the following args are passed only due to potential innerHTML/textContent\r\n// overriding existing VNodes, in which case the old tree must be properly\r\n// unmounted.\r\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n    if (key === \'innerHTML\' || key === \'textContent\') {\r\n        if (prevChildren) {\r\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n        }\r\n        el[key] = value == null ? \'\' : value;\r\n        return;\r\n    }\r\n    if (key === \'value\' && el.tagName !== \'PROGRESS\') {\r\n        // store value as _value as well since\r\n        // non-string values will be stringified.\r\n        el._value = value;\r\n        const newValue = value == null ? \'\' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n        return;\r\n    }\r\n    if (value === \'\' || value == null) {\r\n        const type = typeof el[key];\r\n        if (value === \'\' && type === \'boolean\') {\r\n            // e.g. <select multiple> compiles to { multiple: \'\' }\r\n            el[key] = true;\r\n            return;\r\n        }\r\n        else if (value == null && type === \'string\') {\r\n            // e.g. <div :id="null">\r\n            el[key] = \'\';\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n        else if (type === \'number\') {\r\n            // e.g. <img :width="null">\r\n            el[key] = 0;\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n    }\r\n    // some properties perform value validation and throw\r\n    try {\r\n        el[key] = value;\r\n    }\r\n    catch (e) {\r\n        if ((false)) {}\r\n    }\r\n}\n\n// Async edge case fix requires storing an event listener\'s attach timestamp.\r\nlet _getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\nif (typeof document !== \'undefined\' &&\r\n    _getNow() > document.createEvent(\'Event\').timeStamp) {\r\n    // if the low-res timestamp which is bigger than the event timestamp\r\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n    // and we need to use the hi-res version for event listeners as well.\r\n    _getNow = () => performance.now();\r\n}\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst runtime_dom_esm_bundler_p = Promise.resolve();\r\nconst runtime_dom_esm_bundler_reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (runtime_dom_esm_bundler_p.then(runtime_dom_esm_bundler_reset), (cachedNow = _getNow()));\r\nfunction addEventListener(el, event, handler, options) {\r\n    el.addEventListener(event, handler, options);\r\n}\r\nfunction removeEventListener(el, event, handler, options) {\r\n    el.removeEventListener(event, handler, options);\r\n}\r\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n    // vei = vue event invokers\r\n    const invokers = el._vei || (el._vei = {});\r\n    const existingInvoker = invokers[rawName];\r\n    if (nextValue && existingInvoker) {\r\n        // patch\r\n        existingInvoker.value = nextValue;\r\n    }\r\n    else {\r\n        const [name, options] = parseName(rawName);\r\n        if (nextValue) {\r\n            // add\r\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n            addEventListener(el, name, invoker, options);\r\n        }\r\n        else if (existingInvoker) {\r\n            // remove\r\n            removeEventListener(el, name, existingInvoker, options);\r\n            invokers[rawName] = undefined;\r\n        }\r\n    }\r\n}\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\nfunction parseName(name) {\r\n    let options;\r\n    if (optionsModifierRE.test(name)) {\r\n        options = {};\r\n        let m;\r\n        while ((m = name.match(optionsModifierRE))) {\r\n            name = name.slice(0, name.length - m[0].length);\r\n            options[m[0].toLowerCase()] = true;\r\n        }\r\n    }\r\n    return [Object(shared_esm_bundler["m" /* hyphenate */])(name.slice(2)), options];\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = (e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        const timeStamp = e.timeStamp || _getNow();\r\n        if (timeStamp >= invoker.attached - 1) {\r\n            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n        }\r\n    };\r\n    invoker.value = initialValue;\r\n    invoker.attached = getNow();\r\n    return invoker;\r\n}\r\nfunction patchStopImmediatePropagation(e, value) {\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(value)) {\r\n        const originalStop = e.stopImmediatePropagation;\r\n        e.stopImmediatePropagation = () => {\r\n            originalStop.call(e);\r\n            e._stopped = true;\r\n        };\r\n        return value.map(fn => (e) => !e._stopped && fn(e));\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\n\nconst nativeOnRE = /^on[a-z]/;\r\nconst forcePatchProp = (_, key) => key === \'value\';\r\nconst runtime_dom_esm_bundler_patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n    switch (key) {\r\n        // special\r\n        case \'class\':\r\n            patchClass(el, nextValue, isSVG);\r\n            break;\r\n        case \'style\':\r\n            patchStyle(el, prevValue, nextValue);\r\n            break;\r\n        default:\r\n            if (Object(shared_esm_bundler["w" /* isOn */])(key)) {\r\n                // ignore v-model listeners\r\n                if (!Object(shared_esm_bundler["u" /* isModelListener */])(key)) {\r\n                    patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n                }\r\n            }\r\n            else if (shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n            }\r\n            else {\r\n                // special case for <input v-model type="checkbox"> with\r\n                // :true-value & :false-value\r\n                // store value as dom properties since non-string values will be\r\n                // stringified.\r\n                if (key === \'true-value\') {\r\n                    el._trueValue = nextValue;\r\n                }\r\n                else if (key === \'false-value\') {\r\n                    el._falseValue = nextValue;\r\n                }\r\n                patchAttr(el, key, nextValue, isSVG);\r\n            }\r\n            break;\r\n    }\r\n};\r\nfunction shouldSetAsProp(el, key, value, isSVG) {\r\n    if (isSVG) {\r\n        // most keys must be set as attribute on svg elements to work\r\n        // ...except innerHTML\r\n        if (key === \'innerHTML\') {\r\n            return true;\r\n        }\r\n        // or native onclick with function values\r\n        if (key in el && nativeOnRE.test(key) && Object(shared_esm_bundler["p" /* isFunction */])(value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // spellcheck and draggable are numerated attrs, however their\r\n    // corresponding DOM properties are actually booleans - this leads to\r\n    // setting it with a string "false" value leading it to be coerced to\r\n    // `true`, so we need to always treat them as attributes.\r\n    // Note that `contentEditable` doesn\'t have this problem: its DOM\r\n    // property is also enumerated string values.\r\n    if (key === \'spellcheck\' || key === \'draggable\') {\r\n        return false;\r\n    }\r\n    // #1787, #2840 form property on form elements is readonly and must be set as\r\n    // attribute.\r\n    if (key === \'form\') {\r\n        return false;\r\n    }\r\n    // #1526 <input list> must be set as attribute\r\n    if (key === \'list\' && el.tagName === \'INPUT\') {\r\n        return false;\r\n    }\r\n    // #2766 <textarea type> must be set as attribute\r\n    if (key === \'type\' && el.tagName === \'TEXTAREA\') {\r\n        return false;\r\n    }\r\n    // native onclick with string value, must be set as attribute\r\n    if (nativeOnRE.test(key) && Object(shared_esm_bundler["C" /* isString */])(value)) {\r\n        return false;\r\n    }\r\n    return key in el;\r\n}\n\nfunction useCssModule(name = \'$style\') {\r\n    /* istanbul ignore else */\r\n    {\r\n        const instance = getCurrentInstance();\r\n        if (!instance) {\r\n            ( false) && false;\r\n            return shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        }\r\n        const modules = instance.type.__cssModules;\r\n        if (!modules) {\r\n            ( false) && false;\r\n            return shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        }\r\n        const mod = modules[name];\r\n        if (!mod) {\r\n            ( false) &&\r\n                false;\r\n            return shared_esm_bundler["b" /* EMPTY_OBJ */];\r\n        }\r\n        return mod;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for SFC\'s CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    const instance = getCurrentInstance();\r\n    /* istanbul ignore next */\r\n    if (!instance) {\r\n        ( false) &&\r\n            false;\r\n        return;\r\n    }\r\n    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));\r\n    onMounted(() => watchEffect(setVars, { flush: \'post\' }));\r\n    onUpdated(setVars);\r\n}\r\nfunction setVarsOnVNode(vnode, vars) {\r\n    if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        const suspense = vnode.suspense;\r\n        vnode = suspense.activeBranch;\r\n        if (suspense.pendingBranch && !suspense.isHydrating) {\r\n            suspense.effects.push(() => {\r\n                setVarsOnVNode(suspense.activeBranch, vars);\r\n            });\r\n        }\r\n    }\r\n    // drill down HOCs until it\'s a non-component vnode\r\n    while (vnode.component) {\r\n        vnode = vnode.component.subTree;\r\n    }\r\n    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {\r\n        const style = vnode.el.style;\r\n        for (const key in vars) {\r\n            style.setProperty(`--${key}`, vars[key]);\r\n        }\r\n    }\r\n    else if (vnode.type === Fragment) {\r\n        vnode.children.forEach(c => setVarsOnVNode(c, vars));\r\n    }\r\n}\n\nconst TRANSITION = \'transition\';\r\nconst ANIMATION = \'animation\';\r\n// DOM Transition is a higher-order-component based on the platform-agnostic\r\n// base Transition component, with DOM-specific logic.\r\nconst Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);\r\nTransition.displayName = \'Transition\';\r\nconst DOMTransitionPropsValidators = {\r\n    name: String,\r\n    type: String,\r\n    css: {\r\n        type: Boolean,\r\n        default: true\r\n    },\r\n    duration: [String, Number, Object],\r\n    enterFromClass: String,\r\n    enterActiveClass: String,\r\n    enterToClass: String,\r\n    appearFromClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    leaveFromClass: String,\r\n    leaveActiveClass: String,\r\n    leaveToClass: String\r\n};\r\nconst TransitionPropsValidators = (Transition.props = /*#__PURE__*/ Object(shared_esm_bundler["i" /* extend */])({}, BaseTransition.props, DOMTransitionPropsValidators));\r\nfunction resolveTransitionProps(rawProps) {\r\n    let { name = \'v\', type, css = true, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\r\n    const baseProps = {};\r\n    for (const key in rawProps) {\r\n        if (!(key in DOMTransitionPropsValidators)) {\r\n            baseProps[key] = rawProps[key];\r\n        }\r\n    }\r\n    if (!css) {\r\n        return baseProps;\r\n    }\r\n    const durations = normalizeDuration(duration);\r\n    const enterDuration = durations && durations[0];\r\n    const leaveDuration = durations && durations[1];\r\n    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\r\n    const finishEnter = (el, isAppear, done) => {\r\n        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\r\n        done && done();\r\n    };\r\n    const finishLeave = (el, done) => {\r\n        removeTransitionClass(el, leaveToClass);\r\n        removeTransitionClass(el, leaveActiveClass);\r\n        done && done();\r\n    };\r\n    const makeEnterHook = (isAppear) => {\r\n        return (el, done) => {\r\n            const hook = isAppear ? onAppear : onEnter;\r\n            const resolve = () => finishEnter(el, isAppear, done);\r\n            hook && hook(el, resolve);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\r\n                addTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n                if (!(hook && hook.length > 1)) {\r\n                    whenTransitionEnds(el, type, enterDuration, resolve);\r\n                }\r\n            });\r\n        };\r\n    };\r\n    return Object(shared_esm_bundler["i" /* extend */])(baseProps, {\r\n        onBeforeEnter(el) {\r\n            onBeforeEnter && onBeforeEnter(el);\r\n            addTransitionClass(el, enterFromClass);\r\n            addTransitionClass(el, enterActiveClass);\r\n        },\r\n        onBeforeAppear(el) {\r\n            onBeforeAppear && onBeforeAppear(el);\r\n            addTransitionClass(el, appearFromClass);\r\n            addTransitionClass(el, appearActiveClass);\r\n        },\r\n        onEnter: makeEnterHook(false),\r\n        onAppear: makeEnterHook(true),\r\n        onLeave(el, done) {\r\n            const resolve = () => finishLeave(el, done);\r\n            addTransitionClass(el, leaveFromClass);\r\n            // force reflow so *-leave-from classes immediately take effect (#2593)\r\n            forceReflow();\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, leaveFromClass);\r\n                addTransitionClass(el, leaveToClass);\r\n                if (!(onLeave && onLeave.length > 1)) {\r\n                    whenTransitionEnds(el, type, leaveDuration, resolve);\r\n                }\r\n            });\r\n            onLeave && onLeave(el, resolve);\r\n        },\r\n        onEnterCancelled(el) {\r\n            finishEnter(el, false);\r\n            onEnterCancelled && onEnterCancelled(el);\r\n        },\r\n        onAppearCancelled(el) {\r\n            finishEnter(el, true);\r\n            onAppearCancelled && onAppearCancelled(el);\r\n        },\r\n        onLeaveCancelled(el) {\r\n            finishLeave(el);\r\n            onLeaveCancelled && onLeaveCancelled(el);\r\n        }\r\n    });\r\n}\r\nfunction normalizeDuration(duration) {\r\n    if (duration == null) {\r\n        return null;\r\n    }\r\n    else if (Object(shared_esm_bundler["v" /* isObject */])(duration)) {\r\n        return [NumberOf(duration.enter), NumberOf(duration.leave)];\r\n    }\r\n    else {\r\n        const n = NumberOf(duration);\r\n        return [n, n];\r\n    }\r\n}\r\nfunction NumberOf(val) {\r\n    const res = Object(shared_esm_bundler["O" /* toNumber */])(val);\r\n    if ((false))\r\n        {}\r\n    return res;\r\n}\r\nfunction validateDuration(val) {\r\n    if (typeof val !== \'number\') {\r\n        warn(`<transition> explicit duration is not a valid number - ` +\r\n            `got ${JSON.stringify(val)}.`);\r\n    }\r\n    else if (isNaN(val)) {\r\n        warn(`<transition> explicit duration is NaN - ` +\r\n            \'the duration expression might be incorrect.\');\r\n    }\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\r\n    (el._vtc ||\r\n        (el._vtc = new Set())).add(cls);\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\r\n    const { _vtc } = el;\r\n    if (_vtc) {\r\n        _vtc.delete(cls);\r\n        if (!_vtc.size) {\r\n            el._vtc = undefined;\r\n        }\r\n    }\r\n}\r\nfunction nextFrame(cb) {\r\n    requestAnimationFrame(() => {\r\n        requestAnimationFrame(cb);\r\n    });\r\n}\r\nlet endId = 0;\r\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\r\n    const id = (el._endId = ++endId);\r\n    const resolveIfNotStale = () => {\r\n        if (id === el._endId) {\r\n            resolve();\r\n        }\r\n    };\r\n    if (explicitTimeout) {\r\n        return setTimeout(resolveIfNotStale, explicitTimeout);\r\n    }\r\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\r\n    if (!type) {\r\n        return resolve();\r\n    }\r\n    const endEvent = type + \'end\';\r\n    let ended = 0;\r\n    const end = () => {\r\n        el.removeEventListener(endEvent, onEnd);\r\n        resolveIfNotStale();\r\n    };\r\n    const onEnd = (e) => {\r\n        if (e.target === el && ++ended >= propCount) {\r\n            end();\r\n        }\r\n    };\r\n    setTimeout(() => {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(endEvent, onEnd);\r\n}\r\nfunction getTransitionInfo(el, expectedType) {\r\n    const styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    const getStyleProperties = (key) => (styles[key] || \'\').split(\', \');\r\n    const transitionDelays = getStyleProperties(TRANSITION + \'Delay\');\r\n    const transitionDurations = getStyleProperties(TRANSITION + \'Duration\');\r\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    const animationDelays = getStyleProperties(ANIMATION + \'Delay\');\r\n    const animationDurations = getStyleProperties(ANIMATION + \'Duration\');\r\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    let type = null;\r\n    let timeout = 0;\r\n    let propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    const hasTransform = type === TRANSITION &&\r\n        /\\b(transform|all)(,|$)/.test(styles[TRANSITION + \'Property\']);\r\n    return {\r\n        type,\r\n        timeout,\r\n        propCount,\r\n        hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\r\n// numbers in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down\r\n// (i.e. acting as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(\',\', \'.\')) * 1000;\r\n}\r\n// synchronously force layout to put elements into a certain state\r\nfunction forceReflow() {\r\n    return document.body.offsetHeight;\r\n}\n\nconst positionMap = new WeakMap();\r\nconst newPositionMap = new WeakMap();\r\nconst TransitionGroupImpl = {\r\n    name: \'TransitionGroup\',\r\n    props: /*#__PURE__*/ Object(shared_esm_bundler["i" /* extend */])({}, TransitionPropsValidators, {\r\n        tag: String,\r\n        moveClass: String\r\n    }),\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevChildren;\r\n        let children;\r\n        onUpdated(() => {\r\n            // children is guaranteed to exist after initial render\r\n            if (!prevChildren.length) {\r\n                return;\r\n            }\r\n            const moveClass = props.moveClass || `${props.name || \'v\'}-move`;\r\n            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\r\n                return;\r\n            }\r\n            // we divide the work into three loops to avoid mixing DOM reads and writes\r\n            // in each iteration - which helps prevent layout thrashing.\r\n            prevChildren.forEach(callPendingCbs);\r\n            prevChildren.forEach(recordPosition);\r\n            const movedChildren = prevChildren.filter(applyTranslation);\r\n            // force reflow to put everything in position\r\n            forceReflow();\r\n            movedChildren.forEach(c => {\r\n                const el = c.el;\r\n                const style = el.style;\r\n                addTransitionClass(el, moveClass);\r\n                style.transform = style.webkitTransform = style.transitionDuration = \'\';\r\n                const cb = (el._moveCb = (e) => {\r\n                    if (e && e.target !== el) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el.removeEventListener(\'transitionend\', cb);\r\n                        el._moveCb = null;\r\n                        removeTransitionClass(el, moveClass);\r\n                    }\r\n                });\r\n                el.addEventListener(\'transitionend\', cb);\r\n            });\r\n        });\r\n        return () => {\r\n            const rawProps = toRaw(props);\r\n            const cssTransitionProps = resolveTransitionProps(rawProps);\r\n            const tag = rawProps.tag || Fragment;\r\n            prevChildren = children;\r\n            children = slots.default ? getTransitionRawChildren(slots.default()) : [];\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (child.key != null) {\r\n                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                }\r\n                else if ((false)) {}\r\n            }\r\n            if (prevChildren) {\r\n                for (let i = 0; i < prevChildren.length; i++) {\r\n                    const child = prevChildren[i];\r\n                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                    positionMap.set(child, child.el.getBoundingClientRect());\r\n                }\r\n            }\r\n            return createVNode(tag, null, children);\r\n        };\r\n    }\r\n};\r\nconst TransitionGroup = TransitionGroupImpl;\r\nfunction callPendingCbs(c) {\r\n    const el = c.el;\r\n    if (el._moveCb) {\r\n        el._moveCb();\r\n    }\r\n    if (el._enterCb) {\r\n        el._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    newPositionMap.set(c, c.el.getBoundingClientRect());\r\n}\r\nfunction applyTranslation(c) {\r\n    const oldPos = positionMap.get(c);\r\n    const newPos = newPositionMap.get(c);\r\n    const dx = oldPos.left - newPos.left;\r\n    const dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        const s = c.el.style;\r\n        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\r\n        s.transitionDuration = \'0s\';\r\n        return c;\r\n    }\r\n}\r\nfunction hasCSSTransform(el, root, moveClass) {\r\n    // Detect whether an element with the move class applied has\r\n    // CSS transitions. Since the element may be inside an entering\r\n    // transition at this very moment, we make a clone of it and remove\r\n    // all other transition classes applied to ensure only the move class\r\n    // is applied.\r\n    const clone = el.cloneNode();\r\n    if (el._vtc) {\r\n        el._vtc.forEach(cls => {\r\n            cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\r\n        });\r\n    }\r\n    moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\r\n    clone.style.display = \'none\';\r\n    const container = (root.nodeType === 1\r\n        ? root\r\n        : root.parentNode);\r\n    container.appendChild(clone);\r\n    const { hasTransform } = getTransitionInfo(clone);\r\n    container.removeChild(clone);\r\n    return hasTransform;\r\n}\n\nconst getModelAssigner = (vnode) => {\r\n    const fn = vnode.props[\'onUpdate:modelValue\'];\r\n    return Object(shared_esm_bundler["o" /* isArray */])(fn) ? value => Object(shared_esm_bundler["n" /* invokeArrayFns */])(fn, value) : fn;\r\n};\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    const target = e.target;\r\n    if (target.composing) {\r\n        target.composing = false;\r\n        runtime_dom_esm_bundler_trigger(target, \'input\');\r\n    }\r\n}\r\nfunction runtime_dom_esm_bundler_trigger(el, type) {\r\n    const e = document.createEvent(\'HTMLEvents\');\r\n    e.initEvent(type, true, true);\r\n    el.dispatchEvent(e);\r\n}\r\n// We are exporting the v-model runtime directly as vnode hooks so that it can\r\n// be tree-shaken in case v-model is never used.\r\nconst vModelText = {\r\n    created(el, { modifiers: { lazy, trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        const castToNumber = number || el.type === \'number\';\r\n        addEventListener(el, lazy ? \'change\' : \'input\', e => {\r\n            if (e.target.composing)\r\n                return;\r\n            let domValue = el.value;\r\n            if (trim) {\r\n                domValue = domValue.trim();\r\n            }\r\n            else if (castToNumber) {\r\n                domValue = Object(shared_esm_bundler["O" /* toNumber */])(domValue);\r\n            }\r\n            el._assign(domValue);\r\n        });\r\n        if (trim) {\r\n            addEventListener(el, \'change\', () => {\r\n                el.value = el.value.trim();\r\n            });\r\n        }\r\n        if (!lazy) {\r\n            addEventListener(el, \'compositionstart\', onCompositionStart);\r\n            addEventListener(el, \'compositionend\', onCompositionEnd);\r\n            // Safari < 10.2 & UIWebView doesn\'t fire compositionend when\r\n            // switching focus before confirming composition choice\r\n            // this also fixes the issue where some browsers e.g. iOS Chrome\r\n            // fires "change" instead of "input" on autocomplete.\r\n            addEventListener(el, \'change\', onCompositionEnd);\r\n        }\r\n    },\r\n    // set value on mounted so it\'s after min/max for type="range"\r\n    mounted(el, { value }) {\r\n        el.value = value == null ? \'\' : value;\r\n    },\r\n    beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        // avoid clearing unresolved text. #2302\r\n        if (el.composing)\r\n            return;\r\n        if (document.activeElement === el) {\r\n            if (trim && el.value.trim() === value) {\r\n                return;\r\n            }\r\n            if ((number || el.type === \'number\') && Object(shared_esm_bundler["O" /* toNumber */])(el.value) === value) {\r\n                return;\r\n            }\r\n        }\r\n        const newValue = value == null ? \'\' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n    }\r\n};\r\nconst vModelCheckbox = {\r\n    created(el, _, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, \'change\', () => {\r\n            const modelValue = el._modelValue;\r\n            const elementValue = getValue(el);\r\n            const checked = el.checked;\r\n            const assign = el._assign;\r\n            if (Object(shared_esm_bundler["o" /* isArray */])(modelValue)) {\r\n                const index = Object(shared_esm_bundler["G" /* looseIndexOf */])(modelValue, elementValue);\r\n                const found = index !== -1;\r\n                if (checked && !found) {\r\n                    assign(modelValue.concat(elementValue));\r\n                }\r\n                else if (!checked && found) {\r\n                    const filtered = [...modelValue];\r\n                    filtered.splice(index, 1);\r\n                    assign(filtered);\r\n                }\r\n            }\r\n            else if (Object(shared_esm_bundler["A" /* isSet */])(modelValue)) {\r\n                const cloned = new Set(modelValue);\r\n                if (checked) {\r\n                    cloned.add(elementValue);\r\n                }\r\n                else {\r\n                    cloned.delete(elementValue);\r\n                }\r\n                assign(cloned);\r\n            }\r\n            else {\r\n                assign(getCheckboxValue(el, checked));\r\n            }\r\n        });\r\n    },\r\n    // set initial checked on mount to wait for true-value/false-value\r\n    mounted: setChecked,\r\n    beforeUpdate(el, binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        setChecked(el, binding, vnode);\r\n    }\r\n};\r\nfunction setChecked(el, { value, oldValue }, vnode) {\r\n    el._modelValue = value;\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(value)) {\r\n        el.checked = Object(shared_esm_bundler["G" /* looseIndexOf */])(value, vnode.props.value) > -1;\r\n    }\r\n    else if (Object(shared_esm_bundler["A" /* isSet */])(value)) {\r\n        el.checked = value.has(vnode.props.value);\r\n    }\r\n    else if (value !== oldValue) {\r\n        el.checked = Object(shared_esm_bundler["F" /* looseEqual */])(value, getCheckboxValue(el, true));\r\n    }\r\n}\r\nconst vModelRadio = {\r\n    created(el, { value }, vnode) {\r\n        el.checked = Object(shared_esm_bundler["F" /* looseEqual */])(value, vnode.props.value);\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, \'change\', () => {\r\n            el._assign(getValue(el));\r\n        });\r\n    },\r\n    beforeUpdate(el, { value, oldValue }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        if (value !== oldValue) {\r\n            el.checked = Object(shared_esm_bundler["F" /* looseEqual */])(value, vnode.props.value);\r\n        }\r\n    }\r\n};\r\nconst vModelSelect = {\r\n    created(el, { value, modifiers: { number } }, vnode) {\r\n        const isSetModel = Object(shared_esm_bundler["A" /* isSet */])(value);\r\n        addEventListener(el, \'change\', () => {\r\n            const selectedVal = Array.prototype.filter\r\n                .call(el.options, (o) => o.selected)\r\n                .map((o) => number ? Object(shared_esm_bundler["O" /* toNumber */])(getValue(o)) : getValue(o));\r\n            el._assign(el.multiple\r\n                ? isSetModel\r\n                    ? new Set(selectedVal)\r\n                    : selectedVal\r\n                : selectedVal[0]);\r\n        });\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    // set value in mounted & updated because <select> relies on its children\r\n    // <option>s.\r\n    mounted(el, { value }) {\r\n        setSelected(el, value);\r\n    },\r\n    beforeUpdate(el, _binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    updated(el, { value }) {\r\n        setSelected(el, value);\r\n    }\r\n};\r\nfunction setSelected(el, value) {\r\n    const isMultiple = el.multiple;\r\n    if (isMultiple && !Object(shared_esm_bundler["o" /* isArray */])(value) && !Object(shared_esm_bundler["A" /* isSet */])(value)) {\r\n        ( false) &&\r\n            false;\r\n        return;\r\n    }\r\n    for (let i = 0, l = el.options.length; i < l; i++) {\r\n        const option = el.options[i];\r\n        const optionValue = getValue(option);\r\n        if (isMultiple) {\r\n            if (Object(shared_esm_bundler["o" /* isArray */])(value)) {\r\n                option.selected = Object(shared_esm_bundler["G" /* looseIndexOf */])(value, optionValue) > -1;\r\n            }\r\n            else {\r\n                option.selected = value.has(optionValue);\r\n            }\r\n        }\r\n        else {\r\n            if (Object(shared_esm_bundler["F" /* looseEqual */])(getValue(option), value)) {\r\n                el.selectedIndex = i;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\n// retrieve raw value set via :value bindings\r\nfunction getValue(el) {\r\n    return \'_value\' in el ? el._value : el.value;\r\n}\r\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\r\nfunction getCheckboxValue(el, checked) {\r\n    const key = checked ? \'_trueValue\' : \'_falseValue\';\r\n    return key in el ? el[key] : checked;\r\n}\r\nconst vModelDynamic = {\r\n    created(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, \'created\');\r\n    },\r\n    mounted(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, \'mounted\');\r\n    },\r\n    beforeUpdate(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, \'beforeUpdate\');\r\n    },\r\n    updated(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, \'updated\');\r\n    }\r\n};\r\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\r\n    let modelToUse;\r\n    switch (el.tagName) {\r\n        case \'SELECT\':\r\n            modelToUse = vModelSelect;\r\n            break;\r\n        case \'TEXTAREA\':\r\n            modelToUse = vModelText;\r\n            break;\r\n        default:\r\n            switch (vnode.props && vnode.props.type) {\r\n                case \'checkbox\':\r\n                    modelToUse = vModelCheckbox;\r\n                    break;\r\n                case \'radio\':\r\n                    modelToUse = vModelRadio;\r\n                    break;\r\n                default:\r\n                    modelToUse = vModelText;\r\n            }\r\n    }\r\n    const fn = modelToUse[hook];\r\n    fn && fn(el, binding, vnode, prevVNode);\r\n}\n\nconst systemModifiers = [\'ctrl\', \'shift\', \'alt\', \'meta\'];\r\nconst modifierGuards = {\r\n    stop: e => e.stopPropagation(),\r\n    prevent: e => e.preventDefault(),\r\n    self: e => e.target !== e.currentTarget,\r\n    ctrl: e => !e.ctrlKey,\r\n    shift: e => !e.shiftKey,\r\n    alt: e => !e.altKey,\r\n    meta: e => !e.metaKey,\r\n    left: e => \'button\' in e && e.button !== 0,\r\n    middle: e => \'button\' in e && e.button !== 1,\r\n    right: e => \'button\' in e && e.button !== 2,\r\n    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withModifiers = (fn, modifiers) => {\r\n    return (event, ...args) => {\r\n        for (let i = 0; i < modifiers.length; i++) {\r\n            const guard = modifierGuards[modifiers[i]];\r\n            if (guard && guard(event, modifiers))\r\n                return;\r\n        }\r\n        return fn(event, ...args);\r\n    };\r\n};\r\n// Kept for 2.x compat.\r\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\r\nconst keyNames = {\r\n    esc: \'escape\',\r\n    space: \' \',\r\n    up: \'arrow-up\',\r\n    left: \'arrow-left\',\r\n    right: \'arrow-right\',\r\n    down: \'arrow-down\',\r\n    delete: \'backspace\'\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withKeys = (fn, modifiers) => {\r\n    return (event) => {\r\n        if (!(\'key\' in event))\r\n            return;\r\n        const eventKey = Object(shared_esm_bundler["m" /* hyphenate */])(event.key);\r\n        if (\r\n        // None of the provided key modifiers match the current event key\r\n        !modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\r\n            return;\r\n        }\r\n        return fn(event);\r\n    };\r\n};\n\nconst vShow = {\r\n    beforeMount(el, { value }, { transition }) {\r\n        el._vod = el.style.display === \'none\' ? \'\' : el.style.display;\r\n        if (transition && value) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    mounted(el, { value }, { transition }) {\r\n        if (transition && value) {\r\n            transition.enter(el);\r\n        }\r\n    },\r\n    updated(el, { value, oldValue }, { transition }) {\r\n        if (!value === !oldValue)\r\n            return;\r\n        if (transition) {\r\n            if (value) {\r\n                transition.beforeEnter(el);\r\n                setDisplay(el, true);\r\n                transition.enter(el);\r\n            }\r\n            else {\r\n                transition.leave(el, () => {\r\n                    setDisplay(el, false);\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    beforeUnmount(el, { value }) {\r\n        setDisplay(el, value);\r\n    }\r\n};\r\nfunction setDisplay(el, value) {\r\n    el.style.display = value ? el._vod : \'none\';\r\n}\n\nconst rendererOptions = Object(shared_esm_bundler["i" /* extend */])({ patchProp: runtime_dom_esm_bundler_patchProp, forcePatchProp }, nodeOps);\r\n// lazy create the renderer - this makes core renderer logic tree-shakable\r\n// in case the user only imports reactivity utilities from Vue.\r\nlet renderer;\r\nlet enabledHydration = false;\r\nfunction ensureRenderer() {\r\n    return renderer || (renderer = createRenderer(rendererOptions));\r\n}\r\nfunction ensureHydrationRenderer() {\r\n    renderer = enabledHydration\r\n        ? renderer\r\n        : createHydrationRenderer(rendererOptions);\r\n    enabledHydration = true;\r\n    return renderer;\r\n}\r\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\r\nconst runtime_dom_esm_bundler_render = ((...args) => {\r\n    ensureRenderer().render(...args);\r\n});\r\nconst runtime_dom_esm_bundler_hydrate = ((...args) => {\r\n    ensureHydrationRenderer().hydrate(...args);\r\n});\r\nconst runtime_dom_esm_bundler_createApp = ((...args) => {\r\n    const app = ensureRenderer().createApp(...args);\r\n    if ((false)) {}\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (!container)\r\n            return;\r\n        const component = app._component;\r\n        if (!Object(shared_esm_bundler["p" /* isFunction */])(component) && !component.render && !component.template) {\r\n            component.template = container.innerHTML;\r\n        }\r\n        // clear content before mounting\r\n        container.innerHTML = \'\';\r\n        const proxy = mount(container);\r\n        if (container instanceof Element) {\r\n            container.removeAttribute(\'v-cloak\');\r\n            container.setAttribute(\'data-v-app\', \'\');\r\n        }\r\n        return proxy;\r\n    };\r\n    return app;\r\n});\r\nconst createSSRApp = ((...args) => {\r\n    const app = ensureHydrationRenderer().createApp(...args);\r\n    if ((false)) {}\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (container) {\r\n            return mount(container, true);\r\n        }\r\n    };\r\n    return app;\r\n});\r\nfunction injectNativeTagCheck(app) {\r\n    // Inject `isNativeTag`\r\n    // this is used for component name validation (dev only)\r\n    Object.defineProperty(app.config, \'isNativeTag\', {\r\n        value: (tag) => Object(shared_esm_bundler["r" /* isHTMLTag */])(tag) || Object(shared_esm_bundler["z" /* isSVGTag */])(tag),\r\n        writable: false\r\n    });\r\n}\r\n// dev only\r\nfunction injectCustomElementCheck(app) {\r\n    if (isRuntimeOnly()) {\r\n        const value = app.config.isCustomElement;\r\n        Object.defineProperty(app.config, \'isCustomElement\', {\r\n            get() {\r\n                return value;\r\n            },\r\n            set() {\r\n                warn(`The \\`isCustomElement\\` config option is only respected when using the runtime compiler.` +\r\n                    `If you are using the runtime-only build, \\`isCustomElement\\` must be passed to \\`@vue/compiler-dom\\` in the build setup instead` +\r\n                    `- for example, via the \\`compilerOptions\\` option in vue-loader: https://vue-loader.vuejs.org/options.html#compileroptions.`);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction normalizeContainer(container) {\r\n    if (Object(shared_esm_bundler["C" /* isString */])(container)) {\r\n        const res = document.querySelector(container);\r\n        if (false) {}\r\n        return res;\r\n    }\r\n    if (false) {}\r\n    return container;\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js\n\n\n\nfunction defaultOnError(error) {\r\n    throw error;\r\n}\r\nfunction createCompilerError(code, loc, messages, additionalMessage) {\r\n    const msg =  false\r\n        ? undefined\r\n        : code;\r\n    const error = new SyntaxError(String(msg));\r\n    error.code = code;\r\n    error.loc = loc;\r\n    return error;\r\n}\r\nconst errorMessages = {\r\n    // parse errors\r\n    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: \'Illegal comment.\',\r\n    [1 /* CDATA_IN_HTML_CONTENT */]: \'CDATA section is allowed only in XML context.\',\r\n    [2 /* DUPLICATE_ATTRIBUTE */]: \'Duplicate attribute.\',\r\n    [3 /* END_TAG_WITH_ATTRIBUTES */]: \'End tag cannot have attributes.\',\r\n    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal \'/\' in tags.",\r\n    [5 /* EOF_BEFORE_TAG_NAME */]: \'Unexpected EOF in tag.\',\r\n    [6 /* EOF_IN_CDATA */]: \'Unexpected EOF in CDATA section.\',\r\n    [7 /* EOF_IN_COMMENT */]: \'Unexpected EOF in comment.\',\r\n    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: \'Unexpected EOF in script.\',\r\n    [9 /* EOF_IN_TAG */]: \'Unexpected EOF in tag.\',\r\n    [10 /* INCORRECTLY_CLOSED_COMMENT */]: \'Incorrectly closed comment.\',\r\n    [11 /* INCORRECTLY_OPENED_COMMENT */]: \'Incorrectly opened comment.\',\r\n    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use \'&lt;\' to print \'<\'.",\r\n    [13 /* MISSING_ATTRIBUTE_VALUE */]: \'Attribute value was expected.\',\r\n    [14 /* MISSING_END_TAG_NAME */]: \'End tag name was expected.\',\r\n    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: \'Whitespace was expected.\',\r\n    [16 /* NESTED_COMMENT */]: "Unexpected \'\x3c!--\' in comment.",\r\n    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: \'Attribute name cannot contain U+0022 ("), U+0027 (\\\'), and U+003C (<).\',\r\n    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: \'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\\\'), U+003C (<), U+003D (=), and U+0060 (`).\',\r\n    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with \'=\'.",\r\n    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "\'<?\' is allowed only in XML context.",\r\n    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal \'/\' in tags.",\r\n    // Vue-specific parse errors\r\n    [23 /* X_INVALID_END_TAG */]: \'Invalid end tag.\',\r\n    [24 /* X_MISSING_END_TAG */]: \'Element is missing end tag.\',\r\n    [25 /* X_MISSING_INTERPOLATION_END */]: \'Interpolation end sign was not found.\',\r\n    [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: \'End bracket for dynamic directive argument was not found. \' +\r\n        \'Note that dynamic directive argument cannot contain spaces.\',\r\n    // transform errors\r\n    [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,\r\n    [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,\r\n    [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,\r\n    [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,\r\n    [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,\r\n    [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,\r\n    [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,\r\n    [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,\r\n    [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,\r\n    [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +\r\n        `When there are multiple named slots, all slots should use <template> ` +\r\n        `syntax to avoid scope ambiguity.`,\r\n    [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,\r\n    [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +\r\n        `default slot. These children will be ignored.`,\r\n    [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,\r\n    [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,\r\n    [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,\r\n    [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\r\n    [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,\r\n    [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,\r\n    // generic errors\r\n    [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,\r\n    [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,\r\n    [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,\r\n    [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`\r\n};\n\nconst FRAGMENT = Symbol(( false) ? undefined : ``);\r\nconst TELEPORT = Symbol(( false) ? undefined : ``);\r\nconst SUSPENSE = Symbol(( false) ? undefined : ``);\r\nconst KEEP_ALIVE = Symbol(( false) ? undefined : ``);\r\nconst BASE_TRANSITION = Symbol(( false) ? undefined : ``);\r\nconst OPEN_BLOCK = Symbol(( false) ? undefined : ``);\r\nconst CREATE_BLOCK = Symbol(( false) ? undefined : ``);\r\nconst CREATE_VNODE = Symbol(( false) ? undefined : ``);\r\nconst CREATE_COMMENT = Symbol(( false) ? undefined : ``);\r\nconst CREATE_TEXT = Symbol(( false) ? undefined : ``);\r\nconst CREATE_STATIC = Symbol(( false) ? undefined : ``);\r\nconst RESOLVE_COMPONENT = Symbol(( false) ? undefined : ``);\r\nconst RESOLVE_DYNAMIC_COMPONENT = Symbol(( false) ? undefined : ``);\r\nconst RESOLVE_DIRECTIVE = Symbol(( false) ? undefined : ``);\r\nconst WITH_DIRECTIVES = Symbol(( false) ? undefined : ``);\r\nconst RENDER_LIST = Symbol(( false) ? undefined : ``);\r\nconst RENDER_SLOT = Symbol(( false) ? undefined : ``);\r\nconst CREATE_SLOTS = Symbol(( false) ? undefined : ``);\r\nconst TO_DISPLAY_STRING = Symbol(( false) ? undefined : ``);\r\nconst MERGE_PROPS = Symbol(( false) ? undefined : ``);\r\nconst TO_HANDLERS = Symbol(( false) ? undefined : ``);\r\nconst CAMELIZE = Symbol(( false) ? undefined : ``);\r\nconst CAPITALIZE = Symbol(( false) ? undefined : ``);\r\nconst TO_HANDLER_KEY = Symbol(( false) ? undefined : ``);\r\nconst SET_BLOCK_TRACKING = Symbol(( false) ? undefined : ``);\r\nconst PUSH_SCOPE_ID = Symbol(( false) ? undefined : ``);\r\nconst POP_SCOPE_ID = Symbol(( false) ? undefined : ``);\r\nconst WITH_SCOPE_ID = Symbol(( false) ? undefined : ``);\r\nconst WITH_CTX = Symbol(( false) ? undefined : ``);\r\nconst UNREF = Symbol(( false) ? undefined : ``);\r\nconst IS_REF = Symbol(( false) ? undefined : ``);\r\n// Name mapping for runtime helpers that need to be imported from \'vue\' in\r\n// generated code. Make sure these are correctly exported in the runtime!\r\n// Using `any` here because TS doesn\'t allow symbols as index type.\r\nconst helperNameMap = {\r\n    [FRAGMENT]: `Fragment`,\r\n    [TELEPORT]: `Teleport`,\r\n    [SUSPENSE]: `Suspense`,\r\n    [KEEP_ALIVE]: `KeepAlive`,\r\n    [BASE_TRANSITION]: `BaseTransition`,\r\n    [OPEN_BLOCK]: `openBlock`,\r\n    [CREATE_BLOCK]: `createBlock`,\r\n    [CREATE_VNODE]: `createVNode`,\r\n    [CREATE_COMMENT]: `createCommentVNode`,\r\n    [CREATE_TEXT]: `createTextVNode`,\r\n    [CREATE_STATIC]: `createStaticVNode`,\r\n    [RESOLVE_COMPONENT]: `resolveComponent`,\r\n    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\r\n    [RESOLVE_DIRECTIVE]: `resolveDirective`,\r\n    [WITH_DIRECTIVES]: `withDirectives`,\r\n    [RENDER_LIST]: `renderList`,\r\n    [RENDER_SLOT]: `renderSlot`,\r\n    [CREATE_SLOTS]: `createSlots`,\r\n    [TO_DISPLAY_STRING]: `toDisplayString`,\r\n    [MERGE_PROPS]: `mergeProps`,\r\n    [TO_HANDLERS]: `toHandlers`,\r\n    [CAMELIZE]: `camelize`,\r\n    [CAPITALIZE]: `capitalize`,\r\n    [TO_HANDLER_KEY]: `toHandlerKey`,\r\n    [SET_BLOCK_TRACKING]: `setBlockTracking`,\r\n    [PUSH_SCOPE_ID]: `pushScopeId`,\r\n    [POP_SCOPE_ID]: `popScopeId`,\r\n    [WITH_SCOPE_ID]: `withScopeId`,\r\n    [WITH_CTX]: `withCtx`,\r\n    [UNREF]: `unref`,\r\n    [IS_REF]: `isRef`\r\n};\r\nfunction registerRuntimeHelpers(helpers) {\r\n    Object.getOwnPropertySymbols(helpers).forEach(s => {\r\n        helperNameMap[s] = helpers[s];\r\n    });\r\n}\n\n// AST Utilities ---------------------------------------------------------------\r\n// Some expressions, e.g. sequence and conditional expressions, are never\r\n// associated with template nodes, so their source locations are just a stub.\r\n// Container types like CompoundExpression also don\'t need a real location.\r\nconst locStub = {\r\n    source: \'\',\r\n    start: { line: 1, column: 1, offset: 0 },\r\n    end: { line: 1, column: 1, offset: 0 }\r\n};\r\nfunction createRoot(children, loc = locStub) {\r\n    return {\r\n        type: 0 /* ROOT */,\r\n        children,\r\n        helpers: [],\r\n        components: [],\r\n        directives: [],\r\n        hoists: [],\r\n        imports: [],\r\n        cached: 0,\r\n        temps: 0,\r\n        codegenNode: undefined,\r\n        loc\r\n    };\r\n}\r\nfunction createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {\r\n    if (context) {\r\n        if (isBlock) {\r\n            context.helper(OPEN_BLOCK);\r\n            context.helper(CREATE_BLOCK);\r\n        }\r\n        else {\r\n            context.helper(CREATE_VNODE);\r\n        }\r\n        if (directives) {\r\n            context.helper(WITH_DIRECTIVES);\r\n        }\r\n    }\r\n    return {\r\n        type: 13 /* VNODE_CALL */,\r\n        tag,\r\n        props,\r\n        children,\r\n        patchFlag,\r\n        dynamicProps,\r\n        directives,\r\n        isBlock,\r\n        disableTracking,\r\n        loc\r\n    };\r\n}\r\nfunction createArrayExpression(elements, loc = locStub) {\r\n    return {\r\n        type: 17 /* JS_ARRAY_EXPRESSION */,\r\n        loc,\r\n        elements\r\n    };\r\n}\r\nfunction createObjectExpression(properties, loc = locStub) {\r\n    return {\r\n        type: 15 /* JS_OBJECT_EXPRESSION */,\r\n        loc,\r\n        properties\r\n    };\r\n}\r\nfunction createObjectProperty(key, value) {\r\n    return {\r\n        type: 16 /* JS_PROPERTY */,\r\n        loc: locStub,\r\n        key: Object(shared_esm_bundler["C" /* isString */])(key) ? createSimpleExpression(key, true) : key,\r\n        value\r\n    };\r\n}\r\nfunction createSimpleExpression(content, isStatic, loc = locStub, constType = 0 /* NOT_CONSTANT */) {\r\n    return {\r\n        type: 4 /* SIMPLE_EXPRESSION */,\r\n        loc,\r\n        content,\r\n        isStatic,\r\n        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType\r\n    };\r\n}\r\nfunction createInterpolation(content, loc) {\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        loc,\r\n        content: Object(shared_esm_bundler["C" /* isString */])(content)\r\n            ? createSimpleExpression(content, false, loc)\r\n            : content\r\n    };\r\n}\r\nfunction createCompoundExpression(children, loc = locStub) {\r\n    return {\r\n        type: 8 /* COMPOUND_EXPRESSION */,\r\n        loc,\r\n        children\r\n    };\r\n}\r\nfunction createCallExpression(callee, args = [], loc = locStub) {\r\n    return {\r\n        type: 14 /* JS_CALL_EXPRESSION */,\r\n        loc,\r\n        callee,\r\n        arguments: args\r\n    };\r\n}\r\nfunction createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {\r\n    return {\r\n        type: 18 /* JS_FUNCTION_EXPRESSION */,\r\n        params,\r\n        returns,\r\n        newline,\r\n        isSlot,\r\n        loc\r\n    };\r\n}\r\nfunction createConditionalExpression(test, consequent, alternate, newline = true) {\r\n    return {\r\n        type: 19 /* JS_CONDITIONAL_EXPRESSION */,\r\n        test,\r\n        consequent,\r\n        alternate,\r\n        newline,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createCacheExpression(index, value, isVNode = false) {\r\n    return {\r\n        type: 20 /* JS_CACHE_EXPRESSION */,\r\n        index,\r\n        value,\r\n        isVNode,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createBlockStatement(body) {\r\n    return {\r\n        type: 21 /* JS_BLOCK_STATEMENT */,\r\n        body,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createTemplateLiteral(elements) {\r\n    return {\r\n        type: 22 /* JS_TEMPLATE_LITERAL */,\r\n        elements,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createIfStatement(test, consequent, alternate) {\r\n    return {\r\n        type: 23 /* JS_IF_STATEMENT */,\r\n        test,\r\n        consequent,\r\n        alternate,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createAssignmentExpression(left, right) {\r\n    return {\r\n        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,\r\n        left,\r\n        right,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createSequenceExpression(expressions) {\r\n    return {\r\n        type: 25 /* JS_SEQUENCE_EXPRESSION */,\r\n        expressions,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createReturnStatement(returns) {\r\n    return {\r\n        type: 26 /* JS_RETURN_STATEMENT */,\r\n        returns,\r\n        loc: locStub\r\n    };\r\n}\n\nconst isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;\r\nconst isBuiltInType = (tag, expected) => tag === expected || tag === Object(shared_esm_bundler["m" /* hyphenate */])(expected);\r\nfunction isCoreComponent(tag) {\r\n    if (isBuiltInType(tag, \'Teleport\')) {\r\n        return TELEPORT;\r\n    }\r\n    else if (isBuiltInType(tag, \'Suspense\')) {\r\n        return SUSPENSE;\r\n    }\r\n    else if (isBuiltInType(tag, \'KeepAlive\')) {\r\n        return KEEP_ALIVE;\r\n    }\r\n    else if (isBuiltInType(tag, \'BaseTransition\')) {\r\n        return BASE_TRANSITION;\r\n    }\r\n}\r\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/;\r\nconst isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\r\nconst memberExpRE = /^[A-Za-z_$][\\w$]*(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*|\\[[^\\]]+\\])*$/;\r\nconst isMemberExpression = (path) => {\r\n    if (!path)\r\n        return false;\r\n    return memberExpRE.test(path.trim());\r\n};\r\nfunction getInnerRange(loc, offset, length) {\r\n    const source = loc.source.substr(offset, length);\r\n    const newLoc = {\r\n        source,\r\n        start: advancePositionWithClone(loc.start, loc.source, offset),\r\n        end: loc.end\r\n    };\r\n    if (length != null) {\r\n        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\r\n    }\r\n    return newLoc;\r\n}\r\nfunction advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\r\n    return advancePositionWithMutation(Object(shared_esm_bundler["i" /* extend */])({}, pos), source, numberOfCharacters);\r\n}\r\n// advance by mutation without cloning (for performance reasons), since this\r\n// gets called a lot in the parser\r\nfunction advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\r\n    let linesCount = 0;\r\n    let lastNewLinePos = -1;\r\n    for (let i = 0; i < numberOfCharacters; i++) {\r\n        if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n            linesCount++;\r\n            lastNewLinePos = i;\r\n        }\r\n    }\r\n    pos.offset += numberOfCharacters;\r\n    pos.line += linesCount;\r\n    pos.column =\r\n        lastNewLinePos === -1\r\n            ? pos.column + numberOfCharacters\r\n            : numberOfCharacters - lastNewLinePos;\r\n    return pos;\r\n}\r\nfunction assert(condition, msg) {\r\n    /* istanbul ignore if */\r\n    if (!condition) {\r\n        throw new Error(msg || `unexpected compiler condition`);\r\n    }\r\n}\r\nfunction findDir(node, name, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 7 /* DIRECTIVE */ &&\r\n            (allowEmpty || p.exp) &&\r\n            (Object(shared_esm_bundler["C" /* isString */])(name) ? p.name === name : name.test(p.name))) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nfunction findProp(node, name, dynamicOnly = false, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (dynamicOnly)\r\n                continue;\r\n            if (p.name === name && (p.value || allowEmpty)) {\r\n                return p;\r\n            }\r\n        }\r\n        else if (p.name === \'bind\' &&\r\n            (p.exp || allowEmpty) &&\r\n            isBindKey(p.arg, name)) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nfunction isBindKey(arg, name) {\r\n    return !!(arg && isStaticExp(arg) && arg.content === name);\r\n}\r\nfunction hasDynamicKeyVBind(node) {\r\n    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&\r\n        p.name === \'bind\' &&\r\n        (!p.arg || // v-bind="obj"\r\n            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]\r\n            !p.arg.isStatic) // v-bind:[foo]\r\n    );\r\n}\r\nfunction isText(node) {\r\n    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;\r\n}\r\nfunction isVSlot(p) {\r\n    return p.type === 7 /* DIRECTIVE */ && p.name === \'slot\';\r\n}\r\nfunction isTemplateNode(node) {\r\n    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);\r\n}\r\nfunction isSlotOutlet(node) {\r\n    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;\r\n}\r\nfunction injectProp(node, prop, context) {\r\n    let propsWithInjection;\r\n    const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];\r\n    if (props == null || Object(shared_esm_bundler["C" /* isString */])(props)) {\r\n        propsWithInjection = createObjectExpression([prop]);\r\n    }\r\n    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {\r\n        // merged props... add ours\r\n        // only inject key to object literal if it\'s the first argument so that\r\n        // if doesn\'t override user provided keys\r\n        const first = props.arguments[0];\r\n        if (!Object(shared_esm_bundler["C" /* isString */])(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n            first.properties.unshift(prop);\r\n        }\r\n        else {\r\n            if (props.callee === TO_HANDLERS) {\r\n                // #2366\r\n                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n                    createObjectExpression([prop]),\r\n                    props\r\n                ]);\r\n            }\r\n            else {\r\n                props.arguments.unshift(createObjectExpression([prop]));\r\n            }\r\n        }\r\n        !propsWithInjection && (propsWithInjection = props);\r\n    }\r\n    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n        let alreadyExists = false;\r\n        // check existing key to avoid overriding user provided keys\r\n        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {\r\n            const propKeyName = prop.key.content;\r\n            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                p.key.content === propKeyName);\r\n        }\r\n        if (!alreadyExists) {\r\n            props.properties.unshift(prop);\r\n        }\r\n        propsWithInjection = props;\r\n    }\r\n    else {\r\n        // single v-bind with expression, return a merged replacement\r\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n            createObjectExpression([prop]),\r\n            props\r\n        ]);\r\n    }\r\n    if (node.type === 13 /* VNODE_CALL */) {\r\n        node.props = propsWithInjection;\r\n    }\r\n    else {\r\n        node.arguments[2] = propsWithInjection;\r\n    }\r\n}\r\nfunction toValidAssetId(name, type) {\r\n    return `_${type}_${name.replace(/[^\\w]/g, \'_\')}`;\r\n}\r\n// Check if a node contains expressions that reference current context scope ids\r\nfunction hasScopeRef(node, ids) {\r\n    if (!node || Object.keys(ids).length === 0) {\r\n        return false;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            for (let i = 0; i < node.props.length; i++) {\r\n                const p = node.props[i];\r\n                if (p.type === 7 /* DIRECTIVE */ &&\r\n                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {\r\n                    return true;\r\n                }\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 11 /* FOR */:\r\n            if (hasScopeRef(node.source, ids)) {\r\n                return true;\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 9 /* IF */:\r\n            return node.branches.some(b => hasScopeRef(b, ids));\r\n        case 10 /* IF_BRANCH */:\r\n            if (hasScopeRef(node.condition, ids)) {\r\n                return true;\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            return (!node.isStatic &&\r\n                isSimpleIdentifier(node.content) &&\r\n                !!ids[node.content]);\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            return node.children.some(c => Object(shared_esm_bundler["v" /* isObject */])(c) && hasScopeRef(c, ids));\r\n        case 5 /* INTERPOLATION */:\r\n        case 12 /* TEXT_CALL */:\r\n            return hasScopeRef(node.content, ids);\r\n        case 2 /* TEXT */:\r\n        case 3 /* COMMENT */:\r\n            return false;\r\n        default:\r\n            if ((false)) {}\r\n            return false;\r\n    }\r\n}\n\n// The default decoder only provides escapes for characters reserved as part of\r\n// the template syntax, and is only used if the custom renderer did not provide\r\n// a platform-specific decoder.\r\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g;\r\nconst decodeMap = {\r\n    gt: \'>\',\r\n    lt: \'<\',\r\n    amp: \'&\',\r\n    apos: "\'",\r\n    quot: \'"\'\r\n};\r\nconst defaultParserOptions = {\r\n    delimiters: [`{{`, `}}`],\r\n    getNamespace: () => 0 /* HTML */,\r\n    getTextMode: () => 0 /* DATA */,\r\n    isVoidTag: shared_esm_bundler["c" /* NO */],\r\n    isPreTag: shared_esm_bundler["c" /* NO */],\r\n    isCustomElement: shared_esm_bundler["c" /* NO */],\r\n    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\r\n    onError: defaultOnError,\r\n    comments: false\r\n};\r\nfunction baseParse(content, options = {}) {\r\n    const context = createParserContext(content, options);\r\n    const start = getCursor(context);\r\n    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));\r\n}\r\nfunction createParserContext(content, rawOptions) {\r\n    const options = Object(shared_esm_bundler["i" /* extend */])({}, defaultParserOptions);\r\n    for (const key in rawOptions) {\r\n        // @ts-ignore\r\n        options[key] = rawOptions[key] || defaultParserOptions[key];\r\n    }\r\n    return {\r\n        options,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        originalSource: content,\r\n        source: content,\r\n        inPre: false,\r\n        inVPre: false\r\n    };\r\n}\r\nfunction parseChildren(context, mode, ancestors) {\r\n    const parent = last(ancestors);\r\n    const ns = parent ? parent.ns : 0 /* HTML */;\r\n    const nodes = [];\r\n    while (!isEnd(context, mode, ancestors)) {\r\n        const s = context.source;\r\n        let node = undefined;\r\n        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {\r\n            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\r\n                // \'{{\'\r\n                node = parseInterpolation(context, mode);\r\n            }\r\n            else if (mode === 0 /* DATA */ && s[0] === \'<\') {\r\n                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\r\n                if (s.length === 1) {\r\n                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);\r\n                }\r\n                else if (s[1] === \'!\') {\r\n                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\r\n                    if (startsWith(s, \'\x3c!--\')) {\r\n                        node = parseComment(context);\r\n                    }\r\n                    else if (startsWith(s, \'<!DOCTYPE\')) {\r\n                        // Ignore DOCTYPE by a limitation.\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                    else if (startsWith(s, \'<![CDATA[\')) {\r\n                        if (ns !== 0 /* HTML */) {\r\n                            node = parseCDATA(context, ancestors);\r\n                        }\r\n                        else {\r\n                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);\r\n                            node = parseBogusComment(context);\r\n                        }\r\n                    }\r\n                    else {\r\n                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else if (s[1] === \'/\') {\r\n                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\r\n                    if (s.length === 2) {\r\n                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);\r\n                    }\r\n                    else if (s[2] === \'>\') {\r\n                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);\r\n                        advanceBy(context, 3);\r\n                        continue;\r\n                    }\r\n                    else if (/[a-z]/i.test(s[2])) {\r\n                        emitError(context, 23 /* X_INVALID_END_TAG */);\r\n                        parseTag(context, 1 /* End */, parent);\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else if (/[a-z]/i.test(s[1])) {\r\n                    node = parseElement(context, ancestors);\r\n                }\r\n                else if (s[1] === \'?\') {\r\n                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\r\n                    node = parseBogusComment(context);\r\n                }\r\n                else {\r\n                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\r\n                }\r\n            }\r\n        }\r\n        if (!node) {\r\n            node = parseText(context, mode);\r\n        }\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(node)) {\r\n            for (let i = 0; i < node.length; i++) {\r\n                pushNode(nodes, node[i]);\r\n            }\r\n        }\r\n        else {\r\n            pushNode(nodes, node);\r\n        }\r\n    }\r\n    // Whitespace management for more efficient output\r\n    // (same as v2 whitespace: \'condense\')\r\n    let removedWhitespace = false;\r\n    if (mode !== 2 /* RAWTEXT */) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            if (!context.inPre && node.type === 2 /* TEXT */) {\r\n                if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\r\n                    const prev = nodes[i - 1];\r\n                    const next = nodes[i + 1];\r\n                    // If:\r\n                    // - the whitespace is the first or last node, or:\r\n                    // - the whitespace is adjacent to a comment, or:\r\n                    // - the whitespace is between two elements AND contains newline\r\n                    // Then the whitespace is ignored.\r\n                    if (!prev ||\r\n                        !next ||\r\n                        prev.type === 3 /* COMMENT */ ||\r\n                        next.type === 3 /* COMMENT */ ||\r\n                        (prev.type === 1 /* ELEMENT */ &&\r\n                            next.type === 1 /* ELEMENT */ &&\r\n                            /[\\r\\n]/.test(node.content))) {\r\n                        removedWhitespace = true;\r\n                        nodes[i] = null;\r\n                    }\r\n                    else {\r\n                        // Otherwise, condensed consecutive whitespace inside the text\r\n                        // down to a single space\r\n                        node.content = \' \';\r\n                    }\r\n                }\r\n                else {\r\n                    node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, \' \');\r\n                }\r\n            }\r\n            // also remove comment nodes in prod by default\r\n            if ( true &&\r\n                node.type === 3 /* COMMENT */ &&\r\n                !context.options.comments) {\r\n                removedWhitespace = true;\r\n                nodes[i] = null;\r\n            }\r\n        }\r\n        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\r\n            // remove leading newline per html spec\r\n            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\r\n            const first = nodes[0];\r\n            if (first && first.type === 2 /* TEXT */) {\r\n                first.content = first.content.replace(/^\\r?\\n/, \'\');\r\n            }\r\n        }\r\n    }\r\n    return removedWhitespace ? nodes.filter(Boolean) : nodes;\r\n}\r\nfunction pushNode(nodes, node) {\r\n    if (node.type === 2 /* TEXT */) {\r\n        const prev = last(nodes);\r\n        // Merge if both this and the previous node are text and those are\r\n        // consecutive. This happens for cases like "a < b".\r\n        if (prev &&\r\n            prev.type === 2 /* TEXT */ &&\r\n            prev.loc.end.offset === node.loc.start.offset) {\r\n            prev.content += node.content;\r\n            prev.loc.end = node.loc.end;\r\n            prev.loc.source += node.loc.source;\r\n            return;\r\n        }\r\n    }\r\n    nodes.push(node);\r\n}\r\nfunction parseCDATA(context, ancestors) {\r\n    advanceBy(context, 9);\r\n    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);\r\n    if (context.source.length === 0) {\r\n        emitError(context, 6 /* EOF_IN_CDATA */);\r\n    }\r\n    else {\r\n        advanceBy(context, 3);\r\n    }\r\n    return nodes;\r\n}\r\nfunction parseComment(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    // Regular comment.\r\n    const match = /--(\\!)?>/.exec(context.source);\r\n    if (!match) {\r\n        content = context.source.slice(4);\r\n        advanceBy(context, context.source.length);\r\n        emitError(context, 7 /* EOF_IN_COMMENT */);\r\n    }\r\n    else {\r\n        if (match.index <= 3) {\r\n            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\r\n        }\r\n        if (match[1]) {\r\n            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);\r\n        }\r\n        content = context.source.slice(4, match.index);\r\n        // Advancing with reporting nested comments.\r\n        const s = context.source.slice(0, match.index);\r\n        let prevIndex = 1, nestedIndex = 0;\r\n        while ((nestedIndex = s.indexOf(\'\x3c!--\', prevIndex)) !== -1) {\r\n            advanceBy(context, nestedIndex - prevIndex + 1);\r\n            if (nestedIndex + 4 < s.length) {\r\n                emitError(context, 16 /* NESTED_COMMENT */);\r\n            }\r\n            prevIndex = nestedIndex + 1;\r\n        }\r\n        advanceBy(context, match.index + match[0].length - prevIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseBogusComment(context) {\r\n    const start = getCursor(context);\r\n    const contentStart = context.source[1] === \'?\' ? 1 : 2;\r\n    let content;\r\n    const closeIndex = context.source.indexOf(\'>\');\r\n    if (closeIndex === -1) {\r\n        content = context.source.slice(contentStart);\r\n        advanceBy(context, context.source.length);\r\n    }\r\n    else {\r\n        content = context.source.slice(contentStart, closeIndex);\r\n        advanceBy(context, closeIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseElement(context, ancestors) {\r\n    // Start tag.\r\n    const wasInPre = context.inPre;\r\n    const wasInVPre = context.inVPre;\r\n    const parent = last(ancestors);\r\n    const element = parseTag(context, 0 /* Start */, parent);\r\n    const isPreBoundary = context.inPre && !wasInPre;\r\n    const isVPreBoundary = context.inVPre && !wasInVPre;\r\n    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\r\n        return element;\r\n    }\r\n    // Children.\r\n    ancestors.push(element);\r\n    const mode = context.options.getTextMode(element, parent);\r\n    const children = parseChildren(context, mode, ancestors);\r\n    ancestors.pop();\r\n    element.children = children;\r\n    // End tag.\r\n    if (startsWithEndTagOpen(context.source, element.tag)) {\r\n        parseTag(context, 1 /* End */, parent);\r\n    }\r\n    else {\r\n        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);\r\n        if (context.source.length === 0 && element.tag.toLowerCase() === \'script\') {\r\n            const first = children[0];\r\n            if (first && startsWith(first.loc.source, \'\x3c!--\')) {\r\n                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\r\n            }\r\n        }\r\n    }\r\n    element.loc = getSelection(context, element.loc.start);\r\n    if (isPreBoundary) {\r\n        context.inPre = false;\r\n    }\r\n    if (isVPreBoundary) {\r\n        context.inVPre = false;\r\n    }\r\n    return element;\r\n}\r\nconst isSpecialTemplateDirective = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(`if,else,else-if,for,slot`);\r\n/**\r\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\r\n */\r\nfunction parseTag(context, type, parent) {\r\n    // Tag open.\r\n    const start = getCursor(context);\r\n    const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\r\n    const tag = match[1];\r\n    const ns = context.options.getNamespace(tag, parent);\r\n    advanceBy(context, match[0].length);\r\n    advanceSpaces(context);\r\n    // save current state in case we need to re-parse attributes with v-pre\r\n    const cursor = getCursor(context);\r\n    const currentSource = context.source;\r\n    // Attributes.\r\n    let props = parseAttributes(context, type);\r\n    // check <pre> tag\r\n    if (context.options.isPreTag(tag)) {\r\n        context.inPre = true;\r\n    }\r\n    // check v-pre\r\n    if (!context.inVPre &&\r\n        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === \'pre\')) {\r\n        context.inVPre = true;\r\n        // reset context\r\n        Object(shared_esm_bundler["i" /* extend */])(context, cursor);\r\n        context.source = currentSource;\r\n        // re-parse attrs and filter out v-pre itself\r\n        props = parseAttributes(context, type).filter(p => p.name !== \'v-pre\');\r\n    }\r\n    // Tag close.\r\n    let isSelfClosing = false;\r\n    if (context.source.length === 0) {\r\n        emitError(context, 9 /* EOF_IN_TAG */);\r\n    }\r\n    else {\r\n        isSelfClosing = startsWith(context.source, \'/>\');\r\n        if (type === 1 /* End */ && isSelfClosing) {\r\n            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);\r\n        }\r\n        advanceBy(context, isSelfClosing ? 2 : 1);\r\n    }\r\n    let tagType = 0 /* ELEMENT */;\r\n    const options = context.options;\r\n    if (!context.inVPre && !options.isCustomElement(tag)) {\r\n        const hasVIs = props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === \'is\');\r\n        if (options.isNativeTag && !hasVIs) {\r\n            if (!options.isNativeTag(tag))\r\n                tagType = 1 /* COMPONENT */;\r\n        }\r\n        else if (hasVIs ||\r\n            isCoreComponent(tag) ||\r\n            (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\r\n            /^[A-Z]/.test(tag) ||\r\n            tag === \'component\') {\r\n            tagType = 1 /* COMPONENT */;\r\n        }\r\n        if (tag === \'slot\') {\r\n            tagType = 2 /* SLOT */;\r\n        }\r\n        else if (tag === \'template\' &&\r\n            props.some(p => {\r\n                return (p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name));\r\n            })) {\r\n            tagType = 3 /* TEMPLATE */;\r\n        }\r\n    }\r\n    return {\r\n        type: 1 /* ELEMENT */,\r\n        ns,\r\n        tag,\r\n        tagType,\r\n        props,\r\n        isSelfClosing,\r\n        children: [],\r\n        loc: getSelection(context, start),\r\n        codegenNode: undefined // to be created during transform phase\r\n    };\r\n}\r\nfunction parseAttributes(context, type) {\r\n    const props = [];\r\n    const attributeNames = new Set();\r\n    while (context.source.length > 0 &&\r\n        !startsWith(context.source, \'>\') &&\r\n        !startsWith(context.source, \'/>\')) {\r\n        if (startsWith(context.source, \'/\')) {\r\n            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);\r\n            advanceBy(context, 1);\r\n            advanceSpaces(context);\r\n            continue;\r\n        }\r\n        if (type === 1 /* End */) {\r\n            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);\r\n        }\r\n        const attr = parseAttribute(context, attributeNames);\r\n        if (type === 0 /* Start */) {\r\n            props.push(attr);\r\n        }\r\n        if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\r\n            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\r\n        }\r\n        advanceSpaces(context);\r\n    }\r\n    return props;\r\n}\r\nfunction parseAttribute(context, nameSet) {\r\n    // Name.\r\n    const start = getCursor(context);\r\n    const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\r\n    const name = match[0];\r\n    if (nameSet.has(name)) {\r\n        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);\r\n    }\r\n    nameSet.add(name);\r\n    if (name[0] === \'=\') {\r\n        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\r\n    }\r\n    {\r\n        const pattern = /["\'<]/g;\r\n        let m;\r\n        while ((m = pattern.exec(name))) {\r\n            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\r\n        }\r\n    }\r\n    advanceBy(context, name.length);\r\n    // Value\r\n    let value = undefined;\r\n    if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\r\n        advanceSpaces(context);\r\n        advanceBy(context, 1);\r\n        advanceSpaces(context);\r\n        value = parseAttributeValue(context);\r\n        if (!value) {\r\n            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);\r\n        }\r\n    }\r\n    const loc = getSelection(context, start);\r\n    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {\r\n        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(name);\r\n        const dirName = match[1] ||\r\n            (startsWith(name, \':\') ? \'bind\' : startsWith(name, \'@\') ? \'on\' : \'slot\');\r\n        let arg;\r\n        if (match[2]) {\r\n            const isSlot = dirName === \'slot\';\r\n            const startOffset = name.indexOf(match[2]);\r\n            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || \'\').length));\r\n            let content = match[2];\r\n            let isStatic = true;\r\n            if (content.startsWith(\'[\')) {\r\n                isStatic = false;\r\n                if (!content.endsWith(\']\')) {\r\n                    emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\r\n                }\r\n                content = content.substr(1, content.length - 2);\r\n            }\r\n            else if (isSlot) {\r\n                // #1241 special case for v-slot: vuetify relies extensively on slot\r\n                // names containing dots. v-slot doesn\'t have any modifiers and Vue 2.x\r\n                // supports such usage so we are keeping it consistent with 2.x.\r\n                content += match[3] || \'\';\r\n            }\r\n            arg = {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content,\r\n                isStatic,\r\n                constType: isStatic\r\n                    ? 3 /* CAN_STRINGIFY */\r\n                    : 0 /* NOT_CONSTANT */,\r\n                loc\r\n            };\r\n        }\r\n        if (value && value.isQuoted) {\r\n            const valueLoc = value.loc;\r\n            valueLoc.start.offset++;\r\n            valueLoc.start.column++;\r\n            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\r\n            valueLoc.source = valueLoc.source.slice(1, -1);\r\n        }\r\n        return {\r\n            type: 7 /* DIRECTIVE */,\r\n            name: dirName,\r\n            exp: value && {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content: value.content,\r\n                isStatic: false,\r\n                // Treat as non-constant by default. This can be potentially set to\r\n                // other values by `transformExpression` to make it eligible for hoisting.\r\n                constType: 0 /* NOT_CONSTANT */,\r\n                loc: value.loc\r\n            },\r\n            arg,\r\n            modifiers: match[3] ? match[3].substr(1).split(\'.\') : [],\r\n            loc\r\n        };\r\n    }\r\n    return {\r\n        type: 6 /* ATTRIBUTE */,\r\n        name,\r\n        value: value && {\r\n            type: 2 /* TEXT */,\r\n            content: value.content,\r\n            loc: value.loc\r\n        },\r\n        loc\r\n    };\r\n}\r\nfunction parseAttributeValue(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    const quote = context.source[0];\r\n    const isQuoted = quote === `"` || quote === `\'`;\r\n    if (isQuoted) {\r\n        // Quoted value.\r\n        advanceBy(context, 1);\r\n        const endIndex = context.source.indexOf(quote);\r\n        if (endIndex === -1) {\r\n            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);\r\n        }\r\n        else {\r\n            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);\r\n            advanceBy(context, 1);\r\n        }\r\n    }\r\n    else {\r\n        // Unquoted\r\n        const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\r\n        if (!match) {\r\n            return undefined;\r\n        }\r\n        const unexpectedChars = /["\'<=`]/g;\r\n        let m;\r\n        while ((m = unexpectedChars.exec(match[0]))) {\r\n            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\r\n        }\r\n        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n    return { content, isQuoted, loc: getSelection(context, start) };\r\n}\r\nfunction parseInterpolation(context, mode) {\r\n    const [open, close] = context.options.delimiters;\r\n    const closeIndex = context.source.indexOf(close, open.length);\r\n    if (closeIndex === -1) {\r\n        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);\r\n        return undefined;\r\n    }\r\n    const start = getCursor(context);\r\n    advanceBy(context, open.length);\r\n    const innerStart = getCursor(context);\r\n    const innerEnd = getCursor(context);\r\n    const rawContentLength = closeIndex - open.length;\r\n    const rawContent = context.source.slice(0, rawContentLength);\r\n    const preTrimContent = parseTextData(context, rawContentLength, mode);\r\n    const content = preTrimContent.trim();\r\n    const startOffset = preTrimContent.indexOf(content);\r\n    if (startOffset > 0) {\r\n        advancePositionWithMutation(innerStart, rawContent, startOffset);\r\n    }\r\n    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\r\n    advancePositionWithMutation(innerEnd, rawContent, endOffset);\r\n    advanceBy(context, close.length);\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        content: {\r\n            type: 4 /* SIMPLE_EXPRESSION */,\r\n            isStatic: false,\r\n            // Set `isConstant` to false by default and will decide in transformExpression\r\n            constType: 0 /* NOT_CONSTANT */,\r\n            content,\r\n            loc: getSelection(context, innerStart, innerEnd)\r\n        },\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseText(context, mode) {\r\n    const endTokens = [\'<\', context.options.delimiters[0]];\r\n    if (mode === 3 /* CDATA */) {\r\n        endTokens.push(\']]>\');\r\n    }\r\n    let endIndex = context.source.length;\r\n    for (let i = 0; i < endTokens.length; i++) {\r\n        const index = context.source.indexOf(endTokens[i], 1);\r\n        if (index !== -1 && endIndex > index) {\r\n            endIndex = index;\r\n        }\r\n    }\r\n    const start = getCursor(context);\r\n    const content = parseTextData(context, endIndex, mode);\r\n    return {\r\n        type: 2 /* TEXT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\n/**\r\n * Get text data with a given length from the current location.\r\n * This translates HTML entities in the text data.\r\n */\r\nfunction parseTextData(context, length, mode) {\r\n    const rawText = context.source.slice(0, length);\r\n    advanceBy(context, length);\r\n    if (mode === 2 /* RAWTEXT */ ||\r\n        mode === 3 /* CDATA */ ||\r\n        rawText.indexOf(\'&\') === -1) {\r\n        return rawText;\r\n    }\r\n    else {\r\n        // DATA or RCDATA containing "&"". Entity decoding required.\r\n        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n}\r\nfunction getCursor(context) {\r\n    const { column, line, offset } = context;\r\n    return { column, line, offset };\r\n}\r\nfunction getSelection(context, start, end) {\r\n    end = end || getCursor(context);\r\n    return {\r\n        start,\r\n        end,\r\n        source: context.originalSource.slice(start.offset, end.offset)\r\n    };\r\n}\r\nfunction last(xs) {\r\n    return xs[xs.length - 1];\r\n}\r\nfunction startsWith(source, searchString) {\r\n    return source.startsWith(searchString);\r\n}\r\nfunction advanceBy(context, numberOfCharacters) {\r\n    const { source } = context;\r\n    advancePositionWithMutation(context, source, numberOfCharacters);\r\n    context.source = source.slice(numberOfCharacters);\r\n}\r\nfunction advanceSpaces(context) {\r\n    const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\r\n    if (match) {\r\n        advanceBy(context, match[0].length);\r\n    }\r\n}\r\nfunction getNewPosition(context, start, numberOfCharacters) {\r\n    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\r\n}\r\nfunction emitError(context, code, offset, loc = getCursor(context)) {\r\n    if (offset) {\r\n        loc.offset += offset;\r\n        loc.column += offset;\r\n    }\r\n    context.options.onError(createCompilerError(code, {\r\n        start: loc,\r\n        end: loc,\r\n        source: \'\'\r\n    }));\r\n}\r\nfunction isEnd(context, mode, ancestors) {\r\n    const s = context.source;\r\n    switch (mode) {\r\n        case 0 /* DATA */:\r\n            if (startsWith(s, \'</\')) {\r\n                // TODO: probably bad performance\r\n                for (let i = ancestors.length - 1; i >= 0; --i) {\r\n                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case 1 /* RCDATA */:\r\n        case 2 /* RAWTEXT */: {\r\n            const parent = last(ancestors);\r\n            if (parent && startsWithEndTagOpen(s, parent.tag)) {\r\n                return true;\r\n            }\r\n            break;\r\n        }\r\n        case 3 /* CDATA */:\r\n            if (startsWith(s, \']]>\')) {\r\n                return true;\r\n            }\r\n            break;\r\n    }\r\n    return !s;\r\n}\r\nfunction startsWithEndTagOpen(source, tag) {\r\n    return (startsWith(source, \'</\') &&\r\n        source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\r\n        /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || \'>\'));\r\n}\n\nfunction compiler_core_esm_bundler_hoistStatic(root, context) {\r\n    walk(root, context, \r\n    // Root node is unfortunately non-hoistable due to potential parent\r\n    // fallthrough attributes.\r\n    isSingleElementRoot(root, root.children[0]));\r\n}\r\nfunction isSingleElementRoot(root, child) {\r\n    const { children } = root;\r\n    return (children.length === 1 &&\r\n        child.type === 1 /* ELEMENT */ &&\r\n        !isSlotOutlet(child));\r\n}\r\nfunction walk(node, context, doNotHoistNode = false) {\r\n    let hasHoistedNode = false;\r\n    // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces\r\n    // static bindings with expressions. These expressions are guaranteed to be\r\n    // constant so they are still eligible for hoisting, but they are only\r\n    // available at runtime and therefore cannot be evaluated ahead of time.\r\n    // This is only a concern for pre-stringification (via transformHoist by\r\n    // @vue/compiler-dom), but doing it here allows us to perform only one full\r\n    // walk of the AST and allow `stringifyStatic` to stop walking as soon as its\r\n    // stringficiation threshold is met.\r\n    let canStringify = true;\r\n    const { children } = node;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        // only plain elements & text calls are eligible for hoisting.\r\n        if (child.type === 1 /* ELEMENT */ &&\r\n            child.tagType === 0 /* ELEMENT */) {\r\n            const constantType = doNotHoistNode\r\n                ? 0 /* NOT_CONSTANT */\r\n                : getConstantType(child, context);\r\n            if (constantType > 0 /* NOT_CONSTANT */) {\r\n                if (constantType < 3 /* CAN_STRINGIFY */) {\r\n                    canStringify = false;\r\n                }\r\n                if (constantType >= 2 /* CAN_HOIST */) {\r\n                    child.codegenNode.patchFlag =\r\n                        -1 /* HOISTED */ + (( false) ? undefined : ``);\r\n                    child.codegenNode = context.hoist(child.codegenNode);\r\n                    hasHoistedNode = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                // node may contain dynamic children, but its props may be eligible for\r\n                // hoisting.\r\n                const codegenNode = child.codegenNode;\r\n                if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                    const flag = getPatchFlag(codegenNode);\r\n                    if ((!flag ||\r\n                        flag === 512 /* NEED_PATCH */ ||\r\n                        flag === 1 /* TEXT */) &&\r\n                        getGeneratedPropsConstantType(child, context) >=\r\n                            2 /* CAN_HOIST */) {\r\n                        const props = getNodeProps(child);\r\n                        if (props) {\r\n                            codegenNode.props = context.hoist(props);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (child.type === 12 /* TEXT_CALL */) {\r\n            const contentType = getConstantType(child.content, context);\r\n            if (contentType > 0) {\r\n                if (contentType < 3 /* CAN_STRINGIFY */) {\r\n                    canStringify = false;\r\n                }\r\n                if (contentType >= 2 /* CAN_HOIST */) {\r\n                    child.codegenNode = context.hoist(child.codegenNode);\r\n                    hasHoistedNode = true;\r\n                }\r\n            }\r\n        }\r\n        // walk further\r\n        if (child.type === 1 /* ELEMENT */) {\r\n            walk(child, context);\r\n        }\r\n        else if (child.type === 11 /* FOR */) {\r\n            // Do not hoist v-for single child because it has to be a block\r\n            walk(child, context, child.children.length === 1);\r\n        }\r\n        else if (child.type === 9 /* IF */) {\r\n            for (let i = 0; i < child.branches.length; i++) {\r\n                // Do not hoist v-if single child because it has to be a block\r\n                walk(child.branches[i], context, child.branches[i].children.length === 1);\r\n            }\r\n        }\r\n    }\r\n    if (canStringify && hasHoistedNode && context.transformHoist) {\r\n        context.transformHoist(children, context, node);\r\n    }\r\n}\r\nfunction getConstantType(node, context) {\r\n    const { constantCache } = context;\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            if (node.tagType !== 0 /* ELEMENT */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const cached = constantCache.get(node);\r\n            if (cached !== undefined) {\r\n                return cached;\r\n            }\r\n            const codegenNode = node.codegenNode;\r\n            if (codegenNode.type !== 13 /* VNODE_CALL */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const flag = getPatchFlag(codegenNode);\r\n            if (!flag) {\r\n                let returnType = 3 /* CAN_STRINGIFY */;\r\n                // Element itself has no patch flag. However we still need to check:\r\n                // 1. Even for a node with no patch flag, it is possible for it to contain\r\n                // non-hoistable expressions that refers to scope variables, e.g. compiler\r\n                // injected keys or cached event handlers. Therefore we need to always\r\n                // check the codegenNode\'s props to be sure.\r\n                const generatedPropsType = getGeneratedPropsConstantType(node, context);\r\n                if (generatedPropsType === 0 /* NOT_CONSTANT */) {\r\n                    constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                    return 0 /* NOT_CONSTANT */;\r\n                }\r\n                if (generatedPropsType < returnType) {\r\n                    returnType = generatedPropsType;\r\n                }\r\n                // 2. its children.\r\n                for (let i = 0; i < node.children.length; i++) {\r\n                    const childType = getConstantType(node.children[i], context);\r\n                    if (childType === 0 /* NOT_CONSTANT */) {\r\n                        constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                        return 0 /* NOT_CONSTANT */;\r\n                    }\r\n                    if (childType < returnType) {\r\n                        returnType = childType;\r\n                    }\r\n                }\r\n                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\r\n                // type, check if any of the props can cause the type to be lowered\r\n                // we can skip can_patch because it\'s guaranteed by the absence of a\r\n                // patchFlag.\r\n                if (returnType > 1 /* CAN_SKIP_PATCH */) {\r\n                    for (let i = 0; i < node.props.length; i++) {\r\n                        const p = node.props[i];\r\n                        if (p.type === 7 /* DIRECTIVE */ && p.name === \'bind\' && p.exp) {\r\n                            const expType = getConstantType(p.exp, context);\r\n                            if (expType === 0 /* NOT_CONSTANT */) {\r\n                                constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                                return 0 /* NOT_CONSTANT */;\r\n                            }\r\n                            if (expType < returnType) {\r\n                                returnType = expType;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // only svg/foreignObject could be block here, however if they are\r\n                // static then they don\'t need to be blocks since there will be no\r\n                // nested updates.\r\n                if (codegenNode.isBlock) {\r\n                    codegenNode.isBlock = false;\r\n                    context.helper(CREATE_VNODE);\r\n                }\r\n                constantCache.set(node, returnType);\r\n                return returnType;\r\n            }\r\n            else {\r\n                constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n        case 2 /* TEXT */:\r\n        case 3 /* COMMENT */:\r\n            return 3 /* CAN_STRINGIFY */;\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n        case 10 /* IF_BRANCH */:\r\n            return 0 /* NOT_CONSTANT */;\r\n        case 5 /* INTERPOLATION */:\r\n        case 12 /* TEXT_CALL */:\r\n            return getConstantType(node.content, context);\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            return node.constType;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            let returnType = 3 /* CAN_STRINGIFY */;\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                const child = node.children[i];\r\n                if (Object(shared_esm_bundler["C" /* isString */])(child) || Object(shared_esm_bundler["D" /* isSymbol */])(child)) {\r\n                    continue;\r\n                }\r\n                const childType = getConstantType(child, context);\r\n                if (childType === 0 /* NOT_CONSTANT */) {\r\n                    return 0 /* NOT_CONSTANT */;\r\n                }\r\n                else if (childType < returnType) {\r\n                    returnType = childType;\r\n                }\r\n            }\r\n            return returnType;\r\n        default:\r\n            if ((false)) {}\r\n            return 0 /* NOT_CONSTANT */;\r\n    }\r\n}\r\nfunction getGeneratedPropsConstantType(node, context) {\r\n    let returnType = 3 /* CAN_STRINGIFY */;\r\n    const props = getNodeProps(node);\r\n    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n        const { properties } = props;\r\n        for (let i = 0; i < properties.length; i++) {\r\n            const { key, value } = properties[i];\r\n            const keyType = getConstantType(key, context);\r\n            if (keyType === 0 /* NOT_CONSTANT */) {\r\n                return keyType;\r\n            }\r\n            if (keyType < returnType) {\r\n                returnType = keyType;\r\n            }\r\n            if (value.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const valueType = getConstantType(value, context);\r\n            if (valueType === 0 /* NOT_CONSTANT */) {\r\n                return valueType;\r\n            }\r\n            if (valueType < returnType) {\r\n                returnType = valueType;\r\n            }\r\n        }\r\n    }\r\n    return returnType;\r\n}\r\nfunction getNodeProps(node) {\r\n    const codegenNode = node.codegenNode;\r\n    if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n        return codegenNode.props;\r\n    }\r\n}\r\nfunction getPatchFlag(node) {\r\n    const flag = node.patchFlag;\r\n    return flag ? parseInt(flag, 10) : undefined;\r\n}\n\nfunction createTransformContext(root, { filename = \'\', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = shared_esm_bundler["d" /* NOOP */], isCustomElement = shared_esm_bundler["d" /* NOOP */], expressionPlugins = [], scopeId = null, ssr = false, ssrCssVars = ``, bindingMetadata = shared_esm_bundler["b" /* EMPTY_OBJ */], inline = false, isTS = false, onError = defaultOnError }) {\r\n    const nameMatch = filename.replace(/\\?.*$/, \'\').match(/([^/\\\\]+)\\.\\w+$/);\r\n    const context = {\r\n        // options\r\n        selfName: nameMatch && Object(shared_esm_bundler["g" /* capitalize */])(Object(shared_esm_bundler["f" /* camelize */])(nameMatch[1])),\r\n        prefixIdentifiers,\r\n        hoistStatic,\r\n        cacheHandlers,\r\n        nodeTransforms,\r\n        directiveTransforms,\r\n        transformHoist,\r\n        isBuiltInComponent,\r\n        isCustomElement,\r\n        expressionPlugins,\r\n        scopeId,\r\n        ssr,\r\n        ssrCssVars,\r\n        bindingMetadata,\r\n        inline,\r\n        isTS,\r\n        onError,\r\n        // state\r\n        root,\r\n        helpers: new Set(),\r\n        components: new Set(),\r\n        directives: new Set(),\r\n        hoists: [],\r\n        imports: [],\r\n        constantCache: new Map(),\r\n        temps: 0,\r\n        cached: 0,\r\n        identifiers: Object.create(null),\r\n        scopes: {\r\n            vFor: 0,\r\n            vSlot: 0,\r\n            vPre: 0,\r\n            vOnce: 0\r\n        },\r\n        parent: null,\r\n        currentNode: root,\r\n        childIndex: 0,\r\n        // methods\r\n        helper(name) {\r\n            context.helpers.add(name);\r\n            return name;\r\n        },\r\n        helperString(name) {\r\n            return `_${helperNameMap[context.helper(name)]}`;\r\n        },\r\n        replaceNode(node) {\r\n            /* istanbul ignore if */\r\n            if ((false)) {}\r\n            context.parent.children[context.childIndex] = context.currentNode = node;\r\n        },\r\n        removeNode(node) {\r\n            if (false) {}\r\n            const list = context.parent.children;\r\n            const removalIndex = node\r\n                ? list.indexOf(node)\r\n                : context.currentNode\r\n                    ? context.childIndex\r\n                    : -1;\r\n            /* istanbul ignore if */\r\n            if (false) {}\r\n            if (!node || node === context.currentNode) {\r\n                // current node removed\r\n                context.currentNode = null;\r\n                context.onNodeRemoved();\r\n            }\r\n            else {\r\n                // sibling node removed\r\n                if (context.childIndex > removalIndex) {\r\n                    context.childIndex--;\r\n                    context.onNodeRemoved();\r\n                }\r\n            }\r\n            context.parent.children.splice(removalIndex, 1);\r\n        },\r\n        onNodeRemoved: () => { },\r\n        addIdentifiers(exp) {\r\n        },\r\n        removeIdentifiers(exp) {\r\n        },\r\n        hoist(exp) {\r\n            context.hoists.push(exp);\r\n            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);\r\n            identifier.hoisted = exp;\r\n            return identifier;\r\n        },\r\n        cache(exp, isVNode = false) {\r\n            return createCacheExpression(++context.cached, exp, isVNode);\r\n        }\r\n    };\r\n    return context;\r\n}\r\nfunction transform(root, options) {\r\n    const context = createTransformContext(root, options);\r\n    traverseNode(root, context);\r\n    if (options.hoistStatic) {\r\n        compiler_core_esm_bundler_hoistStatic(root, context);\r\n    }\r\n    if (!options.ssr) {\r\n        createRootCodegen(root, context);\r\n    }\r\n    // finalize meta information\r\n    root.helpers = [...context.helpers];\r\n    root.components = [...context.components];\r\n    root.directives = [...context.directives];\r\n    root.imports = context.imports;\r\n    root.hoists = context.hoists;\r\n    root.temps = context.temps;\r\n    root.cached = context.cached;\r\n}\r\nfunction createRootCodegen(root, context) {\r\n    const { helper } = context;\r\n    const { children } = root;\r\n    if (children.length === 1) {\r\n        const child = children[0];\r\n        // if the single child is an element, turn it into a block.\r\n        if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n            // single element root is never hoisted so codegenNode will never be\r\n            // SimpleExpressionNode\r\n            const codegenNode = child.codegenNode;\r\n            if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                codegenNode.isBlock = true;\r\n                helper(OPEN_BLOCK);\r\n                helper(CREATE_BLOCK);\r\n            }\r\n            root.codegenNode = codegenNode;\r\n        }\r\n        else {\r\n            // - single <slot/>, IfNode, ForNode: already blocks.\r\n            // - single text node: always patched.\r\n            // root codegen falls through via genNode()\r\n            root.codegenNode = child;\r\n        }\r\n    }\r\n    else if (children.length > 1) {\r\n        // root has multiple nodes - return a fragment block.\r\n        let patchFlag = 64 /* STABLE_FRAGMENT */;\r\n        let patchFlagText = shared_esm_bundler["e" /* PatchFlagNames */][64 /* STABLE_FRAGMENT */];\r\n        // check if the fragment actually contains a single valid child with\r\n        // the rest being comments\r\n        if (false) {}\r\n        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (( false) ? undefined : ``), undefined, undefined, true);\r\n    }\r\n    else ;\r\n}\r\nfunction traverseChildren(parent, context) {\r\n    let i = 0;\r\n    const nodeRemoved = () => {\r\n        i--;\r\n    };\r\n    for (; i < parent.children.length; i++) {\r\n        const child = parent.children[i];\r\n        if (Object(shared_esm_bundler["C" /* isString */])(child))\r\n            continue;\r\n        context.parent = parent;\r\n        context.childIndex = i;\r\n        context.onNodeRemoved = nodeRemoved;\r\n        traverseNode(child, context);\r\n    }\r\n}\r\nfunction traverseNode(node, context) {\r\n    context.currentNode = node;\r\n    // apply transform plugins\r\n    const { nodeTransforms } = context;\r\n    const exitFns = [];\r\n    for (let i = 0; i < nodeTransforms.length; i++) {\r\n        const onExit = nodeTransforms[i](node, context);\r\n        if (onExit) {\r\n            if (Object(shared_esm_bundler["o" /* isArray */])(onExit)) {\r\n                exitFns.push(...onExit);\r\n            }\r\n            else {\r\n                exitFns.push(onExit);\r\n            }\r\n        }\r\n        if (!context.currentNode) {\r\n            // node was removed\r\n            return;\r\n        }\r\n        else {\r\n            // node may have been replaced\r\n            node = context.currentNode;\r\n        }\r\n    }\r\n    switch (node.type) {\r\n        case 3 /* COMMENT */:\r\n            if (!context.ssr) {\r\n                // inject import for the Comment symbol, which is needed for creating\r\n                // comment nodes with `createVNode`\r\n                context.helper(CREATE_COMMENT);\r\n            }\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            // no need to traverse, but we need to inject toString helper\r\n            if (!context.ssr) {\r\n                context.helper(TO_DISPLAY_STRING);\r\n            }\r\n            break;\r\n        // for container types, further traverse downwards\r\n        case 9 /* IF */:\r\n            for (let i = 0; i < node.branches.length; i++) {\r\n                traverseNode(node.branches[i], context);\r\n            }\r\n            break;\r\n        case 10 /* IF_BRANCH */:\r\n        case 11 /* FOR */:\r\n        case 1 /* ELEMENT */:\r\n        case 0 /* ROOT */:\r\n            traverseChildren(node, context);\r\n            break;\r\n    }\r\n    // exit transforms\r\n    context.currentNode = node;\r\n    let i = exitFns.length;\r\n    while (i--) {\r\n        exitFns[i]();\r\n    }\r\n}\r\nfunction createStructuralDirectiveTransform(name, fn) {\r\n    const matches = Object(shared_esm_bundler["C" /* isString */])(name)\r\n        ? (n) => n === name\r\n        : (n) => name.test(n);\r\n    return (node, context) => {\r\n        if (node.type === 1 /* ELEMENT */) {\r\n            const { props } = node;\r\n            // structural directive transforms are not concerned with slots\r\n            // as they are handled separately in vSlot.ts\r\n            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {\r\n                return;\r\n            }\r\n            const exitFns = [];\r\n            for (let i = 0; i < props.length; i++) {\r\n                const prop = props[i];\r\n                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {\r\n                    // structural directives are removed to avoid infinite recursion\r\n                    // also we remove them *before* applying so that it can further\r\n                    // traverse itself in case it moves the node around\r\n                    props.splice(i, 1);\r\n                    i--;\r\n                    const onExit = fn(node, prop, context);\r\n                    if (onExit)\r\n                        exitFns.push(onExit);\r\n                }\r\n            }\r\n            return exitFns;\r\n        }\r\n    };\r\n}\n\nconst PURE_ANNOTATION = `/*#__PURE__*/`;\r\nfunction createCodegenContext(ast, { mode = \'function\', prefixIdentifiers = mode === \'module\', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {\r\n    const context = {\r\n        mode,\r\n        prefixIdentifiers,\r\n        sourceMap,\r\n        filename,\r\n        scopeId,\r\n        optimizeImports,\r\n        runtimeGlobalName,\r\n        runtimeModuleName,\r\n        ssr,\r\n        source: ast.loc.source,\r\n        code: ``,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        indentLevel: 0,\r\n        pure: false,\r\n        map: undefined,\r\n        helper(key) {\r\n            return `_${helperNameMap[key]}`;\r\n        },\r\n        push(code, node) {\r\n            context.code += code;\r\n        },\r\n        indent() {\r\n            newline(++context.indentLevel);\r\n        },\r\n        deindent(withoutNewLine = false) {\r\n            if (withoutNewLine) {\r\n                --context.indentLevel;\r\n            }\r\n            else {\r\n                newline(--context.indentLevel);\r\n            }\r\n        },\r\n        newline() {\r\n            newline(context.indentLevel);\r\n        }\r\n    };\r\n    function newline(n) {\r\n        context.push(\'\\n\' + `  `.repeat(n));\r\n    }\r\n    return context;\r\n}\r\nfunction generate(ast, options = {}) {\r\n    const context = createCodegenContext(ast, options);\r\n    if (options.onContextCreated)\r\n        options.onContextCreated(context);\r\n    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;\r\n    const hasHelpers = ast.helpers.length > 0;\r\n    const useWithBlock = !prefixIdentifiers && mode !== \'module\';\r\n    // preambles\r\n    // in setup() inline mode, the preamble is generated in a sub context\r\n    // and returned separately.\r\n    const preambleContext = context;\r\n    {\r\n        genFunctionPreamble(ast, preambleContext);\r\n    }\r\n    // enter render function\r\n    const functionName = ssr ? `ssrRender` : `render`;\r\n    const args = ssr ? [\'_ctx\', \'_push\', \'_parent\', \'_attrs\'] : [\'_ctx\', \'_cache\'];\r\n    const signature = args.join(\', \');\r\n    {\r\n        push(`function ${functionName}(${signature}) {`);\r\n    }\r\n    indent();\r\n    if (useWithBlock) {\r\n        push(`with (_ctx) {`);\r\n        indent();\r\n        // function mode const declarations should be inside with block\r\n        // also they should be renamed to avoid collision with user properties\r\n        if (hasHelpers) {\r\n            push(`const { ${ast.helpers\r\n                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\r\n                .join(\', \')} } = _Vue`);\r\n            push(`\\n`);\r\n            newline();\r\n        }\r\n    }\r\n    // generate asset resolution statements\r\n    if (ast.components.length) {\r\n        genAssets(ast.components, \'component\', context);\r\n        if (ast.directives.length || ast.temps > 0) {\r\n            newline();\r\n        }\r\n    }\r\n    if (ast.directives.length) {\r\n        genAssets(ast.directives, \'directive\', context);\r\n        if (ast.temps > 0) {\r\n            newline();\r\n        }\r\n    }\r\n    if (ast.temps > 0) {\r\n        push(`let `);\r\n        for (let i = 0; i < ast.temps; i++) {\r\n            push(`${i > 0 ? `, ` : ``}_temp${i}`);\r\n        }\r\n    }\r\n    if (ast.components.length || ast.directives.length || ast.temps) {\r\n        push(`\\n`);\r\n        newline();\r\n    }\r\n    // generate the VNode tree expression\r\n    if (!ssr) {\r\n        push(`return `);\r\n    }\r\n    if (ast.codegenNode) {\r\n        genNode(ast.codegenNode, context);\r\n    }\r\n    else {\r\n        push(`null`);\r\n    }\r\n    if (useWithBlock) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    deindent();\r\n    push(`}`);\r\n    return {\r\n        ast,\r\n        code: context.code,\r\n        preamble: ``,\r\n        // SourceMapGenerator does have toJSON() method but it\'s not in the types\r\n        map: context.map ? context.map.toJSON() : undefined\r\n    };\r\n}\r\nfunction genFunctionPreamble(ast, context) {\r\n    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;\r\n    const VueBinding = runtimeGlobalName;\r\n    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\r\n    // Generate const declaration for helpers\r\n    // In prefix mode, we place the const declaration at top so it\'s done\r\n    // only once; But if we not prefixing, we place the declaration inside the\r\n    // with block so it doesn\'t incur the `in` check cost for every helper access.\r\n    if (ast.helpers.length > 0) {\r\n        {\r\n            // "with" mode.\r\n            // save Vue in a separate variable to avoid collision\r\n            push(`const _Vue = ${VueBinding}\\n`);\r\n            // in "with" mode, helpers are declared inside the with block to avoid\r\n            // has check cost, but hoists are lifted out of the function - we need\r\n            // to provide the helper here.\r\n            if (ast.hoists.length) {\r\n                const staticHelpers = [\r\n                    CREATE_VNODE,\r\n                    CREATE_COMMENT,\r\n                    CREATE_TEXT,\r\n                    CREATE_STATIC\r\n                ]\r\n                    .filter(helper => ast.helpers.includes(helper))\r\n                    .map(aliasHelper)\r\n                    .join(\', \');\r\n                push(`const { ${staticHelpers} } = _Vue\\n`);\r\n            }\r\n        }\r\n    }\r\n    genHoists(ast.hoists, context);\r\n    newline();\r\n    push(`return `);\r\n}\r\nfunction genAssets(assets, type, { helper, push, newline }) {\r\n    const resolver = helper(type === \'component\' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);\r\n    for (let i = 0; i < assets.length; i++) {\r\n        const id = assets[i];\r\n        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`);\r\n        if (i < assets.length - 1) {\r\n            newline();\r\n        }\r\n    }\r\n}\r\nfunction genHoists(hoists, context) {\r\n    if (!hoists.length) {\r\n        return;\r\n    }\r\n    context.pure = true;\r\n    const { push, newline, helper, scopeId, mode } = context;\r\n    newline();\r\n    hoists.forEach((exp, i) => {\r\n        if (exp) {\r\n            push(`const _hoisted_${i + 1} = `);\r\n            genNode(exp, context);\r\n            newline();\r\n        }\r\n    });\r\n    context.pure = false;\r\n}\r\nfunction isText$1(n) {\r\n    return (Object(shared_esm_bundler["C" /* isString */])(n) ||\r\n        n.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n        n.type === 2 /* TEXT */ ||\r\n        n.type === 5 /* INTERPOLATION */ ||\r\n        n.type === 8 /* COMPOUND_EXPRESSION */);\r\n}\r\nfunction genNodeListAsArray(nodes, context) {\r\n    const multilines = nodes.length > 3 ||\r\n        ((( false)) && false);\r\n    context.push(`[`);\r\n    multilines && context.indent();\r\n    genNodeList(nodes, context, multilines);\r\n    multilines && context.deindent();\r\n    context.push(`]`);\r\n}\r\nfunction genNodeList(nodes, context, multilines = false, comma = true) {\r\n    const { push, newline } = context;\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        if (Object(shared_esm_bundler["C" /* isString */])(node)) {\r\n            push(node);\r\n        }\r\n        else if (Object(shared_esm_bundler["o" /* isArray */])(node)) {\r\n            genNodeListAsArray(node, context);\r\n        }\r\n        else {\r\n            genNode(node, context);\r\n        }\r\n        if (i < nodes.length - 1) {\r\n            if (multilines) {\r\n                comma && push(\',\');\r\n                newline();\r\n            }\r\n            else {\r\n                comma && push(\', \');\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction genNode(node, context) {\r\n    if (Object(shared_esm_bundler["C" /* isString */])(node)) {\r\n        context.push(node);\r\n        return;\r\n    }\r\n    if (Object(shared_esm_bundler["D" /* isSymbol */])(node)) {\r\n        context.push(context.helper(node));\r\n        return;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n            ( false) &&\r\n                false;\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 2 /* TEXT */:\r\n            genText(node, context);\r\n            break;\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            genExpression(node, context);\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            genInterpolation(node, context);\r\n            break;\r\n        case 12 /* TEXT_CALL */:\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            genCompoundExpression(node, context);\r\n            break;\r\n        case 3 /* COMMENT */:\r\n            genComment(node, context);\r\n            break;\r\n        case 13 /* VNODE_CALL */:\r\n            genVNodeCall(node, context);\r\n            break;\r\n        case 14 /* JS_CALL_EXPRESSION */:\r\n            genCallExpression(node, context);\r\n            break;\r\n        case 15 /* JS_OBJECT_EXPRESSION */:\r\n            genObjectExpression(node, context);\r\n            break;\r\n        case 17 /* JS_ARRAY_EXPRESSION */:\r\n            genArrayExpression(node, context);\r\n            break;\r\n        case 18 /* JS_FUNCTION_EXPRESSION */:\r\n            genFunctionExpression(node, context);\r\n            break;\r\n        case 19 /* JS_CONDITIONAL_EXPRESSION */:\r\n            genConditionalExpression(node, context);\r\n            break;\r\n        case 20 /* JS_CACHE_EXPRESSION */:\r\n            genCacheExpression(node, context);\r\n            break;\r\n        // SSR only types\r\n        case 21 /* JS_BLOCK_STATEMENT */:\r\n            break;\r\n        case 22 /* JS_TEMPLATE_LITERAL */:\r\n            break;\r\n        case 23 /* JS_IF_STATEMENT */:\r\n            break;\r\n        case 24 /* JS_ASSIGNMENT_EXPRESSION */:\r\n            break;\r\n        case 25 /* JS_SEQUENCE_EXPRESSION */:\r\n            break;\r\n        case 26 /* JS_RETURN_STATEMENT */:\r\n            break;\r\n        /* istanbul ignore next */\r\n        case 10 /* IF_BRANCH */:\r\n            // noop\r\n            break;\r\n        default:\r\n            if ((false)) {}\r\n    }\r\n}\r\nfunction genText(node, context) {\r\n    context.push(JSON.stringify(node.content), node);\r\n}\r\nfunction genExpression(node, context) {\r\n    const { content, isStatic } = node;\r\n    context.push(isStatic ? JSON.stringify(content) : content, node);\r\n}\r\nfunction genInterpolation(node, context) {\r\n    const { push, helper, pure } = context;\r\n    if (pure)\r\n        push(PURE_ANNOTATION);\r\n    push(`${helper(TO_DISPLAY_STRING)}(`);\r\n    genNode(node.content, context);\r\n    push(`)`);\r\n}\r\nfunction genCompoundExpression(node, context) {\r\n    for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (Object(shared_esm_bundler["C" /* isString */])(child)) {\r\n            context.push(child);\r\n        }\r\n        else {\r\n            genNode(child, context);\r\n        }\r\n    }\r\n}\r\nfunction genExpressionAsPropertyKey(node, context) {\r\n    const { push } = context;\r\n    if (node.type === 8 /* COMPOUND_EXPRESSION */) {\r\n        push(`[`);\r\n        genCompoundExpression(node, context);\r\n        push(`]`);\r\n    }\r\n    else if (node.isStatic) {\r\n        // only quote keys if necessary\r\n        const text = isSimpleIdentifier(node.content)\r\n            ? node.content\r\n            : JSON.stringify(node.content);\r\n        push(text, node);\r\n    }\r\n    else {\r\n        push(`[${node.content}]`, node);\r\n    }\r\n}\r\nfunction genComment(node, context) {\r\n    if ((false)) {}\r\n}\r\nfunction genVNodeCall(node, context) {\r\n    const { push, helper, pure } = context;\r\n    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking } = node;\r\n    if (directives) {\r\n        push(helper(WITH_DIRECTIVES) + `(`);\r\n    }\r\n    if (isBlock) {\r\n        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\r\n    }\r\n    if (pure) {\r\n        push(PURE_ANNOTATION);\r\n    }\r\n    push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);\r\n    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);\r\n    push(`)`);\r\n    if (isBlock) {\r\n        push(`)`);\r\n    }\r\n    if (directives) {\r\n        push(`, `);\r\n        genNode(directives, context);\r\n        push(`)`);\r\n    }\r\n}\r\nfunction genNullableArgs(args) {\r\n    let i = args.length;\r\n    while (i--) {\r\n        if (args[i] != null)\r\n            break;\r\n    }\r\n    return args.slice(0, i + 1).map(arg => arg || `null`);\r\n}\r\n// JavaScript\r\nfunction genCallExpression(node, context) {\r\n    const { push, helper, pure } = context;\r\n    const callee = Object(shared_esm_bundler["C" /* isString */])(node.callee) ? node.callee : helper(node.callee);\r\n    if (pure) {\r\n        push(PURE_ANNOTATION);\r\n    }\r\n    push(callee + `(`, node);\r\n    genNodeList(node.arguments, context);\r\n    push(`)`);\r\n}\r\nfunction genObjectExpression(node, context) {\r\n    const { push, indent, deindent, newline } = context;\r\n    const { properties } = node;\r\n    if (!properties.length) {\r\n        push(`{}`, node);\r\n        return;\r\n    }\r\n    const multilines = properties.length > 1 ||\r\n        ((( false)) &&\r\n            false);\r\n    push(multilines ? `{` : `{ `);\r\n    multilines && indent();\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const { key, value } = properties[i];\r\n        // key\r\n        genExpressionAsPropertyKey(key, context);\r\n        push(`: `);\r\n        // value\r\n        genNode(value, context);\r\n        if (i < properties.length - 1) {\r\n            // will only reach this if it\'s multilines\r\n            push(`,`);\r\n            newline();\r\n        }\r\n    }\r\n    multilines && deindent();\r\n    push(multilines ? `}` : ` }`);\r\n}\r\nfunction genArrayExpression(node, context) {\r\n    genNodeListAsArray(node.elements, context);\r\n}\r\nfunction genFunctionExpression(node, context) {\r\n    const { push, indent, deindent, scopeId, mode } = context;\r\n    const { params, returns, body, newline, isSlot } = node;\r\n    if (isSlot) {\r\n        push(`_${helperNameMap[WITH_CTX]}(`);\r\n    }\r\n    push(`(`, node);\r\n    if (Object(shared_esm_bundler["o" /* isArray */])(params)) {\r\n        genNodeList(params, context);\r\n    }\r\n    else if (params) {\r\n        genNode(params, context);\r\n    }\r\n    push(`) => `);\r\n    if (newline || body) {\r\n        push(`{`);\r\n        indent();\r\n    }\r\n    if (returns) {\r\n        if (newline) {\r\n            push(`return `);\r\n        }\r\n        if (Object(shared_esm_bundler["o" /* isArray */])(returns)) {\r\n            genNodeListAsArray(returns, context);\r\n        }\r\n        else {\r\n            genNode(returns, context);\r\n        }\r\n    }\r\n    else if (body) {\r\n        genNode(body, context);\r\n    }\r\n    if (newline || body) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    if (isSlot) {\r\n        push(`)`);\r\n    }\r\n}\r\nfunction genConditionalExpression(node, context) {\r\n    const { test, consequent, alternate, newline: needNewline } = node;\r\n    const { push, indent, deindent, newline } = context;\r\n    if (test.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        const needsParens = !isSimpleIdentifier(test.content);\r\n        needsParens && push(`(`);\r\n        genExpression(test, context);\r\n        needsParens && push(`)`);\r\n    }\r\n    else {\r\n        push(`(`);\r\n        genNode(test, context);\r\n        push(`)`);\r\n    }\r\n    needNewline && indent();\r\n    context.indentLevel++;\r\n    needNewline || push(` `);\r\n    push(`? `);\r\n    genNode(consequent, context);\r\n    context.indentLevel--;\r\n    needNewline && newline();\r\n    needNewline || push(` `);\r\n    push(`: `);\r\n    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;\r\n    if (!isNested) {\r\n        context.indentLevel++;\r\n    }\r\n    genNode(alternate, context);\r\n    if (!isNested) {\r\n        context.indentLevel--;\r\n    }\r\n    needNewline && deindent(true /* without newline */);\r\n}\r\nfunction genCacheExpression(node, context) {\r\n    const { push, helper, indent, deindent, newline } = context;\r\n    push(`_cache[${node.index}] || (`);\r\n    if (node.isVNode) {\r\n        indent();\r\n        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\r\n        newline();\r\n    }\r\n    push(`_cache[${node.index}] = `);\r\n    genNode(node.value, context);\r\n    if (node.isVNode) {\r\n        push(`,`);\r\n        newline();\r\n        push(`${helper(SET_BLOCK_TRACKING)}(1),`);\r\n        newline();\r\n        push(`_cache[${node.index}]`);\r\n        deindent();\r\n    }\r\n    push(`)`);\r\n}\n\n// these keywords should not appear inside expressions, but operators like\r\n// typeof, instanceof and in are allowed\r\nconst prohibitedKeywordRE = new RegExp(\'\\\\b\' +\r\n    (\'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,\' +\r\n        \'super,throw,while,yield,delete,export,import,return,switch,default,\' +\r\n        \'extends,finally,continue,debugger,function,arguments,typeof,void\')\r\n        .split(\',\')\r\n        .join(\'\\\\b|\\\\b\') +\r\n    \'\\\\b\');\r\n// strip strings in expressions\r\nconst stripStringRE = /\'(?:[^\'\\\\]|\\\\.)*\'|"(?:[^"\\\\]|\\\\.)*"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\r\n/**\r\n * Validate a non-prefixed expression.\r\n * This is only called when using the in-browser runtime compiler since it\r\n * doesn\'t prefix expressions.\r\n */\r\nfunction validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {\r\n    const exp = node.content;\r\n    // empty expressions are validated per-directive since some directives\r\n    // do allow empty expressions.\r\n    if (!exp.trim()) {\r\n        return;\r\n    }\r\n    try {\r\n        new Function(asRawStatements\r\n            ? ` ${exp} `\r\n            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);\r\n    }\r\n    catch (e) {\r\n        let message = e.message;\r\n        const keywordMatch = exp\r\n            .replace(stripStringRE, \'\')\r\n            .match(prohibitedKeywordRE);\r\n        if (keywordMatch) {\r\n            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;\r\n        }\r\n        context.onError(createCompilerError(43 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));\r\n    }\r\n}\n\nconst transformExpression = (node, context) => {\r\n    if (node.type === 5 /* INTERPOLATION */) {\r\n        node.content = processExpression(node.content, context);\r\n    }\r\n    else if (node.type === 1 /* ELEMENT */) {\r\n        // handle directives on element\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const dir = node.props[i];\r\n            // do not process for v-on & v-for since they are special handled\r\n            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== \'for\') {\r\n                const exp = dir.exp;\r\n                const arg = dir.arg;\r\n                // do not process exp if this is v-on:arg - we need special handling\r\n                // for wrapping inline statements.\r\n                if (exp &&\r\n                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                    !(dir.name === \'on\' && arg)) {\r\n                    dir.exp = processExpression(exp, context, \r\n                    // slot args must be processed as function params\r\n                    dir.name === \'slot\');\r\n                }\r\n                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {\r\n                    dir.arg = processExpression(arg, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !true check so that it can be\r\n// tree-shaken from the browser build.\r\nfunction processExpression(node, context, \r\n// some expressions like v-slot props & v-for aliases should be parsed as\r\n// function params\r\nasParams = false, \r\n// v-on handler values may contain multiple statements\r\nasRawStatements = false) {\r\n    {\r\n        if ((false)) {}\r\n        return node;\r\n    }\r\n}\n\nconst transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\r\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\r\n        // #1587: We need to dynamically increment the key based on the current\r\n        // node\'s sibling nodes, since chained v-if/else branches are\r\n        // rendered at the same depth\r\n        const siblings = context.parent.children;\r\n        let i = siblings.indexOf(ifNode);\r\n        let key = 0;\r\n        while (i-- >= 0) {\r\n            const sibling = siblings[i];\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                key += sibling.branches.length;\r\n            }\r\n        }\r\n        // Exit callback. Complete the codegenNode when all children have been\r\n        // transformed.\r\n        return () => {\r\n            if (isRoot) {\r\n                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);\r\n            }\r\n            else {\r\n                // attach this branch\'s codegen node to the v-if root.\r\n                const parentCondition = getParentCondition(ifNode.codegenNode);\r\n                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);\r\n            }\r\n        };\r\n    });\r\n});\r\n// target-agnostic transform used for both Client and SSR\r\nfunction processIf(node, dir, context, processCodegen) {\r\n    if (dir.name !== \'else\' &&\r\n        (!dir.exp || !dir.exp.content.trim())) {\r\n        const loc = dir.exp ? dir.exp.loc : node.loc;\r\n        context.onError(createCompilerError(27 /* X_V_IF_NO_EXPRESSION */, dir.loc));\r\n        dir.exp = createSimpleExpression(`true`, false, loc);\r\n    }\r\n    if (false) {}\r\n    if (dir.name === \'if\') {\r\n        const branch = createIfBranch(node, dir);\r\n        const ifNode = {\r\n            type: 9 /* IF */,\r\n            loc: node.loc,\r\n            branches: [branch]\r\n        };\r\n        context.replaceNode(ifNode);\r\n        if (processCodegen) {\r\n            return processCodegen(ifNode, branch, true);\r\n        }\r\n    }\r\n    else {\r\n        // locate the adjacent v-if\r\n        const siblings = context.parent.children;\r\n        const comments = [];\r\n        let i = siblings.indexOf(node);\r\n        while (i-- >= -1) {\r\n            const sibling = siblings[i];\r\n            if (false /* COMMENT */) {}\r\n            if (sibling &&\r\n                sibling.type === 2 /* TEXT */ &&\r\n                !sibling.content.trim().length) {\r\n                context.removeNode(sibling);\r\n                continue;\r\n            }\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                // move the node to the if node\'s branches\r\n                context.removeNode();\r\n                const branch = createIfBranch(node, dir);\r\n                if (false) {}\r\n                // check if user is forcing same key on different branches\r\n                if (false) {}\r\n                sibling.branches.push(branch);\r\n                const onExit = processCodegen && processCodegen(sibling, branch, false);\r\n                // since the branch was removed, it will not be traversed.\r\n                // make sure to traverse here.\r\n                traverseNode(branch, context);\r\n                // call on exit\r\n                if (onExit)\r\n                    onExit();\r\n                // make sure to reset currentNode after traversal to indicate this\r\n                // node has been removed.\r\n                context.currentNode = null;\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction createIfBranch(node, dir) {\r\n    return {\r\n        type: 10 /* IF_BRANCH */,\r\n        loc: node.loc,\r\n        condition: dir.name === \'else\' ? undefined : dir.exp,\r\n        children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, \'for\')\r\n            ? node.children\r\n            : [node],\r\n        userKey: findProp(node, `key`)\r\n    };\r\n}\r\nfunction createCodegenNodeForBranch(branch, keyIndex, context) {\r\n    if (branch.condition) {\r\n        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), \r\n        // make sure to pass in asBlock: true so that the comment node call\r\n        // closes the current block.\r\n        createCallExpression(context.helper(CREATE_COMMENT), [\r\n            ( false) ? undefined : \'""\',\r\n            \'true\'\r\n        ]));\r\n    }\r\n    else {\r\n        return createChildrenCodegenNode(branch, keyIndex, context);\r\n    }\r\n}\r\nfunction createChildrenCodegenNode(branch, keyIndex, context) {\r\n    const { helper } = context;\r\n    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));\r\n    const { children } = branch;\r\n    const firstChild = children[0];\r\n    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;\r\n    if (needFragmentWrapper) {\r\n        if (children.length === 1 && firstChild.type === 11 /* FOR */) {\r\n            // optimize away nested fragments when child is a ForNode\r\n            const vnodeCall = firstChild.codegenNode;\r\n            injectProp(vnodeCall, keyProperty, context);\r\n            return vnodeCall;\r\n        }\r\n        else {\r\n            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, 64 /* STABLE_FRAGMENT */ +\r\n                (( false)\r\n                    ? undefined\r\n                    : ``), undefined, undefined, true, false, branch.loc);\r\n        }\r\n    }\r\n    else {\r\n        const vnodeCall = firstChild\r\n            .codegenNode;\r\n        // Change createVNode to createBlock.\r\n        if (vnodeCall.type === 13 /* VNODE_CALL */) {\r\n            vnodeCall.isBlock = true;\r\n            helper(OPEN_BLOCK);\r\n            helper(CREATE_BLOCK);\r\n        }\r\n        // inject branch key\r\n        injectProp(vnodeCall, keyProperty, context);\r\n        return vnodeCall;\r\n    }\r\n}\r\nfunction isSameKey(a, b) {\r\n    if (!a || a.type !== b.type) {\r\n        return false;\r\n    }\r\n    if (a.type === 6 /* ATTRIBUTE */) {\r\n        if (a.value.content !== b.value.content) {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        // directive\r\n        const exp = a.exp;\r\n        const branchExp = b.exp;\r\n        if (exp.type !== branchExp.type) {\r\n            return false;\r\n        }\r\n        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||\r\n            (exp.isStatic !== branchExp.isStatic ||\r\n                exp.content !== branchExp.content)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getParentCondition(node) {\r\n    while (true) {\r\n        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                node = node.alternate;\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n        }\r\n        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {\r\n            node = node.value;\r\n        }\r\n    }\r\n}\n\nconst transformFor = createStructuralDirectiveTransform(\'for\', (node, dir, context) => {\r\n    const { helper } = context;\r\n    return processFor(node, dir, context, forNode => {\r\n        // create the loop render function expression now, and add the\r\n        // iterator on exit after all children have been traversed\r\n        const renderExp = createCallExpression(helper(RENDER_LIST), [\r\n            forNode.source\r\n        ]);\r\n        const keyProp = findProp(node, `key`);\r\n        const keyProperty = keyProp\r\n            ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */\r\n                ? createSimpleExpression(keyProp.value.content, true)\r\n                : keyProp.exp)\r\n            : null;\r\n        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n            forNode.source.constType > 0 /* NOT_CONSTANT */;\r\n        const fragmentFlag = isStableFragment\r\n            ? 64 /* STABLE_FRAGMENT */\r\n            : keyProp\r\n                ? 128 /* KEYED_FRAGMENT */\r\n                : 256 /* UNKEYED_FRAGMENT */;\r\n        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +\r\n            (( false) ? undefined : ``), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, node.loc);\r\n        return () => {\r\n            // finish the codegen now that all children have been traversed\r\n            let childBlock;\r\n            const isTemplate = isTemplateNode(node);\r\n            const { children } = forNode;\r\n            // check <template v-for> key placement\r\n            if (false) {}\r\n            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;\r\n            const slotOutlet = isSlotOutlet(node)\r\n                ? node\r\n                : isTemplate &&\r\n                    node.children.length === 1 &&\r\n                    isSlotOutlet(node.children[0])\r\n                    ? node.children[0] // api-extractor somehow fails to infer this\r\n                    : null;\r\n            if (slotOutlet) {\r\n                // <slot v-for="..."> or <template v-for="..."><slot/></template>\r\n                childBlock = slotOutlet.codegenNode;\r\n                if (isTemplate && keyProperty) {\r\n                    // <template v-for="..." :key="..."><slot/></template>\r\n                    // we need to inject the key to the renderSlot() call.\r\n                    // the props for renderSlot is passed as the 3rd argument.\r\n                    injectProp(childBlock, keyProperty, context);\r\n                }\r\n            }\r\n            else if (needFragmentWrapper) {\r\n                // <template v-for="..."> with text or multi-elements\r\n                // should generate a fragment block for each loop\r\n                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +\r\n                    (( false)\r\n                        ? undefined\r\n                        : ``), undefined, undefined, true);\r\n            }\r\n            else {\r\n                // Normal element v-for. Directly use the child\'s codegenNode\r\n                // but mark it as a block.\r\n                childBlock = children[0]\r\n                    .codegenNode;\r\n                if (isTemplate && keyProperty) {\r\n                    injectProp(childBlock, keyProperty, context);\r\n                }\r\n                childBlock.isBlock = !isStableFragment;\r\n                if (childBlock.isBlock) {\r\n                    helper(OPEN_BLOCK);\r\n                    helper(CREATE_BLOCK);\r\n                }\r\n                else {\r\n                    helper(CREATE_VNODE);\r\n                }\r\n            }\r\n            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));\r\n        };\r\n    });\r\n});\r\n// target-agnostic transform used for both Client and SSR\r\nfunction processFor(node, dir, context, processCodegen) {\r\n    if (!dir.exp) {\r\n        context.onError(createCompilerError(30 /* X_V_FOR_NO_EXPRESSION */, dir.loc));\r\n        return;\r\n    }\r\n    const parseResult = parseForExpression(\r\n    // can only be simple expression because vFor transform is applied\r\n    // before expression transform.\r\n    dir.exp, context);\r\n    if (!parseResult) {\r\n        context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));\r\n        return;\r\n    }\r\n    const { addIdentifiers, removeIdentifiers, scopes } = context;\r\n    const { source, value, key, index } = parseResult;\r\n    const forNode = {\r\n        type: 11 /* FOR */,\r\n        loc: dir.loc,\r\n        source,\r\n        valueAlias: value,\r\n        keyAlias: key,\r\n        objectIndexAlias: index,\r\n        parseResult,\r\n        children: isTemplateNode(node) ? node.children : [node]\r\n    };\r\n    context.replaceNode(forNode);\r\n    // bookkeeping\r\n    scopes.vFor++;\r\n    const onExit = processCodegen && processCodegen(forNode);\r\n    return () => {\r\n        scopes.vFor--;\r\n        if (onExit)\r\n            onExit();\r\n    };\r\n}\r\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\n// This regex doesn\'t cover the case if key or index aliases have destructuring,\r\n// but those do not make sense in the first place, so this works in practice.\r\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\nconst stripParensRE = /^\\(|\\)$/g;\r\nfunction parseForExpression(input, context) {\r\n    const loc = input.loc;\r\n    const exp = input.content;\r\n    const inMatch = exp.match(forAliasRE);\r\n    if (!inMatch)\r\n        return;\r\n    const [, LHS, RHS] = inMatch;\r\n    const result = {\r\n        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\r\n        value: undefined,\r\n        key: undefined,\r\n        index: undefined\r\n    };\r\n    if (false) {}\r\n    let valueContent = LHS.trim()\r\n        .replace(stripParensRE, \'\')\r\n        .trim();\r\n    const trimmedOffset = LHS.indexOf(valueContent);\r\n    const iteratorMatch = valueContent.match(forIteratorRE);\r\n    if (iteratorMatch) {\r\n        valueContent = valueContent.replace(forIteratorRE, \'\').trim();\r\n        const keyContent = iteratorMatch[1].trim();\r\n        let keyOffset;\r\n        if (keyContent) {\r\n            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\r\n            result.key = createAliasExpression(loc, keyContent, keyOffset);\r\n            if (false) {}\r\n        }\r\n        if (iteratorMatch[2]) {\r\n            const indexContent = iteratorMatch[2].trim();\r\n            if (indexContent) {\r\n                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key\r\n                    ? keyOffset + keyContent.length\r\n                    : trimmedOffset + valueContent.length));\r\n                if (false) {}\r\n            }\r\n        }\r\n    }\r\n    if (valueContent) {\r\n        result.value = createAliasExpression(loc, valueContent, trimmedOffset);\r\n        if (false) {}\r\n    }\r\n    return result;\r\n}\r\nfunction createAliasExpression(range, content, offset) {\r\n    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\r\n}\r\nfunction createForLoopParams({ value, key, index }) {\r\n    const params = [];\r\n    if (value) {\r\n        params.push(value);\r\n    }\r\n    if (key) {\r\n        if (!value) {\r\n            params.push(createSimpleExpression(`_`, false));\r\n        }\r\n        params.push(key);\r\n    }\r\n    if (index) {\r\n        if (!key) {\r\n            if (!value) {\r\n                params.push(createSimpleExpression(`_`, false));\r\n            }\r\n            params.push(createSimpleExpression(`__`, false));\r\n        }\r\n        params.push(index);\r\n    }\r\n    return params;\r\n}\n\nconst defaultFallback = createSimpleExpression(`undefined`, false);\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don\'t get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nconst trackSlotScopes = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 1 /* COMPONENT */ ||\r\n            node.tagType === 3 /* TEMPLATE */)) {\r\n        // We are only checking non-empty v-slot here\r\n        // since we only care about slots that introduce scope variables.\r\n        const vSlot = findDir(node, \'slot\');\r\n        if (vSlot) {\r\n            vSlot.exp;\r\n            context.scopes.vSlot++;\r\n            return () => {\r\n                context.scopes.vSlot--;\r\n            };\r\n        }\r\n    }\r\n};\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nconst trackVForSlotScopes = (node, context) => {\r\n    let vFor;\r\n    if (isTemplateNode(node) &&\r\n        node.props.some(isVSlot) &&\r\n        (vFor = findDir(node, \'for\'))) {\r\n        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));\r\n        if (result) {\r\n            const { value, key, index } = result;\r\n            const { addIdentifiers, removeIdentifiers } = context;\r\n            value && addIdentifiers(value);\r\n            key && addIdentifiers(key);\r\n            index && addIdentifiers(index);\r\n            return () => {\r\n                value && removeIdentifiers(value);\r\n                key && removeIdentifiers(key);\r\n                index && removeIdentifiers(index);\r\n            };\r\n        }\r\n    }\r\n};\r\nconst buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nfunction buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\r\n    context.helper(WITH_CTX);\r\n    const { children, loc } = node;\r\n    const slotsProperties = [];\r\n    const dynamicSlots = [];\r\n    const buildDefaultSlotProperty = (props, children) => createObjectProperty(`default`, buildSlotFn(props, children, loc));\r\n    // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n    // since it likely uses a scope variable.\r\n    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\r\n    // 1. Check for slot with slotProps on component itself.\r\n    //    <Comp v-slot="{ prop }"/>\r\n    const onComponentSlot = findDir(node, \'slot\', true);\r\n    if (onComponentSlot) {\r\n        const { arg, exp } = onComponentSlot;\r\n        if (arg && !isStaticExp(arg)) {\r\n            hasDynamicSlots = true;\r\n        }\r\n        slotsProperties.push(createObjectProperty(arg || createSimpleExpression(\'default\', true), buildSlotFn(exp, children, loc)));\r\n    }\r\n    // 2. Iterate through children and check for template slots\r\n    //    <template v-slot:foo="{ prop }">\r\n    let hasTemplateSlots = false;\r\n    let hasNamedDefaultSlot = false;\r\n    const implicitDefaultChildren = [];\r\n    const seenSlotNames = new Set();\r\n    for (let i = 0; i < children.length; i++) {\r\n        const slotElement = children[i];\r\n        let slotDir;\r\n        if (!isTemplateNode(slotElement) ||\r\n            !(slotDir = findDir(slotElement, \'slot\', true))) {\r\n            // not a <template v-slot>, skip.\r\n            if (slotElement.type !== 3 /* COMMENT */) {\r\n                implicitDefaultChildren.push(slotElement);\r\n            }\r\n            continue;\r\n        }\r\n        if (onComponentSlot) {\r\n            // already has on-component slot - this is incorrect usage.\r\n            context.onError(createCompilerError(36 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\r\n            break;\r\n        }\r\n        hasTemplateSlots = true;\r\n        const { children: slotChildren, loc: slotLoc } = slotElement;\r\n        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\r\n        // check if name is dynamic.\r\n        let staticSlotName;\r\n        if (isStaticExp(slotName)) {\r\n            staticSlotName = slotName ? slotName.content : `default`;\r\n        }\r\n        else {\r\n            hasDynamicSlots = true;\r\n        }\r\n        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\r\n        // check if this slot is conditional (v-if/v-for)\r\n        let vIf;\r\n        let vElse;\r\n        let vFor;\r\n        if ((vIf = findDir(slotElement, \'if\'))) {\r\n            hasDynamicSlots = true;\r\n            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));\r\n        }\r\n        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\r\n            // find adjacent v-if\r\n            let j = i;\r\n            let prev;\r\n            while (j--) {\r\n                prev = children[j];\r\n                if (prev.type !== 3 /* COMMENT */) {\r\n                    break;\r\n                }\r\n            }\r\n            if (prev && isTemplateNode(prev) && findDir(prev, \'if\')) {\r\n                // remove node\r\n                children.splice(i, 1);\r\n                i--;\r\n                // attach this slot to previous conditional\r\n                let conditional = dynamicSlots[dynamicSlots.length - 1];\r\n                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                    conditional = conditional.alternate;\r\n                }\r\n                conditional.alternate = vElse.exp\r\n                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)\r\n                    : buildDynamicSlot(slotName, slotFunction);\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\r\n            }\r\n        }\r\n        else if ((vFor = findDir(slotElement, \'for\'))) {\r\n            hasDynamicSlots = true;\r\n            const parseResult = vFor.parseResult ||\r\n                parseForExpression(vFor.exp, context);\r\n            if (parseResult) {\r\n                // Render the dynamic slots as an array and add it to the createSlot()\r\n                // args. The runtime knows how to handle it appropriately.\r\n                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\r\n                    parseResult.source,\r\n                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)\r\n                ]));\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\r\n            }\r\n        }\r\n        else {\r\n            // check duplicate static names\r\n            if (staticSlotName) {\r\n                if (seenSlotNames.has(staticSlotName)) {\r\n                    context.onError(createCompilerError(37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\r\n                    continue;\r\n                }\r\n                seenSlotNames.add(staticSlotName);\r\n                if (staticSlotName === \'default\') {\r\n                    hasNamedDefaultSlot = true;\r\n                }\r\n            }\r\n            slotsProperties.push(createObjectProperty(slotName, slotFunction));\r\n        }\r\n    }\r\n    if (!onComponentSlot) {\r\n        if (!hasTemplateSlots) {\r\n            // implicit default slot (on component)\r\n            slotsProperties.push(buildDefaultSlotProperty(undefined, children));\r\n        }\r\n        else if (implicitDefaultChildren.length) {\r\n            // implicit default slot (mixed with named slots)\r\n            if (hasNamedDefaultSlot) {\r\n                context.onError(createCompilerError(38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\r\n            }\r\n            else {\r\n                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\r\n            }\r\n        }\r\n    }\r\n    const slotFlag = hasDynamicSlots\r\n        ? 2 /* DYNAMIC */\r\n        : hasForwardedSlots(node.children)\r\n            ? 3 /* FORWARDED */\r\n            : 1 /* STABLE */;\r\n    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, \r\n    // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n    // 1 = compiled and static = can skip normalization AND diff as optimized\r\n    createSimpleExpression(slotFlag + (( false) ? undefined : ``), false))), loc);\r\n    if (dynamicSlots.length) {\r\n        slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n            slots,\r\n            createArrayExpression(dynamicSlots)\r\n        ]);\r\n    }\r\n    return {\r\n        slots,\r\n        hasDynamicSlots\r\n    };\r\n}\r\nfunction buildDynamicSlot(name, fn) {\r\n    return createObjectExpression([\r\n        createObjectProperty(`name`, name),\r\n        createObjectProperty(`fn`, fn)\r\n    ]);\r\n}\r\nfunction hasForwardedSlots(children) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (child.type === 1 /* ELEMENT */) {\r\n            if (child.tagType === 2 /* SLOT */ ||\r\n                (child.tagType === 0 /* ELEMENT */ &&\r\n                    hasForwardedSlots(child.children))) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\r\n// import, which should be used instead of a resolveDirective call.\r\nconst directiveImportMap = new WeakMap();\r\n// generate a JavaScript AST for this element\'s codegen\r\nconst transformElement = (node, context) => {\r\n    if (!(node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 0 /* ELEMENT */ ||\r\n            node.tagType === 1 /* COMPONENT */))) {\r\n        return;\r\n    }\r\n    // perform the work on exit, after all child expressions have been\r\n    // processed and merged.\r\n    return function postTransformElement() {\r\n        const { tag, props } = node;\r\n        const isComponent = node.tagType === 1 /* COMPONENT */;\r\n        // The goal of the transform is to create a codegenNode implementing the\r\n        // VNodeCall interface.\r\n        const vnodeTag = isComponent\r\n            ? resolveComponentType(node, context)\r\n            : `"${tag}"`;\r\n        const isDynamicComponent = Object(shared_esm_bundler["v" /* isObject */])(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\r\n        let vnodeProps;\r\n        let vnodeChildren;\r\n        let vnodePatchFlag;\r\n        let patchFlag = 0;\r\n        let vnodeDynamicProps;\r\n        let dynamicPropNames;\r\n        let vnodeDirectives;\r\n        let shouldUseBlock = \r\n        // dynamic component may resolve to plain elements\r\n        isDynamicComponent ||\r\n            vnodeTag === TELEPORT ||\r\n            vnodeTag === SUSPENSE ||\r\n            (!isComponent &&\r\n                // <svg> and <foreignObject> must be forced into blocks so that block\r\n                // updates inside get proper isSVG flag at runtime. (#639, #643)\r\n                // This is technically web-specific, but splitting the logic out of core\r\n                // leads to too much unnecessary complexity.\r\n                (tag === \'svg\' ||\r\n                    tag === \'foreignObject\' ||\r\n                    // #938: elements with dynamic keys should be forced into blocks\r\n                    findProp(node, \'key\', true)));\r\n        // props\r\n        if (props.length > 0) {\r\n            const propsBuildResult = buildProps(node, context);\r\n            vnodeProps = propsBuildResult.props;\r\n            patchFlag = propsBuildResult.patchFlag;\r\n            dynamicPropNames = propsBuildResult.dynamicPropNames;\r\n            const directives = propsBuildResult.directives;\r\n            vnodeDirectives =\r\n                directives && directives.length\r\n                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))\r\n                    : undefined;\r\n        }\r\n        // children\r\n        if (node.children.length > 0) {\r\n            if (vnodeTag === KEEP_ALIVE) {\r\n                // Although a built-in component, we compile KeepAlive with raw children\r\n                // instead of slot functions so that it can be used inside Transition\r\n                // or other Transition-wrapping HOCs.\r\n                // To ensure correct updates with block optimizations, we need to:\r\n                // 1. Force keep-alive into a block. This avoids its children being\r\n                //    collected by a parent block.\r\n                shouldUseBlock = true;\r\n                // 2. Force keep-alive to always be updated, since it uses raw children.\r\n                patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                if (false) {}\r\n            }\r\n            const shouldBuildAsSlots = isComponent &&\r\n                // Teleport is not a real component and has dedicated runtime handling\r\n                vnodeTag !== TELEPORT &&\r\n                // explained above.\r\n                vnodeTag !== KEEP_ALIVE;\r\n            if (shouldBuildAsSlots) {\r\n                const { slots, hasDynamicSlots } = buildSlots(node, context);\r\n                vnodeChildren = slots;\r\n                if (hasDynamicSlots) {\r\n                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n            }\r\n            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\r\n                const child = node.children[0];\r\n                const type = child.type;\r\n                // check for dynamic text children\r\n                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||\r\n                    type === 8 /* COMPOUND_EXPRESSION */;\r\n                if (hasDynamicTextChild &&\r\n                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                    patchFlag |= 1 /* TEXT */;\r\n                }\r\n                // pass directly if the only child is a text node\r\n                // (plain / interpolation / expression)\r\n                if (hasDynamicTextChild || type === 2 /* TEXT */) {\r\n                    vnodeChildren = child;\r\n                }\r\n                else {\r\n                    vnodeChildren = node.children;\r\n                }\r\n            }\r\n            else {\r\n                vnodeChildren = node.children;\r\n            }\r\n        }\r\n        // patchFlag & dynamicPropNames\r\n        if (patchFlag !== 0) {\r\n            if ((false)) {}\r\n            else {\r\n                vnodePatchFlag = String(patchFlag);\r\n            }\r\n            if (dynamicPropNames && dynamicPropNames.length) {\r\n                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\r\n            }\r\n        }\r\n        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, node.loc);\r\n    };\r\n};\r\nfunction resolveComponentType(node, context, ssr = false) {\r\n    const { tag } = node;\r\n    // 1. dynamic component\r\n    const isProp = node.tag === \'component\' ? findProp(node, \'is\') : findDir(node, \'is\');\r\n    if (isProp) {\r\n        const exp = isProp.type === 6 /* ATTRIBUTE */\r\n            ? isProp.value && createSimpleExpression(isProp.value.content, true)\r\n            : isProp.exp;\r\n        if (exp) {\r\n            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n                exp\r\n            ]);\r\n        }\r\n    }\r\n    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\r\n    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\r\n    if (builtIn) {\r\n        // built-ins are simply fallthroughs / have special handling during ssr\r\n        // so we don\'t need to import their runtime equivalents\r\n        if (!ssr)\r\n            context.helper(builtIn);\r\n        return builtIn;\r\n    }\r\n    // 5. user component (resolve)\r\n    context.helper(RESOLVE_COMPONENT);\r\n    context.components.add(tag);\r\n    return toValidAssetId(tag, `component`);\r\n}\r\nfunction buildProps(node, context, props = node.props, ssr = false) {\r\n    const { tag, loc: elementLoc } = node;\r\n    const isComponent = node.tagType === 1 /* COMPONENT */;\r\n    let properties = [];\r\n    const mergeArgs = [];\r\n    const runtimeDirectives = [];\r\n    // patchFlag analysis\r\n    let patchFlag = 0;\r\n    let hasRef = false;\r\n    let hasClassBinding = false;\r\n    let hasStyleBinding = false;\r\n    let hasHydrationEventBinding = false;\r\n    let hasDynamicKeys = false;\r\n    let hasVnodeHook = false;\r\n    const dynamicPropNames = [];\r\n    const analyzePatchFlag = ({ key, value }) => {\r\n        if (isStaticExp(key)) {\r\n            const name = key.content;\r\n            const isEventHandler = Object(shared_esm_bundler["w" /* isOn */])(name);\r\n            if (!isComponent &&\r\n                isEventHandler &&\r\n                // omit the flag for click handlers because hydration gives click\r\n                // dedicated fast path.\r\n                name.toLowerCase() !== \'onclick\' &&\r\n                // omit v-model handlers\r\n                name !== \'onUpdate:modelValue\' &&\r\n                // omit onVnodeXXX hooks\r\n                !Object(shared_esm_bundler["y" /* isReservedProp */])(name)) {\r\n                hasHydrationEventBinding = true;\r\n            }\r\n            if (isEventHandler && Object(shared_esm_bundler["y" /* isReservedProp */])(name)) {\r\n                hasVnodeHook = true;\r\n            }\r\n            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||\r\n                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n                    value.type === 8 /* COMPOUND_EXPRESSION */) &&\r\n                    getConstantType(value, context) > 0)) {\r\n                // skip if the prop is a cached handler or has constant value\r\n                return;\r\n            }\r\n            if (name === \'ref\') {\r\n                hasRef = true;\r\n            }\r\n            else if (name === \'class\' && !isComponent) {\r\n                hasClassBinding = true;\r\n            }\r\n            else if (name === \'style\' && !isComponent) {\r\n                hasStyleBinding = true;\r\n            }\r\n            else if (name !== \'key\' && !dynamicPropNames.includes(name)) {\r\n                dynamicPropNames.push(name);\r\n            }\r\n        }\r\n        else {\r\n            hasDynamicKeys = true;\r\n        }\r\n    };\r\n    for (let i = 0; i < props.length; i++) {\r\n        // static attribute\r\n        const prop = props[i];\r\n        if (prop.type === 6 /* ATTRIBUTE */) {\r\n            const { loc, name, value } = prop;\r\n            let isStatic = true;\r\n            if (name === \'ref\') {\r\n                hasRef = true;\r\n            }\r\n            // skip :is on <component>\r\n            if (name === \'is\' && tag === \'component\') {\r\n                continue;\r\n            }\r\n            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : \'\', isStatic, value ? value.loc : loc)));\r\n        }\r\n        else {\r\n            // directives\r\n            const { name, arg, exp, loc } = prop;\r\n            const isBind = name === \'bind\';\r\n            const isOn = name === \'on\';\r\n            // skip v-slot - it is handled by its dedicated transform.\r\n            if (name === \'slot\') {\r\n                if (!isComponent) {\r\n                    context.onError(createCompilerError(39 /* X_V_SLOT_MISPLACED */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            // skip v-once - it is handled by its dedicated transform.\r\n            if (name === \'once\') {\r\n                continue;\r\n            }\r\n            // skip v-is and :is on <component>\r\n            if (name === \'is\' ||\r\n                (isBind && tag === \'component\' && isBindKey(arg, \'is\'))) {\r\n                continue;\r\n            }\r\n            // skip v-on in SSR compilation\r\n            if (isOn && ssr) {\r\n                continue;\r\n            }\r\n            // special case for v-bind and v-on with no argument\r\n            if (!arg && (isBind || isOn)) {\r\n                hasDynamicKeys = true;\r\n                if (exp) {\r\n                    if (properties.length) {\r\n                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n                        properties = [];\r\n                    }\r\n                    if (isBind) {\r\n                        mergeArgs.push(exp);\r\n                    }\r\n                    else {\r\n                        // v-on="obj" -> toHandlers(obj)\r\n                        mergeArgs.push({\r\n                            type: 14 /* JS_CALL_EXPRESSION */,\r\n                            loc,\r\n                            callee: context.helper(TO_HANDLERS),\r\n                            arguments: [exp]\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    context.onError(createCompilerError(isBind\r\n                        ? 33 /* X_V_BIND_NO_EXPRESSION */\r\n                        : 34 /* X_V_ON_NO_EXPRESSION */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            const directiveTransform = context.directiveTransforms[name];\r\n            if (directiveTransform) {\r\n                // has built-in directive transform.\r\n                const { props, needRuntime } = directiveTransform(prop, node, context);\r\n                !ssr && props.forEach(analyzePatchFlag);\r\n                properties.push(...props);\r\n                if (needRuntime) {\r\n                    runtimeDirectives.push(prop);\r\n                    if (Object(shared_esm_bundler["D" /* isSymbol */])(needRuntime)) {\r\n                        directiveImportMap.set(prop, needRuntime);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // no built-in transform, this is a user custom directive.\r\n                runtimeDirectives.push(prop);\r\n            }\r\n        }\r\n    }\r\n    let propsExpression = undefined;\r\n    // has v-bind="object" or v-on="object", wrap with mergeProps\r\n    if (mergeArgs.length) {\r\n        if (properties.length) {\r\n            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n        }\r\n        if (mergeArgs.length > 1) {\r\n            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\r\n        }\r\n        else {\r\n            // single v-bind with nothing else - no need for a mergeProps call\r\n            propsExpression = mergeArgs[0];\r\n        }\r\n    }\r\n    else if (properties.length) {\r\n        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\r\n    }\r\n    // patchFlag analysis\r\n    if (hasDynamicKeys) {\r\n        patchFlag |= 16 /* FULL_PROPS */;\r\n    }\r\n    else {\r\n        if (hasClassBinding) {\r\n            patchFlag |= 2 /* CLASS */;\r\n        }\r\n        if (hasStyleBinding) {\r\n            patchFlag |= 4 /* STYLE */;\r\n        }\r\n        if (dynamicPropNames.length) {\r\n            patchFlag |= 8 /* PROPS */;\r\n        }\r\n        if (hasHydrationEventBinding) {\r\n            patchFlag |= 32 /* HYDRATE_EVENTS */;\r\n        }\r\n    }\r\n    if ((patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&\r\n        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\r\n        patchFlag |= 512 /* NEED_PATCH */;\r\n    }\r\n    return {\r\n        props: propsExpression,\r\n        directives: runtimeDirectives,\r\n        patchFlag,\r\n        dynamicPropNames\r\n    };\r\n}\r\n// Dedupe props in an object literal.\r\n// Literal duplicated attributes would have been warned during the parse phase,\r\n// however, it\'s possible to encounter duplicated `onXXX` handlers with different\r\n// modifiers. We also need to merge static and dynamic class / style attributes.\r\n// - onXXX handlers / style: merge into array\r\n// - class: merge into single expression with concatenation\r\nfunction dedupeProperties(properties) {\r\n    const knownProps = new Map();\r\n    const deduped = [];\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const prop = properties[i];\r\n        // dynamic keys are always allowed\r\n        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\r\n            deduped.push(prop);\r\n            continue;\r\n        }\r\n        const name = prop.key.content;\r\n        const existing = knownProps.get(name);\r\n        if (existing) {\r\n            if (name === \'style\' || name === \'class\' || name.startsWith(\'on\')) {\r\n                mergeAsArray(existing, prop);\r\n            }\r\n            // unexpected duplicate, should have emitted error during parse\r\n        }\r\n        else {\r\n            knownProps.set(name, prop);\r\n            deduped.push(prop);\r\n        }\r\n    }\r\n    return deduped;\r\n}\r\nfunction mergeAsArray(existing, incoming) {\r\n    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {\r\n        existing.value.elements.push(incoming.value);\r\n    }\r\n    else {\r\n        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\r\n    }\r\n}\r\nfunction buildDirectiveArgs(dir, context) {\r\n    const dirArgs = [];\r\n    const runtime = directiveImportMap.get(dir);\r\n    if (runtime) {\r\n        // built-in directive with runtime\r\n        dirArgs.push(context.helperString(runtime));\r\n    }\r\n    else {\r\n        {\r\n            // inject statement for resolving directive\r\n            context.helper(RESOLVE_DIRECTIVE);\r\n            context.directives.add(dir.name);\r\n            dirArgs.push(toValidAssetId(dir.name, `directive`));\r\n        }\r\n    }\r\n    const { loc } = dir;\r\n    if (dir.exp)\r\n        dirArgs.push(dir.exp);\r\n    if (dir.arg) {\r\n        if (!dir.exp) {\r\n            dirArgs.push(`void 0`);\r\n        }\r\n        dirArgs.push(dir.arg);\r\n    }\r\n    if (Object.keys(dir.modifiers).length) {\r\n        if (!dir.arg) {\r\n            if (!dir.exp) {\r\n                dirArgs.push(`void 0`);\r\n            }\r\n            dirArgs.push(`void 0`);\r\n        }\r\n        const trueExpression = createSimpleExpression(`true`, false, loc);\r\n        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));\r\n    }\r\n    return createArrayExpression(dirArgs, dir.loc);\r\n}\r\nfunction stringifyDynamicPropNames(props) {\r\n    let propsNamesString = `[`;\r\n    for (let i = 0, l = props.length; i < l; i++) {\r\n        propsNamesString += JSON.stringify(props[i]);\r\n        if (i < l - 1)\r\n            propsNamesString += \', \';\r\n    }\r\n    return propsNamesString + `]`;\r\n}\n\n( false)\r\n    ? undefined\r\n    : {};\r\n( false) ? undefined : [];\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \'\'));\r\n});\n\nconst transformSlotOutlet = (node, context) => {\r\n    if (isSlotOutlet(node)) {\r\n        const { children, loc } = node;\r\n        const { slotName, slotProps } = processSlotOutlet(node, context);\r\n        const slotArgs = [\r\n            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\r\n            slotName\r\n        ];\r\n        if (slotProps) {\r\n            slotArgs.push(slotProps);\r\n        }\r\n        if (children.length) {\r\n            if (!slotProps) {\r\n                slotArgs.push(`{}`);\r\n            }\r\n            slotArgs.push(createFunctionExpression([], children, false, false, loc));\r\n        }\r\n        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);\r\n    }\r\n};\r\nfunction processSlotOutlet(node, context) {\r\n    let slotName = `"default"`;\r\n    let slotProps = undefined;\r\n    const nonNameProps = [];\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (p.value) {\r\n                if (p.name === \'name\') {\r\n                    slotName = JSON.stringify(p.value.content);\r\n                }\r\n                else {\r\n                    p.name = camelize(p.name);\r\n                    nonNameProps.push(p);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (p.name === \'bind\' && isBindKey(p.arg, \'name\')) {\r\n                if (p.exp)\r\n                    slotName = p.exp;\r\n            }\r\n            else {\r\n                if (p.name === \'bind\' && p.arg && isStaticExp(p.arg)) {\r\n                    p.arg.content = camelize(p.arg.content);\r\n                }\r\n                nonNameProps.push(p);\r\n            }\r\n        }\r\n    }\r\n    if (nonNameProps.length > 0) {\r\n        const { props, directives } = buildProps(node, context, nonNameProps);\r\n        slotProps = props;\r\n        if (directives.length) {\r\n            context.onError(createCompilerError(35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));\r\n        }\r\n    }\r\n    return {\r\n        slotName,\r\n        slotProps\r\n    };\r\n}\n\nconst fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^\\s*function(?:\\s+[\\w$]+)?\\s*\\(/;\r\nconst transformOn = (dir, node, context, augmentor) => {\r\n    const { loc, modifiers, arg } = dir;\r\n    if (!dir.exp && !modifiers.length) {\r\n        context.onError(createCompilerError(34 /* X_V_ON_NO_EXPRESSION */, loc));\r\n    }\r\n    let eventName;\r\n    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        if (arg.isStatic) {\r\n            const rawName = arg.content;\r\n            // for all event listeners, auto convert it to camelCase. See issue #2249\r\n            eventName = createSimpleExpression(Object(shared_esm_bundler["N" /* toHandlerKey */])(Object(shared_esm_bundler["f" /* camelize */])(rawName)), true, arg.loc);\r\n        }\r\n        else {\r\n            // #2388\r\n            eventName = createCompoundExpression([\r\n                `${context.helperString(TO_HANDLER_KEY)}(`,\r\n                arg,\r\n                `)`\r\n            ]);\r\n        }\r\n    }\r\n    else {\r\n        // already a compound expression.\r\n        eventName = arg;\r\n        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\r\n        eventName.children.push(`)`);\r\n    }\r\n    // handler processing\r\n    let exp = dir.exp;\r\n    if (exp && !exp.content.trim()) {\r\n        exp = undefined;\r\n    }\r\n    let shouldCache = context.cacheHandlers && !exp;\r\n    if (exp) {\r\n        const isMemberExp = isMemberExpression(exp.content);\r\n        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\r\n        const hasMultipleStatements = exp.content.includes(`;`);\r\n        if (false) {}\r\n        if (isInlineStatement || (shouldCache && isMemberExp)) {\r\n            // wrap inline statement in a function expression\r\n            exp = createCompoundExpression([\r\n                `${isInlineStatement\r\n                    ? `$event`\r\n                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\r\n                exp,\r\n                hasMultipleStatements ? `}` : `)`\r\n            ]);\r\n        }\r\n    }\r\n    let ret = {\r\n        props: [\r\n            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))\r\n        ]\r\n    };\r\n    // apply extended compiler augmentor\r\n    if (augmentor) {\r\n        ret = augmentor(ret);\r\n    }\r\n    if (shouldCache) {\r\n        // cache handlers so that it\'s always the same handler being passed down.\r\n        // this avoids unnecessary re-renders when users use inline handlers on\r\n        // components.\r\n        ret.props[0].value = context.cache(ret.props[0].value);\r\n    }\r\n    return ret;\r\n};\n\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\r\n// codegen for the entire props object. This transform here is only for v-bind\r\n// *with* args.\r\nconst transformBind = (dir, node, context) => {\r\n    const { exp, modifiers, loc } = dir;\r\n    const arg = dir.arg;\r\n    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n        arg.children.unshift(`(`);\r\n        arg.children.push(`) || ""`);\r\n    }\r\n    else if (!arg.isStatic) {\r\n        arg.content = `${arg.content} || ""`;\r\n    }\r\n    // .prop is no longer necessary due to new patch behavior\r\n    // .sync is replaced by v-model:arg\r\n    if (modifiers.includes(\'camel\')) {\r\n        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n            if (arg.isStatic) {\r\n                arg.content = Object(shared_esm_bundler["f" /* camelize */])(arg.content);\r\n            }\r\n            else {\r\n                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\r\n            }\r\n        }\r\n        else {\r\n            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\r\n            arg.children.push(`)`);\r\n        }\r\n    }\r\n    if (!exp ||\r\n        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {\r\n        context.onError(createCompilerError(33 /* X_V_BIND_NO_EXPRESSION */, loc));\r\n        return {\r\n            props: [createObjectProperty(arg, createSimpleExpression(\'\', true, loc))]\r\n        };\r\n    }\r\n    return {\r\n        props: [createObjectProperty(arg, exp)]\r\n    };\r\n};\n\n// Merge adjacent text nodes and expressions into a single expression\r\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\r\nconst transformText = (node, context) => {\r\n    if (node.type === 0 /* ROOT */ ||\r\n        node.type === 1 /* ELEMENT */ ||\r\n        node.type === 11 /* FOR */ ||\r\n        node.type === 10 /* IF_BRANCH */) {\r\n        // perform the transform on node exit so that all expressions have already\r\n        // been processed.\r\n        return () => {\r\n            const children = node.children;\r\n            let currentContainer = undefined;\r\n            let hasText = false;\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (isText(child)) {\r\n                    hasText = true;\r\n                    for (let j = i + 1; j < children.length; j++) {\r\n                        const next = children[j];\r\n                        if (isText(next)) {\r\n                            if (!currentContainer) {\r\n                                currentContainer = children[i] = {\r\n                                    type: 8 /* COMPOUND_EXPRESSION */,\r\n                                    loc: child.loc,\r\n                                    children: [child]\r\n                                };\r\n                            }\r\n                            // merge adjacent text node into current\r\n                            currentContainer.children.push(` + `, next);\r\n                            children.splice(j, 1);\r\n                            j--;\r\n                        }\r\n                        else {\r\n                            currentContainer = undefined;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!hasText ||\r\n                // if this is a plain element with a single text child, leave it\r\n                // as-is since the runtime has dedicated fast path for this by directly\r\n                // setting textContent of the element.\r\n                // for component root it\'s always normalized anyway.\r\n                (children.length === 1 &&\r\n                    (node.type === 0 /* ROOT */ ||\r\n                        (node.type === 1 /* ELEMENT */ &&\r\n                            node.tagType === 0 /* ELEMENT */)))) {\r\n                return;\r\n            }\r\n            // pre-convert text nodes into createTextVNode(text) calls to avoid\r\n            // runtime normalization.\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {\r\n                    const callArgs = [];\r\n                    // createTextVNode defaults to single whitespace, so if it is a\r\n                    // single space the code could be an empty call to save bytes.\r\n                    if (child.type !== 2 /* TEXT */ || child.content !== \' \') {\r\n                        callArgs.push(child);\r\n                    }\r\n                    // mark dynamic text with flag so it gets patched inside a block\r\n                    if (!context.ssr &&\r\n                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                        callArgs.push(1 /* TEXT */ +\r\n                            (( false) ? undefined : ``));\r\n                    }\r\n                    children[i] = {\r\n                        type: 12 /* TEXT_CALL */,\r\n                        content: child,\r\n                        loc: child.loc,\r\n                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)\r\n                    };\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\n\nconst compiler_core_esm_bundler_seen = new WeakSet();\r\nconst transformOnce = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ && findDir(node, \'once\', true)) {\r\n        if (compiler_core_esm_bundler_seen.has(node)) {\r\n            return;\r\n        }\r\n        compiler_core_esm_bundler_seen.add(node);\r\n        context.helper(SET_BLOCK_TRACKING);\r\n        return () => {\r\n            const cur = context.currentNode;\r\n            if (cur.codegenNode) {\r\n                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);\r\n            }\r\n        };\r\n    }\r\n};\n\nconst transformModel = (dir, node, context) => {\r\n    const { exp, arg } = dir;\r\n    if (!exp) {\r\n        context.onError(createCompilerError(40 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));\r\n        return createTransformProps();\r\n    }\r\n    const rawExp = exp.loc.source;\r\n    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;\r\n    // im SFC <script setup> inline mode, the exp may have been transformed into\r\n    // _unref(exp)\r\n    context.bindingMetadata[rawExp];\r\n    const maybeRef = !true    /* SETUP_CONST */;\r\n    if (!isMemberExpression(expString) && !maybeRef) {\r\n        context.onError(createCompilerError(41 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));\r\n        return createTransformProps();\r\n    }\r\n    const propName = arg ? arg : createSimpleExpression(\'modelValue\', true);\r\n    const eventName = arg\r\n        ? isStaticExp(arg)\r\n            ? `onUpdate:${arg.content}`\r\n            : createCompoundExpression([\'"onUpdate:" + \', arg])\r\n        : `onUpdate:modelValue`;\r\n    let assignmentExp;\r\n    const eventArg = context.isTS ? `($event: any)` : `$event`;\r\n    {\r\n        assignmentExp = createCompoundExpression([\r\n            `${eventArg} => (`,\r\n            exp,\r\n            ` = $event)`\r\n        ]);\r\n    }\r\n    const props = [\r\n        // modelValue: foo\r\n        createObjectProperty(propName, dir.exp),\r\n        // "onUpdate:modelValue": $event => (foo = $event)\r\n        createObjectProperty(eventName, assignmentExp)\r\n    ];\r\n    // modelModifiers: { foo: true, "bar-baz": true }\r\n    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {\r\n        const modifiers = dir.modifiers\r\n            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\r\n            .join(`, `);\r\n        const modifiersKey = arg\r\n            ? isStaticExp(arg)\r\n                ? `${arg.content}Modifiers`\r\n                : createCompoundExpression([arg, \' + "Modifiers"\'])\r\n            : `modelModifiers`;\r\n        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));\r\n    }\r\n    return createTransformProps(props);\r\n};\r\nfunction createTransformProps(props = []) {\r\n    return { props };\r\n}\n\nfunction getBaseTransformPreset(prefixIdentifiers) {\r\n    return [\r\n        [\r\n            transformOnce,\r\n            transformIf,\r\n            transformFor,\r\n            ...(( false)\r\n                    ? undefined\r\n                    : []),\r\n            transformSlotOutlet,\r\n            transformElement,\r\n            trackSlotScopes,\r\n            transformText\r\n        ],\r\n        {\r\n            on: transformOn,\r\n            bind: transformBind,\r\n            model: transformModel\r\n        }\r\n    ];\r\n}\r\n// we name it `baseCompile` so that higher order compilers like\r\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\r\nfunction baseCompile(template, options = {}) {\r\n    const onError = options.onError || defaultOnError;\r\n    const isModuleMode = options.mode === \'module\';\r\n    /* istanbul ignore if */\r\n    {\r\n        if (options.prefixIdentifiers === true) {\r\n            onError(createCompilerError(45 /* X_PREFIX_ID_NOT_SUPPORTED */));\r\n        }\r\n        else if (isModuleMode) {\r\n            onError(createCompilerError(46 /* X_MODULE_MODE_NOT_SUPPORTED */));\r\n        }\r\n    }\r\n    const prefixIdentifiers = !true ;\r\n    if (options.cacheHandlers) {\r\n        onError(createCompilerError(47 /* X_CACHE_HANDLER_NOT_SUPPORTED */));\r\n    }\r\n    if (options.scopeId && !isModuleMode) {\r\n        onError(createCompilerError(48 /* X_SCOPE_ID_NOT_SUPPORTED */));\r\n    }\r\n    const ast = Object(shared_esm_bundler["C" /* isString */])(template) ? baseParse(template, options) : template;\r\n    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\r\n    transform(ast, Object(shared_esm_bundler["i" /* extend */])({}, options, {\r\n        prefixIdentifiers,\r\n        nodeTransforms: [\r\n            ...nodeTransforms,\r\n            ...(options.nodeTransforms || []) // user transforms\r\n        ],\r\n        directiveTransforms: Object(shared_esm_bundler["i" /* extend */])({}, directiveTransforms, options.directiveTransforms || {} // user transforms\r\n        )\r\n    }));\r\n    return generate(ast, Object(shared_esm_bundler["i" /* extend */])({}, options, {\r\n        prefixIdentifiers\r\n    }));\r\n}\n\nconst noopDirectiveTransform = () => ({ props: [] });\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js\n\n\n\n\nconst V_MODEL_RADIO = Symbol(( false) ? undefined : ``);\r\nconst V_MODEL_CHECKBOX = Symbol(( false) ? undefined : ``);\r\nconst V_MODEL_TEXT = Symbol(( false) ? undefined : ``);\r\nconst V_MODEL_SELECT = Symbol(( false) ? undefined : ``);\r\nconst V_MODEL_DYNAMIC = Symbol(( false) ? undefined : ``);\r\nconst V_ON_WITH_MODIFIERS = Symbol(( false) ? undefined : ``);\r\nconst V_ON_WITH_KEYS = Symbol(( false) ? undefined : ``);\r\nconst V_SHOW = Symbol(( false) ? undefined : ``);\r\nconst compiler_dom_esm_bundler_TRANSITION = Symbol(( false) ? undefined : ``);\r\nconst TRANSITION_GROUP = Symbol(( false) ? undefined : ``);\r\nregisterRuntimeHelpers({\r\n    [V_MODEL_RADIO]: `vModelRadio`,\r\n    [V_MODEL_CHECKBOX]: `vModelCheckbox`,\r\n    [V_MODEL_TEXT]: `vModelText`,\r\n    [V_MODEL_SELECT]: `vModelSelect`,\r\n    [V_MODEL_DYNAMIC]: `vModelDynamic`,\r\n    [V_ON_WITH_MODIFIERS]: `withModifiers`,\r\n    [V_ON_WITH_KEYS]: `withKeys`,\r\n    [V_SHOW]: `vShow`,\r\n    [compiler_dom_esm_bundler_TRANSITION]: `Transition`,\r\n    [TRANSITION_GROUP]: `TransitionGroup`\r\n});\n\n/* eslint-disable no-restricted-globals */\r\nlet decoder;\r\nfunction decodeHtmlBrowser(raw) {\r\n    (decoder || (decoder = document.createElement(\'div\'))).innerHTML = raw;\r\n    return decoder.textContent;\r\n}\n\nconst isRawTextContainer = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'style,iframe,script,noscript\', true);\r\nconst parserOptions = {\r\n    isVoidTag: shared_esm_bundler["E" /* isVoidTag */],\r\n    isNativeTag: tag => Object(shared_esm_bundler["r" /* isHTMLTag */])(tag) || Object(shared_esm_bundler["z" /* isSVGTag */])(tag),\r\n    isPreTag: tag => tag === \'pre\',\r\n    decodeEntities: decodeHtmlBrowser ,\r\n    isBuiltInComponent: (tag) => {\r\n        if (isBuiltInType(tag, `Transition`)) {\r\n            return compiler_dom_esm_bundler_TRANSITION;\r\n        }\r\n        else if (isBuiltInType(tag, `TransitionGroup`)) {\r\n            return TRANSITION_GROUP;\r\n        }\r\n    },\r\n    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\r\n    getNamespace(tag, parent) {\r\n        let ns = parent ? parent.ns : 0 /* HTML */;\r\n        if (parent && ns === 2 /* MATH_ML */) {\r\n            if (parent.tag === \'annotation-xml\') {\r\n                if (tag === \'svg\') {\r\n                    return 1 /* SVG */;\r\n                }\r\n                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&\r\n                    a.name === \'encoding\' &&\r\n                    a.value != null &&\r\n                    (a.value.content === \'text/html\' ||\r\n                        a.value.content === \'application/xhtml+xml\'))) {\r\n                    ns = 0 /* HTML */;\r\n                }\r\n            }\r\n            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&\r\n                tag !== \'mglyph\' &&\r\n                tag !== \'malignmark\') {\r\n                ns = 0 /* HTML */;\r\n            }\r\n        }\r\n        else if (parent && ns === 1 /* SVG */) {\r\n            if (parent.tag === \'foreignObject\' ||\r\n                parent.tag === \'desc\' ||\r\n                parent.tag === \'title\') {\r\n                ns = 0 /* HTML */;\r\n            }\r\n        }\r\n        if (ns === 0 /* HTML */) {\r\n            if (tag === \'svg\') {\r\n                return 1 /* SVG */;\r\n            }\r\n            if (tag === \'math\') {\r\n                return 2 /* MATH_ML */;\r\n            }\r\n        }\r\n        return ns;\r\n    },\r\n    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\r\n    getTextMode({ tag, ns }) {\r\n        if (ns === 0 /* HTML */) {\r\n            if (tag === \'textarea\' || tag === \'title\') {\r\n                return 1 /* RCDATA */;\r\n            }\r\n            if (isRawTextContainer(tag)) {\r\n                return 2 /* RAWTEXT */;\r\n            }\r\n        }\r\n        return 0 /* DATA */;\r\n    }\r\n};\n\n// Parse inline CSS strings for static style attributes into an object.\r\n// This is a NodeTransform since it works on the static `style` attribute and\r\n// converts it into a dynamic equivalent:\r\n// style="color: red" -> :style=\'{ "color": "red" }\'\r\n// It is then processed by `transformElement` and included in the generated\r\n// props.\r\nconst transformStyle = node => {\r\n    if (node.type === 1 /* ELEMENT */) {\r\n        node.props.forEach((p, i) => {\r\n            if (p.type === 6 /* ATTRIBUTE */ && p.name === \'style\' && p.value) {\r\n                // replace p with an expression node\r\n                node.props[i] = {\r\n                    type: 7 /* DIRECTIVE */,\r\n                    name: `bind`,\r\n                    arg: createSimpleExpression(`style`, true, p.loc),\r\n                    exp: parseInlineCSS(p.value.content, p.loc),\r\n                    modifiers: [],\r\n                    loc: p.loc\r\n                };\r\n            }\r\n        });\r\n    }\r\n};\r\nconst parseInlineCSS = (cssText, loc) => {\r\n    const normalized = Object(shared_esm_bundler["K" /* parseStringStyle */])(cssText);\r\n    return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);\r\n};\n\nfunction createDOMCompilerError(code, loc) {\r\n    return createCompilerError(code, loc,  false ? undefined : undefined);\r\n}\r\nconst DOMErrorMessages = {\r\n    [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\r\n    [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\r\n    [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\r\n    [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\r\n    [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\r\n    [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\r\n    [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\r\n    [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model\'s behavior.`,\r\n    [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\r\n    [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\r\n    [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\r\n};\n\nconst transformVHtml = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(49 /* X_V_HTML_NO_EXPRESSION */, loc));\r\n    }\r\n    if (node.children.length) {\r\n        context.onError(createDOMCompilerError(50 /* X_V_HTML_WITH_CHILDREN */, loc));\r\n        node.children.length = 0;\r\n    }\r\n    return {\r\n        props: [\r\n            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression(\'\', true))\r\n        ]\r\n    };\r\n};\n\nconst transformVText = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(51 /* X_V_TEXT_NO_EXPRESSION */, loc));\r\n    }\r\n    if (node.children.length) {\r\n        context.onError(createDOMCompilerError(52 /* X_V_TEXT_WITH_CHILDREN */, loc));\r\n        node.children.length = 0;\r\n    }\r\n    return {\r\n        props: [\r\n            createObjectProperty(createSimpleExpression(`textContent`, true), exp\r\n                ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)\r\n                : createSimpleExpression(\'\', true))\r\n        ]\r\n    };\r\n};\n\nconst compiler_dom_esm_bundler_transformModel = (dir, node, context) => {\r\n    const baseResult = transformModel(dir, node, context);\r\n    // base transform has errors OR component v-model (only need props)\r\n    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {\r\n        return baseResult;\r\n    }\r\n    if (dir.arg) {\r\n        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\r\n    }\r\n    function checkDuplicatedValue() {\r\n        const value = findProp(node, \'value\');\r\n        if (value) {\r\n            context.onError(createDOMCompilerError(56 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\r\n        }\r\n    }\r\n    const { tag } = node;\r\n    const isCustomElement = context.isCustomElement(tag);\r\n    if (tag === \'input\' ||\r\n        tag === \'textarea\' ||\r\n        tag === \'select\' ||\r\n        isCustomElement) {\r\n        let directiveToUse = V_MODEL_TEXT;\r\n        let isInvalidType = false;\r\n        if (tag === \'input\' || isCustomElement) {\r\n            const type = findProp(node, `type`);\r\n            if (type) {\r\n                if (type.type === 7 /* DIRECTIVE */) {\r\n                    // :type="foo"\r\n                    directiveToUse = V_MODEL_DYNAMIC;\r\n                }\r\n                else if (type.value) {\r\n                    switch (type.value.content) {\r\n                        case \'radio\':\r\n                            directiveToUse = V_MODEL_RADIO;\r\n                            break;\r\n                        case \'checkbox\':\r\n                            directiveToUse = V_MODEL_CHECKBOX;\r\n                            break;\r\n                        case \'file\':\r\n                            isInvalidType = true;\r\n                            context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\r\n                            break;\r\n                        default:\r\n                            // text type\r\n                            ( false) && false;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            else if (hasDynamicKeyVBind(node)) {\r\n                // element has bindings with dynamic keys, which can possibly contain\r\n                // "type".\r\n                directiveToUse = V_MODEL_DYNAMIC;\r\n            }\r\n            else {\r\n                // text type\r\n                ( false) && false;\r\n            }\r\n        }\r\n        else if (tag === \'select\') {\r\n            directiveToUse = V_MODEL_SELECT;\r\n        }\r\n        else {\r\n            // textarea\r\n            ( false) && false;\r\n        }\r\n        // inject runtime directive\r\n        // by returning the helper symbol via needRuntime\r\n        // the import will replaced a resolveDirective call.\r\n        if (!isInvalidType) {\r\n            baseResult.needRuntime = context.helper(directiveToUse);\r\n        }\r\n    }\r\n    else {\r\n        context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\r\n    }\r\n    // native vmodel doesn\'t need the `modelValue` props since they are also\r\n    // passed to the runtime as `binding.value`. removing it reduces code size.\r\n    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n        p.key.content === \'modelValue\'));\r\n    return baseResult;\r\n};\n\nconst isEventOptionModifier = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(`passive,once,capture`);\r\nconst isNonKeyModifier = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\r\n// event propagation management\r\n`stop,prevent,self,` +\r\n    // system modifiers + exact\r\n    `ctrl,shift,alt,meta,exact,` +\r\n    // mouse\r\n    `middle`);\r\n// left & right could be mouse or key modifiers based on event type\r\nconst maybeKeyModifier = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(\'left,right\');\r\nconst isKeyboardEvent = /*#__PURE__*/ Object(shared_esm_bundler["H" /* makeMap */])(`onkeyup,onkeydown,onkeypress`, true);\r\nconst resolveModifiers = (key, modifiers) => {\r\n    const keyModifiers = [];\r\n    const nonKeyModifiers = [];\r\n    const eventOptionModifiers = [];\r\n    for (let i = 0; i < modifiers.length; i++) {\r\n        const modifier = modifiers[i];\r\n        if (isEventOptionModifier(modifier)) {\r\n            // eventOptionModifiers: modifiers for addEventListener() options,\r\n            // e.g. .passive & .capture\r\n            eventOptionModifiers.push(modifier);\r\n        }\r\n        else {\r\n            // runtimeModifiers: modifiers that needs runtime guards\r\n            if (maybeKeyModifier(modifier)) {\r\n                if (isStaticExp(key)) {\r\n                    if (isKeyboardEvent(key.content)) {\r\n                        keyModifiers.push(modifier);\r\n                    }\r\n                    else {\r\n                        nonKeyModifiers.push(modifier);\r\n                    }\r\n                }\r\n                else {\r\n                    keyModifiers.push(modifier);\r\n                    nonKeyModifiers.push(modifier);\r\n                }\r\n            }\r\n            else {\r\n                if (isNonKeyModifier(modifier)) {\r\n                    nonKeyModifiers.push(modifier);\r\n                }\r\n                else {\r\n                    keyModifiers.push(modifier);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        keyModifiers,\r\n        nonKeyModifiers,\r\n        eventOptionModifiers\r\n    };\r\n};\r\nconst transformClick = (key, event) => {\r\n    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === \'onclick\';\r\n    return isStaticClick\r\n        ? createSimpleExpression(event, true)\r\n        : key.type !== 4 /* SIMPLE_EXPRESSION */\r\n            ? createCompoundExpression([\r\n                `(`,\r\n                key,\r\n                `) === "onClick" ? "${event}" : (`,\r\n                key,\r\n                `)`\r\n            ])\r\n            : key;\r\n};\r\nconst compiler_dom_esm_bundler_transformOn = (dir, node, context) => {\r\n    return transformOn(dir, node, context, baseResult => {\r\n        const { modifiers } = dir;\r\n        if (!modifiers.length)\r\n            return baseResult;\r\n        let { key, value: handlerExp } = baseResult.props[0];\r\n        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers);\r\n        // normalize click.right and click.middle since they don\'t actually fire\r\n        if (nonKeyModifiers.includes(\'right\')) {\r\n            key = transformClick(key, `onContextmenu`);\r\n        }\r\n        if (nonKeyModifiers.includes(\'middle\')) {\r\n            key = transformClick(key, `onMouseup`);\r\n        }\r\n        if (nonKeyModifiers.length) {\r\n            handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\r\n                handlerExp,\r\n                JSON.stringify(nonKeyModifiers)\r\n            ]);\r\n        }\r\n        if (keyModifiers.length &&\r\n            // if event name is dynamic, always wrap with keys guard\r\n            (!isStaticExp(key) || isKeyboardEvent(key.content))) {\r\n            handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\r\n                handlerExp,\r\n                JSON.stringify(keyModifiers)\r\n            ]);\r\n        }\r\n        if (eventOptionModifiers.length) {\r\n            const modifierPostfix = eventOptionModifiers.map(shared_esm_bundler["g" /* capitalize */]).join(\'\');\r\n            key = isStaticExp(key)\r\n                ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\r\n                : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);\r\n        }\r\n        return {\r\n            props: [createObjectProperty(key, handlerExp)]\r\n        };\r\n    });\r\n};\n\nconst transformShow = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */, loc));\r\n    }\r\n    return {\r\n        props: [],\r\n        needRuntime: context.helper(V_SHOW)\r\n    };\r\n};\n\nconst warnTransitionChildren = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        node.tagType === 1 /* COMPONENT */) {\r\n        const component = context.isBuiltInComponent(node.tag);\r\n        if (component === compiler_dom_esm_bundler_TRANSITION) {\r\n            return () => {\r\n                if (node.children.length && hasMultipleChildren(node)) {\r\n                    context.onError(createDOMCompilerError(58 /* X_TRANSITION_INVALID_CHILDREN */, {\r\n                        start: node.children[0].loc.start,\r\n                        end: node.children[node.children.length - 1].loc.end,\r\n                        source: \'\'\r\n                    }));\r\n                }\r\n            };\r\n        }\r\n    }\r\n};\r\nfunction hasMultipleChildren(node) {\r\n    // #1352 filter out potential comment nodes.\r\n    const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */));\r\n    const child = children[0];\r\n    return (children.length !== 1 ||\r\n        child.type === 11 /* FOR */ ||\r\n        (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));\r\n}\n\nconst ignoreSideEffectTags = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        node.tagType === 0 /* ELEMENT */ &&\r\n        (node.tag === \'script\' || node.tag === \'style\')) {\r\n        context.onError(createDOMCompilerError(59 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\r\n        context.removeNode();\r\n    }\r\n};\n\nconst DOMNodeTransforms = [\r\n    transformStyle,\r\n    ...(( false) ? undefined : [])\r\n];\r\nconst DOMDirectiveTransforms = {\r\n    cloak: noopDirectiveTransform,\r\n    html: transformVHtml,\r\n    text: transformVText,\r\n    model: compiler_dom_esm_bundler_transformModel,\r\n    on: compiler_dom_esm_bundler_transformOn,\r\n    show: transformShow\r\n};\r\nfunction compiler_dom_esm_bundler_compile(template, options = {}) {\r\n    return baseCompile(template, Object(shared_esm_bundler["i" /* extend */])({}, parserOptions, options, {\r\n        nodeTransforms: [\r\n            // ignore <script> and <tag>\r\n            // this is not put inside DOMNodeTransforms because that list is used\r\n            // by compiler-ssr to generate vnode fallback branches\r\n            ignoreSideEffectTags,\r\n            ...DOMNodeTransforms,\r\n            ...(options.nodeTransforms || [])\r\n        ],\r\n        directiveTransforms: Object(shared_esm_bundler["i" /* extend */])({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\r\n        transformHoist: null \r\n    }));\r\n}\r\nfunction parse(template, options = {}) {\r\n    return baseParse(template, Object(shared_esm_bundler["i" /* extend */])({}, parserOptions, options));\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/vue/dist/vue.esm-bundler.js\n\n\n\n\n\n\nfunction initDev() {\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry is the "full-build" that includes both the runtime\r\nif ((false)) {}\r\nconst compileCache = Object.create(null);\r\nfunction compileToFunction(template, options) {\r\n    if (!Object(shared_esm_bundler["C" /* isString */])(template)) {\r\n        if (template.nodeType) {\r\n            template = template.innerHTML;\r\n        }\r\n        else {\r\n            ( false) && false;\r\n            return shared_esm_bundler["d" /* NOOP */];\r\n        }\r\n    }\r\n    const key = template;\r\n    const cached = compileCache[key];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    if (template[0] === \'#\') {\r\n        const el = document.querySelector(template);\r\n        if (false) {}\r\n        // __UNSAFE__\r\n        // Reason: potential execution of JS expressions in in-DOM template.\r\n        // The user must make sure the in-DOM template is trusted. If it\'s rendered\r\n        // by the server, the template should not contain any user data.\r\n        template = el ? el.innerHTML : ``;\r\n    }\r\n    const { code } = compiler_dom_esm_bundler_compile(template, Object(shared_esm_bundler["i" /* extend */])({\r\n        hoistStatic: true,\r\n        onError(err) {\r\n            if ((false)) {}\r\n            else {\r\n                /* istanbul ignore next */\r\n                throw err;\r\n            }\r\n        }\r\n    }, options));\r\n    // The wildcard import results in a huge object with every export\r\n    // with keys that cannot be mangled, and can be quite heavy size-wise.\r\n    // In the global build we know `Vue` is available globally so we can avoid\r\n    // the wildcard object.\r\n    const render = (new Function(\'Vue\', code)(runtime_dom_esm_bundler_namespaceObject));\r\n    render._rc = true;\r\n    return (compileCache[key] = render);\r\n}\r\nregisterRuntimeCompiler(compileToFunction);\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcz9hMWU5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcz81YzQwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanM/ODMwZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL2Rpc3QvY29tcGlsZXItY29yZS5lc20tYnVuZGxlci5qcz8yYmVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWRvbS9kaXN0L2NvbXBpbGVyLWRvbS5lc20tYnVuZGxlci5qcz9lZTUxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanM/ZjJiZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNks7O0FBRTdLO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFxQyxJQUFJLFNBQVM7QUFDOUUsb0NBQW9DLE1BQXFDLElBQUksU0FBaUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBTSxlQUFlLHVDQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhCQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOE1BQThNO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsK0NBQVM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBTztBQUNuQiwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQXdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw2Q0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFDQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFxQyxJQUFJLFNBQWdCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0Esb0JBQW9CLDhDQUFRLFdBQVcsOENBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDLEdBQUcsRUFBQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1Qix1QkFBdUIsdUJBQXVCO0FBQzlDLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxvSUFBb0ksOENBQThDLGtDQUFJLG9CQUFvQixrQ0FBSSwwRkFBMEYsdUNBQVMsMERBQTBEO0FBQ2xaO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnREFBVSxDQUFDLDhDQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNELFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDLEdBQUcsRUFPNUM7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLGdCQUFnQixLQUEwRCxFQUFFLEVBRS9EO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBMkQsRUFBRSxFQUVoRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrRUFBa0Usc0JBQXNCO0FBQ3hGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBYztBQUMxQztBQUNBO0FBQ0EsWUFBWSxLQUM2RCxFQUFFLEVBR2xFO0FBQ1QsOEdBQThHLE1BQXFDLElBQUksU0FBeUI7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0EsWUFBWSw4Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLDBOQUEwTjtBQUM5UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5RUFBeUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLEdBQUcsVUFBVSxHQUFHO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixHQUFHO0FBQzVCLDZCQUE2QixpQkFBaUIsS0FBSyxpQkFBaUI7QUFDcEUsNEJBQTRCLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QyxvQkFBb0Isa0JBQWtCLE9BQU8sRUFBRTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhFQUE4RTtBQUN6RjtBQUNBLGtDQUFrQyxpQkFBaUIsS0FBSyxpQkFBaUI7QUFDekU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsR0FBRyxjQUFjLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLHNCQUFzQix5QkFBeUIsS0FBSyxTQUFTLEdBQUcsbUJBQW1CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQXFDLE1BQU0sS0FBMkM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0EsWUFBWSw4Q0FBUTtBQUNwQjtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOENBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQXFDO0FBQ2xELGdCQUFnQixLQUMwQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDLEdBQUcsRUFLNUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0EsWUFBWSw4Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQyxHQUFHLEVBTTVDO0FBQ0w7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsc0ZBQXNGO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQixHQUFHLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsbUJBQW1CLDhDQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxXQUFXLGFBQWE7QUFDeEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQztBQUNoRCxZQUFZLEtBQWdFO0FBQzVFLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQyxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0NBQXdDO0FBQ25ELFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0EsUUFBUSw2Q0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9EQUFvRDtBQUMvRCxXQUFXLGtDQUFrQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQTBDO0FBQ3JELG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxHQUFHO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSTtBQUN0Qix3QkFBd0IsZUFBZSxJQUFJLE9BQU8sUUFBUSxJQUFJLEdBQUc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZ0JBQWdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDLEdBQUcsRUFHNUM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBMEQsRUFBRSxFQUUvRDtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQXdFLGdCQUFnQixFQUkzRjtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQTBELEVBQUUsRUFFL0Q7QUFDakI7QUFDQSxvQkFBb0IsS0FBZ0QsRUFBRSxFQVNyRDtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQXFDLElBQUksU0FBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLDhFQUE4RSxTQUFTO0FBQ3ZGLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQXFDO0FBQ3ZELHNCQUFzQixTQUFvRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQXFDLElBQUksU0FBd0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBLGdCQUFnQixLQUFnRSxFQUFFLEVBVXJFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBcUM7QUFDM0QsMEJBQTBCLFNBQW9EO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDO0FBQ3ZELFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUErQyxFQUFFLEVBRXBEO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQStDLEVBQUUsRUFFcEQ7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUErQyxFQUFFLEVBRXBEO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQStDLEVBQUUsRUFFcEQ7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLG1CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1Q0FBdUM7QUFDdEQsZUFBZSx1RkFBdUY7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFxQyxJQUFJLFNBQW1DO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEIsbUNBQW1DLDhDQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFtRSxFQUFFLEVBTXhFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBcUMsR0FBRyxFQWM1QztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0EsbUNBQW1DLDBDQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQWM7QUFDL0I7QUFDQTtBQUNBLGtDQUFrQyxvREFBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFN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Q0w7QUFDQSxxQ0FBcUM7QUFDckMsV0FBVyxTQUFTLFdBQVcsNENBQU0sR0FBRztBQUN4Qzs7QUFFdVI7OztBQy9ieE87QUFDdUM7QUFDckQ7QUFDVztBQUM0Qjs7QUFFeEU7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLEtBQXFDLEdBQUcsRUFFNUM7QUFDRDtBQUNBO0FBQ0EsU0FBUyw4Q0FBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBcUMsS0FBSyxLQUEyQztBQUNsRyxtQkFBbUIsa0NBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUE4QyxFQUFFLEVBRW5EO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLEdBQUcsZ0NBQU8sV0FBVyw0Q0FBTTtBQUM3QztBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDLEdBQUcsRUFLNUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFaUIiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVNUFRZX09CSiwgaXNBcnJheSwgaXNNYXAsIGlzSW50ZWdlcktleSwgaXNTeW1ib2wsIGV4dGVuZCwgaGFzT3duLCBpc09iamVjdCwgaGFzQ2hhbmdlZCwgbWFrZU1hcCwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBkZWYsIGlzRnVuY3Rpb24sIE5PT1AgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHRhcmdldE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IGVmZmVjdFN0YWNrID0gW107XHJcbmxldCBhY3RpdmVFZmZlY3Q7XHJcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdpdGVyYXRlJyA6ICcnKTtcclxuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnTWFwIGtleSBpdGVyYXRlJyA6ICcnKTtcclxuZnVuY3Rpb24gaXNFZmZlY3QoZm4pIHtcclxuICAgIHJldHVybiBmbiAmJiBmbi5faXNFZmZlY3QgPT09IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XHJcbiAgICBpZiAoaXNFZmZlY3QoZm4pKSB7XHJcbiAgICAgICAgZm4gPSBmbi5yYXc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlZmZlY3QgPSBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucyk7XHJcbiAgICBpZiAoIW9wdGlvbnMubGF6eSkge1xyXG4gICAgICAgIGVmZmVjdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVmZmVjdDtcclxufVxyXG5mdW5jdGlvbiBzdG9wKGVmZmVjdCkge1xyXG4gICAgaWYgKGVmZmVjdC5hY3RpdmUpIHtcclxuICAgICAgICBjbGVhbnVwKGVmZmVjdCk7XHJcbiAgICAgICAgaWYgKGVmZmVjdC5vcHRpb25zLm9uU3RvcCkge1xyXG4gICAgICAgICAgICBlZmZlY3Qub3B0aW9ucy5vblN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWZmZWN0LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmxldCB1aWQgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgZWZmZWN0ID0gZnVuY3Rpb24gcmVhY3RpdmVFZmZlY3QoKSB7XHJcbiAgICAgICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnNjaGVkdWxlciA/IHVuZGVmaW5lZCA6IGZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZWZmZWN0U3RhY2suaW5jbHVkZXMoZWZmZWN0KSkge1xyXG4gICAgICAgICAgICBjbGVhbnVwKGVmZmVjdCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0U3RhY2sucHVzaChlZmZlY3QpO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdFN0YWNrW2VmZmVjdFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGVmZmVjdC5pZCA9IHVpZCsrO1xyXG4gICAgZWZmZWN0LmFsbG93UmVjdXJzZSA9ICEhb3B0aW9ucy5hbGxvd1JlY3Vyc2U7XHJcbiAgICBlZmZlY3QuX2lzRWZmZWN0ID0gdHJ1ZTtcclxuICAgIGVmZmVjdC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgZWZmZWN0LnJhdyA9IGZuO1xyXG4gICAgZWZmZWN0LmRlcHMgPSBbXTtcclxuICAgIGVmZmVjdC5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHJldHVybiBlZmZlY3Q7XHJcbn1cclxuZnVuY3Rpb24gY2xlYW51cChlZmZlY3QpIHtcclxuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG5jb25zdCB0cmFja1N0YWNrID0gW107XHJcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcclxuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XHJcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcclxuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogbGFzdDtcclxufVxyXG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xyXG4gICAgaWYgKCFzaG91bGRUcmFjayB8fCBhY3RpdmVFZmZlY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIChkZXBzTWFwID0gbmV3IE1hcCgpKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcclxuICAgIGlmICghZGVwKSB7XHJcbiAgICAgICAgZGVwc01hcC5zZXQoa2V5LCAoZGVwID0gbmV3IFNldCgpKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWRlcC5oYXMoYWN0aXZlRWZmZWN0KSkge1xyXG4gICAgICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcclxuICAgICAgICBhY3RpdmVFZmZlY3QuZGVwcy5wdXNoKGRlcCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhY3RpdmVFZmZlY3Qub3B0aW9ucy5vblRyYWNrKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2soe1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0OiBhY3RpdmVFZmZlY3QsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAga2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xyXG4gICAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgIC8vIG5ldmVyIGJlZW4gdHJhY2tlZFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGVmZmVjdHMgPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBhZGQgPSAoZWZmZWN0c1RvQWRkKSA9PiB7XHJcbiAgICAgICAgaWYgKGVmZmVjdHNUb0FkZCkge1xyXG4gICAgICAgICAgICBlZmZlY3RzVG9BZGQuZm9yRWFjaChlZmZlY3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdCAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdC5hbGxvd1JlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzLmFkZChlZmZlY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIiAvKiBDTEVBUiAqLykge1xyXG4gICAgICAgIC8vIGNvbGxlY3Rpb24gYmVpbmcgY2xlYXJlZFxyXG4gICAgICAgIC8vIHRyaWdnZXIgYWxsIGVmZmVjdHMgZm9yIHRhcmdldFxyXG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaChhZGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnbGVuZ3RoJyAmJiBpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdsZW5ndGgnIHx8IGtleSA+PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkKGRlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNjaGVkdWxlIHJ1bnMgZm9yIFNFVCB8IEFERCB8IERFTEVURVxyXG4gICAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsc28gcnVuIGZvciBpdGVyYXRpb24ga2V5IG9uIEFERCB8IERFTEVURSB8IE1hcC5TRVRcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImFkZFwiIC8qIEFERCAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldyBpbmRleCBhZGRlZCB0byBhcnJheSAtPiBsZW5ndGggY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldCgnbGVuZ3RoJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIiAvKiBERUxFVEUgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZXRcIiAvKiBTRVQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcnVuID0gKGVmZmVjdCkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZWZmZWN0Lm9wdGlvbnMub25UcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vcHRpb25zLm9uVHJpZ2dlcih7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3QsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcclxuICAgICAgICAgICAgICAgIG9sZFRhcmdldFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVmZmVjdC5vcHRpb25zLnNjaGVkdWxlcikge1xyXG4gICAgICAgICAgICBlZmZlY3Qub3B0aW9ucy5zY2hlZHVsZXIoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVmZmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBlZmZlY3RzLmZvckVhY2gocnVuKTtcclxufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xyXG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKVxyXG4gICAgLm1hcChrZXkgPT4gU3ltYm9sW2tleV0pXHJcbiAgICAuZmlsdGVyKGlzU3ltYm9sKSk7XHJcbmNvbnN0IGdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcihmYWxzZSwgdHJ1ZSk7XHJcbmNvbnN0IHJlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUsIHRydWUpO1xyXG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7fTtcclxuWydpbmNsdWRlcycsICdpbmRleE9mJywgJ2xhc3RJbmRleE9mJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XHJcbiAgICBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgYXJyID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIgLyogR0VUICovLCBpICsgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3ZSBydW4gdGhlIG1ldGhvZCB1c2luZyB0aGUgb3JpZ2luYWwgYXJncyBmaXJzdCAod2hpY2ggbWF5IGJlIHJlYWN0aXZlKVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IG1ldGhvZC5hcHBseShhcnIsIGFyZ3MpO1xyXG4gICAgICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhhdCBkaWRuJ3Qgd29yaywgcnVuIGl0IGFnYWluIHVzaW5nIHJhdyB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoYXJyLCBhcmdzLm1hcCh0b1JhdykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KTtcclxuWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZSddLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGNvbnN0IG1ldGhvZCA9IEFycmF5LnByb3RvdHlwZVtrZXldO1xyXG4gICAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59KTtcclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLyAmJlxyXG4gICAgICAgICAgICByZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkgPyByZWFkb25seU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghaXNSZWFkb25seSAmJiB0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgaWYgKGlzU3ltYm9sKGtleSlcclxuICAgICAgICAgICAgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KVxyXG4gICAgICAgICAgICA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNSZWFkb25seSkge1xyXG4gICAgICAgICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYocmVzKSkge1xyXG4gICAgICAgICAgICAvLyByZWYgdW53cmFwcGluZyAtIGRvZXMgbm90IGFwcGx5IGZvciBBcnJheSArIGludGVnZXIga2V5LlxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRVbndyYXAgPSAhdGFyZ2V0SXNBcnJheSB8fCAhaXNJbnRlZ2VyS2V5KGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRVbndyYXAgPyByZXMudmFsdWUgOiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgaW50byBhIHByb3h5IGFzIHdlbGwuIHdlIGRvIHRoZSBpc09iamVjdCBjaGVja1xyXG4gICAgICAgICAgICAvLyBoZXJlIHRvIGF2b2lkIGludmFsaWQgdmFsdWUgd2FybmluZy4gQWxzbyBuZWVkIHRvIGxhenkgYWNjZXNzIHJlYWRvbmx5XHJcbiAgICAgICAgICAgIC8vIGFuZCByZWFjdGl2ZSBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5ID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IHNldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dTZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcih0cnVlKTtcclxuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoIXNoYWxsb3cpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpXHJcbiAgICAgICAgICAgID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoXHJcbiAgICAgICAgICAgIDogaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGlmIHRhcmdldCBpcyBzb21ldGhpbmcgdXAgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBvcmlnaW5hbFxyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xyXG4gICAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XHJcbiAgICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzQXJyYXkodGFyZ2V0KSA/ICdsZW5ndGgnIDogSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG59XHJcbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IHtcclxuICAgIGdldCxcclxuICAgIHNldCxcclxuICAgIGRlbGV0ZVByb3BlcnR5LFxyXG4gICAgaGFzLFxyXG4gICAgb3duS2V5c1xyXG59O1xyXG5jb25zdCByZWFkb25seUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiByZWFkb25seUdldCxcclxuICAgIHNldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IGV4dGVuZCh7fSwgbXV0YWJsZUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXHJcbiAgICBzZXQ6IHNoYWxsb3dTZXRcclxufSk7XHJcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxyXG4vLyByZWZzIChpbiBvcmRlciB0byBhbGxvdyByZWZzIHRvIGJlIGV4cGxpY2l0bHkgcGFzc2VkIGRvd24pLCBidXQgc2hvdWxkXHJcbi8vIHJldGFpbiB0aGUgcmVhY3Rpdml0eSBvZiB0aGUgbm9ybWFsIHJlYWRvbmx5IG9iamVjdC5cclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSBleHRlbmQoe30sIHJlYWRvbmx5SGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XHJcbn0pO1xuXG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XHJcbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XHJcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XHJcbmZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAvLyAjMTc3MjogcmVhZG9ubHkocmVhY3RpdmUoTWFwKSkgc2hvdWxkIHJldHVybiByZWFkb25seSArIHJlYWN0aXZlIHZlcnNpb25cclxuICAgIC8vIG9mIHRoZSB2YWx1ZVxyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCByYXdLZXkpO1xyXG4gICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XHJcbiAgICBjb25zdCB3cmFwID0gaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiB0b1JlYWN0aXZlO1xyXG4gICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhcyQxKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCByYXdLZXkpO1xyXG4gICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5XHJcbiAgICAgICAgPyB0YXJnZXQuaGFzKGtleSlcclxuICAgICAgICA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XHJcbn1cclxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCAnc2l6ZScsIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkKHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywgdmFsdWUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIHNldCQxKGtleSwgdmFsdWUpIHtcclxuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xyXG4gICAgaWYgKGhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIERFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XHJcbiAgICBjb25zdCBvbGRUYXJnZXQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IGlzTWFwKHRhcmdldClcclxuICAgICAgICAgICAgPyBuZXcgTWFwKHRhcmdldClcclxuICAgICAgICAgICAgOiBuZXcgU2V0KHRhcmdldClcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXHJcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcclxuICAgIGlmIChoYWRJdGVtcykge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIgLyogQ0xFQVIgKi8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IHRvUmVhY3RpdmU7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogbWFrZSBzdXJlIHRoZSBjYWxsYmFjayBpc1xyXG4gICAgICAgICAgICAvLyAxLiBpbnZva2VkIHdpdGggdGhlIHJlYWN0aXZlIG1hcCBhcyBgdGhpc2AgYW5kIDNyZCBhcmdcclxuICAgICAgICAgICAgLy8gMi4gdGhlIHZhbHVlIHJlY2VpdmVkIHNob3VsZCBiZSBhIGNvcnJlc3BvbmRpbmcgcmVhY3RpdmUvcmVhZG9ubHkuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09ICdlbnRyaWVzJyB8fCAobWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXApO1xyXG4gICAgICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gJ2tleXMnICYmIHRhcmdldElzTWFwO1xyXG4gICAgICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmXHJcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcclxuICAgICAgICAvLyByZXR1cm4gYSB3cmFwcGVkIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgb2JzZXJ2ZWQgdmVyc2lvbnMgb2YgdGhlXHJcbiAgICAgICAgLy8gdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgcmVhbCBpdGVyYXRvclxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXHJcbiAgICAgICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlLCBkb25lIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxyXG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiAvKiBERUxFVEUgKi8gPyBmYWxzZSA6IHRoaXM7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXkpO1xyXG4gICAgfSxcclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGhhczogaGFzJDEsXHJcbiAgICBhZGQsXHJcbiAgICBzZXQ6IHNldCQxLFxyXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgIGNsZWFyLFxyXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBoYXM6IGhhcyQxLFxyXG4gICAgYWRkLFxyXG4gICAgc2V0OiBzZXQkMSxcclxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXHJcbiAgICBjbGVhcixcclxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBTRVQgKi8pLFxyXG4gICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIERFTEVURSAqLyksXHJcbiAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IGl0ZXJhdG9yTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcycsIFN5bWJvbC5pdGVyYXRvcl07XHJcbml0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XHJcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcclxuICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCB0cnVlKTtcclxufSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XHJcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvd1xyXG4gICAgICAgID8gc2hhbGxvd0luc3RydW1lbnRhdGlvbnNcclxuICAgICAgICA6IGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcclxuICAgIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUkFXICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0XHJcbiAgICAgICAgICAgID8gaW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcclxufTtcclxuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcclxufTtcclxuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgYCArXHJcbiAgICAgICAgICAgIGB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgYCArXHJcbiAgICAgICAgICAgIGB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIGAgK1xyXG4gICAgICAgICAgICBgQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgYCArXHJcbiAgICAgICAgICAgIGBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcclxuICAgIHN3aXRjaCAocmF3VHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ09iamVjdCc6XHJcbiAgICAgICAgY2FzZSAnQXJyYXknOlxyXG4gICAgICAgICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XHJcbiAgICAgICAgY2FzZSAnTWFwJzpcclxuICAgICAgICBjYXNlICdTZXQnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtNYXAnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtTZXQnOlxyXG4gICAgICAgICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIiAvKiBTS0lQICovXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSlcclxuICAgICAgICA/IDAgLyogSU5WQUxJRCAqL1xyXG4gICAgICAgIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cclxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0W1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIHNoYWxsb3dseS1yZWFjdGl2ZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3RcclxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcclxuICogcm9vdCBsZXZlbCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcmVhZG9ubHkgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LiBOb3RlIHRoZSByZXR1cm5lZCBjb3B5IGlzIG5vdFxyXG4gKiBtYWRlIHJlYWN0aXZlLCBidXQgYHJlYWRvbmx5YCBjYW4gYmUgY2FsbGVkIG9uIGFuIGFscmVhZHkgcmVhY3RpdmUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCByZWFkb25seUhhbmRsZXJzLCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcclxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxyXG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seSwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMpIHtcclxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBpcyBhbHJlYWR5IGEgUHJveHksIHJldHVybiBpdC5cclxuICAgIC8vIGV4Y2VwdGlvbjogY2FsbGluZyByZWFkb25seSgpIG9uIGEgcmVhY3RpdmUgb2JqZWN0XHJcbiAgICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL10gJiZcclxuICAgICAgICAhKGlzUmVhZG9ubHkgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBhbHJlYWR5IGhhcyBjb3JyZXNwb25kaW5nIFByb3h5XHJcbiAgICBjb25zdCBwcm94eU1hcCA9IGlzUmVhZG9ubHkgPyByZWFkb25seU1hcCA6IHJlYWN0aXZlTWFwO1xyXG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgYSB3aGl0ZWxpc3Qgb2YgdmFsdWUgdHlwZXMgY2FuIGJlIG9ic2VydmVkLlxyXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcclxuICAgIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnMpO1xyXG4gICAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcclxuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcclxuICAgIHJldHVybiAoKG9ic2VydmVkICYmIHRvUmF3KG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pKSB8fCBvYnNlcnZlZCk7XHJcbn1cclxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xyXG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIgLyogU0tJUCAqLywgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuY29uc3QgY29udmVydCA9ICh2YWwpID0+IGlzT2JqZWN0KHZhbCkgPyByZWFjdGl2ZSh2YWwpIDogdmFsO1xyXG5mdW5jdGlvbiBpc1JlZihyKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiByZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xyXG59XHJcbmNsYXNzIFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX3Jhd1ZhbHVlLCBfc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBfcmF3VmFsdWU7XHJcbiAgICAgICAgdGhpcy5fc2hhbGxvdyA9IF9zaGFsbG93O1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF9zaGFsbG93ID8gX3Jhd1ZhbHVlIDogY29udmVydChfcmF3VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHRyYWNrKHRvUmF3KHRoaXMpLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHRvUmF3KG5ld1ZhbCksIHRoaXMuX3Jhd1ZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9zaGFsbG93ID8gbmV3VmFsIDogY29udmVydChuZXdWYWwpO1xyXG4gICAgICAgICAgICB0cmlnZ2VyKHRvUmF3KHRoaXMpLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJywgbmV3VmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcmF3VmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmKSB7XHJcbiAgICB0cmlnZ2VyKHRvUmF3KHJlZiksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyByZWYudmFsdWUgOiB2b2lkIDApO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVmKHJlZikge1xyXG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XHJcbn1cclxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcclxuICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpXHJcbiAgICAgICAgPyBvYmplY3RXaXRoUmVmc1xyXG4gICAgICAgIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xyXG59XHJcbmNsYXNzIEN1c3RvbVJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KCgpID0+IHRyYWNrKHRoaXMsIFwiZ2V0XCIgLyogR0VUICovLCAndmFsdWUnKSwgKCkgPT4gdHJpZ2dlcih0aGlzLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJykpO1xyXG4gICAgICAgIHRoaXMuX2dldCA9IGdldDtcclxuICAgICAgICB0aGlzLl9zZXQgPSBzZXQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldCgpO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NldChuZXdWYWwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmNsYXNzIE9iamVjdFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvUmVmKG9iamVjdCwga2V5KSB7XHJcbiAgICByZXR1cm4gaXNSZWYob2JqZWN0W2tleV0pXHJcbiAgICAgICAgPyBvYmplY3Rba2V5XVxyXG4gICAgICAgIDogbmV3IE9iamVjdFJlZkltcGwob2JqZWN0LCBrZXkpO1xyXG59XG5cbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHkpIHtcclxuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBlZmZlY3QoZ2V0dGVyLCB7XHJcbiAgICAgICAgICAgIGxhenk6IHRydWUsXHJcbiAgICAgICAgICAgIHNjaGVkdWxlcjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKHRvUmF3KHRoaXMpLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10gPSBpc1JlYWRvbmx5O1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuZWZmZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrKHRvUmF3KHRoaXMpLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyKG5ld1ZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMpIHtcclxuICAgIGxldCBnZXR0ZXI7XHJcbiAgICBsZXQgc2V0dGVyO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSkge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcclxuICAgICAgICBzZXR0ZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgPyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcclxuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSB8fCAhZ2V0dGVyT3JPcHRpb25zLnNldCk7XHJcbn1cblxuZXhwb3J0IHsgSVRFUkFURV9LRVksIGNvbXB1dGVkLCBjdXN0b21SZWYsIGVmZmVjdCwgZW5hYmxlVHJhY2tpbmcsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBtYXJrUmF3LCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyYWNrLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiB9O1xuIiwiaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUmVhY3RpdmUsIGVmZmVjdCwgc3RvcCwgcmVmLCBpc1Byb3h5LCBwcm94eVJlZnMsIHRvUmVmLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBjdXN0b21SZWYsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBtYXJrUmF3LCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIGV4dGVuZCwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09uLCBoYXNPd24sIGlzTW9kZWxMaXN0ZW5lciwgZGVmLCBpc1Jlc2VydmVkUHJvcCwgRU1QVFlfQVJSLCBpc09iamVjdCwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBtYWtlTWFwLCByZW1vdmUsIE5PT1AsIGhhc0NoYW5nZWQsIGlzU2V0LCBpc01hcCwgaW52b2tlQXJyYXlGbnMsIE5PLCBnZXRHbG9iYWxUaGlzLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XHJcbiAgICBzdGFjay5wdXNoKHZub2RlKTtcclxufVxyXG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcclxuICAgIHN0YWNrLnBvcCgpO1xyXG59XHJcbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgICAvLyBhdm9pZCBwcm9wcyBmb3JtYXR0aW5nIG9yIHdhcm4gaGFuZGxlciB0cmFja2luZyBkZXBzIHRoYXQgbWlnaHQgYmUgbXV0YXRlZFxyXG4gICAgLy8gZHVyaW5nIHBhdGNoLCBsZWFkaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcclxuICAgIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XHJcbiAgICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XHJcbiAgICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwV2FybkhhbmRsZXIsIGluc3RhbmNlLCAxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovLCBbXHJcbiAgICAgICAgICAgIG1zZyArIGFyZ3Muam9pbignJyksXHJcbiAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmApXHJcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyksXHJcbiAgICAgICAgICAgIHRyYWNlXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHRyYWNlLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xyXG4gICAgICAgICAgICAhZmFsc2UpIHtcclxuICAgICAgICAgICAgd2FybkFyZ3MucHVzaChgXFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcclxuICAgIH1cclxuICAgIHJlc2V0VHJhY2tpbmcoKTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcclxuICAgIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgIGlmICghY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgLy8gd2UgY2FuJ3QganVzdCB1c2UgdGhlIHN0YWNrIGJlY2F1c2UgaXQgd2lsbCBiZSBpbmNvbXBsZXRlIGR1cmluZyB1cGRhdGVzXHJcbiAgICAvLyB0aGF0IGRpZCBub3Qgc3RhcnQgZnJvbSB0aGUgcm9vdC4gUmUtY29uc3RydWN0IHRoZSBwYXJlbnQgY2hhaW4gdXNpbmdcclxuICAgIC8vIGluc3RhbmNlIHBhcmVudCBwb2ludGVycy5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xyXG4gICAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxyXG4gICAgICAgICAgICAgICAgcmVjdXJzZUNvdW50OiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XHJcbiAgICAgICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XHJcbiAgICBjb25zdCBsb2dzID0gW107XHJcbiAgICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgIGxvZ3MucHVzaCguLi4oaSA9PT0gMCA/IFtdIDogW2BcXG5gXSksIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGxvZ3M7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xyXG4gICAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcclxuICAgIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xyXG4gICAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bm9kZS5jb21wb25lbnQsIHZub2RlLnR5cGUsIGlzUm9vdCl9YDtcclxuICAgIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcclxuICAgIHJldHVybiB2bm9kZS5wcm9wc1xyXG4gICAgICAgID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdXHJcbiAgICAgICAgOiBbb3BlbiArIGNsb3NlXTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xyXG4gICAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGtleXMubGVuZ3RoID4gMykge1xyXG4gICAgICAgIHJlcy5wdXNoKGAgLi4uYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fFxyXG4gICAgICAgIHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XHJcbiAgICB9XHJcbn1cblxuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IHtcclxuICAgIFtcImJjXCIgLyogQkVGT1JFX0NSRUFURSAqL106ICdiZWZvcmVDcmVhdGUgaG9vaycsXHJcbiAgICBbXCJjXCIgLyogQ1JFQVRFRCAqL106ICdjcmVhdGVkIGhvb2snLFxyXG4gICAgW1wiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi9dOiAnYmVmb3JlTW91bnQgaG9vaycsXHJcbiAgICBbXCJtXCIgLyogTU9VTlRFRCAqL106ICdtb3VudGVkIGhvb2snLFxyXG4gICAgW1wiYnVcIiAvKiBCRUZPUkVfVVBEQVRFICovXTogJ2JlZm9yZVVwZGF0ZSBob29rJyxcclxuICAgIFtcInVcIiAvKiBVUERBVEVEICovXTogJ3VwZGF0ZWQnLFxyXG4gICAgW1wiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi9dOiAnYmVmb3JlVW5tb3VudCBob29rJyxcclxuICAgIFtcInVtXCIgLyogVU5NT1VOVEVEICovXTogJ3VubW91bnRlZCBob29rJyxcclxuICAgIFtcImFcIiAvKiBBQ1RJVkFURUQgKi9dOiAnYWN0aXZhdGVkIGhvb2snLFxyXG4gICAgW1wiZGFcIiAvKiBERUFDVElWQVRFRCAqL106ICdkZWFjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi9dOiAnZXJyb3JDYXB0dXJlZCBob29rJyxcclxuICAgIFtcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovXTogJ3JlbmRlclRyYWNrZWQgaG9vaycsXHJcbiAgICBbXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovXTogJ3JlbmRlclRyaWdnZXJlZCBob29rJyxcclxuICAgIFswIC8qIFNFVFVQX0ZVTkNUSU9OICovXTogJ3NldHVwIGZ1bmN0aW9uJyxcclxuICAgIFsxIC8qIFJFTkRFUl9GVU5DVElPTiAqL106ICdyZW5kZXIgZnVuY3Rpb24nLFxyXG4gICAgWzIgLyogV0FUQ0hfR0VUVEVSICovXTogJ3dhdGNoZXIgZ2V0dGVyJyxcclxuICAgIFszIC8qIFdBVENIX0NBTExCQUNLICovXTogJ3dhdGNoZXIgY2FsbGJhY2snLFxyXG4gICAgWzQgLyogV0FUQ0hfQ0xFQU5VUCAqL106ICd3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb24nLFxyXG4gICAgWzUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi9dOiAnbmF0aXZlIGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi9dOiAnY29tcG9uZW50IGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzcgLyogVk5PREVfSE9PSyAqL106ICd2bm9kZSBob29rJyxcclxuICAgIFs4IC8qIERJUkVDVElWRV9IT09LICovXTogJ2RpcmVjdGl2ZSBob29rJyxcclxuICAgIFs5IC8qIFRSQU5TSVRJT05fSE9PSyAqL106ICd0cmFuc2l0aW9uIGhvb2snLFxyXG4gICAgWzEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovXTogJ2FwcCBlcnJvckhhbmRsZXInLFxyXG4gICAgWzExIC8qIEFQUF9XQVJOX0hBTkRMRVIgKi9dOiAnYXBwIHdhcm5IYW5kbGVyJyxcclxuICAgIFsxMiAvKiBGVU5DVElPTl9SRUYgKi9dOiAncmVmIGZ1bmN0aW9uJyxcclxuICAgIFsxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovXTogJ2FzeW5jIGNvbXBvbmVudCBsb2FkZXInLFxyXG4gICAgWzE0IC8qIFNDSEVEVUxFUiAqL106ICdzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuICcgK1xyXG4gICAgICAgICdQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvdnVlLW5leHQnXHJcbn07XHJcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICAgIGxldCByZXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlcyA9IGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xyXG4gICAgICAgICAgICByZXMuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xyXG4gICAgICAgIC8vIHRoZSBleHBvc2VkIGluc3RhbmNlIGlzIHRoZSByZW5kZXIgcHJveHkgdG8ga2VlcCBpdCBjb25zaXN0ZW50IHdpdGggMi54XHJcbiAgICAgICAgY29uc3QgZXhwb3NlZEluc3RhbmNlID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICAgICAgLy8gaW4gcHJvZHVjdGlvbiB0aGUgaG9vayByZWNlaXZlcyBvbmx5IHRoZSBlcnJvciBjb2RlXHJcbiAgICAgICAgY29uc3QgZXJyb3JJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXSA6IHR5cGU7XHJcbiAgICAgICAgd2hpbGUgKGN1cikge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhcHAtbGV2ZWwgaGFuZGxpbmdcclxuICAgICAgICBjb25zdCBhcHBFcnJvckhhbmRsZXIgPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5lcnJvckhhbmRsZXI7XHJcbiAgICAgICAgaWYgKGFwcEVycm9ySGFuZGxlcikge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwRXJyb3JIYW5kbGVyLCBudWxsLCAxMCAvKiBBUFBfRVJST1JfSEFORExFUiAqLywgW2VyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm9dKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2KTtcclxufVxyXG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBpbmZvID0gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXTtcclxuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3YXJuKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcclxuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XHJcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyYXNoIGluIGRldiBieSBkZWZhdWx0IHNvIGl0J3MgbW9yZSBub3RpY2VhYmxlXHJcbiAgICAgICAgaWYgKHRocm93SW5EZXYpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHJlY292ZXIgaW4gcHJvZCB0byByZWR1Y2UgdGhlIGltcGFjdCBvbiBlbmQtdXNlclxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgIH1cclxufVxuXG5sZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xyXG5sZXQgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuY29uc3QgcXVldWUgPSBbXTtcclxubGV0IGZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCBwZW5kaW5nUHJlRmx1c2hDYnMgPSBbXTtcclxubGV0IGFjdGl2ZVByZUZsdXNoQ2JzID0gbnVsbDtcclxubGV0IHByZUZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XHJcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xyXG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCByZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcclxubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xyXG5sZXQgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gbnVsbDtcclxuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xyXG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xyXG4gICAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xyXG4gICAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcclxufVxyXG4vLyAjMjc2OFxyXG4vLyBVc2UgYmluYXJ5LXNlYXJjaCB0byBmaW5kIGEgc3VpdGFibGUgcG9zaXRpb24gaW4gdGhlIHF1ZXVlLFxyXG4vLyBzbyB0aGF0IHRoZSBxdWV1ZSBtYWludGFpbnMgdGhlIGluY3JlYXNpbmcgb3JkZXIgb2Ygam9iJ3MgaWQsXHJcbi8vIHdoaWNoIGNhbiBwcmV2ZW50IHRoZSBqb2IgZnJvbSBiZWluZyBza2lwcGVkIGFuZCBhbHNvIGNhbiBhdm9pZCByZXBlYXRlZCBwYXRjaGluZy5cclxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGpvYikge1xyXG4gICAgLy8gdGhlIHN0YXJ0IGluZGV4IHNob3VsZCBiZSBgZmx1c2hJbmRleCArIDFgXHJcbiAgICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcclxuICAgIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XHJcbiAgICBjb25zdCBqb2JJZCA9IGdldElkKGpvYik7XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICBjb25zdCBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQocXVldWVbbWlkZGxlXSk7XHJcbiAgICAgICAgbWlkZGxlSm9iSWQgPCBqb2JJZCA/IChzdGFydCA9IG1pZGRsZSArIDEpIDogKGVuZCA9IG1pZGRsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhcnQ7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XHJcbiAgICAvLyB0aGUgZGVkdXBlIHNlYXJjaCB1c2VzIHRoZSBzdGFydEluZGV4IGFyZ3VtZW50IG9mIEFycmF5LmluY2x1ZGVzKClcclxuICAgIC8vIGJ5IGRlZmF1bHQgdGhlIHNlYXJjaCBpbmRleCBpbmNsdWRlcyB0aGUgY3VycmVudCBqb2IgdGhhdCBpcyBiZWluZyBydW5cclxuICAgIC8vIHNvIGl0IGNhbm5vdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiBhZ2Fpbi5cclxuICAgIC8vIGlmIHRoZSBqb2IgaXMgYSB3YXRjaCgpIGNhbGxiYWNrLCB0aGUgc2VhcmNoIHdpbGwgc3RhcnQgd2l0aCBhICsxIGluZGV4IHRvXHJcbiAgICAvLyBhbGxvdyBpdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiAtIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG9cclxuICAgIC8vIGVuc3VyZSBpdCBkb2Vzbid0IGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wLlxyXG4gICAgaWYgKCghcXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgIXF1ZXVlLmluY2x1ZGVzKGpvYiwgaXNGbHVzaGluZyAmJiBqb2IuYWxsb3dSZWN1cnNlID8gZmx1c2hJbmRleCArIDEgOiBmbHVzaEluZGV4KSkgJiZcclxuICAgICAgICBqb2IgIT09IGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYikge1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRJbnNlcnRpb25JbmRleChqb2IpO1xyXG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xyXG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UocG9zLCAwLCBqb2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXVldWUucHVzaChqb2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZUZsdXNoKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcclxuICAgIGlmICghaXNGbHVzaGluZyAmJiAhaXNGbHVzaFBlbmRpbmcpIHtcclxuICAgICAgICBpc0ZsdXNoUGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW52YWxpZGF0ZUpvYihqb2IpIHtcclxuICAgIGNvbnN0IGkgPSBxdWV1ZS5pbmRleE9mKGpvYik7XHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlQ2IoY2IsIGFjdGl2ZVF1ZXVlLCBwZW5kaW5nUXVldWUsIGluZGV4KSB7XHJcbiAgICBpZiAoIWlzQXJyYXkoY2IpKSB7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVRdWV1ZSB8fFxyXG4gICAgICAgICAgICAhYWN0aXZlUXVldWUuaW5jbHVkZXMoY2IsIGNiLmFsbG93UmVjdXJzZSA/IGluZGV4ICsgMSA6IGluZGV4KSkge1xyXG4gICAgICAgICAgICBwZW5kaW5nUXVldWUucHVzaChjYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgY2IgaXMgYW4gYXJyYXksIGl0IGlzIGEgY29tcG9uZW50IGxpZmVjeWNsZSBob29rIHdoaWNoIGNhbiBvbmx5IGJlXHJcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5IGEgam9iLCB3aGljaCBpcyBhbHJlYWR5IGRlZHVwZWQgaW4gdGhlIG1haW4gcXVldWUsIHNvXHJcbiAgICAgICAgLy8gd2UgY2FuIHNraXAgZHVwbGljYXRlIGNoZWNrIGhlcmUgdG8gaW1wcm92ZSBwZXJmXHJcbiAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goLi4uY2IpO1xyXG4gICAgfVxyXG4gICAgcXVldWVGbHVzaCgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUHJlRmx1c2hDYihjYikge1xyXG4gICAgcXVldWVDYihjYiwgYWN0aXZlUHJlRmx1c2hDYnMsIHBlbmRpbmdQcmVGbHVzaENicywgcHJlRmx1c2hJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xyXG4gICAgcXVldWVDYihjYiwgYWN0aXZlUG9zdEZsdXNoQ2JzLCBwZW5kaW5nUG9zdEZsdXNoQ2JzLCBwb3N0Rmx1c2hJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhzZWVuLCBwYXJlbnRKb2IgPSBudWxsKSB7XHJcbiAgICBpZiAocGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgIGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IHBhcmVudEpvYjtcclxuICAgICAgICBhY3RpdmVQcmVGbHVzaENicyA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQcmVGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHByZUZsdXNoSW5kZXggPSAwOyBwcmVGbHVzaEluZGV4IDwgYWN0aXZlUHJlRmx1c2hDYnMubGVuZ3RoOyBwcmVGbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQcmVGbHVzaENicyA9IG51bGw7XHJcbiAgICAgICAgcHJlRmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gbnVsbDtcclxuICAgICAgICAvLyByZWN1cnNpdmVseSBmbHVzaCB1bnRpbCBpdCBkcmFpbnNcclxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIHBhcmVudEpvYik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xyXG4gICAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gIzE5NDcgYWxyZWFkeSBoYXMgYWN0aXZlIHF1ZXVlLCBuZXN0ZWQgZmx1c2hQb3N0Rmx1c2hDYnMgY2FsbFxyXG4gICAgICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcclxuICAgICAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xyXG4gICAgICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xyXG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xyXG4gICAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGZsdXNoUHJlRmx1c2hDYnMoc2Vlbik7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXHJcbiAgICAvLyAgICBwcmlvcml0eSBudW1iZXIpXHJcbiAgICAvLyAyLiBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHVwZGF0ZSxcclxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXHJcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoam9iKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCAvKiBTQ0hFRFVMRVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgZmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcclxuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgLy8gc29tZSBwb3N0Rmx1c2hDYiBxdWV1ZWQgam9icyFcclxuICAgICAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRyYWlucy5cclxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZsdXNoSm9icyhzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XHJcbiAgICBpZiAoIXNlZW4uaGFzKGZuKSkge1xyXG4gICAgICAgIHNlZW4uc2V0KGZuLCAxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pO1xyXG4gICAgICAgIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGAgK1xyXG4gICAgICAgICAgICAgICAgYGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBgICtcclxuICAgICAgICAgICAgICAgIGBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3IgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZWVuLnNldChmbiwgY291bnQgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XHJcbmNvbnN0IGhtckRpcnR5Q29tcG9uZW50cyA9IG5ldyBTZXQoKTtcclxuLy8gRXhwb3NlIHRoZSBITVIgcnVudGltZSBvbiB0aGUgZ2xvYmFsIG9iamVjdFxyXG4vLyBUaGlzIG1ha2VzIGl0IGVudGlyZWx5IHRyZWUtc2hha2FibGUgd2l0aG91dCBwb2xsdXRpbmcgdGhlIGV4cG9ydHMgYW5kIG1ha2VzXHJcbi8vIGl0IGVhc2llciB0byBiZSB1c2VkIGluIHRvb2xpbmdzIGxpa2UgdnVlLWxvYWRlclxyXG4vLyBOb3RlOiBmb3IgYSBjb21wb25lbnQgdG8gYmUgZWxpZ2libGUgZm9yIEhNUiBpdCBhbHNvIG5lZWRzIHRoZSBfX2htcklkIG9wdGlvblxyXG4vLyB0byBiZSBzZXQgc28gdGhhdCBpdHMgaW5zdGFuY2VzIGNhbiBiZSByZWdpc3RlcmVkIC8gcmVtb3ZlZC5cclxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgY29uc3QgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICA/IGdsb2JhbFxyXG4gICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgOiB7fTtcclxuICAgIGdsb2JhbE9iamVjdC5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxyXG4gICAgICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcclxuICAgICAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxyXG4gICAgfTtcclxufVxyXG5jb25zdCBtYXAgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcclxuICAgIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKSB7XHJcbiAgICAgICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIH1cclxuICAgIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBjb21wb25lbnQpIHtcclxuICAgIGlmICghY29tcG9uZW50KSB7XHJcbiAgICAgICAgd2FybihgSE1SIEFQSSB1c2FnZSBpcyBvdXQgb2YgZGF0ZS5cXG5gICtcclxuICAgICAgICAgICAgYFBsZWFzZSB1cGdyYWRlIHZ1ZS1sb2FkZXIvdml0ZS9yb2xsdXAtcGx1Z2luLXZ1ZSBvciBvdGhlciByZWxldmFudCBgICtcclxuICAgICAgICAgICAgYGRlcGVuZGVuY3kgdGhhdCBoYW5kbGVzIFZ1ZSBTRkMgY29tcGlsYXRpb24uYCk7XHJcbiAgICAgICAgY29tcG9uZW50ID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAobWFwLmhhcyhpZCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtYXAuc2V0KGlkLCB7XHJcbiAgICAgICAgY29tcG9uZW50OiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50LFxyXG4gICAgICAgIGluc3RhbmNlczogbmV3IFNldCgpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcclxuICAgIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgaWYgKCFyZWNvcmQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKG5ld1JlbmRlcilcclxuICAgICAgICByZWNvcmQuY29tcG9uZW50LnJlbmRlciA9IG5ld1JlbmRlcjtcclxuICAgIC8vIEFycmF5LmZyb20gY3JlYXRlcyBhIHNuYXBzaG90IHdoaWNoIGF2b2lkcyB0aGUgc2V0IGJlaW5nIG11dGF0ZWQgZHVyaW5nXHJcbiAgICAvLyB1cGRhdGVzXHJcbiAgICBBcnJheS5mcm9tKHJlY29yZC5pbnN0YW5jZXMpLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChuZXdSZW5kZXIpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xyXG4gICAgICAgIC8vIHRoaXMgZmxhZyBmb3JjZXMgY2hpbGQgY29tcG9uZW50cyB3aXRoIHNsb3QgY29udGVudCB0byB1cGRhdGVcclxuICAgICAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWxvYWQoaWQsIG5ld0NvbXApIHtcclxuICAgIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgaWYgKCFyZWNvcmQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgLy8gQXJyYXkuZnJvbSBjcmVhdGVzIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmdcclxuICAgIC8vIHVwZGF0ZXNcclxuICAgIGNvbnN0IHsgY29tcG9uZW50LCBpbnN0YW5jZXMgfSA9IHJlY29yZDtcclxuICAgIGlmICghaG1yRGlydHlDb21wb25lbnRzLmhhcyhjb21wb25lbnQpKSB7XHJcbiAgICAgICAgLy8gMS4gVXBkYXRlIGV4aXN0aW5nIGNvbXAgZGVmaW5pdGlvbiB0byBtYXRjaCBuZXcgb25lXHJcbiAgICAgICAgbmV3Q29tcCA9IGlzQ2xhc3NDb21wb25lbnQobmV3Q29tcCkgPyBuZXdDb21wLl9fdmNjT3B0cyA6IG5ld0NvbXA7XHJcbiAgICAgICAgZXh0ZW5kKGNvbXBvbmVudCwgbmV3Q29tcCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdDb21wKSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDIuIE1hcmsgY29tcG9uZW50IGRpcnR5LiBUaGlzIGZvcmNlcyB0aGUgcmVuZGVyZXIgdG8gcmVwbGFjZSB0aGUgY29tcG9uZW50XHJcbiAgICAgICAgLy8gb24gcGF0Y2guXHJcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChjb21wb25lbnQpO1xyXG4gICAgICAgIC8vIDMuIE1ha2Ugc3VyZSB0byB1bm1hcmsgdGhlIGNvbXBvbmVudCBhZnRlciB0aGUgcmVsb2FkLlxyXG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKGNvbXBvbmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBBcnJheS5mcm9tKGluc3RhbmNlcykuZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyA0LiBGb3JjZSB0aGUgcGFyZW50IGluc3RhbmNlIHRvIHJlLXJlbmRlci4gVGhpcyB3aWxsIGNhdXNlIGFsbCB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgdG8gYmUgdW5tb3VudGVkIGFuZCByZS1tb3VudGVkLiBRdWV1ZSB0aGUgdXBkYXRlIHNvIHRoYXQgd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGZvcmNpbmcgdGhlIHNhbWUgcGFyZW50IHRvIHJlLXJlbmRlciBtdWx0aXBsZSB0aW1lcy5cclxuICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgbW91bnRlZCB2aWEgY3JlYXRlQXBwKCkgaGFzIGEgcmVsb2FkIG1ldGhvZFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIGluc2lkZSB0cmVlIGNyZWF0ZWQgdmlhIHJhdyByZW5kZXIoKS4gRm9yY2UgcmVsb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xyXG4gICAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxubGV0IGRldnRvb2xzO1xyXG5mdW5jdGlvbiBzZXREZXZ0b29sc0hvb2soaG9vaykge1xyXG4gICAgZGV2dG9vbHMgPSBob29rO1xyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcclxuICAgIC8vIFRPRE8gcXVldWUgaWYgZGV2dG9vbHMgaXMgdW5kZWZpbmVkXHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcclxuICAgICAgICBGcmFnbWVudCxcclxuICAgICAgICBUZXh0LFxyXG4gICAgICAgIENvbW1lbnQsXHJcbiAgICAgICAgU3RhdGljXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xyXG59XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqLyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcyk7XHJcbn1cblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcclxuICAgIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IHsgZW1pdHNPcHRpb25zLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoZW1pdHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGFyZ3MgPSByYXdBcmdzO1xyXG4gICAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aCgndXBkYXRlOicpO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFwcGx5IG1vZGlmaWVycyBvbiBhcmdzXHJcbiAgICBjb25zdCBtb2RlbEFyZyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBldmVudC5zbGljZSg3KTtcclxuICAgIGlmIChtb2RlbEFyZyAmJiBtb2RlbEFyZyBpbiBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSAnbW9kZWxWYWx1ZScgPyAnbW9kZWwnIDogbW9kZWxBcmd9TW9kaWZpZXJzYDtcclxuICAgICAgICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gcHJvcHNbbW9kaWZpZXJzS2V5XSB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGEgPT4gYS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1iZXIpIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKHRvTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcclxuICAgICAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBgICtcclxuICAgICAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBgICtcclxuICAgICAgICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXHJcbiAgICAgICAgICAgICAgICBgWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY29udmVydCBoYW5kbGVyIG5hbWUgdG8gY2FtZWxDYXNlLiBTZWUgaXNzdWUgIzIyNDlcclxuICAgIGxldCBoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpO1xyXG4gICAgbGV0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZV07XHJcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYWxzbyB0cmlnZ2VyIGtlYmFiLWNhc2UgZXF1aXZhbGVudFxyXG4gICAgLy8gZm9yIHByb3BzIHBhc3NlZCB2aWEga2ViYWItY2FzZVxyXG4gICAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xyXG4gICAgICAgIGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpO1xyXG4gICAgICAgIGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZV07XHJcbiAgICB9XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xyXG4gICAgaWYgKG9uY2VIYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XHJcbiAgICAgICAgICAgIChpbnN0YW5jZS5lbWl0dGVkID0ge30pW2hhbmRsZXJOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcob25jZUhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIWFwcENvbnRleHQuZGVvcHQgJiYgY29tcC5fX2VtaXRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY29tcC5fX2VtaXRzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcclxuICAgIGxldCBub3JtYWxpemVkID0ge307XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIHJldHVybiAoY29tcC5fX2VtaXRzID0gbnVsbCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgcmF3LmZvckVhY2goa2V5ID0+IChub3JtYWxpemVkW2tleV0gPSBudWxsKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcclxuICAgIH1cclxuICAgIHJldHVybiAoY29tcC5fX2VtaXRzID0gbm9ybWFsaXplZCk7XHJcbn1cclxuLy8gQ2hlY2sgaWYgYW4gaW5jb21pbmcgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyLlxyXG4vLyBlLmcuIFdpdGggYGVtaXRzOiB7IGNsaWNrOiBudWxsIH1gLCBwcm9wcyBuYW1lZCBgb25DbGlja2AgYW5kIGBvbmNsaWNrYCBhcmVcclxuLy8gYm90aCBjb25zaWRlcmVkIG1hdGNoZWQgbGlzdGVuZXJzLlxyXG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcclxuICAgIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgJycpO1xyXG4gICAgcmV0dXJuIChoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8XHJcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBrZXkpKTtcclxufVxuXG4vKipcclxuICogbWFyayB0aGUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2UgZm9yIGFzc2V0IHJlc29sdXRpb24gKGUuZy5cclxuICogcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSkgZHVyaW5nIHJlbmRlclxyXG4gKi9cclxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgdG8gdHJhY2sgd2hldGhlciAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlci5cclxuICogSWYgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIgdGhlbiB0aGUgd2FybmluZyBmb3IgZmFpbGVkIGF0dHJzXHJcbiAqIGZhbGx0aHJvdWdoIGNhbiBiZSBzdXBwcmVzc2VkLlxyXG4gKi9cclxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcclxuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XHJcbiAgICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCwgdm5vZGUsIHByb3h5LCB3aXRoUHJveHksIHByb3BzLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLCBzbG90cywgYXR0cnMsIGVtaXQsIHJlbmRlciwgcmVuZGVyQ2FjaGUsIGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBsZXQgZmFsbHRocm91Z2hBdHRycztcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gd2l0aFByb3h5IGlzIGEgcHJveHkgd2l0aCBhIGRpZmZlcmVudCBgaGFzYCB0cmFwIG9ubHkgZm9yXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2suXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5jYWxsKHByb3h5VG9Vc2UsIHByb3h5VG9Vc2UsIHJlbmRlckNhY2hlLCBwcm9wcywgc2V0dXBTdGF0ZSwgZGF0YSwgY3R4KSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyBpbiBkZXYsIG1hcmsgYXR0cnMgYWNjZXNzZWQgaWYgb3B0aW9uYWwgcHJvcHMgKGF0dHJzID09PSBwcm9wcylcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxyXG4gICAgICAgICAgICAgICAgOiByZW5kZXIocHJvcHMsIG51bGwgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi8pKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wc1xyXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xyXG4gICAgICAgICAgICAgICAgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhdHRyIG1lcmdpbmdcclxuICAgICAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcclxuICAgICAgICAvLyB0byBoYXZlIGNvbW1lbnRzIGFsb25nIHNpZGUgdGhlIHJvb3QgZWxlbWVudCB3aGljaCBtYWtlcyBpdCBhIGZyYWdtZW50XHJcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQ7XHJcbiAgICAgICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICByZXN1bHQucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmluaGVyaXRBdHRycyAhPT0gZmFsc2UgJiYgZmFsbHRocm91Z2hBdHRycykge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xyXG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSB2LW1vZGVsIGxpc3RlbmVyIChvblVwZGF0ZTp4eHgpIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjbGFyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcCwgaXQgaW5kaWNhdGVzIHRoaXMgY29tcG9uZW50IGV4cGVjdHMgdG8gaGFuZGxlIHYtbW9kZWwgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBub3QgZmFsbHRocm91Z2guXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0ZWQ6ICMxNTQzLCAjMTY0MywgIzE5ODlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKGZhbGx0aHJvdWdoQXR0cnMsIHByb3BzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGhhbmRsZXJzIHdoZW4gdGhleSBmYWlsIHRvIGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmF0ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2V4dHJhQXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2V2ZW50QXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluaGVyaXQgZGlyZWN0aXZlc1xyXG4gICAgICAgIGlmICh2bm9kZS5kaXJzKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluaGVyaXQgdHJhbnNpdGlvbiBkYXRhXHJcbiAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0Um9vdCkge1xyXG4gICAgICAgICAgICBzZXRSb290KHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcm9vdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqIEluIGRldiBtb2RlLCB0ZW1wbGF0ZSByb290IGxldmVsIGNvbW1lbnRzIGFyZSByZW5kZXJlZCwgd2hpY2ggdHVybnMgdGhlXHJcbiAqIHRlbXBsYXRlIGludG8gYSBmcmFnbWVudCByb290LCBidXQgd2UgbmVlZCB0byBsb2NhdGUgdGhlIHNpbmdsZSBlbGVtZW50XHJcbiAqIHJvb3QgZm9yIGF0dHJzIGFuZCBzY29wZSBpZCBwcm9jZXNzaW5nLlxyXG4gKi9cclxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XHJcbiAgICBpZiAoIWNoaWxkUm9vdCkge1xyXG4gICAgICAgIHJldHVybiBbdm5vZGUsIHVuZGVmaW5lZF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcclxuICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcclxuICAgIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcclxuICAgICAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcclxufTtcclxuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xyXG4gICAgbGV0IHNpbmdsZVJvb3Q7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlIHVzZXIgY29tbWVudFxyXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gJ3YtaWYnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBtb3JlIHRoYW4gMSBub24tY29tbWVudCBjaGlsZCwgcmV0dXJuIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzaW5nbGVSb290O1xyXG59XHJcbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xyXG4gICAgbGV0IHJlcztcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScgfHwgaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcclxuICAgIHJldHVybiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gfHxcclxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICB2bm9kZS50eXBlID09PSBDb21tZW50IC8vIHBvdGVudGlhbCB2LWlmIGJyYW5jaCBzd2l0Y2hcclxuICAgICk7XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XHJcbiAgICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xyXG4gICAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcclxuICAgIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcclxuICAgIC8vIFBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24gd2FzIGhvdC11cGRhdGVkLiBTaW5jZSB0aGlzIG1heSBoYXZlXHJcbiAgICAvLyBjYXVzZWQgdGhlIGNoaWxkIGNvbXBvbmVudCdzIHNsb3RzIGNvbnRlbnQgdG8gaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmb3JjZSB0aGUgY2hpbGQgdG8gdXBkYXRlIGFzIHdlbGwuXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBmb3JjZSBjaGlsZCB1cGRhdGUgZm9yIHJ1bnRpbWUgZGlyZWN0aXZlIG9yIHRyYW5zaXRpb24gb24gY29tcG9uZW50IHZub2RlLlxyXG4gICAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLykge1xyXG4gICAgICAgICAgICAvLyBzbG90IGNvbnRlbnQgdGhhdCByZWZlcmVuY2VzIHZhbHVlcyB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gZS5nLiBpbiBhIHYtZm9yXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHRoaXMgZmxhZyBpbmRpY2F0ZXMgcHJvcHMgYXJlIGFsd2F5cyBub24tbnVsbFxyXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHRoaXMgcGF0aCBpcyBvbmx5IHRha2VuIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIC8vIHNvIHByZXNlbmNlIG9mIGFueSBjaGlsZHJlbiBsZWFkcyB0byBhIGZvcmNlZCB1cGRhdGVcclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xyXG4gICAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xyXG4gICAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcclxuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwgLy8gSG9zdE5vZGVcclxuKSB7XHJcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xyXG4gICAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XHJcbi8vIFN1c3BlbnNlIGV4cG9zZXMgYSBjb21wb25lbnQtbGlrZSBBUEksIGFuZCBpcyB0cmVhdGVkIGxpa2UgYSBjb21wb25lbnRcclxuLy8gaW4gdGhlIGNvbXBpbGVyLCBidXQgaW50ZXJuYWxseSBpdCdzIGEgc3BlY2lhbCBidWlsdC1pbiB0eXBlIHRoYXQgaG9va3NcclxuLy8gZGlyZWN0bHkgaW50byB0aGUgcmVuZGVyZXIuXHJcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcclxuICAgIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcclxuICAgIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXHJcbiAgICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcclxuICAgIC8vIGludGVybmFscy5cclxuICAgIF9faXNTdXNwZW5zZTogdHJ1ZSxcclxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgXHJcbiAgICAvLyBwbGF0Zm9ybS1zcGVjaWZpYyBpbXBsIHBhc3NlZCBmcm9tIHJlbmRlcmVyXHJcbiAgICByZW5kZXJlckludGVybmFscykge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vdW50U3VzcGVuc2UobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxyXG4gICAgY3JlYXRlOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5XHJcbn07XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFN1c3BlbnNlID0gKFN1c3BlbnNlSW1wbFxyXG4gICAgKTtcclxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpKTtcclxuICAgIC8vIHN0YXJ0IG1vdW50aW5nIHRoZSBjb250ZW50IHN1YnRyZWUgaW4gYW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgIHBhdGNoKG51bGwsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAvLyBub3cgY2hlY2sgaWYgd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbnkgYXN5bmMgZGVwc1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XHJcbiAgICAgICAgLy8gaGFzIGFzeW5jXHJcbiAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZS5zc0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgIGlzU1ZHKTtcclxuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU3VzcGVuc2UgaGFzIG5vIGFzeW5jIGRlcHMuIEp1c3QgcmVzb2x2ZS5cclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAobjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZSk7XHJcbiAgICBzdXNwZW5zZS52bm9kZSA9IG4yO1xyXG4gICAgbjIuZWwgPSBuMS5lbDtcclxuICAgIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcclxuICAgIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcclxuICAgIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcclxuICAgIGlmIChwZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gc2FtZSByb290IHR5cGUgYnV0IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgcGF0Y2gocGVuZGluZ0JyYW5jaCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2dnbGVkIGJlZm9yZSBwZW5kaW5nIHRyZWUgaXMgcmVzb2x2ZWRcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdG9nZ2xlZCBiZWZvcmUgaHlkcmF0aW9uIGlzIGZpbmlzaGVkLCB0aGUgY3VycmVudCBET00gdHJlZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHZhbGlkLiBzZXQgaXQgYXMgdGhlIGFjdGl2ZSBicmFuY2ggc28gaXQgd2lsbCBiZSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVzb2x2ZWRcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcGVuZGluZyBJRC4gdGhpcyBpcyB1c2VkIHRvIGludmFsaWRhdGUgYXN5bmMgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHN1c3BlbnNlIHN0YXRlXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGVmZmVjdHMgZnJvbSBwZW5kaW5nIGJyYW5jaFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGluIGZhbGxiYWNrIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGVkIFwiYmFja1wiIHRvIGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSByZXNvbHZlXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoZWQgdG8gYSAzcmQgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAvLyByb290IGRpZCBub3QgY2hhbmdlLCBqdXN0IG5vcm1hbCBwYXRjaFxyXG4gICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBub2RlIHRvZ2dsZWRcclxuICAgICAgICAgICAgLy8gaW52b2tlIEBwZW5kaW5nIGV2ZW50XHJcbiAgICAgICAgICAgIGNvbnN0IG9uUGVuZGluZyA9IG4yLnByb3BzICYmIG4yLnByb3BzLm9uUGVuZGluZztcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25QZW5kaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgb25QZW5kaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbW91bnQgcGVuZGluZyBicmFuY2ggaW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGJyYW5jaCBoYXMgbm8gYXN5bmMgZGVwcywgcmVzb2x2ZSBub3cuXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnQsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY29uc29sZS5pbmZvYCBjYW5ub3QgYmUgbnVsbCBlcnJvclxyXG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiB1bm1vdW50LCBuOiBuZXh0LCBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSB0b051bWJlcih2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50aW1lb3V0KTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0ge1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgaXNTVkcsXHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIGhpZGRlbkNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgZGVwczogMCxcclxuICAgICAgICBwZW5kaW5nSWQ6IDAsXHJcbiAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IC0xLFxyXG4gICAgICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcclxuICAgICAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxyXG4gICAgICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcclxuICAgICAgICBpc0h5ZHJhdGluZyxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgZWZmZWN0czogW10sXHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBwZW5kaW5nSWQsIGVmZmVjdHMsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXN1bWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbml0aWFsIGFuY2hvciBvbiBtb3VudFxyXG4gICAgICAgICAgICAgICAgbGV0IHsgYW5jaG9yIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgdHJlZVxyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmYWxsYmFjayB0cmVlIHdhcyBtb3VudGVkLCBpdCBtYXkgaGF2ZSBiZWVuIG1vdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcGFydCBvZiBhIHBhcmVudCBzdXNwZW5zZS4gZ2V0IHRoZSBsYXRlc3QgYW5jaG9yIGZvciBpbnNlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBjb250ZW50IGZyb20gb2ZmLWRvbSBjb250YWluZXIgdG8gYWN0dWFsIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyZWQgZWZmZWN0c1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlXHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgbWVyZ2UgYnVmZmVyZWQgcG9zdCBqb2JzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byB0aGF0IHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIGZsdXNoIGFsbCBqb2JzXHJcbiAgICAgICAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEByZXNvbHZlIGV2ZW50XHJcbiAgICAgICAgICAgIGNvbnN0IG9uUmVzb2x2ZSA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uUmVzb2x2ZTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25SZXNvbHZlKSkge1xyXG4gICAgICAgICAgICAgICAgb25SZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaXNTVkcgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAvLyBpbnZva2UgQGZhbGxiYWNrIGV2ZW50XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRmFsbGJhY2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vbkZhbGxiYWNrO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvbkZhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgb25GYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIGZhbGxiYWNrVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcclxuICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgYnJhbmNoXHJcbiAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcclxuICAgICAgICAgICAgdHJ1ZSAvLyBzaG91bGRSZW1vdmVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudEZhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdmUoY29udGFpbmVyLCBhbmNob3IsIHR5cGUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHR5cGUpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcclxuICAgICAgICAgICAgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgIC5hc3luY0RlcC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luY1NldHVwUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdoZW4gdGhlIHNldHVwKCkgcHJvbWlzZSByZXNvbHZlcy5cclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIHVubW91bnRlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgZnJvbSB0aGlzIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkIGlmIGFuIHVwZGF0ZSBoYXBwZW5lZCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXN5bmMgZGVwIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXHJcbiAgICAgICAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksIHN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlLmVsKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gc3VzcGVuc2U7XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBub2RlLnBhcmVudE5vZGUsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBudWxsLCBpc1NWRywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pKTtcclxuICAgIC8vIHRoZXJlIGFyZSB0d28gcG9zc2libGUgc2NlbmFyaW9zIGZvciBzZXJ2ZXItcmVuZGVyZWQgc3VzcGVuc2U6XHJcbiAgICAvLyAtIHN1Y2Nlc3M6IHNzciBjb250ZW50IHNob3VsZCBiZSBmdWxseSByZXNvbHZlZFxyXG4gICAgLy8gLSBmYWlsdXJlOiBzc3IgY29udGVudCBzaG91bGQgYmUgdGhlIGZhbGxiYWNrIGJyYW5jaC5cclxuICAgIC8vIGhvd2V2ZXIsIG9uIHRoZSBjbGllbnQgd2UgZG9uJ3QgcmVhbGx5IGtub3cgaWYgaXQgaGFzIGZhaWxlZCBvciBub3RcclxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgRE9NIGFzc3VtaW5nIGl0IGhhcyBzdWNjZWVkZWQsIGJ1dCB3ZSBzdGlsbFxyXG4gICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBzdXNwZW5zZSBib3VuZGFyeSBmaXJzdFxyXG4gICAgY29uc3QgcmVzdWx0ID0gaHlkcmF0ZU5vZGUobm9kZSwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICBsZXQgZmFsbGJhY2s7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb250ZW50ID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmRlZmF1bHQpO1xyXG4gICAgICAgIGZhbGxiYWNrID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4pO1xyXG4gICAgICAgIGZhbGxiYWNrID0gbm9ybWFsaXplVk5vZGUobnVsbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgZmFsbGJhY2tcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgcyA9IHMoKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHMpKSB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXNpbmdsZUNoaWxkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVZOb2RlKHMpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xyXG4gICAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShmbikpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcclxuICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XHJcbiAgICBjb25zdCBlbCA9ICh2bm9kZS5lbCA9IGJyYW5jaC5lbCk7XHJcbiAgICAvLyBpbiBjYXNlIHN1c3BlbnNlIGlzIHRoZSByb290IG5vZGUgb2YgYSBjb21wb25lbnQsXHJcbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdGhlIEhPQyBlbFxyXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcclxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XHJcbiAgICB9XHJcbn1cblxubGV0IGlzUmVuZGVyaW5nQ29tcGlsZWRTbG90ID0gMDtcclxuY29uc3Qgc2V0Q29tcGlsZWRTbG90UmVuZGVyaW5nID0gKG4pID0+IChpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdCArPSBuKTtcclxuLyoqXHJcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgYDxzbG90Lz5gXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBcclxuLy8gdGhpcyBpcyBub3QgYSB1c2VyLWZhY2luZyBmdW5jdGlvbiwgc28gdGhlIGZhbGxiYWNrIGlzIGFsd2F5cyBnZW5lcmF0ZWQgYnlcclxuLy8gdGhlIGNvbXBpbGVyIGFuZCBndWFyYW50ZWVkIHRvIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5XHJcbmZhbGxiYWNrKSB7XHJcbiAgICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHdhcm4oYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIGAgK1xyXG4gICAgICAgICAgICBgcGFyZW50IHRlbXBsYXRlLmApO1xyXG4gICAgICAgIHNsb3QgPSAoKSA9PiBbXTtcclxuICAgIH1cclxuICAgIC8vIGEgY29tcGlsZWQgc2xvdCBkaXNhYmxlcyBibG9jayB0cmFja2luZyBieSBkZWZhdWx0IHRvIGF2b2lkIG1hbnVhbFxyXG4gICAgLy8gaW52b2NhdGlvbiBpbnRlcmZlcmluZyB3aXRoIHRlbXBsYXRlLWJhc2VkIGJsb2NrIHRyYWNraW5nLCBidXQgaW5cclxuICAgIC8vIGByZW5kZXJTbG90YCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGl0J3MgdGVtcGxhdGUtYmFzZWQgc28gd2UgY2FuIGZvcmNlXHJcbiAgICAvLyBlbmFibGUgaXQuXHJcbiAgICBpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdCsrO1xyXG4gICAgb3BlbkJsb2NrKCk7XHJcbiAgICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcclxuICAgIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soRnJhZ21lbnQsIHsga2V5OiBwcm9wcy5rZXkgfHwgYF8ke25hbWV9YCB9LCB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSAvKiBTVEFCTEUgKi9cclxuICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgIDogLTIgLyogQkFJTCAqLyk7XHJcbiAgICBpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdC0tO1xyXG4gICAgcmV0dXJuIHJlbmRlcmVkO1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XHJcbiAgICByZXR1cm4gdm5vZGVzLnNvbWUoY2hpbGQgPT4ge1xyXG4gICAgICAgIGlmICghaXNWTm9kZShjaGlsZCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmXHJcbiAgICAgICAgICAgICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSlcclxuICAgICAgICA/IHZub2Rlc1xyXG4gICAgICAgIDogbnVsbDtcclxufVxuXG4vKipcclxuICogV3JhcCBhIHNsb3QgZnVuY3Rpb24gdG8gbWVtb2l6ZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICBpZiAoIWN0eClcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAvLyBJZiBhIHVzZXIgY2FsbHMgYSBjb21waWxlZCBzbG90IGluc2lkZSBhIHRlbXBsYXRlIGV4cHJlc3Npb24gKCMxNzQ1KSwgaXRcclxuICAgICAgICAvLyBjYW4gbWVzcyB1cCBibG9jayB0cmFja2luZywgc28gYnkgZGVmYXVsdCB3ZSBuZWVkIHRvIHB1c2ggYSBudWxsIGJsb2NrIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgdGhhdC4gVGhpcyBpc24ndCBuZWNlc3NhcnkgaWYgcmVuZGVyaW5nIGEgY29tcGlsZWQgYDxzbG90PmAuXHJcbiAgICAgICAgaWYgKCFpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdCkge1xyXG4gICAgICAgICAgICBvcGVuQmxvY2sodHJ1ZSAvKiBudWxsIGJsb2NrIHRoYXQgZGlzYWJsZXMgdHJhY2tpbmcgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcclxuICAgICAgICBjb25zdCByZXMgPSBmbiguLi5hcmdzKTtcclxuICAgICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uob3duZXIpO1xyXG4gICAgICAgIGlmICghaXNSZW5kZXJpbmdDb21waWxlZFNsb3QpIHtcclxuICAgICAgICAgICAgY2xvc2VCbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XHJcbn1cblxuLy8gU0ZDIHNjb3BlZCBzdHlsZSBJRCBtYW5hZ2VtZW50LlxyXG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xyXG5jb25zdCBzY29wZUlkU3RhY2sgPSBbXTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xyXG4gICAgc2NvcGVJZFN0YWNrLnB1c2goKGN1cnJlbnRTY29wZUlkID0gaWQpKTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XHJcbiAgICBzY29wZUlkU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IHNjb3BlSWRTdGFja1tzY29wZUlkU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhTY29wZUlkKGlkKSB7XHJcbiAgICByZXR1cm4gKChmbikgPT4gd2l0aEN0eChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHVzaFNjb3BlSWQoaWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcG9wU2NvcGVJZCgpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9KSk7XHJcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgLy8gcmVzdWx0IG9mIGJpdHdpc2UgZmxhZyBjb21wYXJpc29uXHJcbmlzU1NSID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHByb3BzID0ge307XHJcbiAgICBjb25zdCBhdHRycyA9IHt9O1xyXG4gICAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XHJcbiAgICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xyXG4gICAgLy8gdmFsaWRhdGlvblxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcHMocHJvcHMsIGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGlmIChpc1N0YXRlZnVsKSB7XHJcbiAgICAgICAgLy8gc3RhdGVmdWxcclxuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiBzaGFsbG93UmVhY3RpdmUocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gb3B0aW9uYWwgcHJvcHMsIHByb3BzID09PSBhdHRyc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBkZWNsYXJlZCBwcm9wc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wcywgYXR0cnMsIHZub2RlOiB7IHBhdGNoRmxhZyB9IH0gPSBpbnN0YW5jZTtcclxuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGlmIChcclxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XHJcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxyXG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcclxuICAgICEoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgKGluc3RhbmNlLnR5cGUuX19obXJJZCB8fFxyXG4gICAgICAgICAgICAoaW5zdGFuY2UucGFyZW50ICYmIGluc3RhbmNlLnBhcmVudC50eXBlLl9faG1ySWQpKSkgJiZcclxuICAgICAgICAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmXHJcbiAgICAgICAgIShwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXBpbGVyLWdlbmVyYXRlZCBwcm9wcyAmIG5vIGtleXMgY2hhbmdlLCBqdXN0IHNldCB0aGUgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyB0aGUgcHJvcHMuXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgIC8vIFBST1BTIGZsYWcgZ3VhcmFudGVlcyByYXdQcm9wcyB0byBiZSBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyIC8gcHJvcHMgc2VwYXJhdGlvbiB3YXMgZG9uZSBvbiBpbml0IGFuZCB3aWxsIGJlIGNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNvZGUgcGF0aCwgc28ganVzdCBjaGVjayBpZiBhdHRycyBoYXZlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBjYW1lbGl6ZWRLZXksIHZhbHVlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZnVsbCBwcm9wcyB1cGRhdGUuXHJcbiAgICAgICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcclxuICAgICAgICAvLyBpbiBjYXNlIG9mIGR5bmFtaWMgcHJvcHMsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIGtleXMgZnJvbVxyXG4gICAgICAgIC8vIHRoZSBwcm9wcyBvYmplY3RcclxuICAgICAgICBsZXQga2ViYWJLZXk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcclxuICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXHJcbiAgICAgICAgICAgICAgICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGtlYmFiLWNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3UHJvcHMgfHwgRU1QVFlfT0JKLCBrZXksIHVuZGVmaW5lZCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZ1bmN0aW9uYWwgY29tcG9uZW50IHcvbyBwcm9wcyBkZWNsYXJhdGlvbiwgcHJvcHMgYW5kXHJcbiAgICAgICAgLy8gYXR0cnMgcG9pbnQgdG8gdGhlIHNhbWUgb2JqZWN0IHNvIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHRyaWdnZXIgdXBkYXRlcyBmb3IgJGF0dHJzIGluIGNhc2UgaXQncyB1c2VkIGluIGNvbXBvbmVudCBzbG90c1xyXG4gICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiAvKiBTRVQgKi8sICckYXR0cnMnKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcmF3UHJvcHMpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XHJcbiAgICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgLy8ga2V5LCByZWYgYXJlIHJlc2VydmVkIGFuZCBuZXZlciBwYXNzZWQgZG93blxyXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcCBvcHRpb24gbmFtZXMgYXJlIGNhbWVsaXplZCBkdXJpbmcgbm9ybWFsaXphdGlvbiwgc28gdG8gc3VwcG9ydFxyXG4gICAgICAgICAgICAvLyBrZWJhYiAtPiBjYW1lbCBjb252ZXJzaW9uIGhlcmUgd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUga2V5LlxyXG4gICAgICAgICAgICBsZXQgY2FtZWxLZXk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAoY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFueSBub24tZGVjbGFyZWQgKGVpdGhlciBhcyBhIHByb3Agb3IgYW4gZW1pdHRlZCBldmVudCkgcHJvcHMgYXJlIHB1dFxyXG4gICAgICAgICAgICAgICAgLy8gaW50byBhIHNlcGFyYXRlIGBhdHRyc2Agb2JqZWN0IGZvciBzcHJlYWRpbmcuIE1ha2Ugc3VyZSB0byBwcmVzZXJ2ZVxyXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwga2V5IGNhc2luZ1xyXG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5lZWRDYXN0S2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywga2V5LCByYXdDdXJyZW50UHJvcHNba2V5XSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHByb3BzLCBrZXksIHZhbHVlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgaWYgKG9wdCAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXNcclxuICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xyXG4gICAgICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093bihwcm9wcywga2V5KSAmJiAhaGFzRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiZcclxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGlmICghYXBwQ29udGV4dC5kZW9wdCAmJiBjb21wLl9fcHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gY29tcC5fX3Byb3BzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcclxuICAgIGNvbnN0IG5lZWRDYXN0S2V5cyA9IFtdO1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3KSA9PiB7XHJcbiAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChrZXlzKVxyXG4gICAgICAgICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2goLi4ua2V5cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIHJldHVybiAoY29tcC5fX3Byb3BzID0gRU1QVFlfQVJSKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguYCwgcmF3W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyYXcpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChyYXcpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IChub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID1cclxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IG9wdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wIG5lZWRzIGJvb2xlYW4gY2FzdGluZyBvciBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xIHx8IGhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoY29tcC5fX3Byb3BzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c10pO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XHJcbiAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gdXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIHR5cGUgY29uc3RydWN0b3JzXHJcbi8vIHNvIHRoYXQgaXQgd29ya3MgYWNyb3NzIHZtcyAvIGlmcmFtZXMuXHJcbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xyXG4gICAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgaWYgKGlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHByb3BzLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcmF3VmFsdWVzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgIGlmIChvcHQgPT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wKGtleSwgcmF3VmFsdWVzW2tleV0sIG9wdCwgIWhhc093bihyYXdWYWx1ZXMsIGtleSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yIH0gPSBwcm9wO1xyXG4gICAgLy8gcmVxdWlyZWQhXHJcbiAgICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcclxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBtaXNzaW5nIGJ1dCBvcHRpb25hbFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB0eXBlIGNoZWNrXHJcbiAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xyXG4gICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGFzIGxvbmcgYXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMgbWF0Y2hcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xyXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGN1c3RvbSB2YWxpZGF0b3JcclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludCcpO1xyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIGxldCB2YWxpZDtcclxuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XHJcbiAgICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcclxuICAgICAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcclxuICAgICAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xyXG4gICAgICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpfWA7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcclxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXHJcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcclxuICAgIH1cclxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXHJcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xyXG4gICAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XHJcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xyXG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xyXG4gICAgICAgIC8vIGNhY2hlIHRoZSBlcnJvciBoYW5kbGluZyB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZSBob29rXHJcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXHJcbiAgICAgICAgLy8gaGFuZGxpbmdcIi5cclxuICAgICAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHxcclxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50SW5zdGFuY2UgZHVyaW5nIGhvb2sgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGUgaG9vayBkb2VzIG5vdCBzeW5jaHJvbm91c2x5IHRyaWdnZXIgb3RoZXIgaG9va3MsIHdoaWNoXHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcmVwZW5kKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cmFwcGVkSG9vaztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5nc1t0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCAnJykpO1xyXG4gICAgICAgIHdhcm4oYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcclxuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXHJcbiAgICAgICAgICAgIGBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArXHJcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IFxyXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUlxyXG4haXNJblNTUkNvbXBvbmVudFNldHVwICYmIGluamVjdEhvb2sobGlmZWN5Y2xlLCBob29rLCB0YXJnZXQpO1xyXG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIgLyogQkVGT1JFX01PVU5UICovKTtcclxuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIiAvKiBNT1VOVEVEICovKTtcclxuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFwiYnVcIiAvKiBCRUZPUkVfVVBEQVRFICovKTtcclxuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIiAvKiBVUERBVEVEICovKTtcclxuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcImJ1bVwiIC8qIEJFRk9SRV9VTk1PVU5UICovKTtcclxuY29uc3Qgb25Vbm1vdW50ZWQgPSBjcmVhdGVIb29rKFwidW1cIiAvKiBVTk1PVU5URUQgKi8pO1xyXG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovKTtcclxuY29uc3Qgb25FcnJvckNhcHR1cmVkID0gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xyXG4gICAgaW5qZWN0SG9vayhcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi8sIGhvb2ssIHRhcmdldCk7XHJcbn07XG5cbi8vIFNpbXBsZSBlZmZlY3QuXHJcbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcclxufVxyXG4vLyBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycyB0byB0cmlnZ2VyIG9uIHVuZGVmaW5lZCBpbml0aWFsIHZhbHVlc1xyXG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcclxuICAgICAgICB3YXJuKGBcXGB3YXRjaChmbiwgb3B0aW9ucz8pXFxgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBgICtcclxuICAgICAgICAgICAgYHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25UcmFjaywgb25UcmlnZ2VyIH0gPSBFTVBUWV9PQkosIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWVwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsIHMsIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBgICtcclxuICAgICAgICAgICAgYGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gKTtcclxuICAgIH07XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gISFzb3VyY2UuX3NoYWxsb3c7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2U7XHJcbiAgICAgICAgZGVlcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHMsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLywgW1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLywgW1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHlcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbb25JbnZhbGlkYXRlXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gTk9PUDtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcclxuICAgIH1cclxuICAgIGlmIChjYiAmJiBkZWVwKSB7XHJcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNsZWFudXA7XHJcbiAgICBjb25zdCBvbkludmFsaWRhdGUgPSAoZm4pID0+IHtcclxuICAgICAgICBjbGVhbnVwID0gcnVubmVyLm9wdGlvbnMub25TdG9wID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCA0IC8qIFdBVENIX0NMRUFOVVAgKi8pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgbGV0IG9sZFZhbHVlID0gaXNBcnJheShzb3VyY2UpID8gW10gOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XHJcbiAgICBjb25zdCBqb2IgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFydW5uZXIuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoKHNvdXJjZSwgY2IpXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcnVubmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChkZWVwIHx8IGZvcmNlVHJpZ2dlciB8fCBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdW5kZWZpbmVkIDogb2xkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25JbnZhbGlkYXRlXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoRWZmZWN0XHJcbiAgICAgICAgICAgIHJ1bm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBpbXBvcnRhbnQ6IG1hcmsgdGhlIGpvYiBhcyBhIHdhdGNoZXIgY2FsbGJhY2sgc28gdGhhdCBzY2hlZHVsZXIga25vd3NcclxuICAgIC8vIGl0IGlzIGFsbG93ZWQgdG8gc2VsZi10cmlnZ2VyICgjMTcyNylcclxuICAgIGpvYi5hbGxvd1JlY3Vyc2UgPSAhIWNiO1xyXG4gICAgbGV0IHNjaGVkdWxlcjtcclxuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XHJcbiAgICAgICAgc2NoZWR1bGVyID0gam9iO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGRlZmF1bHQ6ICdwcmUnXHJcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8IGluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcXVldWVQcmVGbHVzaENiKGpvYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aXRoICdwcmUnIG9wdGlvbiwgdGhlIGZpcnN0IGNhbGwgbXVzdCBoYXBwZW4gYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgc28gaXQgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkuXHJcbiAgICAgICAgICAgICAgICBqb2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW5uZXIgPSBlZmZlY3QoZ2V0dGVyLCB7XHJcbiAgICAgICAgbGF6eTogdHJ1ZSxcclxuICAgICAgICBvblRyYWNrLFxyXG4gICAgICAgIG9uVHJpZ2dlcixcclxuICAgICAgICBzY2hlZHVsZXJcclxuICAgIH0pO1xyXG4gICAgcmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdChydW5uZXIsIGluc3RhbmNlKTtcclxuICAgIC8vIGluaXRpYWwgcnVuXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGpvYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSBydW5uZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHJ1bm5lciwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcnVubmVyKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHN0b3AocnVubmVyKTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmVtb3ZlKGluc3RhbmNlLmVmZmVjdHMsIHJ1bm5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyB0aGlzLiR3YXRjaFxyXG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xyXG4gICAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKVxyXG4gICAgICAgID8gKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdXHJcbiAgICAgICAgOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzKTtcclxuICAgIHJldHVybiBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucywgdGhpcyk7XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIHNlZW4gPSBuZXcgU2V0KCkpIHtcclxuICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHNlZW4uaGFzKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNlZW4uYWRkKHZhbHVlKTtcclxuICAgIGlmIChpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcclxuICAgIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNMZWF2aW5nOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGxlYXZpbmdWTm9kZXM6IG5ldyBNYXAoKVxyXG4gICAgfTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbn1cclxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcclxuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xyXG4gICAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbW9kZTogU3RyaW5nLFxyXG4gICAgICAgIGFwcGVhcjogQm9vbGVhbixcclxuICAgICAgICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXHJcbiAgICAgICAgLy8gZW50ZXJcclxuICAgICAgICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGxlYXZlXHJcbiAgICAgICAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICAvLyBhcHBlYXJcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZUcmFuc2l0aW9uS2V5O1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHRyYWNrIHJlYWN0aXZpdHkgZm9yIHRoZXNlIHByb3BzIHNvIHVzZSB0aGUgcmF3XHJcbiAgICAgICAgICAgIC8vIHByb3BzIGZvciBhIGJpdCBiZXR0ZXIgcGVyZlxyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcclxuICAgICAgICAgICAgLy8gY2hlY2sgbW9kZVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1vZGUgJiYgIVsnaW4tb3V0JywgJ291dC1pbicsICdkZWZhdWx0J10uaW5jbHVkZXMobW9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGNoaWxkcmVuIGhhcyBhIGd1YXJhbnRlZWQgbGVuZ3RoIG9mIDEuXHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiA8dHJhbnNpdGlvbj48a2VlcC1hbGl2ZS8+PC90cmFuc2l0aW9uPiwgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0eXBlIG9mIHRoZSBrZXB0LWFsaXZlIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0S2VlcEFsaXZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcclxuICAgICAgICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2VHJhbnNpdGlvbktleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtb2RlXHJcbiAgICAgICAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmXHJcbiAgICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiZcclxuICAgICAgICAgICAgICAgICghaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpIHx8IHRyYW5zaXRpb25LZXlDaGFuZ2VkKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvbGQgdHJlZSdzIGhvb2tzIGluIGNhc2Ugb2YgZHluYW1pYyB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGluZyBiZXR3ZWVuIGRpZmZlcmVudCB2aWV3c1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCBvbGRJbm5lckNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFybHkgcmVtb3ZhbCBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xyXG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xyXG4gICAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcclxuICAgIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcclxuICAgIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcclxufVxyXG4vLyBUaGUgdHJhbnNpdGlvbiBob29rcyBhcmUgYXR0YWNoZWQgdG8gdGhlIHZub2RlIGFzIHZub2RlLnRyYW5zaXRpb25cclxuLy8gYW5kIHdpbGwgYmUgY2FsbGVkIGF0IGFwcHJvcHJpYXRlIHRpbWluZyBpbiB0aGUgcmVuZGVyZXIuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgYXBwZWFyLCBtb2RlLCBwZXJzaXN0ZWQgPSBmYWxzZSwgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25BZnRlckVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkJlZm9yZUxlYXZlLCBvbkxlYXZlLCBvbkFmdGVyTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyLCBvbkFwcGVhciwgb25BZnRlckFwcGVhciwgb25BcHBlYXJDYW5jZWxsZWQgfSA9IHByb3BzO1xyXG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XHJcbiAgICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgaG9vayAmJlxyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi8sIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGhvb2tzID0ge1xyXG4gICAgICAgIG1vZGUsXHJcbiAgICAgICAgcGVyc2lzdGVkLFxyXG4gICAgICAgIGJlZm9yZUVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGxldCBob29rID0gb25CZWZvcmVFbnRlcjtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rID0gb25CZWZvcmVBcHBlYXIgfHwgb25CZWZvcmVFbnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3Igc2FtZSBlbGVtZW50ICh2LXNob3cpXHJcbiAgICAgICAgICAgIGlmIChlbC5fbGVhdmVDYikge1xyXG4gICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IodHJ1ZSAvKiBjYW5jZWxsZWQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciB0b2dnbGVkIGVsZW1lbnQgd2l0aCBzYW1lIGtleSAodi1pZilcclxuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGUgJiZcclxuICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBlYXJseSByZW1vdmFsIChub3QgY2FuY2VsbGVkKVxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlcihlbCkge1xyXG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XHJcbiAgICAgICAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XHJcbiAgICAgICAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2VudGVyQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzLmRlbGF5ZWRMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICAgICAgaG9vayhlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVhdmUoZWwsIHJlbW92ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGVsLl9lbnRlckNiKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzVW5tb3VudGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9PT0gdm5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9IHZub2RlO1xyXG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgb25MZWF2ZShlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob25MZWF2ZS5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmUodm5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gaG9va3M7XHJcbn1cclxuLy8gdGhlIHBsYWNlaG9sZGVyIHJlYWxseSBvbmx5IGhhbmRsZXMgb25lIHNwZWNpYWwgY2FzZTogS2VlcEFsaXZlXHJcbi8vIGluIHRoZSBjYXNlIG9mIGEgS2VlcEFsaXZlIGluIGEgbGVhdmUgcGhhc2Ugd2UgbmVlZCB0byByZXR1cm4gYSBLZWVwQWxpdmVcclxuLy8gcGxhY2Vob2xkZXIgd2l0aCBlbXB0eSBjb250ZW50IHRvIGF2b2lkIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZnJvbSBiZWluZ1xyXG4vLyB1bm1vdW50ZWQuXHJcbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcclxuICAgIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcclxuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcclxuICAgIHJldHVybiBpc0tlZXBBbGl2ZSh2bm9kZSlcclxuICAgICAgICA/IHZub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgID8gdm5vZGUuY2hpbGRyZW5bMF1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWRcclxuICAgICAgICA6IHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyAmJiB2bm9kZS5jb21wb25lbnQpIHtcclxuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGhvb2tzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcclxuICAgICAgICB2bm9kZS5zc0ZhbGxiYWNrLnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0ZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGRyZW4sIGtlZXBDb21tZW50ID0gZmFsc2UpIHtcclxuICAgIGxldCByZXQgPSBbXTtcclxuICAgIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLylcclxuICAgICAgICAgICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xyXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29tbWVudCBwbGFjZWhvbGRlcnMgc2hvdWxkIGJlIHNraXBwZWQsIGUuZy4gdi1pZlxyXG4gICAgICAgIGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICMxMTI2IGlmIGEgdHJhbnNpdGlvbiBjaGlsZHJlbiBsaXN0IGNvbnRhaW5zIG11bHRpcGxlIHN1YiBmcmFnbWVudHMsIHRoZXNlXHJcbiAgICAvLyBmcmFnbWVudHMgd2lsbCBiZSBtZXJnZWQgaW50byBhIGZsYXQgY2hpbGRyZW4gYXJyYXkuIFNpbmNlIGVhY2ggdi1mb3JcclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXHJcbiAgICAvLyB0aGVzZSBjaGlsZHJlbiB0byBmb3JjZSBmdWxsIGRpZmZzIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLlxyXG4gICAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTIgLyogQkFJTCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XHJcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XHJcbiAgICBuYW1lOiBgS2VlcEFsaXZlYCxcclxuICAgIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XHJcbiAgICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxyXG4gICAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxyXG4gICAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICAgICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXHJcbiAgICB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcclxuICAgICAgICAvLyBLZWVwQWxpdmUgY29tbXVuaWNhdGVzIHdpdGggdGhlIGluc3RhbnRpYXRlZCByZW5kZXJlciB2aWEgdGhlXHJcbiAgICAgICAgLy8gY3R4IHdoZXJlIHRoZSByZW5kZXJlciBwYXNzZXMgaW4gaXRzIGludGVybmFscyxcclxuICAgICAgICAvLyBhbmQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBleHBvc2VzIGFjdGl2YXRlL2RlYWN0aXZhdGUgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgIC8vIFRoZSB3aG9sZSBwb2ludCBvZiB0aGlzIGlzIHRvIGF2b2lkIGltcG9ydGluZyBLZWVwQWxpdmUgZGlyZWN0bHkgaW4gdGhlXHJcbiAgICAgICAgLy8gcmVuZGVyZXIgdG8gZmFjaWxpdGF0ZSB0cmVlLXNoYWtpbmcuXHJcbiAgICAgICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcclxuICAgICAgICBjb25zdCB7IHJlbmRlcmVyOiB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogX3VubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gfSA9IHNoYXJlZENvbnRleHQ7XHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHByb3BzIGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICBwYXRjaChpbnN0YW5jZS52bm9kZSwgdm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5hKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlLnBhcmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEgLyogTEVBVkUgKi8sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc2hhcGVGbGFnIHNvIGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcclxuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IGNhY2hlZC50eXBlICE9PSBjdXJyZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBpbnN0YW5jZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGtlcHQtYWxpdmUuXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1bm1vdW50IGl0IG5vdyBidXQgaXQgbWlnaHQgYmUgbGF0ZXIsIHNvIHJlc2V0IGl0cyBmbGFnIG5vdy5cclxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwcnVuZSBjYWNoZSBvbiBpbmNsdWRlL2V4Y2x1ZGUgcHJvcCBjaGFuZ2VcclxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcclxuICAgICAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICB9LCBcclxuICAgICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxyXG4gICAgICAgIHsgZmx1c2g6ICdwb3N0JywgZGVlcDogdHJ1ZSB9KTtcclxuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcclxuICAgICAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goY2FjaGVkID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpbnN0YW5jZSB3aWxsIGJlIHVubW91bnRlZCBhcyBwYXJ0IG9mIGtlZXAtYWxpdmUncyB1bm1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnZva2UgaXRzIGRlYWN0aXZhdGVkIGhvb2sgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAoIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXApO1xyXG4gICAgICAgICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGlmICgoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgLy8gY2xvbmUgdm5vZGUgaWYgaXQncyByZXVzZWQgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gbXV0YXRlIGl0XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAjMTUxMyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgcmV0dXJuZWQgdm5vZGUgdG8gYmUgY2xvbmVkIGR1ZSB0byBhdHRyXHJcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoIG9yIHNjb3BlSWQsIHNvIHRoZSB2bm9kZSBoZXJlIG1heSBub3QgYmUgdGhlIGZpbmFsIHZub2RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbW91bnRlZC4gSW5zdGVhZCBvZiBjYWNoaW5nIGl0IGRpcmVjdGx5LCB3ZSBzdG9yZSB0aGUgcGVuZGluZ1xyXG4gICAgICAgICAgICAvLyBrZXkgYW5kIGNhY2hlIGBpbnN0YW5jZS5zdWJUcmVlYCAodGhlIG5vcm1hbGl6ZWQgdm5vZGUpIGluXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZU1vdW50L2JlZm9yZVVwZGF0ZSBob29rcy5cclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBtb3VudGVkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdHJhbnNpdGlvbiBob29rcyBvbiBzdWJUcmVlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIG1vdW50ZWQgYXMgZnJlc2hcclxuICAgICAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMga2V5IHRoZSBmcmVzaGVzdFxyXG4gICAgICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyB1bm1vdW50ZWRcclxuICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xyXG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcclxuICAgIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0dGVybi50ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIgLyogQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiIC8qIERFQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIC8vIGNhY2hlIHRoZSBkZWFjdGl2YXRlIGJyYW5jaCBjaGVjayB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZVxyXG4gICAgLy8gaG9vayBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2RjXCIgc3RhbmRzIGZvciBcIndpdGhcclxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxyXG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8XHJcbiAgICAgICAgKGhvb2suX193ZGMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhvb2soKTtcclxuICAgICAgICB9KTtcclxuICAgIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XHJcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcclxuICAgIC8vIGNoYWluIGFuZCByZWdpc3RlciBpdCBvbiBhbGwgYW5jZXN0b3IgaW5zdGFuY2VzIHRoYXQgYXJlIGtlZXAtYWxpdmUgcm9vdHMuXHJcbiAgICAvLyBUaGlzIGF2b2lkcyB0aGUgbmVlZCB0byB3YWxrIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUgd2hlbiBpbnZva2luZyB0aGVzZVxyXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxyXG4gICAgLy8gYXJyYXlzLlxyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XHJcbiAgICAvLyBpbmplY3RIb29rIHdyYXBzIHRoZSBvcmlnaW5hbCBmb3IgZXJyb3IgaGFuZGxpbmcsIHNvIG1ha2Ugc3VyZSB0byByZW1vdmVcclxuICAgIC8vIHRoZSB3cmFwcGVkIHZlcnNpb24uXHJcbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcclxuICAgIG9uVW5tb3VudGVkKCgpID0+IHtcclxuICAgICAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xyXG4gICAgfSwgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xyXG4gICAgbGV0IHNoYXBlRmxhZyA9IHZub2RlLnNoYXBlRmxhZztcclxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLztcclxuICAgIH1cclxuICAgIHZub2RlLnNoYXBlRmxhZyA9IHNoYXBlRmxhZztcclxufVxyXG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XHJcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gJ18nIHx8IGtleSA9PT0gJyRzdGFibGUnO1xyXG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpXHJcbiAgICA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSlcclxuICAgIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XHJcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHdpdGhDdHgoKHByb3BzKSA9PiB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHdhcm4oYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogYCArXHJcbiAgICAgICAgICAgIGB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBgICtcclxuICAgICAgICAgICAgYEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KHByb3BzKSk7XHJcbn0sIGN0eCk7XHJcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cykgPT4ge1xyXG4gICAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XHJcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSkge1xyXG4gICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBgICtcclxuICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XHJcbiAgICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSBjaGlsZHJlbjtcclxuICAgICAgICAgICAgLy8gbWFrZSBjb21waWxlciBtYXJrZXIgbm9uLWVudW1lcmFibGVcclxuICAgICAgICAgICAgZGVmKGNoaWxkcmVuLCAnXycsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIChpbnN0YW5jZS5zbG90cyA9IHt9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlZihpbnN0YW5jZS5zbG90cywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG59O1xyXG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcclxuICAgIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XHJcbiAgICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gY29tcGlsZWQgc2xvdHMuXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IHdhcyBITVIgdXBkYXRlZCBzbyBzbG90IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBzbG90cyBhbmQgbWFyayBpbnN0YW5jZSBmb3IgaG1yIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBBTkQgc3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUsIGFuZCBza2lwIHN0YWxlIHNsb3RzIHJlbW92YWwuXHJcbiAgICAgICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgYnV0IGR5bmFtaWMgKHYtaWYvdi1mb3Igb24gc2xvdHMpIC0gdXBkYXRlIHNsb3RzLCBidXQgc2tpcFxyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xyXG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gbm9uIHNsb3Qgb2JqZWN0IGNoaWxkcmVuIChkaXJlY3QgdmFsdWUpIHBhc3NlZCB0byBhIGNvbXBvbmVudFxyXG4gICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcclxuICAgIH1cclxuICAgIC8vIGRlbGV0ZSBzdGFsZSBzbG90c1xyXG4gICAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cbi8qKlxyXG5SdW50aW1lIGhlbHBlciBmb3IgYXBwbHlpbmcgZGlyZWN0aXZlcyB0byBhIHZub2RlLiBFeGFtcGxlIHVzYWdlOlxyXG5cbmNvbnN0IGNvbXAgPSByZXNvbHZlQ29tcG9uZW50KCdjb21wJylcclxuY29uc3QgZm9vID0gcmVzb2x2ZURpcmVjdGl2ZSgnZm9vJylcclxuY29uc3QgYmFyID0gcmVzb2x2ZURpcmVjdGl2ZSgnYmFyJylcclxuXG5yZXR1cm4gd2l0aERpcmVjdGl2ZXMoaChjb21wKSwgW1xyXG4gIFtmb28sIHRoaXMueF0sXHJcbiAgW2JhciwgdGhpcy55XVxyXG5dKVxyXG4qL1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0Jyk7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBkaXJlY3RpdmVzIHRvIGEgVk5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xyXG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcclxuICAgICAgICAgICAgZGlyID0ge1xyXG4gICAgICAgICAgICAgICAgbW91bnRlZDogZGlyLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZDogZGlyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJpbmRpbmdzLnB1c2goe1xyXG4gICAgICAgICAgICBkaXIsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XHJcbiAgICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XHJcbiAgICAgICAgaWYgKG9sZEJpbmRpbmdzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xyXG4gICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4IC8qIERJUkVDVElWRV9IT09LICovLCBbXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCxcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXHJcbiAgICAgICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgICAgIHByZXZWTm9kZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXBwOiBudWxsLFxyXG4gICAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgICAgICBpc05hdGl2ZVRhZzogTk8sXHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXHJcbiAgICAgICAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXHJcbiAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudDogTk8sXHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB3YXJuSGFuZGxlcjogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXhpbnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IHt9LFxyXG4gICAgICAgIHByb3ZpZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXHJcbiAgICB9O1xyXG59XHJcbmxldCB1aWQgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcclxuICAgICAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xyXG4gICAgICAgICAgICByb290UHJvcHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IChjb250ZXh0LmFwcCA9IHtcclxuICAgICAgICAgICAgX3VpZDogdWlkKyssXHJcbiAgICAgICAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXHJcbiAgICAgICAgICAgIF9wcm9wczogcm9vdFByb3BzLFxyXG4gICAgICAgICAgICBfY29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgICAgICBfY29udGV4dDogY29udGV4dCxcclxuICAgICAgICAgICAgdmVyc2lvbixcclxuICAgICAgICAgICAgZ2V0IGNvbmZpZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IGNvbmZpZyh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmdW5jdGlvbi5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1peGluKG1peGluKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnbG9iYWwgbWl4aW4gd2l0aCBwcm9wcy9lbWl0cyBkZS1vcHRpbWl6ZXMgcHJvcHMvZW1pdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiBjYWNoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWl4aW4ucHJvcHMgfHwgbWl4aW4uZW1pdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGVvcHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdNaXhpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6ICcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYXBwIGNvbnRleHQgb24gdGhlIHJvb3QgVk5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIHNldCBvbiB0aGUgcm9vdCBpbnN0YW5jZSBvbiBpbml0aWFsIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhNUiByb290IHJlbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIoY2xvbmVWTm9kZSh2bm9kZSksIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIeWRyYXRlICYmIGh5ZHJhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50LnByb3h5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5tb3VudCgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXIobnVsbCwgYXBwLl9jb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IGFsbG93IHN5bWJvbHMgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNDU4N1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgIH07XHJcbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XHJcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gL3N2Zy8udGVzdChjb250YWluZXIubmFtZXNwYWNlVVJJKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDT01NRU5UICovO1xyXG4vLyBOb3RlOiBoeWRyYXRpb24gaXMgRE9NLXNwZWNpZmljXHJcbi8vIEJ1dCB3ZSBoYXZlIHRvIHBsYWNlIGl0IGluIGNvcmUgZHVlIHRvIHRpZ2h0IGNvdXBsaW5nIHdpdGggY29yZSAtIHNwbGl0dGluZ1xyXG4vLyBpdCBvdXQgY3JlYXRlcyBhIHRvbiBvZiB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4vLyBIeWRyYXRpb24gYWxzbyBkZXBlbmRzIG9uIHNvbWUgcmVuZGVyZXIgaW50ZXJuYWwgbG9naWMgd2hpY2ggbmVlZHMgdG8gYmVcclxuLy8gcGFzc2VkIGluIHZpYSBhcmd1bWVudHMuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBtdDogbW91bnRDb21wb25lbnQsIHA6IHBhdGNoLCBvOiB7IHBhdGNoUHJvcCwgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHJlbW92ZSwgaW5zZXJ0LCBjcmVhdGVDb21tZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNNaXNtYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBpZiAoaGFzTWlzbWF0Y2ggJiYgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgZXJyb3Igc2hvdWxkIHNob3cgdXAgaW4gcHJvZHVjdGlvblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWyc7XHJcbiAgICAgICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc0ZyYWdtZW50U3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgICAgIGNvbnN0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xyXG4gICAgICAgIHZub2RlLmVsID0gbm9kZTtcclxuICAgICAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMyAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gQ2xpZW50OiAke0pTT04uc3RyaW5naWZ5KG5vZGUuZGF0YSl9YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gU2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLyB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgYW5jaG9yLCBhZG9wdCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0aWMgdm5vZGUgaGFzIGl0cyBjb250ZW50IHN0cmlwcGVkIGR1cmluZyBidWlsZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZG9wdCBpdCBmcm9tIHRoZSBzZXJ2ZXItcmVuZGVyZWQgSFRNTC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUub3V0ZXJIVE1MO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGUuc3RhdGljQ291bnQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnR5cGUgIT09IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0dGluZyB1cCB0aGUgcmVuZGVyIGVmZmVjdCwgaWYgdGhlIGluaXRpYWwgdm5vZGUgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyAuZWwgc2V0LCB0aGUgY29tcG9uZW50IHdpbGwgcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGl0cyBzdWItdHJlZS5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc3luYyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkQXN5bmMgPSB2bm9kZS50eXBlLl9fYXN5bmNMb2FkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRBc3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkQXN5bmMoKS50aGVuKGh5ZHJhdGVDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZUNvbXBvbmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGJlIGFzeW5jLCBzbyBpbiB0aGUgY2FzZSBvZiBmcmFnbWVudHMgd2UgY2Fubm90IHJlbHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBjb21wb25lbnQncyByZW5kZXJlZCBvdXRwdXQgdG8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCwgd2UgZG8gYSBsb29rYWhlYWQgdG8gZmluZCB0aGUgZW5kIGFuY2hvciBub2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaXNGcmFnbWVudFN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIocGFyZW50Tm9kZShub2RlKSksIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSG9zdFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gc2tpcCBwcm9wcyAmIGNoaWxkcmVuIGlmIHRoaXMgaXMgaG9pc3RlZCBzdGF0aWMgbm9kZXNcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICE9PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGltaXplZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmIDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiBpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGNsaWNrIGxpc3RlbmVycyAod2hpY2ggaXMgbW9zdCBvZnRlbikgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpbmcgdGhyb3VnaCBwcm9wcy5cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsICdvbkNsaWNrJywgbnVsbCwgcHJvcHMub25DbGljayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdm5vZGUgLyBkaXJlY3RpdmUgaG9va3NcclxuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XHJcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxyXG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKGVsLmZpcnN0Q2hpbGQsIHZub2RlLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTU1JlZCBET00gY29udGFpbnMgbW9yZSBub2RlcyB0aGFuIGl0IHNob3VsZC4gUmVtb3ZlIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gQ2xpZW50OiAke2VsLnRleHRDb250ZW50fVxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gU2VydmVyOiAke3Zub2RlLmNoaWxkcmVufWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbltpXVxyXG4gICAgICAgICAgICAgICAgOiAoY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke2NvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgU1NSZWQgRE9NIGRpZG4ndCBjb250YWluIGVub3VnaCBub2Rlcy4gTW91bnQgdGhlIG1pc3Npbmcgb25lcy5cclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICBjb25zdCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcclxuICAgICAgICAgICAgLy8gYmFjay4gVGhpcyBzaG91bGQgaGF2ZSBsZWQgdG8gbm9kZS9jaGlsZHJlbiBtaXNtYXRjaCB3YXJuaW5ncy5cclxuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XHJcbiAgICAgICAgICAgIGluc2VydCgodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApKSwgY29udGFpbmVyLCBuZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc0ZyYWdtZW50KSA9PiB7XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcXG4tIENsaWVudCB2bm9kZTpgLCB2bm9kZS50eXBlLCBgXFxuLSBTZXJ2ZXIgcmVuZGVyZWQgRE9NOmAsIG5vZGUsIG5vZGUubm9kZVR5cGUgPT09IDMgLyogVEVYVCAqL1xyXG4gICAgICAgICAgICAgICAgPyBgKHRleHQpYFxyXG4gICAgICAgICAgICAgICAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWydcclxuICAgICAgICAgICAgICAgICAgICA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYFxyXG4gICAgICAgICAgICAgICAgICAgIDogYGApO1xyXG4gICAgICAgIHZub2RlLmVsID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNGcmFnbWVudCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhjZXNzaXZlIGZyYWdtZW50IG5vZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgIHJlbW92ZShub2RlKTtcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBuZXh0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpKTtcclxuICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3IgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICdbJylcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xyXG59XG5cbmxldCBzdXBwb3J0ZWQ7XHJcbmxldCBwZXJmO1xyXG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XHJcbiAgICAgICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XHJcbiAgICAgICAgcGVyZi5tYXJrKGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5tZWFzdXJlKGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xyXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xyXG4gICAgaWYgKHN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcclxuICAgIH1cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgaW4gZXNtLWJ1bmRsZXIgYnVpbGRzLlxyXG4gKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHJlbmRlcmVyIGlzIGNyZWF0ZWQsIGluIGBiYXNlQ3JlYXRlUmVuZGVyZXJgIHNvIHRoYXRcclxuICogaW1wb3J0aW5nIHJ1bnRpbWUtY29yZSBpcyBzaWRlLWVmZmVjdHMgZnJlZS5cclxuICpcclxuICogaXN0YW5idWwtaWdub3JlLW5leHRcclxuICovXHJcbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XHJcbiAgICBsZXQgbmVlZFdhcm4gPSBmYWxzZTtcclxuICAgIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgbmVlZFdhcm4gPSB0cnVlO1xyXG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBuZWVkV2FybiA9IHRydWU7XHJcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGAgK1xyXG4gICAgICAgICAgICBgY29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBleHBsaWNpdGx5IHJlcGxhY2UgZmVhdHVyZSBmbGFnIGdsb2JhbHMgYCArXHJcbiAgICAgICAgICAgIGB3aXRoIGJvb2xlYW4gbGl0ZXJhbHMgdG8gZ2V0IHByb3BlciB0cmVlLXNoYWtpbmcgaW4gdGhlIGZpbmFsIGJ1bmRsZS4gYCArXHJcbiAgICAgICAgICAgIGBTZWUgaHR0cDovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MgZm9yIG1vcmUgZGV0YWlscy5gKTtcclxuICAgIH1cclxufVxuXG4vLyBpbXBsZW1lbnRhdGlvbiwgY2xvc2UgdG8gbm8tb3BcclxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8geyBzZXR1cDogb3B0aW9ucywgbmFtZTogb3B0aW9ucy5uYW1lIH0gOiBvcHRpb25zO1xyXG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XHJcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxyXG4gICAgc3VzcGVuc2libGUgPSB0cnVlLCBvbkVycm9yOiB1c2VyT25FcnJvciB9ID0gc291cmNlO1xyXG4gICAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgIGxldCByZXNvbHZlZENvbXA7XHJcbiAgICBsZXQgcmV0cmllcyA9IDA7XHJcbiAgICBjb25zdCByZXRyeSA9ICgpID0+IHtcclxuICAgICAgICByZXRyaWVzKys7XHJcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBsb2FkKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcclxuICAgICAgICBsZXQgdGhpc1JlcXVlc3Q7XHJcbiAgICAgICAgcmV0dXJuIChwZW5kaW5nUmVxdWVzdCB8fFxyXG4gICAgICAgICAgICAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9IGxvYWRlcigpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKGNvbXApID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcclxuICAgICAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxyXG4gICAgICAgIG5hbWU6ICdBc3luY0NvbXBvbmVudFdyYXBwZXInLFxyXG4gICAgICAgIHNldHVwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovLCAhZXJyb3JDb21wb25lbnQgLyogZG8gbm90IHRocm93IGluIGRldiBpZiB1c2VyIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCAqLyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHN1c3BlbnNlLWNvbnRyb2xsZWQgb3IgU1NSLlxyXG4gICAgICAgICAgICBpZiAoKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlKSB8fFxyXG4gICAgICAgICAgICAgICAgKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihjb21wID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCB7IHZub2RlOiB7IHJlZiwgcHJvcHMsIGNoaWxkcmVuIH0gfSkge1xyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xyXG4gICAgLy8gZW5zdXJlIGlubmVyIGNvbXBvbmVudCBpbmhlcml0cyB0aGUgYXN5bmMgd3JhcHBlcidzIHJlZiBvd25lclxyXG4gICAgdm5vZGUucmVmID0gcmVmO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XG5cbmNvbnN0IHByb2RFZmZlY3RPcHRpb25zID0ge1xyXG4gICAgc2NoZWR1bGVyOiBxdWV1ZUpvYixcclxuICAgIC8vICMxODAxLCAjMjA0MyBjb21wb25lbnQgcmVuZGVyIGVmZmVjdHMgc2hvdWxkIGFsbG93IHJlY3Vyc2l2ZSB1cGRhdGVzXHJcbiAgICBhbGxvd1JlY3Vyc2U6IHRydWVcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2RWZmZWN0T3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzY2hlZHVsZXI6IHF1ZXVlSm9iLFxyXG4gICAgICAgIGFsbG93UmVjdXJzZTogdHJ1ZSxcclxuICAgICAgICBvblRyYWNrOiBpbnN0YW5jZS5ydGMgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSkgOiB2b2lkIDAsXHJcbiAgICAgICAgb25UcmlnZ2VyOiBpbnN0YW5jZS5ydGcgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSkgOiB2b2lkIDBcclxuICAgIH07XHJcbn1cclxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2VcclxuICAgIDtcclxuY29uc3Qgc2V0UmVmID0gKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpID0+IHtcclxuICAgIGlmIChpc0FycmF5KHJhd1JlZikpIHtcclxuICAgICAgICByYXdSZWYuZm9yRWFjaCgociwgaSkgPT4gc2V0UmVmKHIsIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSwgcGFyZW50U3VzcGVuc2UsIHZub2RlKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHZhbHVlO1xyXG4gICAgaWYgKCF2bm9kZSB8fCBpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2bm9kZS5jb21wb25lbnQuZXhwb3NlZCB8fCB2bm9kZS5jb21wb25lbnQucHJveHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZub2RlLmVsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhb3duZXIpIHtcclxuICAgICAgICB3YXJuKGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIGAgK1xyXG4gICAgICAgICAgICBgQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xyXG4gICAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IChvd25lci5yZWZzID0ge30pIDogb3duZXIucmVmcztcclxuICAgIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xyXG4gICAgLy8gdW5zZXQgb2xkIHJlZlxyXG4gICAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdHJpbmcocmVmKSkge1xyXG4gICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gIzE3ODk6IGZvciBub24tbnVsbCB2YWx1ZXMsIHNldCB0aGVtIGFmdGVyIHJlbmRlclxyXG4gICAgICAgIC8vIG51bGwgdmFsdWVzIG1lYW5zIHRoaXMgaXMgdW5tb3VudCBhbmQgaXQgc2hvdWxkIG5vdCBvdmVyd3JpdGUgYW5vdGhlclxyXG4gICAgICAgIC8vIHJlZiB3aXRoIHRoZSBzYW1lIGtleVxyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYocmVmKSkge1xyXG4gICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyIC8qIEZVTkNUSU9OX1JFRiAqLywgW3ZhbHVlLCByZWZzXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHZhbHVlLCBgKCR7dHlwZW9mIHZhbHVlfSlgKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFRoZSBjcmVhdGVSZW5kZXJlciBmdW5jdGlvbiBhY2NlcHRzIHR3byBnZW5lcmljIGFyZ3VtZW50czpcclxuICogSG9zdE5vZGUgYW5kIEhvc3RFbGVtZW50LCBjb3JyZXNwb25kaW5nIHRvIE5vZGUgYW5kIEVsZW1lbnQgdHlwZXMgaW4gdGhlXHJcbiAqIGhvc3QgZW52aXJvbm1lbnQuIEZvciBleGFtcGxlLCBmb3IgcnVudGltZS1kb20sIEhvc3ROb2RlIHdvdWxkIGJlIHRoZSBET01cclxuICogYE5vZGVgIGludGVyZmFjZSBhbmQgSG9zdEVsZW1lbnQgd291bGQgYmUgdGhlIERPTSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBDdXN0b20gcmVuZGVyZXJzIGNhbiBwYXNzIGluIHRoZSBwbGF0Zm9ybSBzcGVjaWZpYyB0eXBlcyBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBjb25zdCB7IHJlbmRlciwgY3JlYXRlQXBwIH0gPSBjcmVhdGVSZW5kZXJlcjxOb2RlLCBFbGVtZW50Pih7XHJcbiAqICAgcGF0Y2hQcm9wLFxyXG4gKiAgIC4uLm5vZGVPcHNcclxuICogfSlcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xyXG59XHJcbi8vIFNlcGFyYXRlIEFQSSBmb3IgY3JlYXRpbmcgaHlkcmF0aW9uLWVuYWJsZWQgcmVuZGVyZXIuXHJcbi8vIEh5ZHJhdGlvbiBsb2dpYyBpcyBvbmx5IHVzZWQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIG1ha2luZyBpdFxyXG4vLyB0cmVlLXNoYWthYmxlLlxyXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgLy8gY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgY2hlY2tcclxuICAgIHtcclxuICAgICAgICBpbml0RmVhdHVyZUZsYWdzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcclxuICAgICAgICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XHJcbiAgICAgICAgc2V0RGV2dG9vbHNIb29rKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgaW5zZXJ0OiBob3N0SW5zZXJ0LCByZW1vdmU6IGhvc3RSZW1vdmUsIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCwgZm9yY2VQYXRjaFByb3A6IGhvc3RGb3JjZVBhdGNoUHJvcCwgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCwgc2V0VGV4dDogaG9zdFNldFRleHQsIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLCBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLCBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsIGNsb25lTm9kZTogaG9zdENsb25lTm9kZSwgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnQgfSA9IG9wdGlvbnM7XHJcbiAgICAvLyBOb3RlOiBmdW5jdGlvbnMgaW5zaWRlIHRoaXMgY2xvc3VyZSBzaG91bGQgdXNlIGBjb25zdCB4eHggPSAoKSA9PiB7fWBcclxuICAgIC8vIHN0eWxlIGluIG9yZGVyIHRvIHByZXZlbnQgYmVpbmcgaW5saW5lZCBieSBtaW5pZmllcnMuXHJcbiAgICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIC8vIHBhdGNoaW5nICYgbm90IHNhbWUgdHlwZSwgdW5tb3VudCBvbGQgdHJlZVxyXG4gICAgICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcclxuICAgICAgICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG4xID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIgLyogQkFJTCAqLykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICAgICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBGcmFnbWVudDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NGcmFnbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XHJcbiAgICAgICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KChuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8ICcnKSksIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gc3VwcG9ydCBmb3IgZHluYW1pYyBjb21tZW50c1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV2IC8gSE1SIG9ubHlcclxuICAgICAqL1xyXG4gICAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIC8vIHN0YXRpYyBub2RlcyBhcmUgb25seSBwYXRjaGVkIGR1cmluZyBkZXYgZm9yIEhNUlxyXG4gICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcclxuICAgICAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgICAgICAgICBlbCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoZWwpO1xyXG4gICAgICAgICAgICBlbCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBuMi50eXBlID09PSAnc3ZnJztcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb3VudEVsZW1lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoRWxlbWVudChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGVsO1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBzY29wZUlkLCBwYXRjaEZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHZub2RlLmVsICYmXHJcbiAgICAgICAgICAgIGhvc3RDbG9uZU5vZGUgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8pIHtcclxuICAgICAgICAgICAgLy8gSWYgYSB2bm9kZSBoYXMgbm9uLW51bGwgZWwsIGl0IG1lYW5zIGl0J3MgYmVpbmcgcmV1c2VkLlxyXG4gICAgICAgICAgICAvLyBPbmx5IHN0YXRpYyB2bm9kZXMgY2FuIGJlIHJldXNlZCwgc28gaXRzIG1vdW50ZWQgRE9NIG5vZGVzIHNob3VsZCBiZVxyXG4gICAgICAgICAgICAvLyBleGFjdGx5IHRoZSBzYW1lLCBhbmQgd2UgY2FuIHNpbXBseSBkbyBhIGNsb25lIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIG9ubHkgZG8gdGhpcyBpbiBwcm9kdWN0aW9uIHNpbmNlIGNsb25lZCB0cmVlcyBjYW5ub3QgYmUgSE1SIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q2xvbmVOb2RlKHZub2RlLmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q3JlYXRlRWxlbWVudCh2bm9kZS50eXBlLCBpc1NWRywgcHJvcHMgJiYgcHJvcHMuaXMpO1xyXG4gICAgICAgICAgICAvLyBtb3VudCBjaGlsZHJlbiBmaXJzdCwgc2luY2Ugc29tZSBwcm9wcyBtYXkgcmVseSBvbiBjaGlsZCBjb250ZW50XHJcbiAgICAgICAgICAgIC8vIGJlaW5nIGFscmVhZHkgcmVuZGVyZWQsIGUuZy4gYDxzZWxlY3QgdmFsdWU+YFxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbih2bm9kZS5jaGlsZHJlbiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHICYmIHR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jywgb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2NvcGVJZFxyXG4gICAgICAgICAgICBzZXRTY29wZUlkKGVsLCBzY29wZUlkLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192bm9kZScsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzE1ODMgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIG5vdCByZXNvbHZlZCBjYXNlLCBlbnRlciBob29rIHNob3VsZCBjYWxsIHdoZW4gc3VzcGVuc2UgcmVzb2x2ZWRcclxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XHJcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xyXG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8XHJcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XHJcbiAgICAgICAgICAgIGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgc2NvcGVJZCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChzY29wZUlkKSB7XHJcbiAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmVlT3duZXJJZCA9IHBhcmVudENvbXBvbmVudC50eXBlLl9fc2NvcGVJZDtcclxuICAgICAgICAgICAgLy8gdm5vZGUncyBvd24gc2NvcGVJZCBhbmQgdGhlIGN1cnJlbnQgcGF0Y2hlZCBjb21wb25lbnQncyBzY29wZUlkIGlzXHJcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCAtIHRoaXMgaXMgYSBzbG90IGNvbnRlbnQgbm9kZS5cclxuICAgICAgICAgICAgaWYgKHRyZWVPd25lcklkICYmIHRyZWVPd25lcklkICE9PSBzY29wZUlkKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgdHJlZU93bmVySWQgKyAnLXMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHN1YlRyZWUudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUpIHtcclxuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudENvbXBvbmVudC52bm9kZS5zY29wZUlkLCBwYXJlbnRDb21wb25lbnQudm5vZGUsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IChjaGlsZHJlbltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgY2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcclxuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXHJcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcclxuICAgICAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgICAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRjaEZsYWcgbWVhbnMgdGhpcyBlbGVtZW50J3MgcmVuZGVyIGNvZGUgd2FzXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgYW5kIGNhbiB0YWtlIHRoZSBmYXN0IHBhdGguXHJcbiAgICAgICAgICAgIC8vIGluIHRoaXMgcGF0aCBvbGQgbm9kZSBhbmQgbmV3IG5vZGUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVxyXG4gICAgICAgICAgICAvLyAoaS5lLiBhdCB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIHRlbXBsYXRlKVxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBwcm9wcyBjb250YWluIGR5bmFtaWMga2V5cywgZnVsbCBkaWZmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgY2xhc3MgYmluZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMiAvKiBDTEFTUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ2NsYXNzJywgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdHlsZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBzdHlsZSBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQgLyogU1RZTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnc3R5bGUnLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHByb3AvYXR0ciBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBjbGFzcyBhbmQgc3R5bGUuIFRoZSBrZXlzIG9mIGR5bmFtaWMgcHJvcC9hdHRycyBhcmUgc2F2ZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSBkeW5hbWljIGtleXMgbGlrZSA6W2Zvb109XCJiYXJcIiB3aWxsIGNhdXNlIHRoaXMgb3B0aW1pemF0aW9uIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIG91dCBhbmQgZ28gdGhyb3VnaCBhIGZ1bGwgZGlmZiBiZWNhdXNlIHdlIG5lZWQgdG8gdW5zZXQgdGhlIG9sZCBrZXlcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZsYWcgaXMgcHJlc2VudCB0aGVuIGR5bmFtaWNQcm9wcyBtdXN0IGJlIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhvc3RGb3JjZVBhdGNoUHJvcCAmJiBob3N0Rm9yY2VQYXRjaFByb3AoZWwsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCBuMS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIG9ubHkgZHluYW1pYyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRyk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ3VwZGF0ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUaGUgZmFzdCBwYXRoIGZvciBibG9ja3MuXHJcbiAgICBjb25zdCBwYXRjaEJsb2NrQ2hpbGRyZW4gPSAob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBmYWxsYmFja0NvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgY29udGFpbmVyIChwYXJlbnQgZWxlbWVudCkgZm9yIHRoZSBwYXRjaC5cclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gXHJcbiAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XHJcbiAgICAgICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovXHJcbiAgICAgICAgICAgICAgICA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tDb250YWluZXI7XHJcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIHZub2RlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCB2YWxpZCBwcm9wXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChob3N0Rm9yY2VQYXRjaFByb3AgJiYgaG9zdEZvcmNlUGF0Y2hQcm9wKGVsLCBrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBvbGRQcm9wc1trZXldLCBudWxsLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IChuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50RW5kQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vIGEgZnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBhcnJheSBjaGlsZHJlblxyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSBlaXRoZXIgZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciwgb3IgaW1wbGljaXRseSBjcmVhdGVkXHJcbiAgICAgICAgICAgIC8vIGZyb20gYXJyYXlzLlxyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIHN0YWJsZSBmcmFnbWVudCAodGVtcGxhdGUgcm9vdCBvciA8dGVtcGxhdGUgdi1mb3I+KSBkb2Vzbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGNoaWxkcmVuIG9yZGVyLCBidXQgaXQgbWF5IGNvbnRhaW4gZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxyXG4gICAgICAgICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cclxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cclxuICAgICAgICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUgLyogc2hhbGxvdyAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZXllZCAvIHVua2V5ZWQsIG9yIG1hbnVhbCBmcmFnbWVudHMuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcclxuICAgICAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGJsb2NrIHNvIHRoZSBmcmFnbWVudCB3aWxsIG5ldmVyXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKGluaXRpYWxWTm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSkpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQoaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IHJlbmRlcmVyIGludGVybmFscyBmb3Iga2VlcEFsaXZlXHJcbiAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNvbHZlIHByb3BzIGFuZCBzbG90cyBmb3Igc2V0dXAgY29udGV4dFxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCgpIGlzIGFzeW5jLiBUaGlzIGNvbXBvbmVudCByZWxpZXMgb24gYXN5bmMgbG9naWMgdG8gYmUgcmVzb2x2ZWRcclxuICAgICAgICAvLyBiZWZvcmUgcHJvY2VlZGluZ1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCkge1xyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xyXG4gICAgICAgICAgICAvLyBHaXZlIGl0IGEgcGxhY2Vob2xkZXIgaWYgdGhpcyBpcyBub3QgaHlkcmF0aW9uXHJcbiAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIHNlbGYtZGVmaW5lZCBmYWxsYmFja1xyXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jICYgc3RpbGwgcGVuZGluZyAtIGp1c3QgdXBkYXRlIHByb3BzIGFuZCBzbG90c1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNvbXBvbmVudCdzIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyIGlzbid0IHNldC11cCB5ZXRcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xyXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgY2hpbGQgY29tcG9uZW50IGlzIGFsc28gcXVldWVkLCByZW1vdmUgaXQgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZSB1cGRhdGluZyB0aGUgc2FtZSBjaGlsZCBjb21wb25lbnQgaW4gdGhlIHNhbWUgZmx1c2guXHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS51cGRhdGUgaXMgdGhlIHJlYWN0aXZlIGVmZmVjdCBydW5uZXIuXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gdXBkYXRlIG5lZWRlZC4ganVzdCBjb3B5IG92ZXIgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIC8vIGNyZWF0ZSByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlcmluZ1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSA9IGVmZmVjdChmdW5jdGlvbiBjb21wb25lbnRFZmZlY3QoKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbCwgcHJvcHMgfSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgYm0sIG0sIHBhcmVudCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVNb3VudCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAoYm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlTW91bnRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IChpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVOb2RlKGluaXRpYWxWTm9kZS5lbCwgc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBzdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLmVsID0gc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZU1vdW50ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgc2NvcGVkSW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cclxuICAgICAgICAgICAgICAgIC8vICMxNzQyIGFjdGl2YXRlZCBob29rIG11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgZmlyc3QgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGEgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUuc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChhLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcclxuICAgICAgICAgICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlVXBkYXRlIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChidSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVVcGRhdGVcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaChwcmV2VHJlZSwgbmV4dFRyZWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XHJcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi10cmlnZ2VyZWQgdXBkYXRlLiBJbiBjYXNlIG9mIEhPQywgdXBkYXRlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2hpbGQgY29tcG9uZW50J3Mgdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKHUpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZVVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlRGV2RWZmZWN0T3B0aW9ucyhpbnN0YW5jZSkgOiBwcm9kRWZmZWN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcclxuICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcclxuICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcclxuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcclxuICAgICAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbik7XHJcbiAgICAgICAgLy8gcHJvcHMgdXBkYXRlIG1heSBoYXZlIHRyaWdnZXJlZCBwcmUtZmx1c2ggd2F0Y2hlcnMuXHJcbiAgICAgICAgLy8gZmx1c2ggdGhlbSBiZWZvcmUgdGhlIHJlbmRlciB1cGRhdGUuXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyh1bmRlZmluZWQsIGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hDaGlsZHJlbiA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XHJcbiAgICAgICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICAvLyBmYXN0IHBhdGhcclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGVpdGhlciBmdWxseS1rZXllZCBvciBtaXhlZCAoc29tZSBrZXllZCBzb21lIG5vdClcclxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gdW5rZXllZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hpbGRyZW4gaGFzIDMgcG9zc2liaWxpdGllczogdGV4dCwgYXJyYXkgb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAvLyB0ZXh0IGNoaWxkcmVuIGZhc3QgcGF0aFxyXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjMiAhPT0gYzEpIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR3byBhcnJheXMsIGNhbm5vdCBhc3N1bWUgYW55dGhpbmcsIGRvIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5ldyBjaGlsZHJlbiwganVzdCB1bm1vdW50IG9sZFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyB0ZXh0IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBjaGlsZHJlbiBpcyBhcnJheSBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ldyBpZiBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjMiA9IGMyIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNvbW1vbkxlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCwgbmV3TGVuZ3RoKTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChjMVtpXSwgbmV4dENoaWxkLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGRcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlLCBmYWxzZSwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGFsbC1rZXllZCBvciBtaXhlZFxyXG4gICAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTsgLy8gcHJldiBlbmRpbmcgaW5kZXhcclxuICAgICAgICBsZXQgZTIgPSBsMiAtIDE7IC8vIG5leHQgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgLy8gMS4gc3luYyBmcm9tIHN0YXJ0XHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIChhIGIpIGQgZVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtpXTtcclxuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBzeW5jIGZyb20gZW5kXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIGQgZSAoYiBjKVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtlMV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUxLS07XHJcbiAgICAgICAgICAgIGUyLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIGNvbW1vbiBzZXF1ZW5jZSArIG1vdW50XHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gMSwgZTIgPSAyXHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyBjIChhIGIpXHJcbiAgICAgICAgLy8gaSA9IDAsIGUxID0gLTEsIGUyID0gMFxyXG4gICAgICAgIGlmIChpID4gZTEpIHtcclxuICAgICAgICAgICAgaWYgKGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNC4gY29tbW9uIHNlcXVlbmNlICsgdW5tb3VudFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDIsIGUyID0gMVxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyAoYiBjKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IDAsIGUyID0gLTFcclxuICAgICAgICBlbHNlIGlmIChpID4gZTIpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDUuIHVua25vd24gc2VxdWVuY2VcclxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXHJcbiAgICAgICAgLy8gW2kgLi4uIGUyICsgMV06IGEgYiBbZSBkIGMgaF0gZiBnXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gNCwgZTIgPSA1XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMxID0gaTsgLy8gcHJldiBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICBjb25zdCBzMiA9IGk7IC8vIG5leHQgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXHJcbiAgICAgICAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLCBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSwgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMiBsb29wIHRocm91Z2ggb2xkIGNoaWxkcmVuIGxlZnQgdG8gYmUgcGF0Y2hlZCBhbmQgdHJ5IHRvIHBhdGNoXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIG5vZGVzICYgcmVtb3ZlIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50XHJcbiAgICAgICAgICAgIGxldCBqO1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hlZCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XHJcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55IG5vZGUgaGFzIG1vdmVkXHJcbiAgICAgICAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcclxuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cclxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9sZEluZGV4IGlzIG9mZnNldCBieSArMVxyXG4gICAgICAgICAgICAvLyBhbmQgb2xkSW5kZXggPSAwIGlzIGEgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBuZXcgbm9kZSBoYXNcclxuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cclxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2VcclxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG5ldyBjaGlsZHJlbiBoYXZlIGJlZW4gcGF0Y2hlZCBzbyB0aGlzIGNhbiBvbmx5IGJlIGEgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5LWxlc3Mgbm9kZSwgdHJ5IHRvIGxvY2F0ZSBhIGtleS1sZXNzIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKHByZXZDaGlsZCwgYzJbbmV3SW5kZXhdLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjMgbW92ZSBhbmQgbW91bnRcclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2Ugb25seSB3aGVuIG5vZGVzIGhhdmUgbW92ZWRcclxuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApXHJcbiAgICAgICAgICAgICAgICA6IEVNUFRZX0FSUjtcclxuICAgICAgICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIC8vIGxvb3BpbmcgYmFja3dhcmRzIHNvIHRoYXQgd2UgY2FuIHVzZSBsYXN0IHBhdGNoZWQgbm9kZSBhcyBhbmNob3JcclxuICAgICAgICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzdGFibGUgc3Vic2VxdWVuY2UgKGUuZy4gYSByZXZlcnNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9SIGN1cnJlbnQgbm9kZSBpcyBub3QgYW1vbmcgdGhlIHN0YWJsZSBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcclxuICAgICAgICBjb25zdCBuZWVkVHJhbnNpdGlvbiA9IG1vdmVUeXBlICE9PSAyIC8qIFJFT1JERVIgKi8gJiZcclxuICAgICAgICAgICAgc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb247XHJcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBFTlRFUiAqLykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmUgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIHNoYXBlRmxhZywgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyB1bnNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgZGlycztcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XHJcbiAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZVVubW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcclxuICAgICAgICAgICAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggZm9yIGJsb2NrIG5vZGVzOiBvbmx5IG5lZWQgdG8gdW5tb3VudCBkeW5hbWljIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGR5bmFtaWNDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgKHBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmIDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovKSkgfHxcclxuICAgICAgICAgICAgICAgICghb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbiB1bm1vdW50ZWQgdGVsZXBvcnQgc2hvdWxkIGFsd2F5cyByZW1vdmUgaXRzIGNoaWxkcmVuIGlmIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8gJiZcclxuICAgICAgICAgICAgICAgIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKHZub2RlLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICd1bm1vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJmb3JtUmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XHJcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxyXG4gICAgICAgIC8vIChmcmFnbWVudCBjaGlsZCBub2RlcyBjYW5ub3QgaGF2ZSB0cmFuc2l0aW9uKVxyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgY3VyID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShlbmQpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGJ1bSwgZWZmZWN0cywgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgLy8gYmVmb3JlVW5tb3VudCBob29rXHJcbiAgICAgICAgaWYgKGJ1bSkge1xyXG4gICAgICAgICAgICBpbnZva2VBcnJheUZucyhidW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0cykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN0b3AoZWZmZWN0c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXBkYXRlIG1heSBiZSBudWxsIGlmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgaXRzIGFzeW5jXHJcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxyXG4gICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgc3RvcCh1cGRhdGUpO1xyXG4gICAgICAgICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xyXG4gICAgICAgIGlmICh1bSkge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAvLyBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIGRlcCBpbnNpZGUgYSBwZW5kaW5nIHN1c3BlbnNlIGlzIHVubW91bnRlZCBiZWZvcmVcclxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXHJcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxyXG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJlxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXHJcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5fdm5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoKGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGludGVybmFscyA9IHtcclxuICAgICAgICBwOiBwYXRjaCxcclxuICAgICAgICB1bTogdW5tb3VudCxcclxuICAgICAgICBtOiBtb3ZlLFxyXG4gICAgICAgIHI6IHJlbW92ZSxcclxuICAgICAgICBtdDogbW91bnRDb21wb25lbnQsXHJcbiAgICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXHJcbiAgICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXHJcbiAgICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXHJcbiAgICAgICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxyXG4gICAgICAgIG86IG9wdGlvbnNcclxuICAgIH07XHJcbiAgICBsZXQgaHlkcmF0ZTtcclxuICAgIGxldCBoeWRyYXRlTm9kZTtcclxuICAgIGlmIChjcmVhdGVIeWRyYXRpb25GbnMpIHtcclxuICAgICAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKGludGVybmFscyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbmRlcixcclxuICAgICAgICBoeWRyYXRlLFxyXG4gICAgICAgIGNyZWF0ZUFwcDogY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcgLyogVk5PREVfSE9PSyAqLywgW1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHByZXZWTm9kZVxyXG4gICAgXSk7XHJcbn1cclxuLyoqXHJcbiAqICMxMTU2XHJcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgSE1SLWVuYWJsZWQsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHN0YXRpYyBub2Rlc1xyXG4gKiBpbnNpZGUgYSBibG9jayBhbHNvIGluaGVyaXQgdGhlIERPTSBlbGVtZW50IGZyb20gdGhlIHByZXZpb3VzIHRyZWUgc28gdGhhdFxyXG4gKiBITVIgdXBkYXRlcyAod2hpY2ggYXJlIGZ1bGwgdXBkYXRlcykgY2FuIHJldHJpZXZlIHRoZSBlbGVtZW50IGZvciBwYXRjaGluZy5cclxuICpcclxuICogIzIwODBcclxuICogSW5zaWRlIGtleWVkIGB0ZW1wbGF0ZWAgZnJhZ21lbnQgc3RhdGljIGNoaWxkcmVuLCBpZiBhIGZyYWdtZW50IGlzIG1vdmVkLFxyXG4gKiB0aGUgY2hpbGRyZW4gd2lsbCBhbHdheXMgbW92ZWQgc28gdGhhdCBuZWVkIGluaGVyaXQgZWwgZm9ybSBwcmV2aW91cyBub2Rlc1xyXG4gKiB0byBlbnN1cmUgY29ycmVjdCBtb3ZlZCBwb3NpdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XHJcbiAgICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBjYWxsZWQgaW4gdGhlIG9wdGltaXplZCBwYXRoIHNvIGFycmF5IGNoaWxkcmVuIGFyZVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVkIHRvIGJlIHZub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNoMVtpXTtcclxuICAgICAgICAgICAgbGV0IGMyID0gY2gyW2ldO1xyXG4gICAgICAgICAgICBpZiAoYzIuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYzIgPSBjaDJbaV0gPSBjbG9uZUlmTW91bnRlZChjaDJbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNoYWxsb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gaW5oZXJpdCBmb3IgY29tbWVudCBub2RlcywgYnV0IG5vdCBwbGFjZWhvbGRlcnMgKGUuZy4gdi1pZiB3aGljaFxyXG4gICAgICAgICAgICAvLyB3b3VsZCBoYXZlIHJlY2VpdmVkIC5lbCBkdXJpbmcgYmxvY2sgcGF0Y2gpXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcclxuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXHJcbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xyXG4gICAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xyXG4gICAgbGV0IGksIGosIHUsIHYsIGM7XHJcbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJySSA9IGFycltpXTtcclxuICAgICAgICBpZiAoYXJySSAhPT0gMCkge1xyXG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgIHBbaV0gPSBqO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1ID0gMDtcclxuICAgICAgICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAodSA8IHYpIHtcclxuICAgICAgICAgICAgICAgIGMgPSAoKHUgKyB2KSAvIDIpIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1ID0gYyArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwW2ldID0gcmVzdWx0W3UgLSAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdFt1XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1ID0gcmVzdWx0Lmxlbmd0aDtcclxuICAgIHYgPSByZXN1bHRbdSAtIDFdO1xyXG4gICAgd2hpbGUgKHUtLSA+IDApIHtcclxuICAgICAgICByZXN1bHRbdV0gPSB2O1xyXG4gICAgICAgIHYgPSBwW3ZdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xyXG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gJycpO1xyXG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xyXG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XHJcbiAgICBpZiAoaXNTdHJpbmcodGFyZ2V0U2VsZWN0b3IpKSB7XHJcbiAgICAgICAgaWYgKCFzZWxlY3QpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYE5vdGUgdGhlIHRhcmdldCBlbGVtZW50IG11c3QgZXhpc3QgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAtIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgVGVsZXBvcnQgdGFyZ2V0OiAke3RhcmdldFNlbGVjdG9yfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcclxuICAgIF9faXNUZWxlcG9ydDogdHJ1ZSxcclxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XHJcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuY2hvcnMgaW4gdGhlIG1haW4gdmlld1xyXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChuMi5lbCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBzdGFydCcpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgY29uc3QgbWFpbkFuY2hvciA9IChuMi5hbmNob3IgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ29tbWVudCgndGVsZXBvcnQgZW5kJylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gKG4yLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIC8vICMyNjUyIHdlIGNvdWxkIGJlIHRlbGVwb3J0aW5nIGZyb20gYSBub24tU1ZHIHRyZWUgaW50byBhbiBTVkcgdHJlZVxyXG4gICAgICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZWxlcG9ydCAqYWx3YXlzKiBoYXMgQXJyYXkgY2hpbGRyZW4uIFRoaXMgaXMgZW5mb3JjZWQgaW4gYm90aCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVyIGFuZCB2bm9kZSBjaGlsZHJlbiBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudCh0YXJnZXQsIHRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjb250ZW50XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gbjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IG4xLnRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcclxuICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAobjIuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggd2hlbiB0aGUgdGVsZXBvcnQgaGFwcGVucyB0byBiZSBhIGJsb2NrIHJvb3RcclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIG4yLmR5bmFtaWNDaGlsZHJlbiwgY3VycmVudENvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiBibG9jayB0cmVlIG1vZGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHJvb3QtbGV2ZWwgbm9kZXNcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSB0ZWxlcG9ydCBpbmhlcml0IHByZXZpb3VzIERPTSByZWZlcmVuY2VzIHNvIHRoYXQgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjdXJyZW50Q29udGFpbmVyLCBjdXJyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlZCAtPiBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgY29udGFpbmVyLCBtYWluQW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRBUkdFVF9DSEFOR0UgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgLT4gZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byB0ZWxlcG9ydCB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW1vdmUodm5vZGUsIHsgcjogcmVtb3ZlLCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0pIHtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciB9ID0gdm5vZGU7XHJcbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUoY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxyXG59O1xyXG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFJFT1JERVIgKi8pIHtcclxuICAgIC8vIG1vdmUgdGFyZ2V0IGFuY2hvciBpZiB0aGlzIGlzIGEgdGFyZ2V0IGNoYW5nZS5cclxuICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBUQVJHRVRfQ0hBTkdFICovKSB7XHJcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBSRU9SREVSICovO1xyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHRoaXMgaXMgYSByZS1vcmRlciBhbmQgdGVsZXBvcnQgaXMgZW5hYmxlZCAoY29udGVudCBpcyBpbiB0YXJnZXQpXHJcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xyXG4gICAgLy8gaXMgbm90IGEgcmVvcmRlciwgb3IgdGhlIHRlbGVwb3J0IGlzIGRpc2FibGVkXHJcbiAgICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxyXG4gICAgaWYgKGlzUmVvcmRlcikge1xyXG4gICAgICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH0gfSwgaHlkcmF0ZUNoaWxkcmVuKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSAodm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldCh2bm9kZS5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlIHRlbGVwb3J0cyByZW5kZXJlZCB0byB0aGUgc2FtZSB0YXJnZXQgZWxlbWVudCwgd2UgbmVlZCB0b1xyXG4gICAgICAgIC8vIHBpY2sgdXAgZnJvbSB3aGVyZSB0aGUgbGFzdCB0ZWxlcG9ydCBmaW5pc2hlZCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBub2RlXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICBpZiAoaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgcGFyZW50Tm9kZShub2RlKSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbih0YXJnZXROb2RlLCB2bm9kZSwgdGFyZ2V0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5fbHBhID1cclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcclxufVxyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcclxuY29uc3QgRElSRUNUSVZFUyA9ICdkaXJlY3RpdmVzJztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUpIHtcclxuICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSkgfHwgbmFtZTtcclxufVxyXG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKCk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29tcG9uZW50KSkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaW52YWxpZCB0eXBlcyB3aWxsIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZVZOb2RlIGFuZCByYWlzZSB3YXJuaW5nXHJcbiAgICAgICAgcmV0dXJuIChjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcclxuICAgIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgICAgICAvLyBzZWxmIG5hbWUgaGFzIGhpZ2hlc3QgcHJpb3JpdHlcclxuICAgICAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIHNlbGYgcmVmZXJlbmNpbmcgY2FsbCBnZW5lcmF0ZWQgYnkgY29tcGlsZXJcclxuICAgICAgICAgICAgLy8gaW5mZXJyZWQgZnJvbSBTRkMgZmlsZW5hbWVcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IGBfc2VsZmApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChzZWxmTmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgKHNlbGZOYW1lID09PSBuYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBcclxuICAgICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCBmb3IgY29tcG9uZW50cyB3aXRoIG1peGluIG9yIGV4dGVuZHMuXHJcbiAgICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBgICtcclxuICAgICAgICAgICAgYGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlKHJlZ2lzdHJ5LCBuYW1lKSB7XHJcbiAgICByZXR1cm4gKHJlZ2lzdHJ5ICYmXHJcbiAgICAgICAgKHJlZ2lzdHJ5W25hbWVdIHx8XHJcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pKTtcclxufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnRnJhZ21lbnQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgVGV4dCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnVGV4dCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBDb21tZW50ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdDb21tZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XHJcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XHJcbi8vIGNoYW5nZSwgb25jZSB3ZSBjb25zaWRlciB2LWlmIGJyYW5jaGVzIGFuZCBlYWNoIHYtZm9yIGZyYWdtZW50IGEgYmxvY2ssIHdlXHJcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxyXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xyXG4vLyBhbmQgb25seSB3b3JyeSBhYm91dCB0aGUgZHluYW1pYyBub2RlcyAoaW5kaWNhdGVkIGJ5IHBhdGNoIGZsYWdzKS5cclxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xyXG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcclxuLyoqXHJcbiAqIE9wZW4gYSBibG9jay5cclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxyXG4gKiBiZWNhdXNlIHRoZSBjaGlsZHJlbiBvZiB0aGUgYmxvY2sgYXJlIGV2YWx1YXRlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYCBpdHNlbGZcclxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcclxuICogfVxyXG4gKiBgYGBcclxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXHJcbiAqIGZyYWdtZW50IGFsd2F5cyBkaWZmcyBpdHMgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcclxuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcclxuICAgIGJsb2NrU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vLyBXaGV0aGVyIHdlIHNob3VsZCBiZSB0cmFja2luZyBkeW5hbWljIGNoaWxkIG5vZGVzIGluc2lkZSBhIGJsb2NrLlxyXG4vLyBPbmx5IHRyYWNrcyB3aGVuIHRoaXMgdmFsdWUgaXMgPiAwXHJcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcclxuLy8gaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWQgYnkgbmVzdGVkIHVzYWdlIG9mIHYtb25jZSAoc2VlIGJlbG93KVxyXG5sZXQgc2hvdWxkVHJhY2sgPSAxO1xyXG4vKipcclxuICogQmxvY2sgdHJhY2tpbmcgc29tZXRpbWVzIG5lZWRzIHRvIGJlIGRpc2FibGVkLCBmb3IgZXhhbXBsZSBkdXJpbmcgdGhlXHJcbiAqIGNyZWF0aW9uIG9mIGEgdHJlZSB0aGF0IG5lZWRzIHRvIGJlIGNhY2hlZCBieSB2LW9uY2UuIFRoZSBjb21waWxlciBnZW5lcmF0ZXNcclxuICogY29kZSBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBfY2FjaGVbMV0gfHwgKFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoLTEpLFxyXG4gKiAgIF9jYWNoZVsxXSA9IGNyZWF0ZVZOb2RlKC4uLiksXHJcbiAqICAgc2V0QmxvY2tUcmFja2luZygxKSxcclxuICogICBfY2FjaGVbMV1cclxuICogKVxyXG4gKiBgYGBcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcclxuICAgIHNob3VsZFRyYWNrICs9IHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBibG9jayByb290IHZub2RlLiBUYWtlcyB0aGUgc2FtZSBleGFjdCBhcmd1bWVudHMgYXMgYGNyZWF0ZVZOb2RlYC5cclxuICogQSBibG9jayByb290IGtlZXBzIHRyYWNrIG9mIGR5bmFtaWMgbm9kZXMgd2l0aGluIHRoZSBibG9jayBpbiB0aGVcclxuICogYGR5bmFtaWNDaGlsZHJlbmAgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzKSB7XHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHRydWUgLyogaXNCbG9jazogcHJldmVudCBhIGJsb2NrIGZyb20gdHJhY2tpbmcgaXRzZWxmICovKTtcclxuICAgIC8vIHNhdmUgY3VycmVudCBibG9jayBjaGlsZHJlbiBvbiB0aGUgYmxvY2sgdm5vZGVcclxuICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlI7XHJcbiAgICAvLyBjbG9zZSBibG9ja1xyXG4gICAgY2xvc2VCbG9jaygpO1xyXG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcclxuICAgIC8vIHBhcmVudCBibG9ja1xyXG4gICAgaWYgKHNob3VsZFRyYWNrID4gMCAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgbjIuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiZcclxuICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG4yLnR5cGUpKSB7XHJcbiAgICAgICAgLy8gSE1SIG9ubHk6IGlmIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gaG90LXVwZGF0ZWQsIGZvcmNlIGEgcmVsb2FkLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xyXG59XHJcbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcclxuLyoqXHJcbiAqIEludGVybmFsIEFQSSBmb3IgcmVnaXN0ZXJpbmcgYW4gYXJndW1lbnRzIHRyYW5zZm9ybSBmb3IgY3JlYXRlVk5vZGVcclxuICogdXNlZCBmb3IgY3JlYXRpbmcgc3R1YnMgaW4gdGhlIHRlc3QtdXRpbHNcclxuICogSXQgaXMgKmludGVybmFsKiBidXQgbmVlZHMgdG8gYmUgZXhwb3NlZCBmb3IgdGVzdC11dGlscyB0byBwaWNrIHVwIHByb3BlclxyXG4gKiB0eXBpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcclxuICAgIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XHJcbn1cclxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICByZXR1cm4gX2NyZWF0ZVZOb2RlKC4uLih2bm9kZUFyZ3NUcmFuc2Zvcm1lclxyXG4gICAgICAgID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKVxyXG4gICAgICAgIDogYXJncykpO1xyXG59O1xyXG5jb25zdCBJbnRlcm5hbE9iamVjdEtleSA9IGBfX3ZJbnRlcm5hbGA7XHJcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XHJcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7IHJlZiB9KSA9PiB7XHJcbiAgICByZXR1cm4gKHJlZiAhPSBudWxsXHJcbiAgICAgICAgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpXHJcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiB9XHJcbiAgICAgICAgICAgIDogcmVmXHJcbiAgICAgICAgOiBudWxsKTtcclxufTtcclxuY29uc3QgY3JlYXRlVk5vZGUgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm1cclxuICAgIDogX2NyZWF0ZVZOb2RlKTtcclxuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSBDb21tZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVk5vZGUodHlwZSkpIHtcclxuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXHJcbiAgICAgICAgLy8gPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiLz5cclxuICAgICAgICAvLyAjMjA3OCBtYWtlIHN1cmUgdG8gbWVyZ2UgcmVmcyBkdXJpbmcgdGhlIGNsb25lIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXRcclxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyBjb21wb25lbnQgbm9ybWFsaXphdGlvbi5cclxuICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xyXG4gICAgfVxyXG4gICAgLy8gY2xhc3MgJiBzdHlsZSBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgLy8gZm9yIHJlYWN0aXZlIG9yIHByb3h5IG9iamVjdHMsIHdlIG5lZWQgdG8gY2xvbmUgaXQgdG8gZW5hYmxlIG11dGF0aW9uLlxyXG4gICAgICAgIGlmIChpc1Byb3h5KHByb3BzKSB8fCBJbnRlcm5hbE9iamVjdEtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBwcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcclxuICAgICAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAvLyByZWFjdGl2ZSBzdGF0ZSBvYmplY3RzIG5lZWQgdG8gYmUgY2xvbmVkIHNpbmNlIHRoZXkgYXJlIGxpa2VseSB0byBiZVxyXG4gICAgICAgICAgICAvLyBtdXRhdGVkXHJcbiAgICAgICAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZW5jb2RlIHRoZSB2bm9kZSB0eXBlIGluZm9ybWF0aW9uIGludG8gYSBiaXRtYXBcclxuICAgIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpXHJcbiAgICAgICAgPyAxIC8qIEVMRU1FTlQgKi9cclxuICAgICAgICA6IGlzU3VzcGVuc2UodHlwZSlcclxuICAgICAgICAgICAgPyAxMjggLyogU1VTUEVOU0UgKi9cclxuICAgICAgICAgICAgOiBpc1RlbGVwb3J0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICA/IDY0IC8qIFRFTEVQT1JUICovXHJcbiAgICAgICAgICAgICAgICA6IGlzT2JqZWN0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbih0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDIgLyogRlVOQ1RJT05BTF9DT01QT05FTlQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLyAmJiBpc1Byb3h5KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xyXG4gICAgICAgIHdhcm4oYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gYCArXHJcbiAgICAgICAgICAgIGBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkLCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgYCArXHJcbiAgICAgICAgICAgIGBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgYCArXHJcbiAgICAgICAgICAgIGBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLCBgXFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdm5vZGUgPSB7XHJcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICAgICAgW1wiX192X3NraXBcIiAvKiBTS0lQICovXTogdHJ1ZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcclxuICAgICAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXHJcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXHJcbiAgICAgICAgY2hpbGRyZW46IG51bGwsXHJcbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxyXG4gICAgICAgIHN1c3BlbnNlOiBudWxsLFxyXG4gICAgICAgIHNzQ29udGVudDogbnVsbCxcclxuICAgICAgICBzc0ZhbGxiYWNrOiBudWxsLFxyXG4gICAgICAgIGRpcnM6IG51bGwsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogbnVsbCxcclxuICAgICAgICBlbDogbnVsbCxcclxuICAgICAgICBhbmNob3I6IG51bGwsXHJcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgICAgIHRhcmdldEFuY2hvcjogbnVsbCxcclxuICAgICAgICBzdGF0aWNDb3VudDogMCxcclxuICAgICAgICBzaGFwZUZsYWcsXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXHJcbiAgICAgICAgYXBwQ29udGV4dDogbnVsbFxyXG4gICAgfTtcclxuICAgIC8vIHZhbGlkYXRlIGtleVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xyXG4gICAgICAgIHdhcm4oYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcclxuICAgIH1cclxuICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbik7XHJcbiAgICAvLyBub3JtYWxpemUgc3VzcGVuc2UgY2hpbGRyZW5cclxuICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnQsIGZhbGxiYWNrIH0gPSBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKTtcclxuICAgICAgICB2bm9kZS5zc0NvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgICAgIHZub2RlLnNzRmFsbGJhY2sgPSBmYWxsYmFjaztcclxuICAgIH1cclxuICAgIGlmIChzaG91bGRUcmFjayA+IDAgJiZcclxuICAgICAgICAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcclxuICAgICAgICAhaXNCbG9ja05vZGUgJiZcclxuICAgICAgICAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcclxuICAgICAgICBjdXJyZW50QmxvY2sgJiZcclxuICAgICAgICAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xyXG4gICAgICAgIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cclxuICAgICAgICAocGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcclxuICAgICAgICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxyXG4gICAgICAgIHBhdGNoRmxhZyAhPT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSkge1xyXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IE5PVCB1c2luZyBzcHJlYWQgb3IgZXh0ZW5kIHRvIGF2b2lkIHRoZSBydW50aW1lXHJcbiAgICAvLyBrZXkgZW51bWVyYXRpb24gY29zdC5cclxuICAgIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBbXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi9dOiB0cnVlLFxyXG4gICAgICAgIHR5cGU6IHZub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IG1lcmdlZFByb3BzLFxyXG4gICAgICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcclxuICAgICAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWZcclxuICAgICAgICAgICAgPyAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcclxuICAgICAgICAgICAgICAgIG1lcmdlUmVmICYmIHJlZlxyXG4gICAgICAgICAgICAgICAgICAgID8gaXNBcnJheShyZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXHJcbiAgICAgICAgICAgIDogcmVmLFxyXG4gICAgICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXHJcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8gJiYgaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgICAgICAgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpXHJcbiAgICAgICAgICAgIDogY2hpbGRyZW4sXHJcbiAgICAgICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxyXG4gICAgICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxyXG4gICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXHJcbiAgICAgICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cclxuICAgICAgICAvLyBub3RlOiBwZXJzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXHJcbiAgICAgICAgLy8gZmFzdCBwYXRocyBvbmx5LlxyXG4gICAgICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudFxyXG4gICAgICAgICAgICA/IHBhdGNoRmxhZyA9PT0gLTEgLy8gaG9pc3RlZCBub2RlXHJcbiAgICAgICAgICAgICAgICA/IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgICAgIDogcGF0Y2hGbGFnIHwgMTYgLyogRlVMTF9QUk9QUyAqL1xyXG4gICAgICAgICAgICA6IHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcclxuICAgICAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxyXG4gICAgICAgIGRpcnM6IHZub2RlLmRpcnMsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogdm5vZGUudHJhbnNpdGlvbixcclxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcclxuICAgICAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcclxuICAgICAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXHJcbiAgICAgICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcclxuICAgICAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXHJcbiAgICAgICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxyXG4gICAgICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcclxuICAgICAgICBlbDogdm5vZGUuZWwsXHJcbiAgICAgICAgYW5jaG9yOiB2bm9kZS5hbmNob3JcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIERldiBvbmx5LCBmb3IgSE1SIG9mIGhvaXN0ZWQgdm5vZGVzIHJldXNlZCBpbiB2LWZvclxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzIwMjJcclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XHJcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSAnICcsIGZsYWcgPSAwKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XHJcbiAgICAvLyBBIHN0YXRpYyB2bm9kZSBjYW4gY29udGFpbiBtdWx0aXBsZSBzdHJpbmdpZmllZCBlbGVtZW50cywgYW5kIHRoZSBudW1iZXJcclxuICAgIC8vIG9mIGVsZW1lbnRzIGlzIG5lY2Vzc2FyeSBmb3IgaHlkcmF0aW9uLlxyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xyXG4gICAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSAnJywgXHJcbi8vIHdoZW4gdXNlZCBhcyB0aGUgdi1lbHNlIGJyYW5jaCwgdGhlIGNvbW1lbnQgbm9kZSBtdXN0IGJlIGNyZWF0ZWQgYXMgYVxyXG4vLyBibG9jayB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzLlxyXG5hc0Jsb2NrID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBhc0Jsb2NrXHJcbiAgICAgICAgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKVxyXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcclxuICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgcGxhY2Vob2xkZXJcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xyXG4gICAgICAgIC8vIGZyYWdtZW50XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKEZyYWdtZW50LCBudWxsLCBjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gYWxyZWFkeSB2bm9kZSwgdGhpcyBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHNpbmNlIGNvbXBpbGVkIHRlbXBsYXRlc1xyXG4gICAgICAgIC8vIGFsd2F5cyBwcm9kdWNlIGFsbC12bm9kZSBjaGlsZHJlbiBhcnJheXNcclxuICAgICAgICByZXR1cm4gY2hpbGQuZWwgPT09IG51bGwgPyBjaGlsZCA6IGNsb25lVk5vZGUoY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc3RyaW5ncyBhbmQgbnVtYmVyc1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcclxuICAgIH1cclxufVxyXG4vLyBvcHRpbWl6ZWQgbm9ybWFsaXphdGlvbiBmb3IgdGVtcGxhdGUtY29tcGlsZWQgcmVuZGVyIGZuc1xyXG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcclxuICAgIGxldCB0eXBlID0gMDtcclxuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fCBzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgc2xvdCB0byBwbGFpbiBjaGlsZHJlbiBmb3IgcGxhaW4gZWxlbWVudCBhbmQgVGVsZXBvcnRcclxuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBfYyBtYXJrZXIgaXMgYWRkZWQgYnkgd2l0aEN0eCgpIGluZGljYXRpbmcgdGhpcyBpcyBhIGNvbXBpbGVkIHNsb3RcclxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgc2V0Q29tcGlsZWRTbG90UmVuZGVyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIHNldENvbXBpbGVkU2xvdFJlbmRlcmluZygtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgLyogRk9SV0FSREVEICovICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBjaGlsZCBjb21wb25lbnQgcmVjZWl2ZXMgZm9yd2FyZGVkIHNsb3RzIGZyb20gdGhlIHBhcmVudC5cclxuICAgICAgICAgICAgICAgIC8vIGl0cyBzbG90IHR5cGUgaXMgZGV0ZXJtaW5lZCBieSBpdHMgcGFyZW50J3Mgc2xvdCB0eXBlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS52bm9kZS5wYXRjaEZsYWcgJiAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMiAvKiBEWU5BTUlDICovO1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMSAvKiBTVEFCTEUgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XHJcbiAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xyXG4gICAgICAgIC8vIGZvcmNlIHRlbGVwb3J0IGNoaWxkcmVuIHRvIGFycmF5IHNvIGl0IGNhbiBiZSBtb3ZlZCBhcm91bmRcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSA4IC8qIFRFWFRfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xyXG4gICAgY29uc3QgcmV0ID0gZXh0ZW5kKHt9LCBhcmdzWzBdKTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZyAhPT0gaW5jb21pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCB0b01lcmdlW2tleV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jb21pbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcclxuICAgICAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcclxuICAgICAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xyXG4gICAgICAgIC8vIG93biBwcm92aWRlcyBvYmplY3QgdXNpbmcgcGFyZW50IHByb3ZpZGVzIG9iamVjdCBhcyBwcm90b3R5cGUuXHJcbiAgICAgICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcclxuICAgICAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxyXG4gICAgICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XHJcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxyXG4gICAgLy8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgLy8gIzI0MDBcclxuICAgICAgICAvLyB0byBzdXBwb3J0IGBhcHAudXNlYCBwbHVnaW5zLFxyXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcENvbnRleHQncyBgcHJvdmlkZXNgIGlmIHRoZSBpbnRhbmNlIGlzIGF0IHJvb3RcclxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlLnBhcmVudCA9PSBudWxsXHJcbiAgICAgICAgICAgID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzXHJcbiAgICAgICAgICAgIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlKClcclxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAodHlwZSwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5sZXQgaXNJbkJlZm9yZUNyZWF0ZSA9IGZhbHNlO1xyXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMsIGRlZmVycmVkRGF0YSA9IFtdLCBkZWZlcnJlZFdhdGNoID0gW10sIGRlZmVycmVkUHJvdmlkZSA9IFtdLCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgXHJcbiAgICAvLyBjb21wb3NpdGlvblxyXG4gICAgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucywgXHJcbiAgICAvLyBzdGF0ZVxyXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBcclxuICAgIC8vIGxpZmVjeWNsZVxyXG4gICAgYmVmb3JlTW91bnQsIG1vdW50ZWQsIGJlZm9yZVVwZGF0ZSwgdXBkYXRlZCwgYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCwgYmVmb3JlRGVzdHJveSwgYmVmb3JlVW5tb3VudCwgZGVzdHJveWVkLCB1bm1vdW50ZWQsIHJlbmRlciwgcmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJpZ2dlcmVkLCBlcnJvckNhcHR1cmVkLCBcclxuICAgIC8vIHB1YmxpYyBBUElcclxuICAgIGV4cG9zZSB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcclxuICAgIGNvbnN0IGdsb2JhbE1peGlucyA9IGluc3RhbmNlLmFwcENvbnRleHQubWl4aW5zO1xyXG4gICAgaWYgKGFzTWl4aW4gJiYgcmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcclxuICAgIH1cclxuICAgIC8vIGFwcGx5T3B0aW9ucyBpcyBjYWxsZWQgbm9uLWFzLW1peGluIG9uY2UgcGVyIGluc3RhbmNlXHJcbiAgICBpZiAoIWFzTWl4aW4pIHtcclxuICAgICAgICBpc0luQmVmb3JlQ3JlYXRlID0gdHJ1ZTtcclxuICAgICAgICBjYWxsU3luY0hvb2soJ2JlZm9yZUNyZWF0ZScsIFwiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovLCBvcHRpb25zLCBpbnN0YW5jZSwgZ2xvYmFsTWl4aW5zKTtcclxuICAgICAgICBpc0luQmVmb3JlQ3JlYXRlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBmaXJzdFxyXG4gICAgICAgIGFwcGx5TWl4aW5zKGluc3RhbmNlLCBnbG9iYWxNaXhpbnMsIGRlZmVycmVkRGF0YSwgZGVmZXJyZWRXYXRjaCwgZGVmZXJyZWRQcm92aWRlKTtcclxuICAgIH1cclxuICAgIC8vIGV4dGVuZGluZyBhIGJhc2UgY29tcG9uZW50Li4uXHJcbiAgICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UsIGV4dGVuZHNPcHRpb25zLCBkZWZlcnJlZERhdGEsIGRlZmVycmVkV2F0Y2gsIGRlZmVycmVkUHJvdmlkZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBsb2NhbCBtaXhpbnNcclxuICAgIGlmIChtaXhpbnMpIHtcclxuICAgICAgICBhcHBseU1peGlucyhpbnN0YW5jZSwgbWl4aW5zLCBkZWZlcnJlZERhdGEsIGRlZmVycmVkV2F0Y2gsIGRlZmVycmVkUHJvdmlkZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xyXG4gICAgICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIFBST1BTICovLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gb3B0aW9ucyBpbml0aWFsaXphdGlvbiBvcmRlciAodG8gYmUgY29uc2lzdGVudCB3aXRoIFZ1ZSAyKTpcclxuICAgIC8vIC0gcHJvcHMgKGFscmVhZHkgZG9uZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24pXHJcbiAgICAvLyAtIGluamVjdFxyXG4gICAgLy8gLSBtZXRob2RzXHJcbiAgICAvLyAtIGRhdGEgKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxyXG4gICAgLy8gLSBjb21wdXRlZFxyXG4gICAgLy8gLSB3YXRjaCAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXHJcbiAgICBpZiAoaW5qZWN0T3B0aW9ucykge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0T3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaW5qZWN0T3B0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3RPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSwgb3B0LmRlZmF1bHQsIHRydWUgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KG9wdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG1ldGhvZHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiBkZXYgbW9kZSwgd2UgdXNlIHRoZSBgY3JlYXRlUmVuZGVyQ29udGV4dGAgZnVuY3Rpb24gdG8gZGVmaW5lIG1ldGhvZHMgdG8gdGhlIHByb3h5IHRhcmdldCxcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aG9zZSBhcmUgcmVhZC1vbmx5IGJ1dCByZWNvbmZpZ3VyYWJsZSwgc28gaXQgbmVlZHMgdG8gYmUgcmVkZWZpbmVkIGhlcmVcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghYXNNaXhpbikge1xyXG4gICAgICAgIGlmIChkZWZlcnJlZERhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkRGF0YS5mb3JFYWNoKGRhdGFGbiA9PiByZXNvbHZlRGF0YShpbnN0YW5jZSwgZGF0YUZuLCBwdWJsaWNUaGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRhT3B0aW9ucykge1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIGRhdGFPcHRpb25zIGlzIG5vdCBmdWxseSB0eXBlIHNhZmVcclxuICAgICAgICAgICAgcmVzb2x2ZURhdGEoaW5zdGFuY2UsIGRhdGFPcHRpb25zLCBwdWJsaWNUaGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zdCByYXdEYXRhID0gdG9SYXcoaW5zdGFuY2UuZGF0YSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlIGRhdGEgb24gY3R4IGR1cmluZyBkZXZcclxuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICckJyAmJiBrZXlbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcmF3RGF0YVtrZXldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGFPcHRpb25zKSB7XHJcbiAgICAgICAgZGVmZXJyZWREYXRhLnB1c2goZGF0YU9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24ob3B0LmdldClcclxuICAgICAgICAgICAgICAgICAgICA/IG9wdC5nZXQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIDogTk9PUDtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBnZXQgPT09IE5PT1ApIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldClcclxuICAgICAgICAgICAgICAgID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XHJcbiAgICAgICAgICAgICAgICBnZXQsXHJcbiAgICAgICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHNldDogdiA9PiAoYy52YWx1ZSA9IHYpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgIGRlZmVycmVkV2F0Y2gucHVzaCh3YXRjaE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhc01peGluICYmIGRlZmVycmVkV2F0Y2gubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVmZXJyZWRXYXRjaC5mb3JFYWNoKHdhdGNoT3B0aW9ucyA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcclxuICAgICAgICBkZWZlcnJlZFByb3ZpZGUucHVzaChwcm92aWRlT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFzTWl4aW4gJiYgZGVmZXJyZWRQcm92aWRlLmxlbmd0aCkge1xyXG4gICAgICAgIGRlZmVycmVkUHJvdmlkZS5mb3JFYWNoKHByb3ZpZGVPcHRpb25zID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IHByb3ZpZGVPcHRpb25zO1xyXG4gICAgICAgICAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBhc3NldCBvcHRpb25zLlxyXG4gICAgLy8gVG8gcmVkdWNlIG1lbW9yeSB1c2FnZSwgb25seSBjb21wb25lbnRzIHdpdGggbWl4aW5zIG9yIGV4dGVuZHMgd2lsbCBoYXZlXHJcbiAgICAvLyByZXNvbHZlZCBhc3NldCByZWdpc3RyeSBhdHRhY2hlZCB0byBpbnN0YW5jZS5cclxuICAgIGlmIChhc01peGluKSB7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKGluc3RhbmNlLmNvbXBvbmVudHMgfHxcclxuICAgICAgICAgICAgICAgIChpbnN0YW5jZS5jb21wb25lbnRzID0gZXh0ZW5kKHt9LCBpbnN0YW5jZS50eXBlLmNvbXBvbmVudHMpKSwgY29tcG9uZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChpbnN0YW5jZS5kaXJlY3RpdmVzIHx8XHJcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGV4dGVuZCh7fSwgaW5zdGFuY2UudHlwZS5kaXJlY3RpdmVzKSksIGRpcmVjdGl2ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGxpZmVjeWNsZSBvcHRpb25zXHJcbiAgICBpZiAoIWFzTWl4aW4pIHtcclxuICAgICAgICBjYWxsU3luY0hvb2soJ2NyZWF0ZWQnLCBcImNcIiAvKiBDUkVBVEVEICovLCBvcHRpb25zLCBpbnN0YW5jZSwgZ2xvYmFsTWl4aW5zKTtcclxuICAgIH1cclxuICAgIGlmIChiZWZvcmVNb3VudCkge1xyXG4gICAgICAgIG9uQmVmb3JlTW91bnQoYmVmb3JlTW91bnQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgIG9uTW91bnRlZChtb3VudGVkLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGJlZm9yZVVwZGF0ZSkge1xyXG4gICAgICAgIG9uQmVmb3JlVXBkYXRlKGJlZm9yZVVwZGF0ZS5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmICh1cGRhdGVkKSB7XHJcbiAgICAgICAgb25VcGRhdGVkKHVwZGF0ZWQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgb25BY3RpdmF0ZWQoYWN0aXZhdGVkLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgb25EZWFjdGl2YXRlZChkZWFjdGl2YXRlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmIChlcnJvckNhcHR1cmVkKSB7XHJcbiAgICAgICAgb25FcnJvckNhcHR1cmVkKGVycm9yQ2FwdHVyZWQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVuZGVyVHJhY2tlZCkge1xyXG4gICAgICAgIG9uUmVuZGVyVHJhY2tlZChyZW5kZXJUcmFja2VkLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlbmRlclRyaWdnZXJlZCkge1xyXG4gICAgICAgIG9uUmVuZGVyVHJpZ2dlcmVkKHJlbmRlclRyaWdnZXJlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYmVmb3JlRGVzdHJveSkge1xyXG4gICAgICAgIHdhcm4oYFxcYGJlZm9yZURlc3Ryb3lcXGAgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBiZWZvcmVVbm1vdW50XFxgLmApO1xyXG4gICAgfVxyXG4gICAgaWYgKGJlZm9yZVVubW91bnQpIHtcclxuICAgICAgICBvbkJlZm9yZVVubW91bnQoYmVmb3JlVW5tb3VudC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZGVzdHJveWVkKSB7XHJcbiAgICAgICAgd2FybihgXFxgZGVzdHJveWVkXFxgIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgdW5tb3VudGVkXFxgLmApO1xyXG4gICAgfVxyXG4gICAgaWYgKHVubW91bnRlZCkge1xyXG4gICAgICAgIG9uVW5tb3VudGVkKHVubW91bnRlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcclxuICAgICAgICBpZiAoIWFzTWl4aW4pIHtcclxuICAgICAgICAgICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0gcHJveHlSZWZzKHt9KSk7XHJcbiAgICAgICAgICAgICAgICBleHBvc2UuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRba2V5XSA9IHRvUmVmKHB1YmxpY1RoaXMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IEVNUFRZX09CSjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgVGhlIFxcYGV4cG9zZVxcYCBvcHRpb24gaXMgaWdub3JlZCB3aGVuIHVzZWQgaW4gbWl4aW5zLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsU3luY0hvb2sobmFtZSwgdHlwZSwgb3B0aW9ucywgaW5zdGFuY2UsIGdsb2JhbE1peGlucykge1xyXG4gICAgY2FsbEhvb2tGcm9tTWl4aW5zKG5hbWUsIHR5cGUsIGdsb2JhbE1peGlucywgaW5zdGFuY2UpO1xyXG4gICAgY29uc3QgeyBleHRlbmRzOiBiYXNlLCBtaXhpbnMgfSA9IG9wdGlvbnM7XHJcbiAgICBpZiAoYmFzZSkge1xyXG4gICAgICAgIGNhbGxIb29rRnJvbUV4dGVuZHMobmFtZSwgdHlwZSwgYmFzZSwgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1peGlucykge1xyXG4gICAgICAgIGNhbGxIb29rRnJvbU1peGlucyhuYW1lLCB0eXBlLCBtaXhpbnMsIGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGZIb29rID0gb3B0aW9uc1tuYW1lXTtcclxuICAgIGlmIChzZWxmSG9vaykge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHNlbGZIb29rLmJpbmQoaW5zdGFuY2UucHJveHkpLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbEhvb2tGcm9tRXh0ZW5kcyhuYW1lLCB0eXBlLCBiYXNlLCBpbnN0YW5jZSkge1xyXG4gICAgaWYgKGJhc2UuZXh0ZW5kcykge1xyXG4gICAgICAgIGNhbGxIb29rRnJvbUV4dGVuZHMobmFtZSwgdHlwZSwgYmFzZS5leHRlbmRzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBiYXNlSG9vayA9IGJhc2VbbmFtZV07XHJcbiAgICBpZiAoYmFzZUhvb2spIHtcclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhiYXNlSG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxIb29rRnJvbU1peGlucyhuYW1lLCB0eXBlLCBtaXhpbnMsIGluc3RhbmNlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoYWluZWRNaXhpbnMgPSBtaXhpbnNbaV0ubWl4aW5zO1xyXG4gICAgICAgIGlmIChjaGFpbmVkTWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNhbGxIb29rRnJvbU1peGlucyhuYW1lLCB0eXBlLCBjaGFpbmVkTWl4aW5zLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZuID0gbWl4aW5zW2ldW25hbWVdO1xyXG4gICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbi5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhcHBseU1peGlucyhpbnN0YW5jZSwgbWl4aW5zLCBkZWZlcnJlZERhdGEsIGRlZmVycmVkV2F0Y2gsIGRlZmVycmVkUHJvdmlkZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UsIG1peGluc1tpXSwgZGVmZXJyZWREYXRhLCBkZWZlcnJlZFdhdGNoLCBkZWZlcnJlZFByb3ZpZGUsIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVEYXRhKGluc3RhbmNlLCBkYXRhRm4sIHB1YmxpY1RoaXMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oZGF0YUZuKSkge1xyXG4gICAgICAgIHdhcm4oYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIGAgK1xyXG4gICAgICAgICAgICBgUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gZGF0YUZuLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzUHJvbWlzZShkYXRhKSkge1xyXG4gICAgICAgIHdhcm4oYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBgICtcclxuICAgICAgICAgICAgYGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYCArXHJcbiAgICAgICAgICAgIGBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gKTtcclxuICAgIH1cclxuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5zdGFuY2UuZGF0YSA9PT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZXhpc3RpbmcgZGF0YTogdGhpcyBpcyBhIG1peGluIG9yIGV4dGVuZHMuXHJcbiAgICAgICAgZXh0ZW5kKGluc3RhbmNlLmRhdGEsIGRhdGEpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xyXG4gICAgY29uc3QgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKCcuJylcclxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxyXG4gICAgICAgIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xyXG4gICAgaWYgKGlzU3RyaW5nKHJhdykpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcclxuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgICAgIHJhdy5mb3JFYWNoKHIgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGN0eDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xyXG4gICAgICAgICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcmF3ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGNvbnN0IHsgX19tZXJnZWQsIG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IHJhdztcclxuICAgIGlmIChfX21lcmdlZClcclxuICAgICAgICByZXR1cm4gX19tZXJnZWQ7XHJcbiAgICBjb25zdCBnbG9iYWxNaXhpbnMgPSBpbnN0YW5jZS5hcHBDb250ZXh0Lm1peGlucztcclxuICAgIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucylcclxuICAgICAgICByZXR1cm4gcmF3O1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgZ2xvYmFsTWl4aW5zLmZvckVhY2gobSA9PiBtZXJnZU9wdGlvbnMob3B0aW9ucywgbSwgaW5zdGFuY2UpKTtcclxuICAgIG1lcmdlT3B0aW9ucyhvcHRpb25zLCByYXcsIGluc3RhbmNlKTtcclxuICAgIHJldHVybiAocmF3Ll9fbWVyZ2VkID0gb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3Qgc3RyYXRzID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xyXG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xyXG4gICAgZXh0ZW5kc09wdGlvbnMgJiYgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgaW5zdGFuY2UpO1xyXG4gICAgbWl4aW5zICYmXHJcbiAgICAgICAgbWl4aW5zLmZvckVhY2goKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgaW5zdGFuY2UpKTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcclxuICAgICAgICBpZiAoc3RyYXRzICYmIGhhc093bihzdHJhdHMsIGtleSkpIHtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IHN0cmF0c1trZXldKHRvW2tleV0sIGZyb21ba2V5XSwgaW5zdGFuY2UucHJveHksIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogIzI0MzcgSW4gVnVlIDMsIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3QgaGF2ZSBhIHB1YmxpYyBpbnN0YW5jZSBwcm94eSBidXRcclxuICogdGhleSBleGlzdCBpbiB0aGUgaW50ZXJuYWwgcGFyZW50IGNoYWluLiBGb3IgY29kZSB0aGF0IHJlbGllcyBvbiB0cmF2ZXJzaW5nXHJcbiAqIHB1YmxpYyAkcGFyZW50IGNoYWlucywgc2tpcCBmdW5jdGlvbmFsIG9uZXMgYW5kIGdvIHRvIHRoZSBwYXJlbnQgaW5zdGVhZC5cclxuICovXHJcbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcclxuICAgIGlmICghaSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKVxyXG4gICAgICAgIHJldHVybiBpLmV4cG9zZWQgPyBpLmV4cG9zZWQgOiBpLnByb3h5O1xyXG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcclxufTtcclxuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB7XHJcbiAgICAkOiBpID0+IGksXHJcbiAgICAkZWw6IGkgPT4gaS52bm9kZS5lbCxcclxuICAgICRkYXRhOiBpID0+IGkuZGF0YSxcclxuICAgICRwcm9wczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyksXHJcbiAgICAkYXR0cnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMpLFxyXG4gICAgJHNsb3RzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzKSxcclxuICAgICRyZWZzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyksXHJcbiAgICAkcGFyZW50OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcclxuICAgICRyb290OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXHJcbiAgICAkZW1pdDogaSA9PiBpLmVtaXQsXHJcbiAgICAkb3B0aW9uczogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlKSxcclxuICAgICRmb3JjZVVwZGF0ZTogaSA9PiAoKSA9PiBxdWV1ZUpvYihpLnVwZGF0ZSksXHJcbiAgICAkbmV4dFRpY2s6IGkgPT4gbmV4dFRpY2suYmluZChpLnByb3h5KSxcclxuICAgICR3YXRjaDogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1ApXHJcbn0pO1xyXG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBsZXQgQHZ1ZS9yZWFjdGl2aXR5IGtub3cgaXQgc2hvdWxkIG5ldmVyIG9ic2VydmUgVnVlIHB1YmxpYyBpbnN0YW5jZXMuXHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCBmb3JtYXR0ZXJzIHRvIGtub3cgdGhhdCB0aGlzIGlzIGEgVnVlIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgPT09ICdfX2lzVnVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGF0YSAvIHByb3BzIC8gY3R4XHJcbiAgICAgICAgLy8gVGhpcyBnZXR0ZXIgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgcmVuZGVyIGNvbnRleHRcclxuICAgICAgICAvLyBkdXJpbmcgcmVuZGVyIGFuZCBpcyBhIG1ham9yIGhvdHNwb3QuIFRoZSBtb3N0IGV4cGVuc2l2ZSBwYXJ0IG9mIHRoaXNcclxuICAgICAgICAvLyBpcyB0aGUgbXVsdGlwbGUgaGFzT3duKCkgY2FsbHMuIEl0J3MgbXVjaCBmYXN0ZXIgdG8gZG8gYSBzaW1wbGUgcHJvcGVydHlcclxuICAgICAgICAvLyBhY2Nlc3Mgb24gYSBwbGFpbiBvYmplY3QsIHNvIHdlIHVzZSBhbiBhY2Nlc3NDYWNoZSBvYmplY3QgKHdpdGggbnVsbFxyXG4gICAgICAgIC8vIHByb3RvdHlwZSkgdG8gbWVtb2l6ZSB3aGF0IGFjY2VzcyB0eXBlIGEga2V5IGNvcnJlc3BvbmRzIHRvLlxyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogU0VUVVAgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIENPTlRFWFQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogUFJPUFMgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6IGp1c3QgZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIFNFVFVQICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIERBVEEgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogUFJPUFMgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8ICFpc0luQmVmb3JlQ3JlYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBPVEhFUiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XHJcbiAgICAgICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcclxuICAgICAgICAvLyBwdWJsaWMgJHh4eCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHB1YmxpY0dldHRlcikge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJGF0dHJzJykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXHJcbiAgICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJlxyXG4gICAgICAgICAgICAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjc3NNb2R1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXHJcbiAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcclxuICAgICAgICAgICAgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiZcclxuICAgICAgICAgICAgKCFpc1N0cmluZyhrZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXHJcbiAgICAgICAgICAgICAgICBrZXkuaW5kZXhPZignX192JykgIT09IDApKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiZcclxuICAgICAgICAgICAgICAgIChrZXlbMF0gPT09ICckJyB8fCBrZXlbMF0gPT09ICdfJykgJiZcclxuICAgICAgICAgICAgICAgIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBoYXMoeyBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9IH0sIGtleSkge1xyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIChhY2Nlc3NDYWNoZVtrZXldICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihjdHgsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSkpO1xyXG4gICAgfVxyXG59O1xyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSkge1xyXG4gICAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgd2FybihgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSBleHRlbmQoe30sIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycywge1xyXG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgLy8gZmFzdCBwYXRoIGZvciB1bnNjb3BhYmxlcyB3aGVuIHVzaW5nIGB3aXRoYCBibG9ja1xyXG4gICAgICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xyXG4gICAgfSxcclxuICAgIGhhcyhfLCBrZXkpIHtcclxuICAgICAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09ICdfJyAmJiAhaXNHbG9iYWxseVdoaXRlbGlzdGVkKGtleSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzO1xyXG4gICAgfVxyXG59KTtcclxuLy8gSW4gZGV2IG1vZGUsIHRoZSBwcm94eSB0YXJnZXQgZXhwb3NlcyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHNlZW4gb24gYHRoaXNgXHJcbi8vIGZvciBlYXNpZXIgY29uc29sZSBpbnNwZWN0aW9uLiBJbiBwcm9kIG1vZGUgaXQgd2lsbCBiZSBhbiBlbXB0eSBvYmplY3Qgc29cclxuLy8gdGhlc2UgcHJvcGVydGllcyBkZWZpbml0aW9ucyBjYW4gYmUgc2tpcHBlZC5cclxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0ge307XHJcbiAgICAvLyBleHBvc2UgaW50ZXJuYWwgaW5zdGFuY2UgZm9yIHByb3h5IGhhbmRsZXJzXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxyXG4gICAgfSk7XHJcbiAgICAvLyBleHBvc2UgcHVibGljIHByb3BlcnRpZXNcclxuICAgIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAvLyBpbnRlcmNlcHRlZCBieSB0aGUgcHJveHkgc28gbm8gbmVlZCBmb3IgaW1wbGVtZW50YXRpb24sXHJcbiAgICAgICAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXHJcbiAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBleHBvc2UgZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IHsgZ2xvYmFsUHJvcGVydGllcyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XHJcbiAgICBPYmplY3Qua2V5cyhnbG9iYWxQcm9wZXJ0aWVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gZ2xvYmFsUHJvcGVydGllc1trZXldLFxyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xyXG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xyXG4gICAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgfHwga2V5WzBdID09PSAnXycpIHtcclxuICAgICAgICAgICAgd2Fybihgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgYCArXHJcbiAgICAgICAgICAgICAgICBgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxubGV0IHVpZCQxID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xyXG4gICAgLy8gaW5oZXJpdCBwYXJlbnQgYXBwIGNvbnRleHQgLSBvciAtIGlmIHJvb3QsIGFkb3B0IGZyb20gcm9vdCB2bm9kZVxyXG4gICAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcclxuICAgIGNvbnN0IGluc3RhbmNlID0ge1xyXG4gICAgICAgIHVpZDogdWlkJDErKyxcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBhcHBDb250ZXh0LFxyXG4gICAgICAgIHJvb3Q6IG51bGwsXHJcbiAgICAgICAgbmV4dDogbnVsbCxcclxuICAgICAgICBzdWJUcmVlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZTogbnVsbCxcclxuICAgICAgICByZW5kZXI6IG51bGwsXHJcbiAgICAgICAgcHJveHk6IG51bGwsXHJcbiAgICAgICAgZXhwb3NlZDogbnVsbCxcclxuICAgICAgICB3aXRoUHJveHk6IG51bGwsXHJcbiAgICAgICAgZWZmZWN0czogbnVsbCxcclxuICAgICAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcclxuICAgICAgICBhY2Nlc3NDYWNoZTogbnVsbCxcclxuICAgICAgICByZW5kZXJDYWNoZTogW10sXHJcbiAgICAgICAgLy8gbG9jYWwgcmVzb3ZsZWQgYXNzZXRzXHJcbiAgICAgICAgY29tcG9uZW50czogbnVsbCxcclxuICAgICAgICBkaXJlY3RpdmVzOiBudWxsLFxyXG4gICAgICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXHJcbiAgICAgICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgLy8gZW1pdFxyXG4gICAgICAgIGVtaXQ6IG51bGwsXHJcbiAgICAgICAgZW1pdHRlZDogbnVsbCxcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIGN0eDogRU1QVFlfT0JKLFxyXG4gICAgICAgIGRhdGE6IEVNUFRZX09CSixcclxuICAgICAgICBwcm9wczogRU1QVFlfT0JKLFxyXG4gICAgICAgIGF0dHJzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2xvdHM6IEVNUFRZX09CSixcclxuICAgICAgICByZWZzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwQ29udGV4dDogbnVsbCxcclxuICAgICAgICAvLyBzdXNwZW5zZSByZWxhdGVkXHJcbiAgICAgICAgc3VzcGVuc2UsXHJcbiAgICAgICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxyXG4gICAgICAgIGFzeW5jRGVwOiBudWxsLFxyXG4gICAgICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxyXG4gICAgICAgIC8vIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXHJcbiAgICAgICAgYmM6IG51bGwsXHJcbiAgICAgICAgYzogbnVsbCxcclxuICAgICAgICBibTogbnVsbCxcclxuICAgICAgICBtOiBudWxsLFxyXG4gICAgICAgIGJ1OiBudWxsLFxyXG4gICAgICAgIHU6IG51bGwsXHJcbiAgICAgICAgdW06IG51bGwsXHJcbiAgICAgICAgYnVtOiBudWxsLFxyXG4gICAgICAgIGRhOiBudWxsLFxyXG4gICAgICAgIGE6IG51bGwsXHJcbiAgICAgICAgcnRnOiBudWxsLFxyXG4gICAgICAgIHJ0YzogbnVsbCxcclxuICAgICAgICBlYzogbnVsbFxyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcclxuICAgIH1cclxuICAgIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xyXG4gICAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbn1cclxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xyXG4gICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbn07XHJcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnKTtcclxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbmZpZykge1xyXG4gICAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgTk87XHJcbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGFwcElzTmF0aXZlVGFnKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogJyArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLztcclxufVxyXG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XHJcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcclxuICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcclxuICAgIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsXHJcbiAgICAgICAgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUilcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHNldHVwUmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGlmIChDb21wb25lbnQubmFtZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAwLiBjcmVhdGUgcmVuZGVyIHByb3h5IHByb3BlcnR5IGFjY2VzcyBjYWNoZVxyXG4gICAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgLy8gMS4gY3JlYXRlIHB1YmxpYyBpbnN0YW5jZSAvIHJlbmRlciBwcm94eVxyXG4gICAgLy8gYWxzbyBtYXJrIGl0IHJhdyBzbyBpdCdzIG5ldmVyIG9ic2VydmVkXHJcbiAgICBpbnN0YW5jZS5wcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLy8gMi4gY2FsbCBzZXR1cCgpXHJcbiAgICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XHJcbiAgICBpZiAoc2V0dXApIHtcclxuICAgICAgICBjb25zdCBzZXR1cENvbnRleHQgPSAoaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID1cclxuICAgICAgICAgICAgc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsKTtcclxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovLCBbKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNQcm9taXNlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNTU1IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJvbWlzZSBzbyBzZXJ2ZXItcmVuZGVyZXIgY2FuIHdhaXQgb24gaXRcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFJlc3VsdC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jIHNldHVwIHJldHVybmVkIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGhlcmUgYW5kIHdhaXQgZm9yIHJlLWVudHJ5LlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYW4gaW5saW5lIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIGAgK1xyXG4gICAgICAgICAgICAgICAgYHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBiaW5kaW5ncy5cclxuICAgICAgICAvLyBhc3N1bWluZyBhIHJlbmRlciBmdW5jdGlvbiBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gKTtcclxuICAgIH1cclxuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlKTtcclxufVxyXG5sZXQgY29tcGlsZTtcclxuLy8gZGV2IG9ubHlcclxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xyXG4vKipcclxuICogRm9yIHJ1bnRpbWUtZG9tIHRvIHJlZ2lzdGVyIHRoZSBjb21waWxlci5cclxuICogTm90ZSB0aGUgZXhwb3J0ZWQgbWV0aG9kIHVzZXMgYW55IHRvIGF2b2lkIGQudHMgcmVseWluZyBvbiB0aGUgY29tcGlsZXIgdHlwZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xyXG4gICAgY29tcGlsZSA9IF9jb21waWxlO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUikge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIC8vIHRlbXBsYXRlIC8gcmVuZGVyIGZ1bmN0aW9uIG5vcm1hbGl6YXRpb25cclxuICAgIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XHJcbiAgICAgICAgLy8gY291bGQgYmUgc2V0IGZyb20gc2V0dXAoKVxyXG4gICAgICAgIGlmIChjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUoQ29tcG9uZW50LnRlbXBsYXRlLCB7XHJcbiAgICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQ6IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIGRlbGltaXRlcnM6IENvbXBvbmVudC5kZWxpbWl0ZXJzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IE5PT1ApO1xyXG4gICAgICAgIC8vIGZvciBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrcywgdGhlIHJlbmRlclxyXG4gICAgICAgIC8vIHByb3h5IHVzZWQgbmVlZHMgYSBkaWZmZXJlbnQgYGhhc2AgaGFuZGxlciB3aGljaCBpcyBtb3JlIHBlcmZvcm1hbnQgYW5kXHJcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX3JjKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLndpdGhQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc3VwcG9ydCBmb3IgMi54IG9wdGlvbnNcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSwgQ29tcG9uZW50KTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vIHdhcm4gbWlzc2luZyB0ZW1wbGF0ZS9yZW5kZXJcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgIGBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXHJcbiAgICAgICAgICAgICAgICAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gXHJcbiAgICAgICAgICAgICAgICAgICAgKSAvKiBzaG91bGQgbm90IGhhcHBlbiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGF0dHJIYW5kbGVycyA9IHtcclxuICAgIGdldDogKHRhcmdldCwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICB9LFxyXG4gICAgc2V0OiAoKSA9PiB7XHJcbiAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkZWxldGVQcm9wZXJ0eTogKCkgPT4ge1xyXG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgZXhwb3NlID0gZXhwb3NlZCA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gcHJveHlSZWZzKGV4cG9zZWQpO1xyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAvLyBXZSB1c2UgZ2V0dGVycyBpbiBkZXYgaW4gY2FzZSBsaWJzIGxpa2UgdGVzdC11dGlscyBvdmVyd3JpdGUgaW5zdGFuY2VcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIChvdmVyd3JpdGVzIHNob3VsZCBub3QgYmUgZG9uZSBpbiBwcm9kKVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgZ2V0IHByb3BzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRySGFuZGxlcnMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgc2xvdHMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnNsb3RzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IGVtaXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhdHRyczogaW5zdGFuY2UuYXR0cnMsXHJcbiAgICAgICAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcclxuICAgICAgICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vLyByZWNvcmQgZWZmZWN0cyBjcmVhdGVkIGR1cmluZyBhIGNvbXBvbmVudCdzIHNldHVwKCkgc28gdGhhdCB0aGV5IGNhbiBiZVxyXG4vLyBzdG9wcGVkIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xyXG5mdW5jdGlvbiByZWNvcmRJbnN0YW5jZUJvdW5kRWZmZWN0KGVmZmVjdCwgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIChpbnN0YW5jZS5lZmZlY3RzIHx8IChpbnN0YW5jZS5lZmZlY3RzID0gW10pKS5wdXNoKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcclxuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCAnJyk7XHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihDb21wb25lbnQpXHJcbiAgICAgICAgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWVcclxuICAgICAgICA6IENvbXBvbmVudC5uYW1lO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcclxuICAgIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAvLyB0cnkgdG8gaW5mZXIgdGhlIG5hbWUgYmFzZWQgb24gcmV2ZXJzZSByZXNvbHV0aW9uXHJcbiAgICAgICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBuYW1lID1cclxuICAgICAgICAgICAgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuY29tcG9uZW50cyB8fFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50cykgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiAnX192Y2NPcHRzJyBpbiB2YWx1ZTtcclxufVxuXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGMgPSBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucyk7XHJcbiAgICByZWNvcmRJbnN0YW5jZUJvdW5kRWZmZWN0KGMuZWZmZWN0KTtcclxuICAgIHJldHVybiBjO1xyXG59XG5cbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYGRlZmluZVByb3BzKCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcclxuICAgICAgICAgICAgYDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBgICtcclxuICAgICAgICAgICAgYGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gZGVmaW5lRW1pdCgpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBkZWZpbmVFbWl0KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcclxuICAgICAgICAgICAgYDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBgICtcclxuICAgICAgICAgICAgYGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdXNlQ29udGV4dCgpIHtcclxuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWkpIHtcclxuICAgICAgICB3YXJuKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XHJcbn1cblxuLy8gQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xyXG4gICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICBpZiAobCA9PT0gMikge1xyXG4gICAgICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIHZub2RlIHdpdGhvdXQgcHJvcHNcclxuICAgICAgICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wcyB3aXRob3V0IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gb21pdCBwcm9wc1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobCA+IDMpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNzckNvbnRleHRgIDogYGApO1xyXG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcclxuICAgICAgICBpZiAoIWN0eCkge1xyXG4gICAgICAgICAgICB3YXJuKGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdHg7XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzNiYTc3NicgfTtcclxuICAgIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMwYjFiYzknIH07XHJcbiAgICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojYjYyZTI0JyB9O1xyXG4gICAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiM5ZDI4OGMnIH07XHJcbiAgICAvLyBjdXN0b20gZm9ybWF0dGVyIGZvciBDaHJvbWVcclxuICAgIC8vIGh0dHBzOi8vd3d3Lm1hdHR6ZXVuZXJ0LmNvbS8yMDE2LzAyLzE5L2N1c3RvbS1jaHJvbWUtZGV2dG9vbHMtb2JqZWN0LWZvcm1hdHRlcnMuaHRtbFxyXG4gICAgY29uc3QgZm9ybWF0dGVyID0ge1xyXG4gICAgICAgIGhlYWRlcihvYmopIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBhbHNvIGZvcm1hdCBDb21wb25lbnRQdWJsaWNJbnN0YW5jZSAmIGN0eC5zbG90cy9hdHRycyBpbiBzZXR1cFxyXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iai52YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgYD5gXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgJ1JlYWN0aXZlJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXHJcbiAgICAgICAgICAgICAgICAgICAgYD4ke2lzUmVhZG9ubHkob2JqKSA/IGAgKHJlYWRvbmx5KWAgOiBgYH1gXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhZG9ubHkob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgJ1JlYWRvbmx5J10sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzQm9keShvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHkob2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgYmxvY2tzID0gW107XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygncHJvcHMnLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdzZXR1cCcsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdkYXRhJywgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2NvbXB1dGVkJyk7XHJcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2NvbXB1dGVkJywgY29tcHV0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2luamVjdCcpO1xyXG4gICAgICAgIGlmIChpbmplY3RlZCkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdpbmplY3RlZCcsIGluamVjdGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJsb2Nrcy5wdXNoKFtcclxuICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnc3BhbicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArICc7b3BhY2l0eTowLjY2J1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICckIChpbnRlcm5hbCk6ICdcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWydvYmplY3QnLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cclxuICAgICAgICBdKTtcclxuICAgICAgICByZXR1cm4gYmxvY2tzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcclxuICAgICAgICB0YXJnZXQgPSBleHRlbmQoe30sIHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywge31dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgeyBzdHlsZTogJ2xpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtJyB9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOiM0NzY1ODInXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3BhZGRpbmctbGVmdDoxLjI1ZW0nXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIGtleXdvcmRTdHlsZSwga2V5ICsgJzogJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKHRhcmdldFtrZXldLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBudW1iZXJTdHlsZSwgdl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywga2V5d29yZFN0eWxlLCB2XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnb2JqZWN0JywgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xyXG4gICAgICAgIGlmICgoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkpIHx8XHJcbiAgICAgICAgICAgIChpc09iamVjdChvcHRzKSAmJiBrZXkgaW4gb3B0cykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZShtID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xyXG4gICAgICAgIGlmICh2Ll9zaGFsbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2LmVmZmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYENvbXB1dGVkUmVmYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGBSZWZgO1xyXG4gICAgfVxyXG4gICAgaWYgKHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMpIHtcclxuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSkge1xyXG4gICAgbGV0IHJldDtcclxuICAgIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2VbaV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgICAgICAgcmV0ID0gQXJyYXkuZnJvbShzb3VyY2UsIHJlbmRlckl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0ID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgcHJlZml4aW5nIGtleXMgaW4gdi1vbj1cIm9ialwiIHdpdGggXCJvblwiXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaikge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICByZXRbdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgY3JlYXRpbmcgZHluYW1pYyBzbG90cyBvYmplY3RcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcclxuICAgICAgICAvLyBhcnJheSBvZiBkeW5hbWljIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiICNbLi4uXT5cclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gY29uZGl0aW9uYWwgc2luZ2xlIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWlmPVwiLi4uXCIgI2Zvbz5cclxuICAgICAgICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3QuZm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3RzO1xyXG59XG5cbi8vIENvcmUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5jb25zdCB2ZXJzaW9uID0gXCIzLjAuN1wiO1xyXG4vKipcclxuICogU1NSIHV0aWxzIGZvciBcXEB2dWUvc2VydmVyLXJlbmRlcmVyLiBPbmx5IGV4cG9zZWQgaW4gY2pzIGJ1aWxkcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBzc3JVdGlscyA9IChudWxsKTtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIENvbW1lbnQsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wdXRlZCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTbG90cywgY3JlYXRlU3RhdGljVk5vZGUsIGNyZWF0ZVRleHRWTm9kZSwgY3JlYXRlVk5vZGUsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlZmluZUVtaXQsIGRlZmluZVByb3BzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGgsIGhhbmRsZUVycm9yLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUNvbnRleHQsIHVzZVNTUkNvbnRleHQsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3aXRoQ3R4LCB3aXRoRGlyZWN0aXZlcywgd2l0aFNjb3BlSWQgfTtcbiIsImltcG9ydCB7IGNhbWVsaXplLCB3YXJuLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZ2V0Q3VycmVudEluc3RhbmNlLCBvbk1vdW50ZWQsIHdhdGNoRWZmZWN0LCBvblVwZGF0ZWQsIEZyYWdtZW50LCBoLCBCYXNlVHJhbnNpdGlvbiwgdXNlVHJhbnNpdGlvblN0YXRlLCB0b1JhdywgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBzZXRUcmFuc2l0aW9uSG9va3MsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIGNyZWF0ZVZOb2RlLCBjcmVhdGVSZW5kZXJlciwgaXNSdW50aW1lT25seSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNBcnJheSwgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBpc0Z1bmN0aW9uLCBFTVBUWV9PQkosIGV4dGVuZCwgaXNPYmplY3QsIHRvTnVtYmVyLCBpbnZva2VBcnJheUZucywgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaXNIVE1MVGFnLCBpc1NWR1RhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG5jb25zdCBkb2MgPSAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbCk7XHJcbmxldCB0ZW1wQ29udGFpbmVyO1xyXG5sZXQgdGVtcFNWR0NvbnRhaW5lcjtcclxuY29uc3Qgbm9kZU9wcyA9IHtcclxuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzKSA9PiBpc1NWR1xyXG4gICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKVxyXG4gICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCksXHJcbiAgICBjcmVhdGVUZXh0OiB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcclxuICAgIGNyZWF0ZUNvbW1lbnQ6IHRleHQgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXHJcbiAgICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xyXG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XHJcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xyXG4gICAgfSxcclxuICAgIHBhcmVudE5vZGU6IG5vZGUgPT4gbm9kZS5wYXJlbnROb2RlLFxyXG4gICAgbmV4dFNpYmxpbmc6IG5vZGUgPT4gbm9kZS5uZXh0U2libGluZyxcclxuICAgIHF1ZXJ5U2VsZWN0b3I6IHNlbGVjdG9yID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcclxuICAgIHNldFNjb3BlSWQoZWwsIGlkKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGlkLCAnJyk7XHJcbiAgICB9LFxyXG4gICAgY2xvbmVOb2RlKGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsLmNsb25lTm9kZSh0cnVlKTtcclxuICAgIH0sXHJcbiAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAvLyBSZWFzb246IGlubmVySFRNTC5cclxuICAgIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cclxuICAgIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXHJcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBpc1NWRykge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBpc1NWR1xyXG4gICAgICAgICAgICA/IHRlbXBTVkdDb250YWluZXIgfHxcclxuICAgICAgICAgICAgICAgICh0ZW1wU1ZHQ29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgJ3N2ZycpKVxyXG4gICAgICAgICAgICA6IHRlbXBDb250YWluZXIgfHwgKHRlbXBDb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xyXG4gICAgICAgIHRlbXAuaW5uZXJIVE1MID0gY29udGVudDtcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHRlbXAuZmlyc3RDaGlsZDtcclxuICAgICAgICBsZXQgbm9kZSA9IGZpcnN0O1xyXG4gICAgICAgIGxldCBsYXN0ID0gbm9kZTtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBsYXN0ID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnQobm9kZSwgcGFyZW50LCBhbmNob3IpO1xyXG4gICAgICAgICAgICBub2RlID0gdGVtcC5maXJzdENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcclxuICAgIH1cclxufTtcblxuLy8gY29tcGlsZXIgc2hvdWxkIG5vcm1hbGl6ZSBjbGFzcyArIDpjbGFzcyBiaW5kaW5ncyBvbiB0aGUgc2FtZSBlbGVtZW50XHJcbi8vIGludG8gYSBzaW5nbGUgYmluZGluZyBbJ3N0YXRpY0NsYXNzJywgZHluYW1pY11cclxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkcpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGlyZWN0bHkgc2V0dGluZyBjbGFzc05hbWUgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNldEF0dHJpYnV0ZSBpbiB0aGVvcnlcclxuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGVsZW1lbnQgZHVyaW5nIGEgdHJhbnNpdGlvbiwgdGFrZSB0aGUgdGVtcG9yYXJ5IHRyYW5zaXRpb25cclxuICAgICAgICAvLyBjbGFzc2VzIGludG8gYWNjb3VudC5cclxuICAgICAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlXHJcbiAgICAgICAgICAgICAgICA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdXHJcbiAgICAgICAgICAgICAgICA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oJyAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xyXG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgIGlmICghbmV4dCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKG5leHQpKSB7XHJcbiAgICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xyXG4gICAgICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0aGUgYGRpc3BsYXlgIG9mIHRoZSBlbGVtZW50IGlzIGNvbnRyb2xsZWQgYnkgYHYtc2hvd2AsXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGFsd2F5cyBrZWVwIHRoZSBjdXJyZW50IGBkaXNwbGF5YCB2YWx1ZSByZWdhcmRsZXNzIG9mIHRoZSBgc3R5bGVgIHZhbHVlLFxyXG4gICAgICAgICAgICAvLyB0aHVzIGhhbmRpbmcgb3ZlciBjb250cm9sIHRvIGB2LXNob3dgLlxyXG4gICAgICAgICAgICBpZiAoJ192b2QnIGluIGVsKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gY3VycmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcclxuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xyXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgdmFsLmZvckVhY2godiA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLS0nKSkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gcHJvcGVydHkgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gIWltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKHByZWZpeGVkKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcbmNvbnN0IHByZWZpeENhY2hlID0ge307XHJcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xyXG4gICAgaWYgKG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgaW4gc3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZSk7XHJcbiAgICB9XHJcbiAgICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcclxuICAgICAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3TmFtZTtcclxufVxuXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoJ3hsaW5rOicpKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vdGUgd2UgYXJlIG9ubHkgY2hlY2tpbmcgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgZG9uJ3QgaGF2ZSBhXHJcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBkb20gcHJvcCBvZiB0aGUgc2FtZSBuYW1lIGhlcmUuXHJcbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KTtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoaXNCb29sZWFuICYmIHZhbHVlID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyAnJyA6IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gX19VTlNBRkVfX1xyXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcclxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcclxuLy8gdW5tb3VudGVkLlxyXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xyXG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xyXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cclxuICAgICAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBlbFtrZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycgJiYgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPHNlbGVjdCBtdWx0aXBsZT4gY29tcGlsZXMgdG8geyBtdWx0aXBsZTogJycgfVxyXG4gICAgICAgICAgICBlbFtrZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGRpdiA6aWQ9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIGVsW2tleV0gPSAnJztcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8aW1nIDp3aWR0aD1cIm51bGxcIj5cclxuICAgICAgICAgICAgZWxba2V5XSA9IDA7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIHBlcmZvcm0gdmFsdWUgdmFsaWRhdGlvbiBhbmQgdGhyb3dcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXHJcbiAgICAgICAgICAgICAgICBgdmFsdWUgJHt2YWx1ZX0gaXMgaW52YWxpZC5gLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cclxubGV0IF9nZXROb3cgPSBEYXRlLm5vdztcclxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcclxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcclxuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXHJcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cclxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIF9nZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgLy8gaWYgdGhlIGxvdy1yZXMgdGltZXN0YW1wIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBldmVudCB0aW1lc3RhbXBcclxuICAgIC8vICh3aGljaCBpcyBldmFsdWF0ZWQgQUZURVIpIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXHJcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cclxuICAgIF9nZXROb3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcclxufVxyXG4vLyBUbyBhdm9pZCB0aGUgb3ZlcmhlYWQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpLCB3ZSBjYWNoZVxyXG4vLyBhbmQgdXNlIHRoZSBzYW1lIHRpbWVzdGFtcCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCBpbiB0aGUgc2FtZSB0aWNrLlxyXG5sZXQgY2FjaGVkTm93ID0gMDtcclxuY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCByZXNldCA9ICgpID0+IHtcclxuICAgIGNhY2hlZE5vdyA9IDA7XHJcbn07XHJcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKHJlc2V0KSwgKGNhY2hlZE5vdyA9IF9nZXROb3coKSkpO1xyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcclxuICAgIC8vIHZlaSA9IHZ1ZSBldmVudCBpbnZva2Vyc1xyXG4gICAgY29uc3QgaW52b2tlcnMgPSBlbC5fdmVpIHx8IChlbC5fdmVpID0ge30pO1xyXG4gICAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XHJcbiAgICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgIC8vIHBhdGNoXHJcbiAgICAgICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xyXG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gYWRkXHJcbiAgICAgICAgICAgIGNvbnN0IGludm9rZXIgPSAoaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgICAgICAvLyByZW1vdmVcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xyXG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xyXG4gICAgbGV0IG9wdGlvbnM7XHJcbiAgICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtoeXBoZW5hdGUobmFtZS5zbGljZSgyKSksIG9wdGlvbnNdO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XHJcbiAgICAgICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXHJcbiAgICAgICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXHJcbiAgICAgICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcclxuICAgICAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXHJcbiAgICAgICAgY29uc3QgdGltZVN0YW1wID0gZS50aW1lU3RhbXAgfHwgX2dldE5vdygpO1xyXG4gICAgICAgIGlmICh0aW1lU3RhbXAgPj0gaW52b2tlci5hdHRhY2hlZCAtIDEpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcocGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksIGluc3RhbmNlLCA1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovLCBbZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xyXG4gICAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xyXG4gICAgcmV0dXJuIGludm9rZXI7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xyXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcclxuICAgICAgICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZuID0+IChlKSA9PiAhZS5fc3RvcHBlZCAmJiBmbihlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmF0aXZlT25SRSA9IC9eb25bYS16XS87XHJcbmNvbnN0IGZvcmNlUGF0Y2hQcm9wID0gKF8sIGtleSkgPT4ga2V5ID09PSAndmFsdWUnO1xyXG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGlzU1ZHID0gZmFsc2UsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIC8vIHNwZWNpYWxcclxuICAgICAgICBjYXNlICdjbGFzcyc6XHJcbiAgICAgICAgICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzdHlsZSc6XHJcbiAgICAgICAgICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPGlucHV0IHYtbW9kZWwgdHlwZT1cImNoZWNrYm94XCI+IHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIDp0cnVlLXZhbHVlICYgOmZhbHNlLXZhbHVlXHJcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBkb20gcHJvcGVydGllcyBzaW5jZSBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlXHJcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd0cnVlLXZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdmYWxzZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xyXG4gICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgLy8gbW9zdCBrZXlzIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZSBvbiBzdmcgZWxlbWVudHMgdG8gd29ya1xyXG4gICAgICAgIC8vIC4uLmV4Y2VwdCBpbm5lckhUTUxcclxuICAgICAgICBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3IgbmF0aXZlIG9uY2xpY2sgd2l0aCBmdW5jdGlvbiB2YWx1ZXNcclxuICAgICAgICBpZiAoa2V5IGluIGVsICYmIG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBzcGVsbGNoZWNrIGFuZCBkcmFnZ2FibGUgYXJlIG51bWVyYXRlZCBhdHRycywgaG93ZXZlciB0aGVpclxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBET00gcHJvcGVydGllcyBhcmUgYWN0dWFsbHkgYm9vbGVhbnMgLSB0aGlzIGxlYWRzIHRvXHJcbiAgICAvLyBzZXR0aW5nIGl0IHdpdGggYSBzdHJpbmcgXCJmYWxzZVwiIHZhbHVlIGxlYWRpbmcgaXQgdG8gYmUgY29lcmNlZCB0b1xyXG4gICAgLy8gYHRydWVgLCBzbyB3ZSBuZWVkIHRvIGFsd2F5cyB0cmVhdCB0aGVtIGFzIGF0dHJpYnV0ZXMuXHJcbiAgICAvLyBOb3RlIHRoYXQgYGNvbnRlbnRFZGl0YWJsZWAgZG9lc24ndCBoYXZlIHRoaXMgcHJvYmxlbTogaXRzIERPTVxyXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBlbnVtZXJhdGVkIHN0cmluZyB2YWx1ZXMuXHJcbiAgICBpZiAoa2V5ID09PSAnc3BlbGxjaGVjaycgfHwga2V5ID09PSAnZHJhZ2dhYmxlJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMxNzg3LCAjMjg0MCBmb3JtIHByb3BlcnR5IG9uIGZvcm0gZWxlbWVudHMgaXMgcmVhZG9ubHkgYW5kIG11c3QgYmUgc2V0IGFzXHJcbiAgICAvLyBhdHRyaWJ1dGUuXHJcbiAgICBpZiAoa2V5ID09PSAnZm9ybScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTUyNiA8aW5wdXQgbGlzdD4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAnbGlzdCcgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMyNzY2IDx0ZXh0YXJlYSB0eXBlPiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChrZXkgPT09ICd0eXBlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gbmF0aXZlIG9uY2xpY2sgd2l0aCBzdHJpbmcgdmFsdWUsIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXkgaW4gZWw7XHJcbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XHJcbiAgICAgICAgaWYgKCFtb2R1bGVzKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XHJcbiAgICAgICAgaWYgKCFtb2QpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIGdldHRlcihpbnN0YW5jZS5wcm94eSkpO1xyXG4gICAgb25Nb3VudGVkKCgpID0+IHdhdGNoRWZmZWN0KHNldFZhcnMsIHsgZmx1c2g6ICdwb3N0JyB9KSk7XHJcbiAgICBvblVwZGF0ZWQoc2V0VmFycyk7XHJcbn1cclxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlO1xyXG4gICAgICAgIHZub2RlID0gc3VzcGVuc2UuYWN0aXZlQnJhbmNoO1xyXG4gICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0VmFyc09uVk5vZGUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB2YXJzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZHJpbGwgZG93biBIT0NzIHVudGlsIGl0J3MgYSBub24tY29tcG9uZW50IHZub2RlXHJcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcclxuICAgIH1cclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgdm5vZGUuZWwpIHtcclxuICAgICAgICBjb25zdCBzdHlsZSA9IHZub2RlLmVsLnN0eWxlO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcclxuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goYyA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcclxuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XHJcbi8vIERPTSBUcmFuc2l0aW9uIGlzIGEgaGlnaGVyLW9yZGVyLWNvbXBvbmVudCBiYXNlZCBvbiB0aGUgcGxhdGZvcm0tYWdub3N0aWNcclxuLy8gYmFzZSBUcmFuc2l0aW9uIGNvbXBvbmVudCwgd2l0aCBET00tc3BlY2lmaWMgbG9naWMuXHJcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcclxuVHJhbnNpdGlvbi5kaXNwbGF5TmFtZSA9ICdUcmFuc2l0aW9uJztcclxuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIGNzczoge1xyXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXHJcbiAgICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcclxufTtcclxuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IChUcmFuc2l0aW9uLnByb3BzID0gLyojX19QVVJFX18qLyBleHRlbmQoe30sIEJhc2VUcmFuc2l0aW9uLnByb3BzLCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSk7XHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcclxuICAgIGxldCB7IG5hbWUgPSAndicsIHR5cGUsIGNzcyA9IHRydWUsIGR1cmF0aW9uLCBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLCBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCwgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLCBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcywgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLCBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLCBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLCBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCwgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gIH0gPSByYXdQcm9wcztcclxuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcclxuICAgICAgICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghY3NzKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VQcm9wcztcclxuICAgIH1cclxuICAgIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcclxuICAgIGNvbnN0IGVudGVyRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzBdO1xyXG4gICAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XHJcbiAgICBjb25zdCB7IG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlciwgb25BcHBlYXIgPSBvbkVudGVyLCBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWQgfSA9IGJhc2VQcm9wcztcclxuICAgIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcclxuICAgICAgICBkb25lICYmIGRvbmUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcclxuICAgICAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaEVudGVyKGVsLCBpc0FwcGVhciwgZG9uZSk7XHJcbiAgICAgICAgICAgIGhvb2sgJiYgaG9vayhlbCwgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoaG9vayAmJiBob29rLmxlbmd0aCA+IDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xyXG4gICAgICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgb25CZWZvcmVFbnRlciAmJiBvbkJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xyXG4gICAgICAgICAgICBvbkJlZm9yZUFwcGVhciAmJiBvbkJlZm9yZUFwcGVhcihlbCk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcclxuICAgICAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcclxuICAgICAgICBvbkxlYXZlKGVsLCBkb25lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgc28gKi1sZWF2ZS1mcm9tIGNsYXNzZXMgaW1tZWRpYXRlbHkgdGFrZSBlZmZlY3QgKCMyNTkzKVxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShvbkxlYXZlICYmIG9uTGVhdmUubGVuZ3RoID4gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgb25MZWF2ZSAmJiBvbkxlYXZlKGVsLCByZXNvbHZlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgb25FbnRlckNhbmNlbGxlZCAmJiBvbkVudGVyQ2FuY2VsbGVkKGVsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQgJiYgb25BcHBlYXJDYW5jZWxsZWQoZWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hMZWF2ZShlbCk7XHJcbiAgICAgICAgICAgIG9uTGVhdmVDYW5jZWxsZWQgJiYgb25MZWF2ZUNhbmNlbGxlZChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pIHtcclxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChkdXJhdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIFtuLCBuXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcclxuICAgIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxyXG4gICAgICAgIHZhbGlkYXRlRHVyYXRpb24ocmVzKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVEdXJhdGlvbih2YWwpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBgICtcclxuICAgICAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbiBpcyBOYU4gLSBgICtcclxuICAgICAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xyXG4gICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICAoZWwuX3Z0YyB8fFxyXG4gICAgICAgIChlbC5fdnRjID0gbmV3IFNldCgpKSkuYWRkKGNscyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgY29uc3QgeyBfdnRjIH0gPSBlbDtcclxuICAgIGlmIChfdnRjKSB7XHJcbiAgICAgICAgX3Z0Yy5kZWxldGUoY2xzKTtcclxuICAgICAgICBpZiAoIV92dGMuc2l6ZSkge1xyXG4gICAgICAgICAgICBlbC5fdnRjID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcclxuICAgIH0pO1xyXG59XHJcbmxldCBlbmRJZCA9IDA7XHJcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcclxuICAgIGNvbnN0IGlkID0gKGVsLl9lbmRJZCA9ICsrZW5kSWQpO1xyXG4gICAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoZXhwbGljaXRUaW1lb3V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XHJcbiAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgJ2VuZCc7XHJcbiAgICBsZXQgZW5kZWQgPSAwO1xyXG4gICAgY29uc3QgZW5kID0gKCkgPT4ge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxuICAgICAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGltZW91dCArIDEpO1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcclxuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCAnJykuc3BsaXQoJywgJyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoVFJBTlNJVElPTiArICdEdXJhdGlvbicpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKEFOSU1BVElPTiArICdEZWxheScpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKEFOSU1BVElPTiArICdEdXJhdGlvbicpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xyXG4gICAgbGV0IHR5cGUgPSBudWxsO1xyXG4gICAgbGV0IHRpbWVvdXQgPSAwO1xyXG4gICAgbGV0IHByb3BDb3VudCA9IDA7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBBTklNQVRJT047XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XHJcbiAgICAgICAgdHlwZSA9XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxyXG4gICAgICAgICAgICAgICAgICAgID8gVFJBTlNJVElPTlxyXG4gICAgICAgICAgICAgICAgICAgIDogQU5JTUFUSU9OXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgcHJvcENvdW50ID0gdHlwZVxyXG4gICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxyXG4gICAgICAgICAgICA6IDA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmXHJcbiAgICAgICAgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KHN0eWxlc1tUUkFOU0lUSU9OICsgJ1Byb3BlcnR5J10pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHRpbWVvdXQsXHJcbiAgICAgICAgcHJvcENvdW50LFxyXG4gICAgICAgIGhhc1RyYW5zZm9ybVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xyXG59XHJcbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyXHJcbi8vIG51bWJlcnMgaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxyXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duXHJcbi8vIChpLmUuIGFjdGluZyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXHJcbmZ1bmN0aW9uIHRvTXMocykge1xyXG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwO1xyXG59XHJcbi8vIHN5bmNocm9ub3VzbHkgZm9yY2UgbGF5b3V0IHRvIHB1dCBlbGVtZW50cyBpbnRvIGEgY2VydGFpbiBzdGF0ZVxyXG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcclxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IHtcclxuICAgIG5hbWU6ICdUcmFuc2l0aW9uR3JvdXAnLFxyXG4gICAgcHJvcHM6IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XHJcbiAgICAgICAgdGFnOiBTdHJpbmcsXHJcbiAgICAgICAgbW92ZUNsYXNzOiBTdHJpbmdcclxuICAgIH0pLFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcclxuICAgICAgICBsZXQgcHJldkNoaWxkcmVuO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbjtcclxuICAgICAgICBvblVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjaGlsZHJlbiBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IGFmdGVyIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8ICd2J30tbW92ZWA7XHJcbiAgICAgICAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKHByZXZDaGlsZHJlblswXS5lbCwgaW5zdGFuY2Uudm5vZGUuZWwsIG1vdmVDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcclxuICAgICAgICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcclxuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XHJcbiAgICAgICAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaChjID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gKGVsLl9tb3ZlQ2IgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjc3NUcmFuc2l0aW9uUHJvcHMgPSByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHByZXZDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoY2hpbGQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGNoaWxkLCBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XHJcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcclxuICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgIGlmIChlbC5fbW92ZUNiKSB7XHJcbiAgICAgICAgZWwuX21vdmVDYigpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsLl9lbnRlckNiKSB7XHJcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XHJcbiAgICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XHJcbiAgICBjb25zdCBvbGRQb3MgPSBwb3NpdGlvbk1hcC5nZXQoYyk7XHJcbiAgICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XHJcbiAgICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XHJcbiAgICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xyXG4gICAgaWYgKGR4IHx8IGR5KSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XHJcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XHJcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XHJcbiAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcclxuICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xyXG4gICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxyXG4gICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXHJcbiAgICAvLyBpcyBhcHBsaWVkLlxyXG4gICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcclxuICAgIGlmIChlbC5fdnRjKSB7XHJcbiAgICAgICAgZWwuX3Z0Yy5mb3JFYWNoKGNscyA9PiB7XHJcbiAgICAgICAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gKHJvb3Qubm9kZVR5cGUgPT09IDFcclxuICAgICAgICA/IHJvb3RcclxuICAgICAgICA6IHJvb3QucGFyZW50Tm9kZSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcclxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgICByZXR1cm4gaGFzVHJhbnNmb3JtO1xyXG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbJ29uVXBkYXRlOm1vZGVsVmFsdWUnXTtcclxuICAgIHJldHVybiBpc0FycmF5KGZuKSA/IHZhbHVlID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcclxufTtcclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcclxuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XHJcbiAgICAgICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCAnaW5wdXQnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKGVsLCB0eXBlKSB7XHJcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxyXG4vLyBXZSBhcmUgZXhwb3J0aW5nIHRoZSB2LW1vZGVsIHJ1bnRpbWUgZGlyZWN0bHkgYXMgdm5vZGUgaG9va3Mgc28gdGhhdCBpdCBjYW5cclxuLy8gYmUgdHJlZS1zaGFrZW4gaW4gY2FzZSB2LW1vZGVsIGlzIG5ldmVyIHVzZWQuXHJcbmNvbnN0IHZNb2RlbFRleHQgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgZWwudHlwZSA9PT0gJ251bWJlcic7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2FzdFRvTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IHRvTnVtYmVyKGRvbVZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGRvbVZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWxhenkpIHtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxyXG4gICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXHJcbiAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcclxuICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICAvLyBhdm9pZCBjbGVhcmluZyB1bnJlc29sdmVkIHRleHQuICMyMzAyXHJcbiAgICAgICAgaWYgKGVsLmNvbXBvc2luZylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xyXG4gICAgICAgICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChudW1iZXIgfHwgZWwudHlwZSA9PT0gJ251bWJlcicpICYmIHRvTnVtYmVyKGVsLnZhbHVlKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xyXG4gICAgICAgICAgICBjb25zdCBhc3NpZ24gPSBlbC5fYXNzaWduO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gaW5kZXggIT09IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoZWNrZWQgJiYgZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihmaWx0ZXJlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTZXQobW9kZWxWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2lnbihjbG9uZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxyXG4gICAgbW91bnRlZDogc2V0Q2hlY2tlZCxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZ2V0VmFsdWUoZWwpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IHRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pKTtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgPyBpc1NldE1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcclxuICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXHJcbiAgICAvLyA8b3B0aW9uPnMuXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xyXG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcclxuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICB9XHJcbn1cclxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIHNldCB2aWEgOnZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XHJcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgZm9yIHRydWUtdmFsdWUgYW5kIGZhbHNlLXZhbHVlIHNldCB2aWEgOnRydWUtdmFsdWUgb3IgOmZhbHNlLXZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcclxuICAgIGNvbnN0IGtleSA9IGNoZWNrZWQgPyAnX3RydWVWYWx1ZScgOiAnX2ZhbHNlVmFsdWUnO1xyXG4gICAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xyXG59XHJcbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnY3JlYXRlZCcpO1xyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdtb3VudGVkJyk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAndXBkYXRlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XHJcbiAgICBsZXQgbW9kZWxUb1VzZTtcclxuICAgIHN3aXRjaCAoZWwudGFnTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ1NFTEVDVCc6XHJcbiAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxTZWxlY3Q7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1RFWFRBUkVBJzpcclxuICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN3aXRjaCAodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxDaGVja2JveDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsUmFkaW87XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XHJcbiAgICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XHJcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ107XHJcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xyXG4gICAgc3RvcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgcHJldmVudDogZSA9PiBlLnByZXZlbnREZWZhdWx0KCksXHJcbiAgICBzZWxmOiBlID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXHJcbiAgICBjdHJsOiBlID0+ICFlLmN0cmxLZXksXHJcbiAgICBzaGlmdDogZSA9PiAhZS5zaGlmdEtleSxcclxuICAgIGFsdDogZSA9PiAhZS5hbHRLZXksXHJcbiAgICBtZXRhOiBlID0+ICFlLm1ldGFLZXksXHJcbiAgICBsZWZ0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDAsXHJcbiAgICBtaWRkbGU6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcclxuICAgIHJpZ2h0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDIsXHJcbiAgICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUobSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XHJcbiAgICAgICAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH07XHJcbn07XHJcbi8vIEtlcHQgZm9yIDIueCBjb21wYXQuXHJcbi8vIE5vdGU6IElFMTEgY29tcGF0IGZvciBgc3BhY2ViYXJgIGFuZCBgZGVsYCBpcyByZW1vdmVkIGZvciBub3cuXHJcbmNvbnN0IGtleU5hbWVzID0ge1xyXG4gICAgZXNjOiAnZXNjYXBlJyxcclxuICAgIHNwYWNlOiAnICcsXHJcbiAgICB1cDogJ2Fycm93LXVwJyxcclxuICAgIGxlZnQ6ICdhcnJvdy1sZWZ0JyxcclxuICAgIHJpZ2h0OiAnYXJyb3ctcmlnaHQnLFxyXG4gICAgZG93bjogJ2Fycm93LWRvd24nLFxyXG4gICAgZGVsZXRlOiAnYmFja3NwYWNlJ1xyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoISgna2V5JyBpbiBldmVudCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAvLyBOb25lIG9mIHRoZSBwcm92aWRlZCBrZXkgbW9kaWZpZXJzIG1hdGNoIHRoZSBjdXJyZW50IGV2ZW50IGtleVxyXG4gICAgICAgICFtb2RpZmllcnMuc29tZShrID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm4oZXZlbnQpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3QgdlNob3cgPSB7XHJcbiAgICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGVsLl92b2QgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBiZWZvcmVVbm1vdW50KGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XHJcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fdm9kIDogJ25vbmUnO1xyXG59XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IGV4dGVuZCh7IHBhdGNoUHJvcCwgZm9yY2VQYXRjaFByb3AgfSwgbm9kZU9wcyk7XHJcbi8vIGxhenkgY3JlYXRlIHRoZSByZW5kZXJlciAtIHRoaXMgbWFrZXMgY29yZSByZW5kZXJlciBsb2dpYyB0cmVlLXNoYWthYmxlXHJcbi8vIGluIGNhc2UgdGhlIHVzZXIgb25seSBpbXBvcnRzIHJlYWN0aXZpdHkgdXRpbGl0aWVzIGZyb20gVnVlLlxyXG5sZXQgcmVuZGVyZXI7XHJcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xyXG4gICAgcmV0dXJuIHJlbmRlcmVyIHx8IChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpO1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xyXG4gICAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uXHJcbiAgICAgICAgPyByZW5kZXJlclxyXG4gICAgICAgIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcclxuICAgIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlcmVyO1xyXG59XHJcbi8vIHVzZSBleHBsaWNpdCB0eXBlIGNhc3RzIGhlcmUgdG8gYXZvaWQgaW1wb3J0KCkgY2FsbHMgaW4gcm9sbGVkLXVwIGQudHNcclxuY29uc3QgcmVuZGVyID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcclxufSk7XHJcbmNvbnN0IGh5ZHJhdGUgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZUFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDdXN0b21FbGVtZW50Q2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbGVhciBjb250ZW50IGJlZm9yZSBtb3VudGluZ1xyXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLXYtYXBwJywgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDdXN0b21FbGVtZW50Q2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcclxuICAgIC8vIEluamVjdCBgaXNOYXRpdmVUYWdgXHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgZm9yIGNvbXBvbmVudCBuYW1lIHZhbGlkYXRpb24gKGRldiBvbmx5KVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc05hdGl2ZVRhZycsIHtcclxuICAgICAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGluamVjdEN1c3RvbUVsZW1lbnRDaGVjayhhcHApIHtcclxuICAgIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNDdXN0b21FbGVtZW50Jywge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBydW50aW1lIGNvbXBpbGVyLmAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAtIGZvciBleGFtcGxlLCB2aWEgdGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBvcHRpb24gaW4gdnVlLWxvYWRlcjogaHR0cHM6Ly92dWUtbG9hZGVyLnZ1ZWpzLm9yZy9vcHRpb25zLmh0bWwjY29tcGlsZXJvcHRpb25zLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiZcclxuICAgICAgICBjb250YWluZXIubW9kZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICB3YXJuKGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG59XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGh5ZHJhdGUsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCJpbXBvcnQgeyBpc1N0cmluZywgaHlwaGVuYXRlLCBleHRlbmQsIGlzT2JqZWN0LCBpc0FycmF5LCBOTywgbWFrZU1hcCwgaXNTeW1ib2wsIE5PT1AsIEVNUFRZX09CSiwgY2FwaXRhbGl6ZSwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgUGF0Y2hGbGFnTmFtZXMsIHNsb3RGbGFnc1RleHQsIGlzT24sIGlzUmVzZXJ2ZWRQcm9wLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcclxuICAgIHRocm93IGVycm9yO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jLCBtZXNzYWdlcywgYWRkaXRpb25hbE1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IG1zZyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZVxyXG4gICAgICAgID8gKG1lc3NhZ2VzIHx8IGVycm9yTWVzc2FnZXMpW2NvZGVdICsgKGFkZGl0aW9uYWxNZXNzYWdlIHx8IGBgKVxyXG4gICAgICAgIDogY29kZTtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKFN0cmluZyhtc2cpKTtcclxuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgZXJyb3IubG9jID0gbG9jO1xyXG4gICAgcmV0dXJuIGVycm9yO1xyXG59XHJcbmNvbnN0IGVycm9yTWVzc2FnZXMgPSB7XHJcbiAgICAvLyBwYXJzZSBlcnJvcnNcclxuICAgIFswIC8qIEFCUlVQVF9DTE9TSU5HX09GX0VNUFRZX0NPTU1FTlQgKi9dOiAnSWxsZWdhbCBjb21tZW50LicsXHJcbiAgICBbMSAvKiBDREFUQV9JTl9IVE1MX0NPTlRFTlQgKi9dOiAnQ0RBVEEgc2VjdGlvbiBpcyBhbGxvd2VkIG9ubHkgaW4gWE1MIGNvbnRleHQuJyxcclxuICAgIFsyIC8qIERVUExJQ0FURV9BVFRSSUJVVEUgKi9dOiAnRHVwbGljYXRlIGF0dHJpYnV0ZS4nLFxyXG4gICAgWzMgLyogRU5EX1RBR19XSVRIX0FUVFJJQlVURVMgKi9dOiAnRW5kIHRhZyBjYW5ub3QgaGF2ZSBhdHRyaWJ1dGVzLicsXHJcbiAgICBbNCAvKiBFTkRfVEFHX1dJVEhfVFJBSUxJTkdfU09MSURVUyAqL106IFwiSWxsZWdhbCAnLycgaW4gdGFncy5cIixcclxuICAgIFs1IC8qIEVPRl9CRUZPUkVfVEFHX05BTUUgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gdGFnLicsXHJcbiAgICBbNiAvKiBFT0ZfSU5fQ0RBVEEgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gQ0RBVEEgc2VjdGlvbi4nLFxyXG4gICAgWzcgLyogRU9GX0lOX0NPTU1FTlQgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gY29tbWVudC4nLFxyXG4gICAgWzggLyogRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHNjcmlwdC4nLFxyXG4gICAgWzkgLyogRU9GX0lOX1RBRyAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiB0YWcuJyxcclxuICAgIFsxMCAvKiBJTkNPUlJFQ1RMWV9DTE9TRURfQ09NTUVOVCAqL106ICdJbmNvcnJlY3RseSBjbG9zZWQgY29tbWVudC4nLFxyXG4gICAgWzExIC8qIElOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UICovXTogJ0luY29ycmVjdGx5IG9wZW5lZCBjb21tZW50LicsXHJcbiAgICBbMTIgLyogSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUUgKi9dOiBcIklsbGVnYWwgdGFnIG5hbWUuIFVzZSAnJmx0OycgdG8gcHJpbnQgJzwnLlwiLFxyXG4gICAgWzEzIC8qIE1JU1NJTkdfQVRUUklCVVRFX1ZBTFVFICovXTogJ0F0dHJpYnV0ZSB2YWx1ZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIFsxNCAvKiBNSVNTSU5HX0VORF9UQUdfTkFNRSAqL106ICdFbmQgdGFnIG5hbWUgd2FzIGV4cGVjdGVkLicsXHJcbiAgICBbMTUgLyogTUlTU0lOR19XSElURVNQQUNFX0JFVFdFRU5fQVRUUklCVVRFUyAqL106ICdXaGl0ZXNwYWNlIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgWzE2IC8qIE5FU1RFRF9DT01NRU5UICovXTogXCJVbmV4cGVjdGVkICc8IS0tJyBpbiBjb21tZW50LlwiLFxyXG4gICAgWzE3IC8qIFVORVhQRUNURURfQ0hBUkFDVEVSX0lOX0FUVFJJQlVURV9OQU1FICovXTogJ0F0dHJpYnV0ZSBuYW1lIGNhbm5vdCBjb250YWluIFUrMDAyMiAoXCIpLCBVKzAwMjcgKFxcJyksIGFuZCBVKzAwM0MgKDwpLicsXHJcbiAgICBbMTggLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFICovXTogJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3IChcXCcpLCBVKzAwM0MgKDwpLCBVKzAwM0QgKD0pLCBhbmQgVSswMDYwIChgKS4nLFxyXG4gICAgWzE5IC8qIFVORVhQRUNURURfRVFVQUxTX1NJR05fQkVGT1JFX0FUVFJJQlVURV9OQU1FICovXTogXCJBdHRyaWJ1dGUgbmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCAnPScuXCIsXHJcbiAgICBbMjEgLyogVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUUgKi9dOiBcIic8PycgaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LlwiLFxyXG4gICAgWzIyIC8qIFVORVhQRUNURURfU09MSURVU19JTl9UQUcgKi9dOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXHJcbiAgICAvLyBWdWUtc3BlY2lmaWMgcGFyc2UgZXJyb3JzXHJcbiAgICBbMjMgLyogWF9JTlZBTElEX0VORF9UQUcgKi9dOiAnSW52YWxpZCBlbmQgdGFnLicsXHJcbiAgICBbMjQgLyogWF9NSVNTSU5HX0VORF9UQUcgKi9dOiAnRWxlbWVudCBpcyBtaXNzaW5nIGVuZCB0YWcuJyxcclxuICAgIFsyNSAvKiBYX01JU1NJTkdfSU5URVJQT0xBVElPTl9FTkQgKi9dOiAnSW50ZXJwb2xhdGlvbiBlbmQgc2lnbiB3YXMgbm90IGZvdW5kLicsXHJcbiAgICBbMjYgLyogWF9NSVNTSU5HX0RZTkFNSUNfRElSRUNUSVZFX0FSR1VNRU5UX0VORCAqL106ICdFbmQgYnJhY2tldCBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgd2FzIG5vdCBmb3VuZC4gJyArXHJcbiAgICAgICAgJ05vdGUgdGhhdCBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCBjYW5ub3QgY29udGFpbiBzcGFjZXMuJyxcclxuICAgIC8vIHRyYW5zZm9ybSBlcnJvcnNcclxuICAgIFsyNyAvKiBYX1ZfSUZfTk9fRVhQUkVTU0lPTiAqL106IGB2LWlmL3YtZWxzZS1pZiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFsyOCAvKiBYX1ZfSUZfU0FNRV9LRVkgKi9dOiBgdi1pZi9lbHNlIGJyYW5jaGVzIG11c3QgdXNlIHVuaXF1ZSBrZXlzLmAsXHJcbiAgICBbMjkgLyogWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi9dOiBgdi1lbHNlL3YtZWxzZS1pZiBoYXMgbm8gYWRqYWNlbnQgdi1pZi5gLFxyXG4gICAgWzMwIC8qIFhfVl9GT1JfTk9fRVhQUkVTU0lPTiAqL106IGB2LWZvciBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszMSAvKiBYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovXTogYHYtZm9yIGhhcyBpbnZhbGlkIGV4cHJlc3Npb24uYCxcclxuICAgIFszMiAvKiBYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi9dOiBgPHRlbXBsYXRlIHYtZm9yPiBrZXkgc2hvdWxkIGJlIHBsYWNlZCBvbiB0aGUgPHRlbXBsYXRlPiB0YWcuYCxcclxuICAgIFszMyAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovXTogYHYtYmluZCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszNCAvKiBYX1ZfT05fTk9fRVhQUkVTU0lPTiAqL106IGB2LW9uIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzM1IC8qIFhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovXTogYFVuZXhwZWN0ZWQgY3VzdG9tIGRpcmVjdGl2ZSBvbiA8c2xvdD4gb3V0bGV0LmAsXHJcbiAgICBbMzYgLyogWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRSAqL106IGBNaXhlZCB2LXNsb3QgdXNhZ2Ugb24gYm90aCB0aGUgY29tcG9uZW50IGFuZCBuZXN0ZWQgPHRlbXBsYXRlPi5gICtcclxuICAgICAgICBgV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgbmFtZWQgc2xvdHMsIGFsbCBzbG90cyBzaG91bGQgdXNlIDx0ZW1wbGF0ZT4gYCArXHJcbiAgICAgICAgYHN5bnRheCB0byBhdm9pZCBzY29wZSBhbWJpZ3VpdHkuYCxcclxuICAgIFszNyAvKiBYX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FUyAqL106IGBEdXBsaWNhdGUgc2xvdCBuYW1lcyBmb3VuZC4gYCxcclxuICAgIFszOCAvKiBYX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqL106IGBFeHRyYW5lb3VzIGNoaWxkcmVuIGZvdW5kIHdoZW4gY29tcG9uZW50IGFscmVhZHkgaGFzIGV4cGxpY2l0bHkgbmFtZWQgYCArXHJcbiAgICAgICAgYGRlZmF1bHQgc2xvdC4gVGhlc2UgY2hpbGRyZW4gd2lsbCBiZSBpZ25vcmVkLmAsXHJcbiAgICBbMzkgLyogWF9WX1NMT1RfTUlTUExBQ0VEICovXTogYHYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPiB0YWdzLmAsXHJcbiAgICBbNDAgLyogWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi9dOiBgdi1tb2RlbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs0MSAvKiBYX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT04gKi9dOiBgdi1tb2RlbCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBtZW1iZXIgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzQyIC8qIFhfVl9NT0RFTF9PTl9TQ09QRV9WQVJJQUJMRSAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIHYtZm9yIG9yIHYtc2xvdCBzY29wZSB2YXJpYWJsZXMgYmVjYXVzZSB0aGV5IGFyZSBub3Qgd3JpdGFibGUuYCxcclxuICAgIFs0MyAvKiBYX0lOVkFMSURfRVhQUkVTU0lPTiAqL106IGBFcnJvciBwYXJzaW5nIEphdmFTY3JpcHQgZXhwcmVzc2lvbjogYCxcclxuICAgIFs0NCAvKiBYX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTiAqL106IGA8S2VlcEFsaXZlPiBleHBlY3RzIGV4YWN0bHkgb25lIGNoaWxkIGNvbXBvbmVudC5gLFxyXG4gICAgLy8gZ2VuZXJpYyBlcnJvcnNcclxuICAgIFs0NSAvKiBYX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovXTogYFwicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLmAsXHJcbiAgICBbNDYgLyogWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEICovXTogYEVTIG1vZHVsZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxyXG4gICAgWzQ3IC8qIFhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovXTogYFwiY2FjaGVIYW5kbGVyc1wiIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHRoZSBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIGVuYWJsZWQuYCxcclxuICAgIFs0OCAvKiBYX1NDT1BFX0lEX05PVF9TVVBQT1JURUQgKi9dOiBgXCJzY29wZUlkXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIG1vZHVsZSBtb2RlLmBcclxufTtcblxuY29uc3QgRlJBR01FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEZyYWdtZW50YCA6IGBgKTtcclxuY29uc3QgVEVMRVBPUlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRlbGVwb3J0YCA6IGBgKTtcclxuY29uc3QgU1VTUEVOU0UgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFN1c3BlbnNlYCA6IGBgKTtcclxuY29uc3QgS0VFUF9BTElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgS2VlcEFsaXZlYCA6IGBgKTtcclxuY29uc3QgQkFTRV9UUkFOU0lUSU9OID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBCYXNlVHJhbnNpdGlvbmAgOiBgYCk7XHJcbmNvbnN0IE9QRU5fQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG9wZW5CbG9ja2AgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQmxvY2tgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfVk5PREUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVZOb2RlYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX0NPTU1FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUNvbW1lbnRWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9URVhUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVUZXh0Vk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfU1RBVElDID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVTdGF0aWNWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlQ29tcG9uZW50YCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnRgIDogYGApO1xyXG5jb25zdCBSRVNPTFZFX0RJUkVDVElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZURpcmVjdGl2ZWAgOiBgYCk7XHJcbmNvbnN0IFdJVEhfRElSRUNUSVZFUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aERpcmVjdGl2ZXNgIDogYGApO1xyXG5jb25zdCBSRU5ERVJfTElTVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVuZGVyTGlzdGAgOiBgYCk7XHJcbmNvbnN0IFJFTkRFUl9TTE9UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZW5kZXJTbG90YCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1NMT1RTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVTbG90c2AgOiBgYCk7XHJcbmNvbnN0IFRPX0RJU1BMQVlfU1RSSU5HID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB0b0Rpc3BsYXlTdHJpbmdgIDogYGApO1xyXG5jb25zdCBNRVJHRV9QUk9QUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgbWVyZ2VQcm9wc2AgOiBgYCk7XHJcbmNvbnN0IFRPX0hBTkRMRVJTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB0b0hhbmRsZXJzYCA6IGBgKTtcclxuY29uc3QgQ0FNRUxJWkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNhbWVsaXplYCA6IGBgKTtcclxuY29uc3QgQ0FQSVRBTElaRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY2FwaXRhbGl6ZWAgOiBgYCk7XHJcbmNvbnN0IFRPX0hBTkRMRVJfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB0b0hhbmRsZXJLZXlgIDogYGApO1xyXG5jb25zdCBTRVRfQkxPQ0tfVFJBQ0tJTkcgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNldEJsb2NrVHJhY2tpbmdgIDogYGApO1xyXG5jb25zdCBQVVNIX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwdXNoU2NvcGVJZGAgOiBgYCk7XHJcbmNvbnN0IFBPUF9TQ09QRV9JRCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcG9wU2NvcGVJZGAgOiBgYCk7XHJcbmNvbnN0IFdJVEhfU0NPUEVfSUQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgV0lUSF9DVFggPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhDdHhgIDogYGApO1xyXG5jb25zdCBVTlJFRiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdW5yZWZgIDogYGApO1xyXG5jb25zdCBJU19SRUYgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGlzUmVmYCA6IGBgKTtcclxuLy8gTmFtZSBtYXBwaW5nIGZvciBydW50aW1lIGhlbHBlcnMgdGhhdCBuZWVkIHRvIGJlIGltcG9ydGVkIGZyb20gJ3Z1ZScgaW5cclxuLy8gZ2VuZXJhdGVkIGNvZGUuIE1ha2Ugc3VyZSB0aGVzZSBhcmUgY29ycmVjdGx5IGV4cG9ydGVkIGluIHRoZSBydW50aW1lIVxyXG4vLyBVc2luZyBgYW55YCBoZXJlIGJlY2F1c2UgVFMgZG9lc24ndCBhbGxvdyBzeW1ib2xzIGFzIGluZGV4IHR5cGUuXHJcbmNvbnN0IGhlbHBlck5hbWVNYXAgPSB7XHJcbiAgICBbRlJBR01FTlRdOiBgRnJhZ21lbnRgLFxyXG4gICAgW1RFTEVQT1JUXTogYFRlbGVwb3J0YCxcclxuICAgIFtTVVNQRU5TRV06IGBTdXNwZW5zZWAsXHJcbiAgICBbS0VFUF9BTElWRV06IGBLZWVwQWxpdmVgLFxyXG4gICAgW0JBU0VfVFJBTlNJVElPTl06IGBCYXNlVHJhbnNpdGlvbmAsXHJcbiAgICBbT1BFTl9CTE9DS106IGBvcGVuQmxvY2tgLFxyXG4gICAgW0NSRUFURV9CTE9DS106IGBjcmVhdGVCbG9ja2AsXHJcbiAgICBbQ1JFQVRFX1ZOT0RFXTogYGNyZWF0ZVZOb2RlYCxcclxuICAgIFtDUkVBVEVfQ09NTUVOVF06IGBjcmVhdGVDb21tZW50Vk5vZGVgLFxyXG4gICAgW0NSRUFURV9URVhUXTogYGNyZWF0ZVRleHRWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX1NUQVRJQ106IGBjcmVhdGVTdGF0aWNWTm9kZWAsXHJcbiAgICBbUkVTT0xWRV9DT01QT05FTlRdOiBgcmVzb2x2ZUNvbXBvbmVudGAsXHJcbiAgICBbUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVF06IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAsXHJcbiAgICBbUkVTT0xWRV9ESVJFQ1RJVkVdOiBgcmVzb2x2ZURpcmVjdGl2ZWAsXHJcbiAgICBbV0lUSF9ESVJFQ1RJVkVTXTogYHdpdGhEaXJlY3RpdmVzYCxcclxuICAgIFtSRU5ERVJfTElTVF06IGByZW5kZXJMaXN0YCxcclxuICAgIFtSRU5ERVJfU0xPVF06IGByZW5kZXJTbG90YCxcclxuICAgIFtDUkVBVEVfU0xPVFNdOiBgY3JlYXRlU2xvdHNgLFxyXG4gICAgW1RPX0RJU1BMQVlfU1RSSU5HXTogYHRvRGlzcGxheVN0cmluZ2AsXHJcbiAgICBbTUVSR0VfUFJPUFNdOiBgbWVyZ2VQcm9wc2AsXHJcbiAgICBbVE9fSEFORExFUlNdOiBgdG9IYW5kbGVyc2AsXHJcbiAgICBbQ0FNRUxJWkVdOiBgY2FtZWxpemVgLFxyXG4gICAgW0NBUElUQUxJWkVdOiBgY2FwaXRhbGl6ZWAsXHJcbiAgICBbVE9fSEFORExFUl9LRVldOiBgdG9IYW5kbGVyS2V5YCxcclxuICAgIFtTRVRfQkxPQ0tfVFJBQ0tJTkddOiBgc2V0QmxvY2tUcmFja2luZ2AsXHJcbiAgICBbUFVTSF9TQ09QRV9JRF06IGBwdXNoU2NvcGVJZGAsXHJcbiAgICBbUE9QX1NDT1BFX0lEXTogYHBvcFNjb3BlSWRgLFxyXG4gICAgW1dJVEhfU0NPUEVfSURdOiBgd2l0aFNjb3BlSWRgLFxyXG4gICAgW1dJVEhfQ1RYXTogYHdpdGhDdHhgLFxyXG4gICAgW1VOUkVGXTogYHVucmVmYCxcclxuICAgIFtJU19SRUZdOiBgaXNSZWZgXHJcbn07XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMoaGVscGVycykge1xyXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhoZWxwZXJzKS5mb3JFYWNoKHMgPT4ge1xyXG4gICAgICAgIGhlbHBlck5hbWVNYXBbc10gPSBoZWxwZXJzW3NdO1xyXG4gICAgfSk7XHJcbn1cblxuLy8gQVNUIFV0aWxpdGllcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gU29tZSBleHByZXNzaW9ucywgZS5nLiBzZXF1ZW5jZSBhbmQgY29uZGl0aW9uYWwgZXhwcmVzc2lvbnMsIGFyZSBuZXZlclxyXG4vLyBhc3NvY2lhdGVkIHdpdGggdGVtcGxhdGUgbm9kZXMsIHNvIHRoZWlyIHNvdXJjZSBsb2NhdGlvbnMgYXJlIGp1c3QgYSBzdHViLlxyXG4vLyBDb250YWluZXIgdHlwZXMgbGlrZSBDb21wb3VuZEV4cHJlc3Npb24gYWxzbyBkb24ndCBuZWVkIGEgcmVhbCBsb2NhdGlvbi5cclxuY29uc3QgbG9jU3R1YiA9IHtcclxuICAgIHNvdXJjZTogJycsXHJcbiAgICBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMCB9LFxyXG4gICAgZW5kOiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH1cclxufTtcclxuZnVuY3Rpb24gY3JlYXRlUm9vdChjaGlsZHJlbiwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAwIC8qIFJPT1QgKi8sXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgaGVscGVyczogW10sXHJcbiAgICAgICAgY29tcG9uZW50czogW10sXHJcbiAgICAgICAgZGlyZWN0aXZlczogW10sXHJcbiAgICAgICAgaG9pc3RzOiBbXSxcclxuICAgICAgICBpbXBvcnRzOiBbXSxcclxuICAgICAgICBjYWNoZWQ6IDAsXHJcbiAgICAgICAgdGVtcHM6IDAsXHJcbiAgICAgICAgY29kZWdlbk5vZGU6IHVuZGVmaW5lZCxcclxuICAgICAgICBsb2NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jayA9IGZhbHNlLCBkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgaWYgKGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoaXNCbG9jaykge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoQ1JFQVRFX0JMT0NLKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9WTk9ERSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKFdJVEhfRElSRUNUSVZFUyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxMyAvKiBWTk9ERV9DQUxMICovLFxyXG4gICAgICAgIHRhZyxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzLFxyXG4gICAgICAgIGRpcmVjdGl2ZXMsXHJcbiAgICAgICAgaXNCbG9jayxcclxuICAgICAgICBkaXNhYmxlVHJhY2tpbmcsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihlbGVtZW50cywgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBlbGVtZW50c1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIHByb3BlcnRpZXNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0UHJvcGVydHkoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNiAvKiBKU19QUk9QRVJUWSAqLyxcclxuICAgICAgICBsb2M6IGxvY1N0dWIsXHJcbiAgICAgICAga2V5OiBpc1N0cmluZyhrZXkpID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXksIHRydWUpIDoga2V5LFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgaXNTdGF0aWMsIGxvYyA9IGxvY1N0dWIsIGNvbnN0VHlwZSA9IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgaXNTdGF0aWMsXHJcbiAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpYyA/IDMgLyogQ0FOX1NUUklOR0lGWSAqLyA6IGNvbnN0VHlwZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnRlcnBvbGF0aW9uKGNvbnRlbnQsIGxvYykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA1IC8qIElOVEVSUE9MQVRJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNvbnRlbnQ6IGlzU3RyaW5nKGNvbnRlbnQpXHJcbiAgICAgICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihjb250ZW50LCBmYWxzZSwgbG9jKVxyXG4gICAgICAgICAgICA6IGNvbnRlbnRcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY2hpbGRyZW5cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY2FsbGVlLCBhcmdzID0gW10sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjYWxsZWUsXHJcbiAgICAgICAgYXJndW1lbnRzOiBhcmdzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIHJldHVybnMgPSB1bmRlZmluZWQsIG5ld2xpbmUgPSBmYWxzZSwgaXNTbG90ID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTggLyogSlNfRlVOQ1RJT05fRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgcmV0dXJucyxcclxuICAgICAgICBuZXdsaW5lLFxyXG4gICAgICAgIGlzU2xvdCxcclxuICAgICAgICBsb2NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbmV3bGluZSA9IHRydWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICB0ZXN0LFxyXG4gICAgICAgIGNvbnNlcXVlbnQsXHJcbiAgICAgICAgYWx0ZXJuYXRlLFxyXG4gICAgICAgIG5ld2xpbmUsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihpbmRleCwgdmFsdWUsIGlzVk5vZGUgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGluZGV4LFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIGlzVk5vZGUsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrU3RhdGVtZW50KGJvZHkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjEgLyogSlNfQkxPQ0tfU1RBVEVNRU5UICovLFxyXG4gICAgICAgIGJvZHksXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbChlbGVtZW50cykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMiAvKiBKU19URU1QTEFURV9MSVRFUkFMICovLFxyXG4gICAgICAgIGVsZW1lbnRzLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjMgLyogSlNfSUZfU1RBVEVNRU5UICovLFxyXG4gICAgICAgIHRlc3QsXHJcbiAgICAgICAgY29uc2VxdWVudCxcclxuICAgICAgICBhbHRlcm5hdGUsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDI0IC8qIEpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0LFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjUgLyogSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBleHByZXNzaW9ucyxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmV0dXJuU3RhdGVtZW50KHJldHVybnMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjYgLyogSlNfUkVUVVJOX1NUQVRFTUVOVCAqLyxcclxuICAgICAgICByZXR1cm5zLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxuXG5jb25zdCBpc1N0YXRpY0V4cCA9IChwKSA9PiBwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiYgcC5pc1N0YXRpYztcclxuY29uc3QgaXNCdWlsdEluVHlwZSA9ICh0YWcsIGV4cGVjdGVkKSA9PiB0YWcgPT09IGV4cGVjdGVkIHx8IHRhZyA9PT0gaHlwaGVuYXRlKGV4cGVjdGVkKTtcclxuZnVuY3Rpb24gaXNDb3JlQ29tcG9uZW50KHRhZykge1xyXG4gICAgaWYgKGlzQnVpbHRJblR5cGUodGFnLCAnVGVsZXBvcnQnKSkge1xyXG4gICAgICAgIHJldHVybiBURUxFUE9SVDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCAnU3VzcGVuc2UnKSkge1xyXG4gICAgICAgIHJldHVybiBTVVNQRU5TRTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCAnS2VlcEFsaXZlJykpIHtcclxuICAgICAgICByZXR1cm4gS0VFUF9BTElWRTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCAnQmFzZVRyYW5zaXRpb24nKSkge1xyXG4gICAgICAgIHJldHVybiBCQVNFX1RSQU5TSVRJT047XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgbm9uSWRlbnRpZmllclJFID0gL15cXGR8W15cXCRcXHddLztcclxuY29uc3QgaXNTaW1wbGVJZGVudGlmaWVyID0gKG5hbWUpID0+ICFub25JZGVudGlmaWVyUkUudGVzdChuYW1lKTtcclxuY29uc3QgbWVtYmVyRXhwUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFxzKlxcLlxccypbQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcXV0rXFxdKSokLztcclxuY29uc3QgaXNNZW1iZXJFeHByZXNzaW9uID0gKHBhdGgpID0+IHtcclxuICAgIGlmICghcGF0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gbWVtYmVyRXhwUkUudGVzdChwYXRoLnRyaW0oKSk7XHJcbn07XHJcbmZ1bmN0aW9uIGdldElubmVyUmFuZ2UobG9jLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgY29uc3Qgc291cmNlID0gbG9jLnNvdXJjZS5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgY29uc3QgbmV3TG9jID0ge1xyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICBzdGFydDogYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKGxvYy5zdGFydCwgbG9jLnNvdXJjZSwgb2Zmc2V0KSxcclxuICAgICAgICBlbmQ6IGxvYy5lbmRcclxuICAgIH07XHJcbiAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcclxuICAgICAgICBuZXdMb2MuZW5kID0gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKGxvYy5zdGFydCwgbG9jLnNvdXJjZSwgb2Zmc2V0ICsgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdMb2M7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGV4dGVuZCh7fSwgcG9zKSwgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG59XHJcbi8vIGFkdmFuY2UgYnkgbXV0YXRpb24gd2l0aG91dCBjbG9uaW5nIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyksIHNpbmNlIHRoaXNcclxuLy8gZ2V0cyBjYWxsZWQgYSBsb3QgaW4gdGhlIHBhcnNlclxyXG5mdW5jdGlvbiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24ocG9zLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIGxldCBsaW5lc0NvdW50ID0gMDtcclxuICAgIGxldCBsYXN0TmV3TGluZVBvcyA9IC0xO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNoYXJhY3RlcnM7IGkrKykge1xyXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpKSA9PT0gMTAgLyogbmV3bGluZSBjaGFyIGNvZGUgKi8pIHtcclxuICAgICAgICAgICAgbGluZXNDb3VudCsrO1xyXG4gICAgICAgICAgICBsYXN0TmV3TGluZVBvcyA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9zLm9mZnNldCArPSBudW1iZXJPZkNoYXJhY3RlcnM7XHJcbiAgICBwb3MubGluZSArPSBsaW5lc0NvdW50O1xyXG4gICAgcG9zLmNvbHVtbiA9XHJcbiAgICAgICAgbGFzdE5ld0xpbmVQb3MgPT09IC0xXHJcbiAgICAgICAgICAgID8gcG9zLmNvbHVtbiArIG51bWJlck9mQ2hhcmFjdGVyc1xyXG4gICAgICAgICAgICA6IG51bWJlck9mQ2hhcmFjdGVycyAtIGxhc3ROZXdMaW5lUG9zO1xyXG4gICAgcmV0dXJuIHBvcztcclxufVxyXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8IGB1bmV4cGVjdGVkIGNvbXBpbGVyIGNvbmRpdGlvbmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmREaXIobm9kZSwgbmFtZSwgYWxsb3dFbXB0eSA9IGZhbHNlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgICAgICAoYWxsb3dFbXB0eSB8fCBwLmV4cCkgJiZcclxuICAgICAgICAgICAgKGlzU3RyaW5nKG5hbWUpID8gcC5uYW1lID09PSBuYW1lIDogbmFtZS50ZXN0KHAubmFtZSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaW5kUHJvcChub2RlLCBuYW1lLCBkeW5hbWljT25seSA9IGZhbHNlLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljT25seSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSBuYW1lICYmIChwLnZhbHVlIHx8IGFsbG93RW1wdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJlxyXG4gICAgICAgICAgICAocC5leHAgfHwgYWxsb3dFbXB0eSkgJiZcclxuICAgICAgICAgICAgaXNCaW5kS2V5KHAuYXJnLCBuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNCaW5kS2V5KGFyZywgbmFtZSkge1xyXG4gICAgcmV0dXJuICEhKGFyZyAmJiBpc1N0YXRpY0V4cChhcmcpICYmIGFyZy5jb250ZW50ID09PSBuYW1lKTtcclxufVxyXG5mdW5jdGlvbiBoYXNEeW5hbWljS2V5VkJpbmQobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUucHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICBwLm5hbWUgPT09ICdiaW5kJyAmJlxyXG4gICAgICAgICghcC5hcmcgfHwgLy8gdi1iaW5kPVwib2JqXCJcclxuICAgICAgICAgICAgcC5hcmcudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fCAvLyB2LWJpbmQ6W19jdHguZm9vXVxyXG4gICAgICAgICAgICAhcC5hcmcuaXNTdGF0aWMpIC8vIHYtYmluZDpbZm9vXVxyXG4gICAgKTtcclxufVxyXG5mdW5jdGlvbiBpc1RleHQobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovIHx8IG5vZGUudHlwZSA9PT0gMiAvKiBURVhUICovO1xyXG59XHJcbmZ1bmN0aW9uIGlzVlNsb3QocCkge1xyXG4gICAgcmV0dXJuIHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnc2xvdCc7XHJcbn1cclxuZnVuY3Rpb24gaXNUZW1wbGF0ZU5vZGUobm9kZSkge1xyXG4gICAgcmV0dXJuIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJiBub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2xvdE91dGxldChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiYgbm9kZS50YWdUeXBlID09PSAyIC8qIFNMT1QgKi87XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0UHJvcChub2RlLCBwcm9wLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgY29uc3QgcHJvcHMgPSBub2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8gPyBub2RlLnByb3BzIDogbm9kZS5hcmd1bWVudHNbMl07XHJcbiAgICBpZiAocHJvcHMgPT0gbnVsbCB8fCBpc1N0cmluZyhwcm9wcykpIHtcclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAvLyBtZXJnZWQgcHJvcHMuLi4gYWRkIG91cnNcclxuICAgICAgICAvLyBvbmx5IGluamVjdCBrZXkgdG8gb2JqZWN0IGxpdGVyYWwgaWYgaXQncyB0aGUgZmlyc3QgYXJndW1lbnQgc28gdGhhdFxyXG4gICAgICAgIC8vIGlmIGRvZXNuJ3Qgb3ZlcnJpZGUgdXNlciBwcm92aWRlZCBrZXlzXHJcbiAgICAgICAgY29uc3QgZmlyc3QgPSBwcm9wcy5hcmd1bWVudHNbMF07XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhmaXJzdCkgJiYgZmlyc3QudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgZmlyc3QucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByb3BzLmNhbGxlZSA9PT0gVE9fSEFORExFUlMpIHtcclxuICAgICAgICAgICAgICAgIC8vICMyMzY2XHJcbiAgICAgICAgICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMuYXJndW1lbnRzLnVuc2hpZnQoY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAhcHJvcHNXaXRoSW5qZWN0aW9uICYmIChwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGxldCBhbHJlYWR5RXhpc3RzID0gZmFsc2U7XHJcbiAgICAgICAgLy8gY2hlY2sgZXhpc3Rpbmcga2V5IHRvIGF2b2lkIG92ZXJyaWRpbmcgdXNlciBwcm92aWRlZCBrZXlzXHJcbiAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcEtleU5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xyXG4gICAgICAgICAgICBhbHJlYWR5RXhpc3RzID0gcHJvcHMucHJvcGVydGllcy5zb21lKHAgPT4gcC5rZXkudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgcC5rZXkuY29udGVudCA9PT0gcHJvcEtleU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFscmVhZHlFeGlzdHMpIHtcclxuICAgICAgICAgICAgcHJvcHMucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBleHByZXNzaW9uLCByZXR1cm4gYSBtZXJnZWQgcmVwbGFjZW1lbnRcclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxyXG4gICAgICAgICAgICBwcm9wc1xyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgIG5vZGUucHJvcHMgPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBub2RlLmFyZ3VtZW50c1syXSA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1ZhbGlkQXNzZXRJZChuYW1lLCB0eXBlKSB7XHJcbiAgICByZXR1cm4gYF8ke3R5cGV9XyR7bmFtZS5yZXBsYWNlKC9bXlxcd10vZywgJ18nKX1gO1xyXG59XHJcbi8vIENoZWNrIGlmIGEgbm9kZSBjb250YWlucyBleHByZXNzaW9ucyB0aGF0IHJlZmVyZW5jZSBjdXJyZW50IGNvbnRleHQgc2NvcGUgaWRzXHJcbmZ1bmN0aW9uIGhhc1Njb3BlUmVmKG5vZGUsIGlkcykge1xyXG4gICAgaWYgKCFub2RlIHx8IE9iamVjdC5rZXlzKGlkcykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGhhc1Njb3BlUmVmKHAuYXJnLCBpZHMpIHx8IGhhc1Njb3BlUmVmKHAuZXhwLCBpZHMpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuc291cmNlLCBpZHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5icmFuY2hlcy5zb21lKGIgPT4gaGFzU2NvcGVSZWYoYiwgaWRzKSk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLmNvbmRpdGlvbiwgaWRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICghbm9kZS5pc1N0YXRpYyAmJlxyXG4gICAgICAgICAgICAgICAgaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudCkgJiZcclxuICAgICAgICAgICAgICAgICEhaWRzW25vZGUuY29udGVudF0pO1xyXG4gICAgICAgIGNhc2UgOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaXNPYmplY3QoYykgJiYgaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNTY29wZVJlZihub2RlLmNvbnRlbnQsIGlkcyk7XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSA7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxuXG4vLyBUaGUgZGVmYXVsdCBkZWNvZGVyIG9ubHkgcHJvdmlkZXMgZXNjYXBlcyBmb3IgY2hhcmFjdGVycyByZXNlcnZlZCBhcyBwYXJ0IG9mXHJcbi8vIHRoZSB0ZW1wbGF0ZSBzeW50YXgsIGFuZCBpcyBvbmx5IHVzZWQgaWYgdGhlIGN1c3RvbSByZW5kZXJlciBkaWQgbm90IHByb3ZpZGVcclxuLy8gYSBwbGF0Zm9ybS1zcGVjaWZpYyBkZWNvZGVyLlxyXG5jb25zdCBkZWNvZGVSRSA9IC8mKGd0fGx0fGFtcHxhcG9zfHF1b3QpOy9nO1xyXG5jb25zdCBkZWNvZGVNYXAgPSB7XHJcbiAgICBndDogJz4nLFxyXG4gICAgbHQ6ICc8JyxcclxuICAgIGFtcDogJyYnLFxyXG4gICAgYXBvczogXCInXCIsXHJcbiAgICBxdW90OiAnXCInXHJcbn07XHJcbmNvbnN0IGRlZmF1bHRQYXJzZXJPcHRpb25zID0ge1xyXG4gICAgZGVsaW1pdGVyczogW2B7e2AsIGB9fWBdLFxyXG4gICAgZ2V0TmFtZXNwYWNlOiAoKSA9PiAwIC8qIEhUTUwgKi8sXHJcbiAgICBnZXRUZXh0TW9kZTogKCkgPT4gMCAvKiBEQVRBICovLFxyXG4gICAgaXNWb2lkVGFnOiBOTyxcclxuICAgIGlzUHJlVGFnOiBOTyxcclxuICAgIGlzQ3VzdG9tRWxlbWVudDogTk8sXHJcbiAgICBkZWNvZGVFbnRpdGllczogKHJhd1RleHQpID0+IHJhd1RleHQucmVwbGFjZShkZWNvZGVSRSwgKF8sIHAxKSA9PiBkZWNvZGVNYXBbcDFdKSxcclxuICAgIG9uRXJyb3I6IGRlZmF1bHRPbkVycm9yLFxyXG4gICAgY29tbWVudHM6IGZhbHNlXHJcbn07XHJcbmZ1bmN0aW9uIGJhc2VQYXJzZShjb250ZW50LCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVQYXJzZXJDb250ZXh0KGNvbnRlbnQsIG9wdGlvbnMpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUm9vdChwYXJzZUNoaWxkcmVuKGNvbnRleHQsIDAgLyogREFUQSAqLywgW10pLCBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQYXJzZXJDb250ZXh0KGNvbnRlbnQsIHJhd09wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRQYXJzZXJPcHRpb25zKTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd09wdGlvbnMpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgb3B0aW9uc1trZXldID0gcmF3T3B0aW9uc1trZXldIHx8IGRlZmF1bHRQYXJzZXJPcHRpb25zW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgY29sdW1uOiAxLFxyXG4gICAgICAgIGxpbmU6IDEsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiBjb250ZW50LFxyXG4gICAgICAgIHNvdXJjZTogY29udGVudCxcclxuICAgICAgICBpblByZTogZmFsc2UsXHJcbiAgICAgICAgaW5WUHJlOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykge1xyXG4gICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xyXG4gICAgY29uc3QgbnMgPSBwYXJlbnQgPyBwYXJlbnQubnMgOiAwIC8qIEhUTUwgKi87XHJcbiAgICBjb25zdCBub2RlcyA9IFtdO1xyXG4gICAgd2hpbGUgKCFpc0VuZChjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpKSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xyXG4gICAgICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChtb2RlID09PSAwIC8qIERBVEEgKi8gfHwgbW9kZSA9PT0gMSAvKiBSQ0RBVEEgKi8pIHtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LmluVlByZSAmJiBzdGFydHNXaXRoKHMsIGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gJ3t7J1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlSW50ZXJwb2xhdGlvbihjb250ZXh0LCBtb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAwIC8qIERBVEEgKi8gJiYgc1swXSA9PT0gJzwnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjdGFnLW9wZW4tc3RhdGVcclxuICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA1IC8qIEVPRl9CRUZPUkVfVEFHX05BTUUgKi8sIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1sxXSA9PT0gJyEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI21hcmt1cC1kZWNsYXJhdGlvbi1vcGVuLXN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgocywgJzwhLS0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydHNXaXRoKHMsICc8IURPQ1RZUEUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgRE9DVFlQRSBieSBhIGxpbWl0YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFbQ0RBVEFbJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5zICE9PSAwIC8qIEhUTUwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUNEQVRBKGNvbnRleHQsIGFuY2VzdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMSAvKiBDREFUQV9JTl9IVE1MX0NPTlRFTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTEgLyogSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1sxXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI2VuZC10YWctb3Blbi1zdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc1syXSA9PT0gJz4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNCAvKiBNSVNTSU5HX0VORF9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9bYS16XS9pLnRlc3Qoc1syXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIzIC8qIFhfSU5WQUxJRF9FTkRfVEFHICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VUYWcoY29udGV4dCwgMSAvKiBFbmQgKi8sIHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9bYS16XS9pLnRlc3Qoc1sxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VFbGVtZW50KGNvbnRleHQsIGFuY2VzdG9ycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnPycpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjEgLyogVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUUgKi8sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBwYXJzZVRleHQoY29udGV4dCwgbW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcHVzaE5vZGUobm9kZXMsIG5vZGVbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwdXNoTm9kZShub2Rlcywgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gV2hpdGVzcGFjZSBtYW5hZ2VtZW50IGZvciBtb3JlIGVmZmljaWVudCBvdXRwdXRcclxuICAgIC8vIChzYW1lIGFzIHYyIHdoaXRlc3BhY2U6ICdjb25kZW5zZScpXHJcbiAgICBsZXQgcmVtb3ZlZFdoaXRlc3BhY2UgPSBmYWxzZTtcclxuICAgIGlmIChtb2RlICE9PSAyIC8qIFJBV1RFWFQgKi8pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LmluUHJlICYmIG5vZGUudHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIS9bXlxcdFxcclxcblxcZiBdLy50ZXN0KG5vZGUuY29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gbm9kZXNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2Rlc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWY6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSB0aGUgd2hpdGVzcGFjZSBpcyB0aGUgZmlyc3Qgb3IgbGFzdCBub2RlLCBvcjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIHRoZSB3aGl0ZXNwYWNlIGlzIGFkamFjZW50IHRvIGEgY29tbWVudCwgb3I6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSB0aGUgd2hpdGVzcGFjZSBpcyBiZXR3ZWVuIHR3byBlbGVtZW50cyBBTkQgY29udGFpbnMgbmV3bGluZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gdGhlIHdoaXRlc3BhY2UgaXMgaWdub3JlZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW5leHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHByZXYudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgL1tcXHJcXG5dLy50ZXN0KG5vZGUuY29udGVudCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRXaGl0ZXNwYWNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjb25kZW5zZWQgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBpbnNpZGUgdGhlIHRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0byBhIHNpbmdsZSBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSAnICc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2UoL1tcXHRcXHJcXG5cXGYgXSsvZywgJyAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHNvIHJlbW92ZSBjb21tZW50IG5vZGVzIGluIHByb2QgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICFjb250ZXh0Lm9wdGlvbnMuY29tbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRXaGl0ZXNwYWNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dC5pblByZSAmJiBwYXJlbnQgJiYgY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHBhcmVudC50YWcpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIG5ld2xpbmUgcGVyIGh0bWwgc3BlY1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9ncm91cGluZy1jb250ZW50Lmh0bWwjdGhlLXByZS1lbGVtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gbm9kZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBmaXJzdC50eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdC5jb250ZW50LnJlcGxhY2UoL15cXHI/XFxuLywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZWRXaGl0ZXNwYWNlID8gbm9kZXMuZmlsdGVyKEJvb2xlYW4pIDogbm9kZXM7XHJcbn1cclxuZnVuY3Rpb24gcHVzaE5vZGUobm9kZXMsIG5vZGUpIHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgIGNvbnN0IHByZXYgPSBsYXN0KG5vZGVzKTtcclxuICAgICAgICAvLyBNZXJnZSBpZiBib3RoIHRoaXMgYW5kIHRoZSBwcmV2aW91cyBub2RlIGFyZSB0ZXh0IGFuZCB0aG9zZSBhcmVcclxuICAgICAgICAvLyBjb25zZWN1dGl2ZS4gVGhpcyBoYXBwZW5zIGZvciBjYXNlcyBsaWtlIFwiYSA8IGJcIi5cclxuICAgICAgICBpZiAocHJldiAmJlxyXG4gICAgICAgICAgICBwcmV2LnR5cGUgPT09IDIgLyogVEVYVCAqLyAmJlxyXG4gICAgICAgICAgICBwcmV2LmxvYy5lbmQub2Zmc2V0ID09PSBub2RlLmxvYy5zdGFydC5vZmZzZXQpIHtcclxuICAgICAgICAgICAgcHJldi5jb250ZW50ICs9IG5vZGUuY29udGVudDtcclxuICAgICAgICAgICAgcHJldi5sb2MuZW5kID0gbm9kZS5sb2MuZW5kO1xyXG4gICAgICAgICAgICBwcmV2LmxvYy5zb3VyY2UgKz0gbm9kZS5sb2Muc291cmNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbm9kZXMucHVzaChub2RlKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNEQVRBKGNvbnRleHQsIGFuY2VzdG9ycykge1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIDkpO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIDMgLyogQ0RBVEEgKi8sIGFuY2VzdG9ycyk7XHJcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDYgLyogRU9GX0lOX0NEQVRBICovKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlcztcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNvbW1lbnQoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIC8vIFJlZ3VsYXIgY29tbWVudC5cclxuICAgIGNvbnN0IG1hdGNoID0gLy0tKFxcISk/Pi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA3IC8qIEVPRl9JTl9DT01NRU5UICovKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA8PSAzKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAwIC8qIEFCUlVQVF9DTE9TSU5HX09GX0VNUFRZX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEwIC8qIElOQ09SUkVDVExZX0NMT1NFRF9DT01NRU5UICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDQsIG1hdGNoLmluZGV4KTtcclxuICAgICAgICAvLyBBZHZhbmNpbmcgd2l0aCByZXBvcnRpbmcgbmVzdGVkIGNvbW1lbnRzLlxyXG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCBtYXRjaC5pbmRleCk7XHJcbiAgICAgICAgbGV0IHByZXZJbmRleCA9IDEsIG5lc3RlZEluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAoKG5lc3RlZEluZGV4ID0gcy5pbmRleE9mKCc8IS0tJywgcHJldkluZGV4KSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBuZXN0ZWRJbmRleCAtIHByZXZJbmRleCArIDEpO1xyXG4gICAgICAgICAgICBpZiAobmVzdGVkSW5kZXggKyA0IDwgcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNiAvKiBORVNURURfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldkluZGV4ID0gbmVzdGVkSW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggLSBwcmV2SW5kZXggKyAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMyAvKiBDT01NRU5UICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgY29udGVudFN0YXJ0ID0gY29udGV4dC5zb3VyY2VbMV0gPT09ICc/JyA/IDEgOiAyO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZignPicpO1xyXG4gICAgaWYgKGNsb3NlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRlbnRTdGFydCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGVudFN0YXJ0LCBjbG9zZUluZGV4KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY2xvc2VJbmRleCArIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAzIC8qIENPTU1FTlQgKi8sXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VFbGVtZW50KGNvbnRleHQsIGFuY2VzdG9ycykge1xyXG4gICAgLy8gU3RhcnQgdGFnLlxyXG4gICAgY29uc3Qgd2FzSW5QcmUgPSBjb250ZXh0LmluUHJlO1xyXG4gICAgY29uc3Qgd2FzSW5WUHJlID0gY29udGV4dC5pblZQcmU7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gcGFyc2VUYWcoY29udGV4dCwgMCAvKiBTdGFydCAqLywgcGFyZW50KTtcclxuICAgIGNvbnN0IGlzUHJlQm91bmRhcnkgPSBjb250ZXh0LmluUHJlICYmICF3YXNJblByZTtcclxuICAgIGNvbnN0IGlzVlByZUJvdW5kYXJ5ID0gY29udGV4dC5pblZQcmUgJiYgIXdhc0luVlByZTtcclxuICAgIGlmIChlbGVtZW50LmlzU2VsZkNsb3NpbmcgfHwgY29udGV4dC5vcHRpb25zLmlzVm9pZFRhZyhlbGVtZW50LnRhZykpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuICAgIC8vIENoaWxkcmVuLlxyXG4gICAgYW5jZXN0b3JzLnB1c2goZWxlbWVudCk7XHJcbiAgICBjb25zdCBtb2RlID0gY29udGV4dC5vcHRpb25zLmdldFRleHRNb2RlKGVsZW1lbnQsIHBhcmVudCk7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKTtcclxuICAgIGFuY2VzdG9ycy5wb3AoKTtcclxuICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIC8vIEVuZCB0YWcuXHJcbiAgICBpZiAoc3RhcnRzV2l0aEVuZFRhZ09wZW4oY29udGV4dC5zb3VyY2UsIGVsZW1lbnQudGFnKSkge1xyXG4gICAgICAgIHBhcnNlVGFnKGNvbnRleHQsIDEgLyogRW5kICovLCBwYXJlbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI0IC8qIFhfTUlTU0lOR19FTkRfVEFHICovLCAwLCBlbGVtZW50LmxvYy5zdGFydCk7XHJcbiAgICAgICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCAmJiBlbGVtZW50LnRhZy50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0Jykge1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3QgJiYgc3RhcnRzV2l0aChmaXJzdC5sb2Muc291cmNlLCAnPCEtLScpKSB7XHJcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgOCAvKiBFT0ZfSU5fU0NSSVBUX0hUTUxfQ09NTUVOVF9MSUtFX1RFWFQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxlbWVudC5sb2MgPSBnZXRTZWxlY3Rpb24oY29udGV4dCwgZWxlbWVudC5sb2Muc3RhcnQpO1xyXG4gICAgaWYgKGlzUHJlQm91bmRhcnkpIHtcclxuICAgICAgICBjb250ZXh0LmluUHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNWUHJlQm91bmRhcnkpIHtcclxuICAgICAgICBjb250ZXh0LmluVlByZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuY29uc3QgaXNTcGVjaWFsVGVtcGxhdGVEaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGlmLGVsc2UsZWxzZS1pZixmb3Isc2xvdGApO1xyXG4vKipcclxuICogUGFyc2UgYSB0YWcgKEUuZy4gYDxkaXYgaWQ9YT5gKSB3aXRoIHRoYXQgdHlwZSAoc3RhcnQgdGFnIG9yIGVuZCB0YWcpLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VUYWcoY29udGV4dCwgdHlwZSwgcGFyZW50KSB7XHJcbiAgICAvLyBUYWcgb3Blbi5cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgbWF0Y2ggPSAvXjxcXC8/KFthLXpdW15cXHRcXHJcXG5cXGYgLz5dKikvaS5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGNvbnN0IHRhZyA9IG1hdGNoWzFdO1xyXG4gICAgY29uc3QgbnMgPSBjb250ZXh0Lm9wdGlvbnMuZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgIC8vIHNhdmUgY3VycmVudCBzdGF0ZSBpbiBjYXNlIHdlIG5lZWQgdG8gcmUtcGFyc2UgYXR0cmlidXRlcyB3aXRoIHYtcHJlXHJcbiAgICBjb25zdCBjdXJzb3IgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjdXJyZW50U291cmNlID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICAvLyBBdHRyaWJ1dGVzLlxyXG4gICAgbGV0IHByb3BzID0gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpO1xyXG4gICAgLy8gY2hlY2sgPHByZT4gdGFnXHJcbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHRhZykpIHtcclxuICAgICAgICBjb250ZXh0LmluUHJlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIHYtcHJlXHJcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmXHJcbiAgICAgICAgcHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAncHJlJykpIHtcclxuICAgICAgICBjb250ZXh0LmluVlByZSA9IHRydWU7XHJcbiAgICAgICAgLy8gcmVzZXQgY29udGV4dFxyXG4gICAgICAgIGV4dGVuZChjb250ZXh0LCBjdXJzb3IpO1xyXG4gICAgICAgIGNvbnRleHQuc291cmNlID0gY3VycmVudFNvdXJjZTtcclxuICAgICAgICAvLyByZS1wYXJzZSBhdHRycyBhbmQgZmlsdGVyIG91dCB2LXByZSBpdHNlbGZcclxuICAgICAgICBwcm9wcyA9IHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKS5maWx0ZXIocCA9PiBwLm5hbWUgIT09ICd2LXByZScpO1xyXG4gICAgfVxyXG4gICAgLy8gVGFnIGNsb3NlLlxyXG4gICAgbGV0IGlzU2VsZkNsb3NpbmcgPSBmYWxzZTtcclxuICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgOSAvKiBFT0ZfSU5fVEFHICovKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlzU2VsZkNsb3NpbmcgPSBzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLz4nKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gMSAvKiBFbmQgKi8gJiYgaXNTZWxmQ2xvc2luZykge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNCAvKiBFTkRfVEFHX1dJVEhfVFJBSUxJTkdfU09MSURVUyAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBpc1NlbGZDbG9zaW5nID8gMiA6IDEpO1xyXG4gICAgfVxyXG4gICAgbGV0IHRhZ1R5cGUgPSAwIC8qIEVMRU1FTlQgKi87XHJcbiAgICBjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xyXG4gICAgaWYgKCFjb250ZXh0LmluVlByZSAmJiAhb3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQodGFnKSkge1xyXG4gICAgICAgIGNvbnN0IGhhc1ZJcyA9IHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ2lzJyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNOYXRpdmVUYWcgJiYgIWhhc1ZJcykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaXNOYXRpdmVUYWcodGFnKSlcclxuICAgICAgICAgICAgICAgIHRhZ1R5cGUgPSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzVklzIHx8XHJcbiAgICAgICAgICAgIGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8XHJcbiAgICAgICAgICAgIChvcHRpb25zLmlzQnVpbHRJbkNvbXBvbmVudCAmJiBvcHRpb25zLmlzQnVpbHRJbkNvbXBvbmVudCh0YWcpKSB8fFxyXG4gICAgICAgICAgICAvXltBLVpdLy50ZXN0KHRhZykgfHxcclxuICAgICAgICAgICAgdGFnID09PSAnY29tcG9uZW50Jykge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YWcgPT09ICdzbG90Jykge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMiAvKiBTTE9UICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09ICd0ZW1wbGF0ZScgJiZcclxuICAgICAgICAgICAgcHJvcHMuc29tZShwID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZShwLm5hbWUpKTtcclxuICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgdGFnVHlwZSA9IDMgLyogVEVNUExBVEUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxIC8qIEVMRU1FTlQgKi8sXHJcbiAgICAgICAgbnMsXHJcbiAgICAgICAgdGFnLFxyXG4gICAgICAgIHRhZ1R5cGUsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgaXNTZWxmQ2xvc2luZyxcclxuICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpLFxyXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQgLy8gdG8gYmUgY3JlYXRlZCBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xyXG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XHJcbiAgICB3aGlsZSAoY29udGV4dC5zb3VyY2UubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICFzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnPicpICYmXHJcbiAgICAgICAgIXN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvPicpKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvJykpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIyIC8qIFVORVhQRUNURURfU09MSURVU19JTl9UQUcgKi8pO1xyXG4gICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gMSAvKiBFbmQgKi8pIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDMgLyogRU5EX1RBR19XSVRIX0FUVFJJQlVURVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhdHRyID0gcGFyc2VBdHRyaWJ1dGUoY29udGV4dCwgYXR0cmlidXRlTmFtZXMpO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAwIC8qIFN0YXJ0ICovKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnB1c2goYXR0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgvXlteXFx0XFxyXFxuXFxmIC8+XS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE1IC8qIE1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIG5hbWVTZXQpIHtcclxuICAgIC8vIE5hbWUuXHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiAvPl1bXlxcdFxcclxcblxcZiAvPj1dKi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBjb25zdCBuYW1lID0gbWF0Y2hbMF07XHJcbiAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMiAvKiBEVVBMSUNBVEVfQVRUUklCVVRFICovKTtcclxuICAgIH1cclxuICAgIG5hbWVTZXQuYWRkKG5hbWUpO1xyXG4gICAgaWYgKG5hbWVbMF0gPT09ICc9Jykge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOSAvKiBVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqLyk7XHJcbiAgICB9XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IC9bXCInPF0vZztcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBwYXR0ZXJuLmV4ZWMobmFtZSkpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNyAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqLywgbS5pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5hbWUubGVuZ3RoKTtcclxuICAgIC8vIFZhbHVlXHJcbiAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoL15bXFx0XFxyXFxuXFxmIF0qPS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgIHZhbHVlID0gcGFyc2VBdHRyaWJ1dGVWYWx1ZShjb250ZXh0KTtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMyAvKiBNSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KTtcclxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgL14odi18OnxAfCMpLy50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvKD86XnYtKFthLXowLTktXSspKT8oPzooPzo6fF5AfF4jKShcXFtbXlxcXV0rXFxdfFteXFwuXSspKT8oLispPyQvaS5leGVjKG5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGRpck5hbWUgPSBtYXRjaFsxXSB8fFxyXG4gICAgICAgICAgICAoc3RhcnRzV2l0aChuYW1lLCAnOicpID8gJ2JpbmQnIDogc3RhcnRzV2l0aChuYW1lLCAnQCcpID8gJ29uJyA6ICdzbG90Jyk7XHJcbiAgICAgICAgbGV0IGFyZztcclxuICAgICAgICBpZiAobWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgY29uc3QgaXNTbG90ID0gZGlyTmFtZSA9PT0gJ3Nsb3QnO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IG5hbWUuaW5kZXhPZihtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQpLCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQgKyBtYXRjaFsyXS5sZW5ndGggKyAoKGlzU2xvdCAmJiBtYXRjaFszXSkgfHwgJycpLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudC5zdGFydHNXaXRoKCdbJykpIHtcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQuZW5kc1dpdGgoJ10nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNiAvKiBYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cigxLCBjb250ZW50Lmxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2xvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gIzEyNDEgc3BlY2lhbCBjYXNlIGZvciB2LXNsb3Q6IHZ1ZXRpZnkgcmVsaWVzIGV4dGVuc2l2ZWx5IG9uIHNsb3RcclxuICAgICAgICAgICAgICAgIC8vIG5hbWVzIGNvbnRhaW5pbmcgZG90cy4gdi1zbG90IGRvZXNuJ3QgaGF2ZSBhbnkgbW9kaWZpZXJzIGFuZCBWdWUgMi54XHJcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0cyBzdWNoIHVzYWdlIHNvIHdlIGFyZSBrZWVwaW5nIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnguXHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IG1hdGNoWzNdIHx8ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFyZyA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICBjb25zdFR5cGU6IGlzU3RhdGljXHJcbiAgICAgICAgICAgICAgICAgICAgPyAzIC8qIENBTl9TVFJJTkdJRlkgKi9cclxuICAgICAgICAgICAgICAgICAgICA6IDAgLyogTk9UX0NPTlNUQU5UICovLFxyXG4gICAgICAgICAgICAgICAgbG9jXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc1F1b3RlZCkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZUxvYyA9IHZhbHVlLmxvYztcclxuICAgICAgICAgICAgdmFsdWVMb2Muc3RhcnQub2Zmc2V0Kys7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLnN0YXJ0LmNvbHVtbisrO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUodmFsdWVMb2Muc3RhcnQsIHZhbHVlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5zb3VyY2UgPSB2YWx1ZUxvYy5zb3VyY2Uuc2xpY2UoMSwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiA3IC8qIERJUkVDVElWRSAqLyxcclxuICAgICAgICAgICAgbmFtZTogZGlyTmFtZSxcclxuICAgICAgICAgICAgZXhwOiB2YWx1ZSAmJiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IGFzIG5vbi1jb25zdGFudCBieSBkZWZhdWx0LiBUaGlzIGNhbiBiZSBwb3RlbnRpYWxseSBzZXQgdG9cclxuICAgICAgICAgICAgICAgIC8vIG90aGVyIHZhbHVlcyBieSBgdHJhbnNmb3JtRXhwcmVzc2lvbmAgdG8gbWFrZSBpdCBlbGlnaWJsZSBmb3IgaG9pc3RpbmcuXHJcbiAgICAgICAgICAgICAgICBjb25zdFR5cGU6IDAgLyogTk9UX0NPTlNUQU5UICovLFxyXG4gICAgICAgICAgICAgICAgbG9jOiB2YWx1ZS5sb2NcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnM6IG1hdGNoWzNdID8gbWF0Y2hbM10uc3Vic3RyKDEpLnNwbGl0KCcuJykgOiBbXSxcclxuICAgICAgICAgICAgbG9jXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNiAvKiBBVFRSSUJVVEUgKi8sXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICB2YWx1ZTogdmFsdWUgJiYge1xyXG4gICAgICAgICAgICB0eXBlOiAyIC8qIFRFWFQgKi8sXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmNvbnRlbnQsXHJcbiAgICAgICAgICAgIGxvYzogdmFsdWUubG9jXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVWYWx1ZShjb250ZXh0KSB7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgY29uc3QgcXVvdGUgPSBjb250ZXh0LnNvdXJjZVswXTtcclxuICAgIGNvbnN0IGlzUXVvdGVkID0gcXVvdGUgPT09IGBcImAgfHwgcXVvdGUgPT09IGAnYDtcclxuICAgIGlmIChpc1F1b3RlZCkge1xyXG4gICAgICAgIC8vIFF1b3RlZCB2YWx1ZS5cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKHF1b3RlKTtcclxuICAgICAgICBpZiAoZW5kSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCwgNCAvKiBBVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgZW5kSW5kZXgsIDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFVucXVvdGVkXHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvXlteXFx0XFxyXFxuXFxmID5dKy8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bmV4cGVjdGVkQ2hhcnMgPSAvW1wiJzw9YF0vZztcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSB1bmV4cGVjdGVkQ2hhcnMuZXhlYyhtYXRjaFswXSkpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOCAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9VTlFVT1RFRF9BVFRSSUJVVEVfVkFMVUUgKi8sIG0uaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgsIDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGNvbnRlbnQsIGlzUXVvdGVkLCBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSkge1xyXG4gICAgY29uc3QgW29wZW4sIGNsb3NlXSA9IGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzO1xyXG4gICAgY29uc3QgY2xvc2VJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoY2xvc2UsIG9wZW4ubGVuZ3RoKTtcclxuICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNSAvKiBYX01JU1NJTkdfSU5URVJQT0xBVElPTl9FTkQgKi8pO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBvcGVuLmxlbmd0aCk7XHJcbiAgICBjb25zdCBpbm5lclN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgaW5uZXJFbmQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCByYXdDb250ZW50TGVuZ3RoID0gY2xvc2VJbmRleCAtIG9wZW4ubGVuZ3RoO1xyXG4gICAgY29uc3QgcmF3Q29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIHJhd0NvbnRlbnRMZW5ndGgpO1xyXG4gICAgY29uc3QgcHJlVHJpbUNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIHJhd0NvbnRlbnRMZW5ndGgsIG1vZGUpO1xyXG4gICAgY29uc3QgY29udGVudCA9IHByZVRyaW1Db250ZW50LnRyaW0oKTtcclxuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gcHJlVHJpbUNvbnRlbnQuaW5kZXhPZihjb250ZW50KTtcclxuICAgIGlmIChzdGFydE9mZnNldCA+IDApIHtcclxuICAgICAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oaW5uZXJTdGFydCwgcmF3Q29udGVudCwgc3RhcnRPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gcmF3Q29udGVudExlbmd0aCAtIChwcmVUcmltQ29udGVudC5sZW5ndGggLSBjb250ZW50Lmxlbmd0aCAtIHN0YXJ0T2Zmc2V0KTtcclxuICAgIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihpbm5lckVuZCwgcmF3Q29udGVudCwgZW5kT2Zmc2V0KTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBjbG9zZS5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA1IC8qIElOVEVSUE9MQVRJT04gKi8sXHJcbiAgICAgICAgY29udGVudDoge1xyXG4gICAgICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICBpc1N0YXRpYzogZmFsc2UsXHJcbiAgICAgICAgICAgIC8vIFNldCBgaXNDb25zdGFudGAgdG8gZmFsc2UgYnkgZGVmYXVsdCBhbmQgd2lsbCBkZWNpZGUgaW4gdHJhbnNmb3JtRXhwcmVzc2lvblxyXG4gICAgICAgICAgICBjb25zdFR5cGU6IDAgLyogTk9UX0NPTlNUQU5UICovLFxyXG4gICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBpbm5lclN0YXJ0LCBpbm5lckVuZClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVRleHQoY29udGV4dCwgbW9kZSkge1xyXG4gICAgY29uc3QgZW5kVG9rZW5zID0gWyc8JywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF1dO1xyXG4gICAgaWYgKG1vZGUgPT09IDMgLyogQ0RBVEEgKi8pIHtcclxuICAgICAgICBlbmRUb2tlbnMucHVzaCgnXV0+Jyk7XHJcbiAgICB9XHJcbiAgICBsZXQgZW5kSW5kZXggPSBjb250ZXh0LnNvdXJjZS5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZFRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihlbmRUb2tlbnNbaV0sIDEpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEgJiYgZW5kSW5kZXggPiBpbmRleCkge1xyXG4gICAgICAgICAgICBlbmRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgZW5kSW5kZXgsIG1vZGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyIC8qIFRFWFQgKi8sXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0ZXh0IGRhdGEgd2l0aCBhIGdpdmVuIGxlbmd0aCBmcm9tIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxyXG4gKiBUaGlzIHRyYW5zbGF0ZXMgSFRNTCBlbnRpdGllcyBpbiB0aGUgdGV4dCBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBsZW5ndGgsIG1vZGUpIHtcclxuICAgIGNvbnN0IHJhd1RleHQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCBsZW5ndGgpO1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIGxlbmd0aCk7XHJcbiAgICBpZiAobW9kZSA9PT0gMiAvKiBSQVdURVhUICovIHx8XHJcbiAgICAgICAgbW9kZSA9PT0gMyAvKiBDREFUQSAqLyB8fFxyXG4gICAgICAgIHJhd1RleHQuaW5kZXhPZignJicpID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiByYXdUZXh0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gREFUQSBvciBSQ0RBVEEgY29udGFpbmluZyBcIiZcIlwiLiBFbnRpdHkgZGVjb2RpbmcgcmVxdWlyZWQuXHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQub3B0aW9ucy5kZWNvZGVFbnRpdGllcyhyYXdUZXh0LCBtb2RlID09PSA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3Vyc29yKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgY29sdW1uLCBsaW5lLCBvZmZzZXQgfSA9IGNvbnRleHQ7XHJcbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUsIG9mZnNldCB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCwgZW5kKSB7XHJcbiAgICBlbmQgPSBlbmQgfHwgZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBlbmQsXHJcbiAgICAgICAgc291cmNlOiBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbGFzdCh4cykge1xyXG4gICAgcmV0dXJuIHhzW3hzLmxlbmd0aCAtIDFdO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc291cmNlLCBzZWFyY2hTdHJpbmcpIHtcclxuICAgIHJldHVybiBzb3VyY2Uuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpO1xyXG59XHJcbmZ1bmN0aW9uIGFkdmFuY2VCeShjb250ZXh0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcclxuICAgIGNvbnN0IHsgc291cmNlIH0gPSBjb250ZXh0O1xyXG4gICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGNvbnRleHQsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxuICAgIGNvbnRleHQuc291cmNlID0gc291cmNlLnNsaWNlKG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZVNwYWNlcyhjb250ZXh0KSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IC9eW1xcdFxcclxcblxcZiBdKy8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSB7XHJcbiAgICByZXR1cm4gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHN0YXJ0LCBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxufVxyXG5mdW5jdGlvbiBlbWl0RXJyb3IoY29udGV4dCwgY29kZSwgb2Zmc2V0LCBsb2MgPSBnZXRDdXJzb3IoY29udGV4dCkpIHtcclxuICAgIGlmIChvZmZzZXQpIHtcclxuICAgICAgICBsb2Mub2Zmc2V0ICs9IG9mZnNldDtcclxuICAgICAgICBsb2MuY29sdW1uICs9IG9mZnNldDtcclxuICAgIH1cclxuICAgIGNvbnRleHQub3B0aW9ucy5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoY29kZSwge1xyXG4gICAgICAgIHN0YXJ0OiBsb2MsXHJcbiAgICAgICAgZW5kOiBsb2MsXHJcbiAgICAgICAgc291cmNlOiAnJ1xyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRW5kKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykge1xyXG4gICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xyXG4gICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8LycpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwcm9iYWJseSBiYWQgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgYW5jZXN0b3JzW2ldLnRhZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMSAvKiBSQ0RBVEEgKi86XHJcbiAgICAgICAgY2FzZSAyIC8qIFJBV1RFWFQgKi86IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHMsIHBhcmVudC50YWcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAzIC8qIENEQVRBICovOlxyXG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnXV0+JykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICFzO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHNvdXJjZSwgdGFnKSB7XHJcbiAgICByZXR1cm4gKHN0YXJ0c1dpdGgoc291cmNlLCAnPC8nKSAmJlxyXG4gICAgICAgIHNvdXJjZS5zdWJzdHIoMiwgdGFnLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCkgJiZcclxuICAgICAgICAvW1xcdFxcclxcblxcZiAvPl0vLnRlc3Qoc291cmNlWzIgKyB0YWcubGVuZ3RoXSB8fCAnPicpKTtcclxufVxuXG5mdW5jdGlvbiBob2lzdFN0YXRpYyhyb290LCBjb250ZXh0KSB7XHJcbiAgICB3YWxrKHJvb3QsIGNvbnRleHQsIFxyXG4gICAgLy8gUm9vdCBub2RlIGlzIHVuZm9ydHVuYXRlbHkgbm9uLWhvaXN0YWJsZSBkdWUgdG8gcG90ZW50aWFsIHBhcmVudFxyXG4gICAgLy8gZmFsbHRocm91Z2ggYXR0cmlidXRlcy5cclxuICAgIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgcm9vdC5jaGlsZHJlblswXSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpIHtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XHJcbiAgICByZXR1cm4gKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICFpc1Nsb3RPdXRsZXQoY2hpbGQpKTtcclxufVxyXG5mdW5jdGlvbiB3YWxrKG5vZGUsIGNvbnRleHQsIGRvTm90SG9pc3ROb2RlID0gZmFsc2UpIHtcclxuICAgIGxldCBoYXNIb2lzdGVkTm9kZSA9IGZhbHNlO1xyXG4gICAgLy8gU29tZSB0cmFuc2Zvcm1zLCBlLmcuIHRyYW5zZm9ybUFzc2V0VXJscyBmcm9tIEB2dWUvY29tcGlsZXItc2ZjLCByZXBsYWNlc1xyXG4gICAgLy8gc3RhdGljIGJpbmRpbmdzIHdpdGggZXhwcmVzc2lvbnMuIFRoZXNlIGV4cHJlc3Npb25zIGFyZSBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICAvLyBjb25zdGFudCBzbyB0aGV5IGFyZSBzdGlsbCBlbGlnaWJsZSBmb3IgaG9pc3RpbmcsIGJ1dCB0aGV5IGFyZSBvbmx5XHJcbiAgICAvLyBhdmFpbGFibGUgYXQgcnVudGltZSBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSBldmFsdWF0ZWQgYWhlYWQgb2YgdGltZS5cclxuICAgIC8vIFRoaXMgaXMgb25seSBhIGNvbmNlcm4gZm9yIHByZS1zdHJpbmdpZmljYXRpb24gKHZpYSB0cmFuc2Zvcm1Ib2lzdCBieVxyXG4gICAgLy8gQHZ1ZS9jb21waWxlci1kb20pLCBidXQgZG9pbmcgaXQgaGVyZSBhbGxvd3MgdXMgdG8gcGVyZm9ybSBvbmx5IG9uZSBmdWxsXHJcbiAgICAvLyB3YWxrIG9mIHRoZSBBU1QgYW5kIGFsbG93IGBzdHJpbmdpZnlTdGF0aWNgIHRvIHN0b3Agd2Fsa2luZyBhcyBzb29uIGFzIGl0c1xyXG4gICAgLy8gc3RyaW5nZmljaWF0aW9uIHRocmVzaG9sZCBpcyBtZXQuXHJcbiAgICBsZXQgY2FuU3RyaW5naWZ5ID0gdHJ1ZTtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IG5vZGU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAvLyBvbmx5IHBsYWluIGVsZW1lbnRzICYgdGV4dCBjYWxscyBhcmUgZWxpZ2libGUgZm9yIGhvaXN0aW5nLlxyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgY2hpbGQudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0YW50VHlwZSA9IGRvTm90SG9pc3ROb2RlXHJcbiAgICAgICAgICAgICAgICA/IDAgLyogTk9UX0NPTlNUQU5UICovXHJcbiAgICAgICAgICAgICAgICA6IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChjb25zdGFudFR5cGUgPiAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA8IDMgLyogQ0FOX1NUUklOR0lGWSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhblN0cmluZ2lmeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+PSAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvZGVnZW5Ob2RlLnBhdGNoRmxhZyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0xIC8qIEhPSVNURUQgKi8gKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiBIT0lTVEVEICovYCA6IGBgKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0hvaXN0ZWROb2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vZGUgbWF5IGNvbnRhaW4gZHluYW1pYyBjaGlsZHJlbiwgYnV0IGl0cyBwcm9wcyBtYXkgYmUgZWxpZ2libGUgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBob2lzdGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gY2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBnZXRQYXRjaEZsYWcoY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWZsYWcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9PT0gNTEyIC8qIE5FRURfUEFUQ0ggKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9PT0gMSAvKiBURVhUICovKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPj1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLyogQ0FOX0hPSVNUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5wcm9wcyA9IGNvbnRleHQuaG9pc3QocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDEyIC8qIFRFWFRfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGdldENvbnN0YW50VHlwZShjaGlsZC5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlIDwgMyAvKiBDQU5fU1RSSU5HSUZZICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuU3RyaW5naWZ5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPj0gMiAvKiBDQU5fSE9JU1QgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0hvaXN0ZWROb2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3YWxrIGZ1cnRoZXJcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8pIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGhvaXN0IHYtZm9yIHNpbmdsZSBjaGlsZCBiZWNhdXNlIGl0IGhhcyB0byBiZSBhIGJsb2NrXHJcbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQsIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZC5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGhvaXN0IHYtaWYgc2luZ2xlIGNoaWxkIGJlY2F1c2UgaXQgaGFzIHRvIGJlIGEgYmxvY2tcclxuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQuYnJhbmNoZXNbaV0sIGNvbnRleHQsIGNoaWxkLmJyYW5jaGVzW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoY2FuU3RyaW5naWZ5ICYmIGhhc0hvaXN0ZWROb2RlICYmIGNvbnRleHQudHJhbnNmb3JtSG9pc3QpIHtcclxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybUhvaXN0KGNoaWxkcmVuLCBjb250ZXh0LCBub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBjb25zdGFudENhY2hlIH0gPSBjb250ZXh0O1xyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSAhPT0gMCAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY29uc3RhbnRDYWNoZS5nZXQobm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlICE9PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZmxhZyA9IGdldFBhdGNoRmxhZyhjb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghZmxhZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGl0c2VsZiBoYXMgbm8gcGF0Y2ggZmxhZy4gSG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrOlxyXG4gICAgICAgICAgICAgICAgLy8gMS4gRXZlbiBmb3IgYSBub2RlIHdpdGggbm8gcGF0Y2ggZmxhZywgaXQgaXMgcG9zc2libGUgZm9yIGl0IHRvIGNvbnRhaW5cclxuICAgICAgICAgICAgICAgIC8vIG5vbi1ob2lzdGFibGUgZXhwcmVzc2lvbnMgdGhhdCByZWZlcnMgdG8gc2NvcGUgdmFyaWFibGVzLCBlLmcuIGNvbXBpbGVyXHJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3RlZCBrZXlzIG9yIGNhY2hlZCBldmVudCBoYW5kbGVycy4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgY29kZWdlbk5vZGUncyBwcm9wcyB0byBiZSBzdXJlLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkUHJvcHNUeXBlID0gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBnZW5lcmF0ZWRQcm9wc1R5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAyLiBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUobm9kZS5jaGlsZHJlbltpXSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gMy4gaWYgdGhlIHR5cGUgaXMgbm90IGFscmVhZHkgQ0FOX1NLSVBfUEFUQ0ggd2hpY2ggaXMgdGhlIGxvd2VzdCBub24tMFxyXG4gICAgICAgICAgICAgICAgLy8gdHlwZSwgY2hlY2sgaWYgYW55IG9mIHRoZSBwcm9wcyBjYW4gY2F1c2UgdGhlIHR5cGUgdG8gYmUgbG93ZXJlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIHNraXAgY2FuX3BhdGNoIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIGJ5IHRoZSBhYnNlbmNlIG9mIGFcclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoRmxhZy5cclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UeXBlID4gMSAvKiBDQU5fU0tJUF9QQVRDSCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnYmluZCcgJiYgcC5leHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cFR5cGUgPSBnZXRDb25zdGFudFR5cGUocC5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBleHBUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBzdmcvZm9yZWlnbk9iamVjdCBjb3VsZCBiZSBibG9jayBoZXJlLCBob3dldmVyIGlmIHRoZXkgYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBzdGF0aWMgdGhlbiB0aGV5IGRvbid0IG5lZWQgdG8gYmUgYmxvY2tzIHNpbmNlIHRoZXJlIHdpbGwgYmUgbm9cclxuICAgICAgICAgICAgICAgIC8vIG5lc3RlZCB1cGRhdGVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5pc0Jsb2NrID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoQ1JFQVRFX1ZOT0RFKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIHJldHVyblR5cGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIE5PVF9DT05TVEFOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBjYXNlIDIgLyogVEVYVCAqLzpcclxuICAgICAgICBjYXNlIDMgLyogQ09NTUVOVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDMgLyogQ0FOX1NUUklOR0lGWSAqLztcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICBjYXNlIDEyIC8qIFRFWFRfQ0FMTCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgICAgIGNhc2UgNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29uc3RUeXBlO1xyXG4gICAgICAgIGNhc2UgOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBsZXQgcmV0dXJuVHlwZSA9IDMgLyogQ0FOX1NUUklOR0lGWSAqLztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoY2hpbGQpIHx8IGlzU3ltYm9sKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgO1xyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhub2RlKTtcclxuICAgIGlmIChwcm9wcyAmJiBwcm9wcy50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gcHJvcHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qga2V5VHlwZSA9IGdldENvbnN0YW50VHlwZShrZXksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrZXlUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGtleVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBnZXRDb25zdGFudFR5cGUodmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWVUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWVUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IHZhbHVlVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5vZGVQcm9wcyhub2RlKSB7XHJcbiAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGU7XHJcbiAgICBpZiAoY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgIHJldHVybiBjb2RlZ2VuTm9kZS5wcm9wcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRQYXRjaEZsYWcobm9kZSkge1xyXG4gICAgY29uc3QgZmxhZyA9IG5vZGUucGF0Y2hGbGFnO1xyXG4gICAgcmV0dXJuIGZsYWcgPyBwYXJzZUludChmbGFnLCAxMCkgOiB1bmRlZmluZWQ7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCB7IGZpbGVuYW1lID0gJycsIHByZWZpeElkZW50aWZpZXJzID0gZmFsc2UsIGhvaXN0U3RhdGljID0gZmFsc2UsIGNhY2hlSGFuZGxlcnMgPSBmYWxzZSwgbm9kZVRyYW5zZm9ybXMgPSBbXSwgZGlyZWN0aXZlVHJhbnNmb3JtcyA9IHt9LCB0cmFuc2Zvcm1Ib2lzdCA9IG51bGwsIGlzQnVpbHRJbkNvbXBvbmVudCA9IE5PT1AsIGlzQ3VzdG9tRWxlbWVudCA9IE5PT1AsIGV4cHJlc3Npb25QbHVnaW5zID0gW10sIHNjb3BlSWQgPSBudWxsLCBzc3IgPSBmYWxzZSwgc3NyQ3NzVmFycyA9IGBgLCBiaW5kaW5nTWV0YWRhdGEgPSBFTVBUWV9PQkosIGlubGluZSA9IGZhbHNlLCBpc1RTID0gZmFsc2UsIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvciB9KSB7XHJcbiAgICBjb25zdCBuYW1lTWF0Y2ggPSBmaWxlbmFtZS5yZXBsYWNlKC9cXD8uKiQvLCAnJykubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgLy8gb3B0aW9uc1xyXG4gICAgICAgIHNlbGZOYW1lOiBuYW1lTWF0Y2ggJiYgY2FwaXRhbGl6ZShjYW1lbGl6ZSQxKG5hbWVNYXRjaFsxXSkpLFxyXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzLFxyXG4gICAgICAgIGhvaXN0U3RhdGljLFxyXG4gICAgICAgIGNhY2hlSGFuZGxlcnMsXHJcbiAgICAgICAgbm9kZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtcyxcclxuICAgICAgICB0cmFuc2Zvcm1Ib2lzdCxcclxuICAgICAgICBpc0J1aWx0SW5Db21wb25lbnQsXHJcbiAgICAgICAgaXNDdXN0b21FbGVtZW50LFxyXG4gICAgICAgIGV4cHJlc3Npb25QbHVnaW5zLFxyXG4gICAgICAgIHNjb3BlSWQsXHJcbiAgICAgICAgc3NyLFxyXG4gICAgICAgIHNzckNzc1ZhcnMsXHJcbiAgICAgICAgYmluZGluZ01ldGFkYXRhLFxyXG4gICAgICAgIGlubGluZSxcclxuICAgICAgICBpc1RTLFxyXG4gICAgICAgIG9uRXJyb3IsXHJcbiAgICAgICAgLy8gc3RhdGVcclxuICAgICAgICByb290LFxyXG4gICAgICAgIGhlbHBlcnM6IG5ldyBTZXQoKSxcclxuICAgICAgICBjb21wb25lbnRzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgZGlyZWN0aXZlczogbmV3IFNldCgpLFxyXG4gICAgICAgIGhvaXN0czogW10sXHJcbiAgICAgICAgaW1wb3J0czogW10sXHJcbiAgICAgICAgY29uc3RhbnRDYWNoZTogbmV3IE1hcCgpLFxyXG4gICAgICAgIHRlbXBzOiAwLFxyXG4gICAgICAgIGNhY2hlZDogMCxcclxuICAgICAgICBpZGVudGlmaWVyczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgICAgICBzY29wZXM6IHtcclxuICAgICAgICAgICAgdkZvcjogMCxcclxuICAgICAgICAgICAgdlNsb3Q6IDAsXHJcbiAgICAgICAgICAgIHZQcmU6IDAsXHJcbiAgICAgICAgICAgIHZPbmNlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgY3VycmVudE5vZGU6IHJvb3QsXHJcbiAgICAgICAgY2hpbGRJbmRleDogMCxcclxuICAgICAgICAvLyBtZXRob2RzXHJcbiAgICAgICAgaGVscGVyKG5hbWUpIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLmFkZChuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoZWxwZXJTdHJpbmcobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBbY29udGV4dC5oZWxwZXIobmFtZSldfWA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXBsYWNlTm9kZShub2RlKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgYmVpbmcgcmVwbGFjZWQgaXMgYWxyZWFkeSByZW1vdmVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugcm9vdCBub2RlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRJbmRleF0gPSBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZU5vZGUobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb250ZXh0LnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVtb3ZlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92YWxJbmRleCA9IG5vZGVcclxuICAgICAgICAgICAgICAgID8gbGlzdC5pbmRleE9mKG5vZGUpXHJcbiAgICAgICAgICAgICAgICA6IGNvbnRleHQuY3VycmVudE5vZGVcclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnRleHQuY2hpbGRJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIDogLTE7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHJlbW92YWxJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm9kZSBiZWluZyByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIGN1cnJlbnQgcGFyZW50YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IGNvbnRleHQuY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbm9kZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc2libGluZyBub2RlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmNoaWxkSW5kZXggPiByZW1vdmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LnBhcmVudC5jaGlsZHJlbi5zcGxpY2UocmVtb3ZhbEluZGV4LCAxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTm9kZVJlbW92ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgICBhZGRJZGVudGlmaWVycyhleHApIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUlkZW50aWZpZXJzKGV4cCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG9pc3QoZXhwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaG9pc3RzLnB1c2goZXhwKTtcclxuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9ob2lzdGVkXyR7Y29udGV4dC5ob2lzdHMubGVuZ3RofWAsIGZhbHNlLCBleHAubG9jLCAyIC8qIENBTl9IT0lTVCAqLyk7XHJcbiAgICAgICAgICAgIGlkZW50aWZpZXIuaG9pc3RlZCA9IGV4cDtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWNoZShleHAsIGlzVk5vZGUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKCsrY29udGV4dC5jYWNoZWQsIGV4cCwgaXNWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBjb250ZXh0O1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybShyb290LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCBvcHRpb25zKTtcclxuICAgIHRyYXZlcnNlTm9kZShyb290LCBjb250ZXh0KTtcclxuICAgIGlmIChvcHRpb25zLmhvaXN0U3RhdGljKSB7XHJcbiAgICAgICAgaG9pc3RTdGF0aWMocm9vdCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIW9wdGlvbnMuc3NyKSB7XHJcbiAgICAgICAgY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvLyBmaW5hbGl6ZSBtZXRhIGluZm9ybWF0aW9uXHJcbiAgICByb290LmhlbHBlcnMgPSBbLi4uY29udGV4dC5oZWxwZXJzXTtcclxuICAgIHJvb3QuY29tcG9uZW50cyA9IFsuLi5jb250ZXh0LmNvbXBvbmVudHNdO1xyXG4gICAgcm9vdC5kaXJlY3RpdmVzID0gWy4uLmNvbnRleHQuZGlyZWN0aXZlc107XHJcbiAgICByb290LmltcG9ydHMgPSBjb250ZXh0LmltcG9ydHM7XHJcbiAgICByb290LmhvaXN0cyA9IGNvbnRleHQuaG9pc3RzO1xyXG4gICAgcm9vdC50ZW1wcyA9IGNvbnRleHQudGVtcHM7XHJcbiAgICByb290LmNhY2hlZCA9IGNvbnRleHQuY2FjaGVkO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJvb3RDb2RlZ2VuKHJvb3QsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgaGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcm9vdDtcclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgIC8vIGlmIHRoZSBzaW5nbGUgY2hpbGQgaXMgYW4gZWxlbWVudCwgdHVybiBpdCBpbnRvIGEgYmxvY2suXHJcbiAgICAgICAgaWYgKGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpICYmIGNoaWxkLmNvZGVnZW5Ob2RlKSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSBlbGVtZW50IHJvb3QgaXMgbmV2ZXIgaG9pc3RlZCBzbyBjb2RlZ2VuTm9kZSB3aWxsIG5ldmVyIGJlXHJcbiAgICAgICAgICAgIC8vIFNpbXBsZUV4cHJlc3Npb25Ob2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gY2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5pc0Jsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgIGhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjb2RlZ2VuTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIC0gc2luZ2xlIDxzbG90Lz4sIElmTm9kZSwgRm9yTm9kZTogYWxyZWFkeSBibG9ja3MuXHJcbiAgICAgICAgICAgIC8vIC0gc2luZ2xlIHRleHQgbm9kZTogYWx3YXlzIHBhdGNoZWQuXHJcbiAgICAgICAgICAgIC8vIHJvb3QgY29kZWdlbiBmYWxscyB0aHJvdWdoIHZpYSBnZW5Ob2RlKClcclxuICAgICAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNoaWxkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAvLyByb290IGhhcyBtdWx0aXBsZSBub2RlcyAtIHJldHVybiBhIGZyYWdtZW50IGJsb2NrLlxyXG4gICAgICAgIGxldCBwYXRjaEZsYWcgPSA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi87XHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmcmFnbWVudCBhY3R1YWxseSBjb250YWlucyBhIHNpbmdsZSB2YWxpZCBjaGlsZCB3aXRoXHJcbiAgICAgICAgLy8gdGhlIHJlc3QgYmVpbmcgY29tbWVudHNcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi87XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZ1RleHQgKz0gYCwgJHtQYXRjaEZsYWdOYW1lc1syMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIHVuZGVmaW5lZCwgcm9vdC5jaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgO1xyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlQ2hpbGRyZW4ocGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICBjb25zdCBub2RlUmVtb3ZlZCA9ICgpID0+IHtcclxuICAgICAgICBpLS07XHJcbiAgICB9O1xyXG4gICAgZm9yICg7IGkgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcoY2hpbGQpKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjb250ZXh0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXggPSBpO1xyXG4gICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCA9IG5vZGVSZW1vdmVkO1xyXG4gICAgICAgIHRyYXZlcnNlTm9kZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgLy8gYXBwbHkgdHJhbnNmb3JtIHBsdWdpbnNcclxuICAgIGNvbnN0IHsgbm9kZVRyYW5zZm9ybXMgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBleGl0Rm5zID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb25FeGl0ID0gbm9kZVRyYW5zZm9ybXNbaV0obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKG9uRXhpdCkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvbkV4aXQpKSB7XHJcbiAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2goLi4ub25FeGl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaChvbkV4aXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAvLyBub2RlIHdhcyByZW1vdmVkXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZFxyXG4gICAgICAgICAgICBub2RlID0gY29udGV4dC5jdXJyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3QgaW1wb3J0IGZvciB0aGUgQ29tbWVudCBzeW1ib2wsIHdoaWNoIGlzIG5lZWRlZCBmb3IgY3JlYXRpbmdcclxuICAgICAgICAgICAgICAgIC8vIGNvbW1lbnQgbm9kZXMgd2l0aCBgY3JlYXRlVk5vZGVgXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdHJhdmVyc2UsIGJ1dCB3ZSBuZWVkIHRvIGluamVjdCB0b1N0cmluZyBoZWxwZXJcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnNzcikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIGZvciBjb250YWluZXIgdHlwZXMsIGZ1cnRoZXIgdHJhdmVyc2UgZG93bndhcmRzXHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShub2RlLmJyYW5jaGVzW2ldLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICBjYXNlIDAgLyogUk9PVCAqLzpcclxuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICAvLyBleGl0IHRyYW5zZm9ybXNcclxuICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgbGV0IGkgPSBleGl0Rm5zLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBleGl0Rm5zW2ldKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybShuYW1lLCBmbikge1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGlzU3RyaW5nKG5hbWUpXHJcbiAgICAgICAgPyAobikgPT4gbiA9PT0gbmFtZVxyXG4gICAgICAgIDogKG4pID0+IG5hbWUudGVzdChuKTtcclxuICAgIHJldHVybiAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBub2RlO1xyXG4gICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0cmFuc2Zvcm1zIGFyZSBub3QgY29uY2VybmVkIHdpdGggc2xvdHNcclxuICAgICAgICAgICAgLy8gYXMgdGhleSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGluIHZTbG90LnRzXHJcbiAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8gJiYgcHJvcHMuc29tZShpc1ZTbG90KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgbWF0Y2hlcyhwcm9wLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzIGFyZSByZW1vdmVkIHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gd2UgcmVtb3ZlIHRoZW0gKmJlZm9yZSogYXBwbHlpbmcgc28gdGhhdCBpdCBjYW4gZnVydGhlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYXZlcnNlIGl0c2VsZiBpbiBjYXNlIGl0IG1vdmVzIHRoZSBub2RlIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FeGl0ID0gZm4obm9kZSwgcHJvcCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV4aXRGbnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5jb25zdCBQVVJFX0FOTk9UQVRJT04gPSBgLyojX19QVVJFX18qL2A7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvZGVnZW5Db250ZXh0KGFzdCwgeyBtb2RlID0gJ2Z1bmN0aW9uJywgcHJlZml4SWRlbnRpZmllcnMgPSBtb2RlID09PSAnbW9kdWxlJywgc291cmNlTWFwID0gZmFsc2UsIGZpbGVuYW1lID0gYHRlbXBsYXRlLnZ1ZS5odG1sYCwgc2NvcGVJZCA9IG51bGwsIG9wdGltaXplSW1wb3J0cyA9IGZhbHNlLCBydW50aW1lR2xvYmFsTmFtZSA9IGBWdWVgLCBydW50aW1lTW9kdWxlTmFtZSA9IGB2dWVgLCBzc3IgPSBmYWxzZSB9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgIG1vZGUsXHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgc291cmNlTWFwLFxyXG4gICAgICAgIGZpbGVuYW1lLFxyXG4gICAgICAgIHNjb3BlSWQsXHJcbiAgICAgICAgb3B0aW1pemVJbXBvcnRzLFxyXG4gICAgICAgIHJ1bnRpbWVHbG9iYWxOYW1lLFxyXG4gICAgICAgIHJ1bnRpbWVNb2R1bGVOYW1lLFxyXG4gICAgICAgIHNzcixcclxuICAgICAgICBzb3VyY2U6IGFzdC5sb2Muc291cmNlLFxyXG4gICAgICAgIGNvZGU6IGBgLFxyXG4gICAgICAgIGNvbHVtbjogMSxcclxuICAgICAgICBsaW5lOiAxLFxyXG4gICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICBpbmRlbnRMZXZlbDogMCxcclxuICAgICAgICBwdXJlOiBmYWxzZSxcclxuICAgICAgICBtYXA6IHVuZGVmaW5lZCxcclxuICAgICAgICBoZWxwZXIoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtrZXldfWA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoKGNvZGUsIG5vZGUpIHtcclxuICAgICAgICAgICAgY29udGV4dC5jb2RlICs9IGNvZGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmRlbnQoKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKytjb250ZXh0LmluZGVudExldmVsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlaW5kZW50KHdpdGhvdXROZXdMaW5lID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKHdpdGhvdXROZXdMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAtLWNvbnRleHQuaW5kZW50TGV2ZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdsaW5lKC0tY29udGV4dC5pbmRlbnRMZXZlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG5ld2xpbmUoKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoY29udGV4dC5pbmRlbnRMZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIG5ld2xpbmUobikge1xyXG4gICAgICAgIGNvbnRleHQucHVzaCgnXFxuJyArIGAgIGAucmVwZWF0KG4pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZXh0O1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRlKGFzdCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCBvcHRpb25zKTtcclxuICAgIGlmIChvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQpXHJcbiAgICAgICAgb3B0aW9ucy5vbkNvbnRleHRDcmVhdGVkKGNvbnRleHQpO1xyXG4gICAgY29uc3QgeyBtb2RlLCBwdXNoLCBwcmVmaXhJZGVudGlmaWVycywgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSwgc2NvcGVJZCwgc3NyIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgaGFzSGVscGVycyA9IGFzdC5oZWxwZXJzLmxlbmd0aCA+IDA7XHJcbiAgICBjb25zdCB1c2VXaXRoQmxvY2sgPSAhcHJlZml4SWRlbnRpZmllcnMgJiYgbW9kZSAhPT0gJ21vZHVsZSc7XHJcbiAgICAvLyBwcmVhbWJsZXNcclxuICAgIC8vIGluIHNldHVwKCkgaW5saW5lIG1vZGUsIHRoZSBwcmVhbWJsZSBpcyBnZW5lcmF0ZWQgaW4gYSBzdWIgY29udGV4dFxyXG4gICAgLy8gYW5kIHJldHVybmVkIHNlcGFyYXRlbHkuXHJcbiAgICBjb25zdCBwcmVhbWJsZUNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAge1xyXG4gICAgICAgIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBwcmVhbWJsZUNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLy8gZW50ZXIgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBzc3IgPyBgc3NyUmVuZGVyYCA6IGByZW5kZXJgO1xyXG4gICAgY29uc3QgYXJncyA9IHNzciA/IFsnX2N0eCcsICdfcHVzaCcsICdfcGFyZW50JywgJ19hdHRycyddIDogWydfY3R4JywgJ19jYWNoZSddO1xyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXJncy5qb2luKCcsICcpO1xyXG4gICAge1xyXG4gICAgICAgIHB1c2goYGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgke3NpZ25hdHVyZX0pIHtgKTtcclxuICAgIH1cclxuICAgIGluZGVudCgpO1xyXG4gICAgaWYgKHVzZVdpdGhCbG9jaykge1xyXG4gICAgICAgIHB1c2goYHdpdGggKF9jdHgpIHtgKTtcclxuICAgICAgICBpbmRlbnQoKTtcclxuICAgICAgICAvLyBmdW5jdGlvbiBtb2RlIGNvbnN0IGRlY2xhcmF0aW9ucyBzaG91bGQgYmUgaW5zaWRlIHdpdGggYmxvY2tcclxuICAgICAgICAvLyBhbHNvIHRoZXkgc2hvdWxkIGJlIHJlbmFtZWQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggdXNlciBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKGhhc0hlbHBlcnMpIHtcclxuICAgICAgICAgICAgcHVzaChgY29uc3QgeyAke2FzdC5oZWxwZXJzXHJcbiAgICAgICAgICAgICAgICAubWFwKHMgPT4gYCR7aGVscGVyTmFtZU1hcFtzXX06IF8ke2hlbHBlck5hbWVNYXBbc119YClcclxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSB9ID0gX1Z1ZWApO1xyXG4gICAgICAgICAgICBwdXNoKGBcXG5gKTtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGdlbmVyYXRlIGFzc2V0IHJlc29sdXRpb24gc3RhdGVtZW50c1xyXG4gICAgaWYgKGFzdC5jb21wb25lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGdlbkFzc2V0cyhhc3QuY29tcG9uZW50cywgJ2NvbXBvbmVudCcsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGggfHwgYXN0LnRlbXBzID4gMCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCkge1xyXG4gICAgICAgIGdlbkFzc2V0cyhhc3QuZGlyZWN0aXZlcywgJ2RpcmVjdGl2ZScsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LnRlbXBzID4gMCkge1xyXG4gICAgICAgIHB1c2goYGxldCBgKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC50ZW1wczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHB1c2goYCR7aSA+IDAgPyBgLCBgIDogYGB9X3RlbXAke2l9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5jb21wb25lbnRzLmxlbmd0aCB8fCBhc3QuZGlyZWN0aXZlcy5sZW5ndGggfHwgYXN0LnRlbXBzKSB7XHJcbiAgICAgICAgcHVzaChgXFxuYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gZ2VuZXJhdGUgdGhlIFZOb2RlIHRyZWUgZXhwcmVzc2lvblxyXG4gICAgaWYgKCFzc3IpIHtcclxuICAgICAgICBwdXNoKGByZXR1cm4gYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmNvZGVnZW5Ob2RlKSB7XHJcbiAgICAgICAgZ2VuTm9kZShhc3QuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgbnVsbGApO1xyXG4gICAgfVxyXG4gICAgaWYgKHVzZVdpdGhCbG9jaykge1xyXG4gICAgICAgIGRlaW5kZW50KCk7XHJcbiAgICAgICAgcHVzaChgfWApO1xyXG4gICAgfVxyXG4gICAgZGVpbmRlbnQoKTtcclxuICAgIHB1c2goYH1gKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXN0LFxyXG4gICAgICAgIGNvZGU6IGNvbnRleHQuY29kZSxcclxuICAgICAgICBwcmVhbWJsZTogYGAsXHJcbiAgICAgICAgLy8gU291cmNlTWFwR2VuZXJhdG9yIGRvZXMgaGF2ZSB0b0pTT04oKSBtZXRob2QgYnV0IGl0J3Mgbm90IGluIHRoZSB0eXBlc1xyXG4gICAgICAgIG1hcDogY29udGV4dC5tYXAgPyBjb250ZXh0Lm1hcC50b0pTT04oKSA6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZW5GdW5jdGlvblByZWFtYmxlKGFzdCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBzc3IsIHByZWZpeElkZW50aWZpZXJzLCBwdXNoLCBuZXdsaW5lLCBydW50aW1lTW9kdWxlTmFtZSwgcnVudGltZUdsb2JhbE5hbWUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBWdWVCaW5kaW5nID0gcnVudGltZUdsb2JhbE5hbWU7XHJcbiAgICBjb25zdCBhbGlhc0hlbHBlciA9IChzKSA9PiBgJHtoZWxwZXJOYW1lTWFwW3NdfTogXyR7aGVscGVyTmFtZU1hcFtzXX1gO1xyXG4gICAgLy8gR2VuZXJhdGUgY29uc3QgZGVjbGFyYXRpb24gZm9yIGhlbHBlcnNcclxuICAgIC8vIEluIHByZWZpeCBtb2RlLCB3ZSBwbGFjZSB0aGUgY29uc3QgZGVjbGFyYXRpb24gYXQgdG9wIHNvIGl0J3MgZG9uZVxyXG4gICAgLy8gb25seSBvbmNlOyBCdXQgaWYgd2Ugbm90IHByZWZpeGluZywgd2UgcGxhY2UgdGhlIGRlY2xhcmF0aW9uIGluc2lkZSB0aGVcclxuICAgIC8vIHdpdGggYmxvY2sgc28gaXQgZG9lc24ndCBpbmN1ciB0aGUgYGluYCBjaGVjayBjb3N0IGZvciBldmVyeSBoZWxwZXIgYWNjZXNzLlxyXG4gICAgaWYgKGFzdC5oZWxwZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFwid2l0aFwiIG1vZGUuXHJcbiAgICAgICAgICAgIC8vIHNhdmUgVnVlIGluIGEgc2VwYXJhdGUgdmFyaWFibGUgdG8gYXZvaWQgY29sbGlzaW9uXHJcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IF9WdWUgPSAke1Z1ZUJpbmRpbmd9XFxuYCk7XHJcbiAgICAgICAgICAgIC8vIGluIFwid2l0aFwiIG1vZGUsIGhlbHBlcnMgYXJlIGRlY2xhcmVkIGluc2lkZSB0aGUgd2l0aCBibG9jayB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyBoYXMgY2hlY2sgY29zdCwgYnV0IGhvaXN0cyBhcmUgbGlmdGVkIG91dCBvZiB0aGUgZnVuY3Rpb24gLSB3ZSBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIHByb3ZpZGUgdGhlIGhlbHBlciBoZXJlLlxyXG4gICAgICAgICAgICBpZiAoYXN0LmhvaXN0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRpY0hlbHBlcnMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1ZOT0RFLFxyXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9DT01NRU5ULFxyXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9URVhULFxyXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9TVEFUSUNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGhlbHBlciA9PiBhc3QuaGVscGVycy5pbmNsdWRlcyhoZWxwZXIpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYWxpYXNIZWxwZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICBwdXNoKGBjb25zdCB7ICR7c3RhdGljSGVscGVyc30gfSA9IF9WdWVcXG5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdlbkhvaXN0cyhhc3QuaG9pc3RzLCBjb250ZXh0KTtcclxuICAgIG5ld2xpbmUoKTtcclxuICAgIHB1c2goYHJldHVybiBgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Bc3NldHMoYXNzZXRzLCB0eXBlLCB7IGhlbHBlciwgcHVzaCwgbmV3bGluZSB9KSB7XHJcbiAgICBjb25zdCByZXNvbHZlciA9IGhlbHBlcih0eXBlID09PSAnY29tcG9uZW50JyA/IFJFU09MVkVfQ09NUE9ORU5UIDogUkVTT0xWRV9ESVJFQ1RJVkUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpZCA9IGFzc2V0c1tpXTtcclxuICAgICAgICBwdXNoKGBjb25zdCAke3RvVmFsaWRBc3NldElkKGlkLCB0eXBlKX0gPSAke3Jlc29sdmVyfSgke0pTT04uc3RyaW5naWZ5KGlkKX0pYCk7XHJcbiAgICAgICAgaWYgKGkgPCBhc3NldHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkhvaXN0cyhob2lzdHMsIGNvbnRleHQpIHtcclxuICAgIGlmICghaG9pc3RzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnRleHQucHVyZSA9IHRydWU7XHJcbiAgICBjb25zdCB7IHB1c2gsIG5ld2xpbmUsIGhlbHBlciwgc2NvcGVJZCwgbW9kZSB9ID0gY29udGV4dDtcclxuICAgIG5ld2xpbmUoKTtcclxuICAgIGhvaXN0cy5mb3JFYWNoKChleHAsIGkpID0+IHtcclxuICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IF9ob2lzdGVkXyR7aSArIDF9ID0gYCk7XHJcbiAgICAgICAgICAgIGdlbk5vZGUoZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29udGV4dC5wdXJlID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNUZXh0JDEobikge1xyXG4gICAgcmV0dXJuIChpc1N0cmluZyhuKSB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gMiAvKiBURVhUICovIHx8XHJcbiAgICAgICAgbi50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHxcclxuICAgICAgICBuLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGVzLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBtdWx0aWxpbmVzID0gbm9kZXMubGVuZ3RoID4gMyB8fFxyXG4gICAgICAgICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSAmJiBub2Rlcy5zb21lKG4gPT4gaXNBcnJheShuKSB8fCAhaXNUZXh0JDEobikpKTtcclxuICAgIGNvbnRleHQucHVzaChgW2ApO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmluZGVudCgpO1xyXG4gICAgZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMpO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmRlaW5kZW50KCk7XHJcbiAgICBjb250ZXh0LnB1c2goYF1gKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlTGlzdChub2RlcywgY29udGV4dCwgbXVsdGlsaW5lcyA9IGZhbHNlLCBjb21tYSA9IHRydWUpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPCBub2Rlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tYSAmJiBwdXNoKCcsJyk7XHJcbiAgICAgICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21tYSAmJiBwdXNoKCcsICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbk5vZGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc1N5bWJvbChub2RlKSkge1xyXG4gICAgICAgIGNvbnRleHQucHVzaChjb250ZXh0LmhlbHBlcihub2RlKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KG5vZGUuY29kZWdlbk5vZGUgIT0gbnVsbCwgYENvZGVnZW4gbm9kZSBpcyBtaXNzaW5nIGZvciBlbGVtZW50L2lmL2ZvciBub2RlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgQXBwbHkgYXBwcm9wcmlhdGUgdHJhbnNmb3JtcyBmaXJzdC5gKTtcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgICAgIGdlblRleHQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDMgLyogQ09NTUVOVCAqLzpcclxuICAgICAgICAgICAgZ2VuQ29tbWVudChub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMyAvKiBWTk9ERV9DQUxMICovOlxyXG4gICAgICAgICAgICBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuT2JqZWN0RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTggLyogSlNfRlVOQ1RJT05fRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIFNTUiBvbmx5IHR5cGVzXHJcbiAgICAgICAgY2FzZSAyMSAvKiBKU19CTE9DS19TVEFURU1FTlQgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjIgLyogSlNfVEVNUExBVEVfTElURVJBTCAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyMyAvKiBKU19JRl9TVEFURU1FTlQgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjQgLyogSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI1IC8qIEpTX1NFUVVFTkNFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjYgLyogSlNfUkVUVVJOX1NUQVRFTUVOVCAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICAgICAgLy8gbm9vcFxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bmhhbmRsZWQgY29kZWdlbiBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGV4aGF1c3QgYWxsIHBvc3NpYmxlIHR5cGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aGF1c3RpdmVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlblRleHQobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29udGV4dC5wdXNoKEpTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCksIG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBjb250ZW50LCBpc1N0YXRpYyB9ID0gbm9kZTtcclxuICAgIGNvbnRleHQucHVzaChpc1N0YXRpYyA/IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpIDogY29udGVudCwgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuSW50ZXJwb2xhdGlvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcclxuICAgIGlmIChwdXJlKVxyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIHB1c2goYCR7aGVscGVyKFRPX0RJU1BMQVlfU1RSSU5HKX0oYCk7XHJcbiAgICBnZW5Ob2RlKG5vZGUuY29udGVudCwgY29udGV4dCk7XHJcbiAgICBwdXNoKGApYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnZW5Ob2RlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgcHVzaChgW2ApO1xyXG4gICAgICAgIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBwdXNoKGBdYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChub2RlLmlzU3RhdGljKSB7XHJcbiAgICAgICAgLy8gb25seSBxdW90ZSBrZXlzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGNvbnN0IHRleHQgPSBpc1NpbXBsZUlkZW50aWZpZXIobm9kZS5jb250ZW50KVxyXG4gICAgICAgICAgICA/IG5vZGUuY29udGVudFxyXG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCk7XHJcbiAgICAgICAgcHVzaCh0ZXh0LCBub2RlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1c2goYFske25vZGUuY29udGVudH1dYCwgbm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ29tbWVudChub2RlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgaWYgKHB1cmUpIHtcclxuICAgICAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdXNoKGAke2hlbHBlcihDUkVBVEVfQ09NTUVOVCl9KCR7SlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KX0pYCwgbm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuVk5vZGVDYWxsKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2ssIGRpc2FibGVUcmFja2luZyB9ID0gbm9kZTtcclxuICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcHVzaChoZWxwZXIoV0lUSF9ESVJFQ1RJVkVTKSArIGAoYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCbG9jaykge1xyXG4gICAgICAgIHB1c2goYCgke2hlbHBlcihPUEVOX0JMT0NLKX0oJHtkaXNhYmxlVHJhY2tpbmcgPyBgdHJ1ZWAgOiBgYH0pLCBgKTtcclxuICAgIH1cclxuICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgfVxyXG4gICAgcHVzaChoZWxwZXIoaXNCbG9jayA/IENSRUFURV9CTE9DSyA6IENSRUFURV9WTk9ERSkgKyBgKGAsIG5vZGUpO1xyXG4gICAgZ2VuTm9kZUxpc3QoZ2VuTnVsbGFibGVBcmdzKFt0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHNdKSwgY29udGV4dCk7XHJcbiAgICBwdXNoKGApYCk7XHJcbiAgICBpZiAoaXNCbG9jaykge1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcHVzaChgLCBgKTtcclxuICAgICAgICBnZW5Ob2RlKGRpcmVjdGl2ZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5OdWxsYWJsZUFyZ3MoYXJncykge1xyXG4gICAgbGV0IGkgPSBhcmdzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBpZiAoYXJnc1tpXSAhPSBudWxsKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzLnNsaWNlKDAsIGkgKyAxKS5tYXAoYXJnID0+IGFyZyB8fCBgbnVsbGApO1xyXG59XHJcbi8vIEphdmFTY3JpcHRcclxuZnVuY3Rpb24gZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBjYWxsZWUgPSBpc1N0cmluZyhub2RlLmNhbGxlZSkgPyBub2RlLmNhbGxlZSA6IGhlbHBlcihub2RlLmNhbGxlZSk7XHJcbiAgICBpZiAocHVyZSkge1xyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIH1cclxuICAgIHB1c2goY2FsbGVlICsgYChgLCBub2RlKTtcclxuICAgIGdlbk5vZGVMaXN0KG5vZGUuYXJndW1lbnRzLCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZTtcclxuICAgIGlmICghcHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICBwdXNoKGB7fWAsIG5vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG11bHRpbGluZXMgPSBwcm9wZXJ0aWVzLmxlbmd0aCA+IDEgfHxcclxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiZcclxuICAgICAgICAgICAgcHJvcGVydGllcy5zb21lKHAgPT4gcC52YWx1ZS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSk7XHJcbiAgICBwdXNoKG11bHRpbGluZXMgPyBge2AgOiBgeyBgKTtcclxuICAgIG11bHRpbGluZXMgJiYgaW5kZW50KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgLy8ga2V5XHJcbiAgICAgICAgZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkoa2V5LCBjb250ZXh0KTtcclxuICAgICAgICBwdXNoKGA6IGApO1xyXG4gICAgICAgIC8vIHZhbHVlXHJcbiAgICAgICAgZ2VuTm9kZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGkgPCBwcm9wZXJ0aWVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgLy8gd2lsbCBvbmx5IHJlYWNoIHRoaXMgaWYgaXQncyBtdWx0aWxpbmVzXHJcbiAgICAgICAgICAgIHB1c2goYCxgKTtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG11bHRpbGluZXMgJiYgZGVpbmRlbnQoKTtcclxuICAgIHB1c2gobXVsdGlsaW5lcyA/IGB9YCA6IGAgfWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkFycmF5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZS5lbGVtZW50cywgY29udGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgc2NvcGVJZCwgbW9kZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgcGFyYW1zLCByZXR1cm5zLCBib2R5LCBuZXdsaW5lLCBpc1Nsb3QgfSA9IG5vZGU7XHJcbiAgICBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgcHVzaChgXyR7aGVscGVyTmFtZU1hcFtXSVRIX0NUWF19KGApO1xyXG4gICAgfVxyXG4gICAgcHVzaChgKGAsIG5vZGUpO1xyXG4gICAgaWYgKGlzQXJyYXkocGFyYW1zKSkge1xyXG4gICAgICAgIGdlbk5vZGVMaXN0KHBhcmFtcywgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJhbXMpIHtcclxuICAgICAgICBnZW5Ob2RlKHBhcmFtcywgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGApID0+IGApO1xyXG4gICAgaWYgKG5ld2xpbmUgfHwgYm9keSkge1xyXG4gICAgICAgIHB1c2goYHtgKTtcclxuICAgICAgICBpbmRlbnQoKTtcclxuICAgIH1cclxuICAgIGlmIChyZXR1cm5zKSB7XHJcbiAgICAgICAgaWYgKG5ld2xpbmUpIHtcclxuICAgICAgICAgICAgcHVzaChgcmV0dXJuIGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheShyZXR1cm5zKSkge1xyXG4gICAgICAgICAgICBnZW5Ob2RlTGlzdEFzQXJyYXkocmV0dXJucywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnZW5Ob2RlKHJldHVybnMsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGJvZHkpIHtcclxuICAgICAgICBnZW5Ob2RlKGJvZHksIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5ld2xpbmUgfHwgYm9keSkge1xyXG4gICAgICAgIGRlaW5kZW50KCk7XHJcbiAgICAgICAgcHVzaChgfWApO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU2xvdCkge1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Db25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmU6IG5lZWROZXdsaW5lIH0gPSBub2RlO1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKHRlc3QudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGNvbnN0IG5lZWRzUGFyZW5zID0gIWlzU2ltcGxlSWRlbnRpZmllcih0ZXN0LmNvbnRlbnQpO1xyXG4gICAgICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYChgKTtcclxuICAgICAgICBnZW5FeHByZXNzaW9uKHRlc3QsIGNvbnRleHQpO1xyXG4gICAgICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1c2goYChgKTtcclxuICAgICAgICBnZW5Ob2RlKHRlc3QsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIG5lZWROZXdsaW5lICYmIGluZGVudCgpO1xyXG4gICAgY29udGV4dC5pbmRlbnRMZXZlbCsrO1xyXG4gICAgbmVlZE5ld2xpbmUgfHwgcHVzaChgIGApO1xyXG4gICAgcHVzaChgPyBgKTtcclxuICAgIGdlbk5vZGUoY29uc2VxdWVudCwgY29udGV4dCk7XHJcbiAgICBjb250ZXh0LmluZGVudExldmVsLS07XHJcbiAgICBuZWVkTmV3bGluZSAmJiBuZXdsaW5lKCk7XHJcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XHJcbiAgICBwdXNoKGA6IGApO1xyXG4gICAgY29uc3QgaXNOZXN0ZWQgPSBhbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLztcclxuICAgIGlmICghaXNOZXN0ZWQpIHtcclxuICAgICAgICBjb250ZXh0LmluZGVudExldmVsKys7XHJcbiAgICB9XHJcbiAgICBnZW5Ob2RlKGFsdGVybmF0ZSwgY29udGV4dCk7XHJcbiAgICBpZiAoIWlzTmVzdGVkKSB7XHJcbiAgICAgICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xyXG4gICAgfVxyXG4gICAgbmVlZE5ld2xpbmUgJiYgZGVpbmRlbnQodHJ1ZSAvKiB3aXRob3V0IG5ld2xpbmUgKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNhY2hlRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSB8fCAoYCk7XHJcbiAgICBpZiAobm9kZS5pc1ZOb2RlKSB7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oLTEpLGApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSA9IGApO1xyXG4gICAgZ2VuTm9kZShub2RlLnZhbHVlLCBjb250ZXh0KTtcclxuICAgIGlmIChub2RlLmlzVk5vZGUpIHtcclxuICAgICAgICBwdXNoKGAsYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIHB1c2goYCR7aGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyl9KDEpLGApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICBwdXNoKGBfY2FjaGVbJHtub2RlLmluZGV4fV1gKTtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgKWApO1xyXG59XG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXHJcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcclxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArXHJcbiAgICAoJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXHJcbiAgICAgICAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcclxuICAgICAgICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cyx0eXBlb2Ysdm9pZCcpXHJcbiAgICAgICAgLnNwbGl0KCcsJylcclxuICAgICAgICAuam9pbignXFxcXGJ8XFxcXGInKSArXHJcbiAgICAnXFxcXGInKTtcclxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xyXG5jb25zdCBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBhIG5vbi1wcmVmaXhlZCBleHByZXNzaW9uLlxyXG4gKiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdXNpbmcgdGhlIGluLWJyb3dzZXIgcnVudGltZSBjb21waWxlciBzaW5jZSBpdFxyXG4gKiBkb2Vzbid0IHByZWZpeCBleHByZXNzaW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMgPSBmYWxzZSwgYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcclxuICAgIC8vIGVtcHR5IGV4cHJlc3Npb25zIGFyZSB2YWxpZGF0ZWQgcGVyLWRpcmVjdGl2ZSBzaW5jZSBzb21lIGRpcmVjdGl2ZXNcclxuICAgIC8vIGRvIGFsbG93IGVtcHR5IGV4cHJlc3Npb25zLlxyXG4gICAgaWYgKCFleHAudHJpbSgpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBuZXcgRnVuY3Rpb24oYXNSYXdTdGF0ZW1lbnRzXHJcbiAgICAgICAgICAgID8gYCAke2V4cH0gYFxyXG4gICAgICAgICAgICA6IGByZXR1cm4gJHthc1BhcmFtcyA/IGAoJHtleHB9KSA9PiB7fWAgOiBgKCR7ZXhwfSlgfWApO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsZXQgbWVzc2FnZSA9IGUubWVzc2FnZTtcclxuICAgICAgICBjb25zdCBrZXl3b3JkTWF0Y2ggPSBleHBcclxuICAgICAgICAgICAgLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpXHJcbiAgICAgICAgICAgIC5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcclxuICAgICAgICBpZiAoa2V5d29yZE1hdGNoKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiJHtrZXl3b3JkTWF0Y2hbMF19XCJgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MyAvKiBYX0lOVkFMSURfRVhQUkVTU0lPTiAqLywgbm9kZS5sb2MsIHVuZGVmaW5lZCwgbWVzc2FnZSkpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHRyYW5zZm9ybUV4cHJlc3Npb24gPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovKSB7XHJcbiAgICAgICAgbm9kZS5jb250ZW50ID0gcHJvY2Vzc0V4cHJlc3Npb24obm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgLy8gaGFuZGxlIGRpcmVjdGl2ZXMgb24gZWxlbWVudFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXIgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgICAgICAvLyBkbyBub3QgcHJvY2VzcyBmb3Igdi1vbiAmIHYtZm9yIHNpbmNlIHRoZXkgYXJlIHNwZWNpYWwgaGFuZGxlZFxyXG4gICAgICAgICAgICBpZiAoZGlyLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIGRpci5uYW1lICE9PSAnZm9yJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwID0gZGlyLmV4cDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgcHJvY2VzcyBleHAgaWYgdGhpcyBpcyB2LW9uOmFyZyAtIHdlIG5lZWQgc3BlY2lhbCBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHdyYXBwaW5nIGlubGluZSBzdGF0ZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGV4cCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShkaXIubmFtZSA9PT0gJ29uJyAmJiBhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLmV4cCA9IHByb2Nlc3NFeHByZXNzaW9uKGV4cCwgY29udGV4dCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2xvdCBhcmdzIG11c3QgYmUgcHJvY2Vzc2VkIGFzIGZ1bmN0aW9uIHBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgIGRpci5uYW1lID09PSAnc2xvdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiAhYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLmFyZyA9IHByb2Nlc3NFeHByZXNzaW9uKGFyZywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8vIEltcG9ydGFudDogc2luY2UgdGhpcyBmdW5jdGlvbiB1c2VzIE5vZGUuanMgb25seSBkZXBlbmRlbmNpZXMsIGl0IHNob3VsZFxyXG4vLyBhbHdheXMgYmUgdXNlZCB3aXRoIGEgbGVhZGluZyAhdHJ1ZSBjaGVjayBzbyB0aGF0IGl0IGNhbiBiZVxyXG4vLyB0cmVlLXNoYWtlbiBmcm9tIHRoZSBicm93c2VyIGJ1aWxkLlxyXG5mdW5jdGlvbiBwcm9jZXNzRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBcclxuLy8gc29tZSBleHByZXNzaW9ucyBsaWtlIHYtc2xvdCBwcm9wcyAmIHYtZm9yIGFsaWFzZXMgc2hvdWxkIGJlIHBhcnNlZCBhc1xyXG4vLyBmdW5jdGlvbiBwYXJhbXNcclxuYXNQYXJhbXMgPSBmYWxzZSwgXHJcbi8vIHYtb24gaGFuZGxlciB2YWx1ZXMgbWF5IGNvbnRhaW4gbXVsdGlwbGUgc3RhdGVtZW50c1xyXG5hc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSkge1xyXG4gICAge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgLy8gc2ltcGxlIGluLWJyb3dzZXIgdmFsaWRhdGlvbiAoc2FtZSBsb2dpYyBpbiAyLngpXHJcbiAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMsIGFzUmF3U3RhdGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHRyYW5zZm9ybUlmID0gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSgvXihpZnxlbHNlfGVsc2UtaWYpJC8sIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcclxuICAgIHJldHVybiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCAoaWZOb2RlLCBicmFuY2gsIGlzUm9vdCkgPT4ge1xyXG4gICAgICAgIC8vICMxNTg3OiBXZSBuZWVkIHRvIGR5bmFtaWNhbGx5IGluY3JlbWVudCB0aGUga2V5IGJhc2VkIG9uIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gbm9kZSdzIHNpYmxpbmcgbm9kZXMsIHNpbmNlIGNoYWluZWQgdi1pZi9lbHNlIGJyYW5jaGVzIGFyZVxyXG4gICAgICAgIC8vIHJlbmRlcmVkIGF0IHRoZSBzYW1lIGRlcHRoXHJcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2YoaWZOb2RlKTtcclxuICAgICAgICBsZXQga2V5ID0gMDtcclxuICAgICAgICB3aGlsZSAoaS0tID49IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgICAgIGtleSArPSBzaWJsaW5nLmJyYW5jaGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFeGl0IGNhbGxiYWNrLiBDb21wbGV0ZSB0aGUgY29kZWdlbk5vZGUgd2hlbiBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtZWQuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgaWZOb2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIHRoaXMgYnJhbmNoJ3MgY29kZWdlbiBub2RlIHRvIHRoZSB2LWlmIHJvb3QuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDb25kaXRpb24gPSBnZXRQYXJlbnRDb25kaXRpb24oaWZOb2RlLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbmRpdGlvbi5hbHRlcm5hdGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSArIGlmTm9kZS5icmFuY2hlcy5sZW5ndGggLSAxLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufSk7XHJcbi8vIHRhcmdldC1hZ25vc3RpYyB0cmFuc2Zvcm0gdXNlZCBmb3IgYm90aCBDbGllbnQgYW5kIFNTUlxyXG5mdW5jdGlvbiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgaWYgKGRpci5uYW1lICE9PSAnZWxzZScgJiZcclxuICAgICAgICAoIWRpci5leHAgfHwgIWRpci5leHAuY29udGVudC50cmltKCkpKSB7XHJcbiAgICAgICAgY29uc3QgbG9jID0gZGlyLmV4cCA/IGRpci5leHAubG9jIDogbm9kZS5sb2M7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjcgLyogWF9WX0lGX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICBkaXIuZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlICYmIGRpci5leHApIHtcclxuICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGRpci5leHAsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpci5uYW1lID09PSAnaWYnKSB7XHJcbiAgICAgICAgY29uc3QgYnJhbmNoID0gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKTtcclxuICAgICAgICBjb25zdCBpZk5vZGUgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IDkgLyogSUYgKi8sXHJcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXHJcbiAgICAgICAgICAgIGJyYW5jaGVzOiBbYnJhbmNoXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29udGV4dC5yZXBsYWNlTm9kZShpZk5vZGUpO1xyXG4gICAgICAgIGlmIChwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0NvZGVnZW4oaWZOb2RlLCBicmFuY2gsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgYWRqYWNlbnQgdi1pZlxyXG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgY29tbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSk7XHJcbiAgICAgICAgd2hpbGUgKGktLSA+PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29tbWVudHMudW5zaGlmdChzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmXHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnR5cGUgPT09IDIgLyogVEVYVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgIXNpYmxpbmcuY29udGVudC50cmltKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIG5vZGUgdG8gdGhlIGlmIG5vZGUncyBicmFuY2hlc1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb21tZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmFuY2guY2hpbGRyZW4gPSBbLi4uY29tbWVudHMsIC4uLmJyYW5jaC5jaGlsZHJlbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB1c2VyIGlzIGZvcmNpbmcgc2FtZSBrZXkgb24gZGlmZmVyZW50IGJyYW5jaGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYnJhbmNoLnVzZXJLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLmZvckVhY2goKHsgdXNlcktleSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lS2V5KHVzZXJLZXksIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOCAvKiBYX1ZfSUZfU0FNRV9LRVkgKi8sIGJyYW5jaC51c2VyS2V5LmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLnB1c2goYnJhbmNoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKHNpYmxpbmcsIGJyYW5jaCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGJyYW5jaCB3YXMgcmVtb3ZlZCwgaXQgd2lsbCBub3QgYmUgdHJhdmVyc2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHRyYXZlcnNlIGhlcmUuXHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZU5vZGUoYnJhbmNoLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIC8vIGNhbGwgb24gZXhpdFxyXG4gICAgICAgICAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgICAgICAgICBvbkV4aXQoKTtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCBjdXJyZW50Tm9kZSBhZnRlciB0cmF2ZXJzYWwgdG8gaW5kaWNhdGUgdGhpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBoYXMgYmVlbiByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOSAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqLywgbm9kZS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDEwIC8qIElGX0JSQU5DSCAqLyxcclxuICAgICAgICBsb2M6IG5vZGUubG9jLFxyXG4gICAgICAgIGNvbmRpdGlvbjogZGlyLm5hbWUgPT09ICdlbHNlJyA/IHVuZGVmaW5lZCA6IGRpci5leHAsXHJcbiAgICAgICAgY2hpbGRyZW46IG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyAmJiAhZmluZERpcihub2RlLCAnZm9yJylcclxuICAgICAgICAgICAgPyBub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgIDogW25vZGVdLFxyXG4gICAgICAgIHVzZXJLZXk6IGZpbmRQcm9wKG5vZGUsIGBrZXlgKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgICBpZiAoYnJhbmNoLmNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oYnJhbmNoLmNvbmRpdGlvbiwgY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSwgXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHBhc3MgaW4gYXNCbG9jazogdHJ1ZSBzbyB0aGF0IHRoZSBjb21tZW50IG5vZGUgY2FsbFxyXG4gICAgICAgIC8vIGNsb3NlcyB0aGUgY3VycmVudCBibG9jay5cclxuICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCksIFtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1widi1pZlwiJyA6ICdcIlwiJyxcclxuICAgICAgICAgICAgJ3RydWUnXHJcbiAgICAgICAgXSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGtleVByb3BlcnR5ID0gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5SW5kZXh9YCwgZmFsc2UsIGxvY1N0dWIsIDIgLyogQ0FOX0hPSVNUICovKSk7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBicmFuY2g7XHJcbiAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICBjb25zdCBuZWVkRnJhZ21lbnRXcmFwcGVyID0gY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGZpcnN0Q2hpbGQudHlwZSAhPT0gMSAvKiBFTEVNRU5UICovO1xyXG4gICAgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGF3YXkgbmVzdGVkIGZyYWdtZW50cyB3aGVuIGNoaWxkIGlzIGEgRm9yTm9kZVxyXG4gICAgICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pLCBjaGlsZHJlbiwgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICtcclxuICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dfSAqL2BcclxuICAgICAgICAgICAgICAgICAgICA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUsIGZhbHNlLCBicmFuY2gubG9jKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBmaXJzdENoaWxkXHJcbiAgICAgICAgICAgIC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAvLyBDaGFuZ2UgY3JlYXRlVk5vZGUgdG8gY3JlYXRlQmxvY2suXHJcbiAgICAgICAgaWYgKHZub2RlQ2FsbC50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgIHZub2RlQ2FsbC5pc0Jsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICBoZWxwZXIoQ1JFQVRFX0JMT0NLKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IGJyYW5jaCBrZXlcclxuICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB2bm9kZUNhbGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lS2V5KGEsIGIpIHtcclxuICAgIGlmICghYSB8fCBhLnR5cGUgIT09IGIudHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChhLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgaWYgKGEudmFsdWUuY29udGVudCAhPT0gYi52YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkaXJlY3RpdmVcclxuICAgICAgICBjb25zdCBleHAgPSBhLmV4cDtcclxuICAgICAgICBjb25zdCBicmFuY2hFeHAgPSBiLmV4cDtcclxuICAgICAgICBpZiAoZXhwLnR5cGUgIT09IGJyYW5jaEV4cC50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgIChleHAuaXNTdGF0aWMgIT09IGJyYW5jaEV4cC5pc1N0YXRpYyB8fFxyXG4gICAgICAgICAgICAgICAgZXhwLmNvbnRlbnQgIT09IGJyYW5jaEV4cC5jb250ZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFyZW50Q29uZGl0aW9uKG5vZGUpIHtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuYWx0ZXJuYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCB0cmFuc2Zvcm1Gb3IgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKCdmb3InLCAobm9kZSwgZGlyLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIHJldHVybiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgZm9yTm9kZSA9PiB7XHJcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBsb29wIHJlbmRlciBmdW5jdGlvbiBleHByZXNzaW9uIG5vdywgYW5kIGFkZCB0aGVcclxuICAgICAgICAvLyBpdGVyYXRvciBvbiBleGl0IGFmdGVyIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdHJhdmVyc2VkXHJcbiAgICAgICAgY29uc3QgcmVuZGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xyXG4gICAgICAgICAgICBmb3JOb2RlLnNvdXJjZVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnN0IGtleVByb3AgPSBmaW5kUHJvcChub2RlLCBga2V5YCk7XHJcbiAgICAgICAgY29uc3Qga2V5UHJvcGVydHkgPSBrZXlQcm9wXHJcbiAgICAgICAgICAgID8gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGtleVByb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi9cclxuICAgICAgICAgICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXlQcm9wLnZhbHVlLmNvbnRlbnQsIHRydWUpXHJcbiAgICAgICAgICAgICAgICA6IGtleVByb3AuZXhwKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgaXNTdGFibGVGcmFnbWVudCA9IGZvck5vZGUuc291cmNlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgZm9yTm9kZS5zb3VyY2UuY29uc3RUeXBlID4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRGbGFnID0gaXNTdGFibGVGcmFnbWVudFxyXG4gICAgICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgICAgICA6IGtleVByb3BcclxuICAgICAgICAgICAgICAgID8gMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovXHJcbiAgICAgICAgICAgICAgICA6IDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovO1xyXG4gICAgICAgIGZvck5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByZW5kZXJFeHAsIGZyYWdtZW50RmxhZyArXHJcbiAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbZnJhZ21lbnRGbGFnXX0gKi9gIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSAvKiBpc0Jsb2NrICovLCAhaXNTdGFibGVGcmFnbWVudCAvKiBkaXNhYmxlVHJhY2tpbmcgKi8sIG5vZGUubG9jKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBmaW5pc2ggdGhlIGNvZGVnZW4gbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiB0cmF2ZXJzZWRcclxuICAgICAgICAgICAgbGV0IGNoaWxkQmxvY2s7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVGVtcGxhdGUgPSBpc1RlbXBsYXRlTm9kZShub2RlKTtcclxuICAgICAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gZm9yTm9kZTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgPHRlbXBsYXRlIHYtZm9yPiBrZXkgcGxhY2VtZW50XHJcbiAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSAmJiBpc1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGZpbmRQcm9wKGMsICdrZXknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzIgLyogWF9WX0ZPUl9URU1QTEFURV9LRVlfUExBQ0VNRU5UICovLCBrZXkubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgY2hpbGRyZW5bMF0udHlwZSAhPT0gMSAvKiBFTEVNRU5UICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90T3V0bGV0ID0gaXNTbG90T3V0bGV0KG5vZGUpXHJcbiAgICAgICAgICAgICAgICA/IG5vZGVcclxuICAgICAgICAgICAgICAgIDogaXNUZW1wbGF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTbG90T3V0bGV0KG5vZGUuY2hpbGRyZW5bMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlLmNoaWxkcmVuWzBdIC8vIGFwaS1leHRyYWN0b3Igc29tZWhvdyBmYWlscyB0byBpbmZlciB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoc2xvdE91dGxldCkge1xyXG4gICAgICAgICAgICAgICAgLy8gPHNsb3Qgdi1mb3I9XCIuLi5cIj4gb3IgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+PHNsb3QvPjwvdGVtcGxhdGU+XHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gc2xvdE91dGxldC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlICYmIGtleVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgOmtleT1cIi4uLlwiPjxzbG90Lz48L3RlbXBsYXRlPlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaW5qZWN0IHRoZSBrZXkgdG8gdGhlIHJlbmRlclNsb3QoKSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9wcyBmb3IgcmVuZGVyU2xvdCBpcyBwYXNzZWQgYXMgdGhlIDNyZCBhcmd1bWVudC5cclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RQcm9wKGNoaWxkQmxvY2ssIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIj4gd2l0aCB0ZXh0IG9yIG11bHRpLWVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgZ2VuZXJhdGUgYSBmcmFnbWVudCBibG9jayBmb3IgZWFjaCBsb29wXHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIGtleVByb3BlcnR5ID8gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihba2V5UHJvcGVydHldKSA6IHVuZGVmaW5lZCwgbm9kZS5jaGlsZHJlbiwgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICtcclxuICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL119ICovYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIGVsZW1lbnQgdi1mb3IuIERpcmVjdGx5IHVzZSB0aGUgY2hpbGQncyBjb2RlZ2VuTm9kZVxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IG1hcmsgaXQgYXMgYSBibG9jay5cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBjaGlsZHJlblswXVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlICYmIGtleVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrLmlzQmxvY2sgPSAhaXNTdGFibGVGcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKENSRUFURV9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoQ1JFQVRFX1ZOT0RFKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2goY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCksIGNoaWxkQmxvY2ssIHRydWUgLyogZm9yY2UgbmV3bGluZSAqLykpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufSk7XHJcbi8vIHRhcmdldC1hZ25vc3RpYyB0cmFuc2Zvcm0gdXNlZCBmb3IgYm90aCBDbGllbnQgYW5kIFNTUlxyXG5mdW5jdGlvbiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgcHJvY2Vzc0NvZGVnZW4pIHtcclxuICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIFhfVl9GT1JfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gcGFyc2VGb3JFeHByZXNzaW9uKFxyXG4gICAgLy8gY2FuIG9ubHkgYmUgc2ltcGxlIGV4cHJlc3Npb24gYmVjYXVzZSB2Rm9yIHRyYW5zZm9ybSBpcyBhcHBsaWVkXHJcbiAgICAvLyBiZWZvcmUgZXhwcmVzc2lvbiB0cmFuc2Zvcm0uXHJcbiAgICBkaXIuZXhwLCBjb250ZXh0KTtcclxuICAgIGlmICghcGFyc2VSZXN1bHQpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMSAvKiBYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBhZGRJZGVudGlmaWVycywgcmVtb3ZlSWRlbnRpZmllcnMsIHNjb3BlcyB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgc291cmNlLCB2YWx1ZSwga2V5LCBpbmRleCB9ID0gcGFyc2VSZXN1bHQ7XHJcbiAgICBjb25zdCBmb3JOb2RlID0ge1xyXG4gICAgICAgIHR5cGU6IDExIC8qIEZPUiAqLyxcclxuICAgICAgICBsb2M6IGRpci5sb2MsXHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHZhbHVlQWxpYXM6IHZhbHVlLFxyXG4gICAgICAgIGtleUFsaWFzOiBrZXksXHJcbiAgICAgICAgb2JqZWN0SW5kZXhBbGlhczogaW5kZXgsXHJcbiAgICAgICAgcGFyc2VSZXN1bHQsXHJcbiAgICAgICAgY2hpbGRyZW46IGlzVGVtcGxhdGVOb2RlKG5vZGUpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXVxyXG4gICAgfTtcclxuICAgIGNvbnRleHQucmVwbGFjZU5vZGUoZm9yTm9kZSk7XHJcbiAgICAvLyBib29ra2VlcGluZ1xyXG4gICAgc2NvcGVzLnZGb3IrKztcclxuICAgIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKGZvck5vZGUpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBzY29wZXMudkZvci0tO1xyXG4gICAgICAgIGlmIChvbkV4aXQpXHJcbiAgICAgICAgICAgIG9uRXhpdCgpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xyXG4vLyBUaGlzIHJlZ2V4IGRvZXNuJ3QgY292ZXIgdGhlIGNhc2UgaWYga2V5IG9yIGluZGV4IGFsaWFzZXMgaGF2ZSBkZXN0cnVjdHVyaW5nLFxyXG4vLyBidXQgdGhvc2UgZG8gbm90IG1ha2Ugc2Vuc2UgaW4gdGhlIGZpcnN0IHBsYWNlLCBzbyB0aGlzIHdvcmtzIGluIHByYWN0aWNlLlxyXG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xyXG5jb25zdCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xyXG5mdW5jdGlvbiBwYXJzZUZvckV4cHJlc3Npb24oaW5wdXQsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGxvYyA9IGlucHV0LmxvYztcclxuICAgIGNvbnN0IGV4cCA9IGlucHV0LmNvbnRlbnQ7XHJcbiAgICBjb25zdCBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xyXG4gICAgaWYgKCFpbk1hdGNoKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IFssIExIUywgUkhTXSA9IGluTWF0Y2g7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgc291cmNlOiBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBSSFMudHJpbSgpLCBleHAuaW5kZXhPZihSSFMsIExIUy5sZW5ndGgpKSxcclxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGtleTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGluZGV4OiB1bmRlZmluZWRcclxuICAgIH07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5zb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgbGV0IHZhbHVlQ29udGVudCA9IExIUy50cmltKClcclxuICAgICAgICAucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJylcclxuICAgICAgICAudHJpbSgpO1xyXG4gICAgY29uc3QgdHJpbW1lZE9mZnNldCA9IExIUy5pbmRleE9mKHZhbHVlQ29udGVudCk7XHJcbiAgICBjb25zdCBpdGVyYXRvck1hdGNoID0gdmFsdWVDb250ZW50Lm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xyXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcclxuICAgICAgICB2YWx1ZUNvbnRlbnQgPSB2YWx1ZUNvbnRlbnQucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xyXG4gICAgICAgIGNvbnN0IGtleUNvbnRlbnQgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcclxuICAgICAgICBsZXQga2V5T2Zmc2V0O1xyXG4gICAgICAgIGlmIChrZXlDb250ZW50KSB7XHJcbiAgICAgICAgICAgIGtleU9mZnNldCA9IGV4cC5pbmRleE9mKGtleUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQgKyB2YWx1ZUNvbnRlbnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmVzdWx0LmtleSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIGtleUNvbnRlbnQsIGtleU9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQua2V5LCBjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleENvbnRlbnQgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgaW5kZXhDb250ZW50LCBleHAuaW5kZXhPZihpbmRleENvbnRlbnQsIHJlc3VsdC5rZXlcclxuICAgICAgICAgICAgICAgICAgICA/IGtleU9mZnNldCArIGtleUNvbnRlbnQubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0cmltbWVkT2Zmc2V0ICsgdmFsdWVDb250ZW50Lmxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuaW5kZXgsIGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlQ29udGVudCkge1xyXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIHZhbHVlQ29udGVudCwgdHJpbW1lZE9mZnNldCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LnZhbHVlLCBjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihyYW5nZSwgY29udGVudCwgb2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihjb250ZW50LCBmYWxzZSwgZ2V0SW5uZXJSYW5nZShyYW5nZSwgb2Zmc2V0LCBjb250ZW50Lmxlbmd0aCkpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvckxvb3BQYXJhbXMoeyB2YWx1ZSwga2V5LCBpbmRleCB9KSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcclxuICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIHBhcmFtcy5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJhbXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKCFrZXkpIHtcclxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2AsIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX19gLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJhbXMucHVzaChpbmRleCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XG5cbmNvbnN0IGRlZmF1bHRGYWxsYmFjayA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHVuZGVmaW5lZGAsIGZhbHNlKTtcclxuLy8gQSBOb2RlVHJhbnNmb3JtIHRoYXQ6XHJcbi8vIDEuIFRyYWNrcyBzY29wZSBpZGVudGlmaWVycyBmb3Igc2NvcGVkIHNsb3RzIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgcHJlZml4ZWRcclxuLy8gICAgYnkgdHJhbnNmb3JtRXhwcmVzc2lvbi4gVGhpcyBpcyBvbmx5IGFwcGxpZWQgaW4gbm9uLWJyb3dzZXIgYnVpbGRzIHdpdGhcclxuLy8gICAgeyBwcmVmaXhJZGVudGlmaWVyczogdHJ1ZSB9LlxyXG4vLyAyLiBUcmFjayB2LXNsb3QgZGVwdGhzIHNvIHRoYXQgd2Uga25vdyBhIHNsb3QgaXMgaW5zaWRlIGFub3RoZXIgc2xvdC5cclxuLy8gICAgTm90ZSB0aGUgZXhpdCBjYWxsYmFjayBpcyBleGVjdXRlZCBiZWZvcmUgYnVpbGRTbG90cygpIG9uIHRoZSBzYW1lIG5vZGUsXHJcbi8vICAgIHNvIG9ubHkgbmVzdGVkIHNsb3RzIHNlZSBwb3NpdGl2ZSBudW1iZXJzLlxyXG5jb25zdCB0cmFja1Nsb3RTY29wZXMgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8gfHxcclxuICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovKSkge1xyXG4gICAgICAgIC8vIFdlIGFyZSBvbmx5IGNoZWNraW5nIG5vbi1lbXB0eSB2LXNsb3QgaGVyZVxyXG4gICAgICAgIC8vIHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCBzbG90cyB0aGF0IGludHJvZHVjZSBzY29wZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgY29uc3QgdlNsb3QgPSBmaW5kRGlyKG5vZGUsICdzbG90Jyk7XHJcbiAgICAgICAgaWYgKHZTbG90KSB7XHJcbiAgICAgICAgICAgIHZTbG90LmV4cDtcclxuICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QrKztcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90LS07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdCB0cmFja3Mgc2NvcGUgaWRlbnRpZmllcnMgZm9yIHNjb3BlZCBzbG90cyB3aXRoIHYtZm9yLlxyXG4vLyBUaGlzIHRyYW5zZm9ybSBpcyBvbmx5IGFwcGxpZWQgaW4gbm9uLWJyb3dzZXIgYnVpbGRzIHdpdGggeyBwcmVmaXhJZGVudGlmaWVyczogdHJ1ZSB9XHJcbmNvbnN0IHRyYWNrVkZvclNsb3RTY29wZXMgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgbGV0IHZGb3I7XHJcbiAgICBpZiAoaXNUZW1wbGF0ZU5vZGUobm9kZSkgJiZcclxuICAgICAgICBub2RlLnByb3BzLnNvbWUoaXNWU2xvdCkgJiZcclxuICAgICAgICAodkZvciA9IGZpbmREaXIobm9kZSwgJ2ZvcicpKSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICh2Rm9yLnBhcnNlUmVzdWx0ID0gcGFyc2VGb3JFeHByZXNzaW9uKHZGb3IuZXhwLCBjb250ZXh0KSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBrZXksIGluZGV4IH0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB2YWx1ZSAmJiBhZGRJZGVudGlmaWVycyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGtleSAmJiBhZGRJZGVudGlmaWVycyhrZXkpO1xyXG4gICAgICAgICAgICBpbmRleCAmJiBhZGRJZGVudGlmaWVycyhpbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJiByZW1vdmVJZGVudGlmaWVycyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBrZXkgJiYgcmVtb3ZlSWRlbnRpZmllcnMoa2V5KTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICYmIHJlbW92ZUlkZW50aWZpZXJzKGluZGV4KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGJ1aWxkQ2xpZW50U2xvdEZuID0gKHByb3BzLCBjaGlsZHJlbiwgbG9jKSA9PiBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24ocHJvcHMsIGNoaWxkcmVuLCBmYWxzZSAvKiBuZXdsaW5lICovLCB0cnVlIC8qIGlzU2xvdCAqLywgY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW5bMF0ubG9jIDogbG9jKTtcclxuLy8gSW5zdGVhZCBvZiBiZWluZyBhIERpcmVjdGl2ZVRyYW5zZm9ybSwgdi1zbG90IHByb2Nlc3NpbmcgaXMgY2FsbGVkIGR1cmluZ1xyXG4vLyB0cmFuc2Zvcm1FbGVtZW50IHRvIGJ1aWxkIHRoZSBzbG90cyBvYmplY3QgZm9yIGEgY29tcG9uZW50LlxyXG5mdW5jdGlvbiBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQsIGJ1aWxkU2xvdEZuID0gYnVpbGRDbGllbnRTbG90Rm4pIHtcclxuICAgIGNvbnRleHQuaGVscGVyKFdJVEhfQ1RYKTtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IHNsb3RzUHJvcGVydGllcyA9IFtdO1xyXG4gICAgY29uc3QgZHluYW1pY1Nsb3RzID0gW107XHJcbiAgICBjb25zdCBidWlsZERlZmF1bHRTbG90UHJvcGVydHkgPSAocHJvcHMsIGNoaWxkcmVuKSA9PiBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZGVmYXVsdGAsIGJ1aWxkU2xvdEZuKHByb3BzLCBjaGlsZHJlbiwgbG9jKSk7XHJcbiAgICAvLyBJZiB0aGUgc2xvdCBpcyBpbnNpZGUgYSB2LWZvciBvciBhbm90aGVyIHYtc2xvdCwgZm9yY2UgaXQgdG8gYmUgZHluYW1pY1xyXG4gICAgLy8gc2luY2UgaXQgbGlrZWx5IHVzZXMgYSBzY29wZSB2YXJpYWJsZS5cclxuICAgIGxldCBoYXNEeW5hbWljU2xvdHMgPSBjb250ZXh0LnNjb3Blcy52U2xvdCA+IDAgfHwgY29udGV4dC5zY29wZXMudkZvciA+IDA7XHJcbiAgICAvLyAxLiBDaGVjayBmb3Igc2xvdCB3aXRoIHNsb3RQcm9wcyBvbiBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgLy8gICAgPENvbXAgdi1zbG90PVwieyBwcm9wIH1cIi8+XHJcbiAgICBjb25zdCBvbkNvbXBvbmVudFNsb3QgPSBmaW5kRGlyKG5vZGUsICdzbG90JywgdHJ1ZSk7XHJcbiAgICBpZiAob25Db21wb25lbnRTbG90KSB7XHJcbiAgICAgICAgY29uc3QgeyBhcmcsIGV4cCB9ID0gb25Db21wb25lbnRTbG90O1xyXG4gICAgICAgIGlmIChhcmcgJiYgIWlzU3RhdGljRXhwKGFyZykpIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ2RlZmF1bHQnLCB0cnVlKSwgYnVpbGRTbG90Rm4oZXhwLCBjaGlsZHJlbiwgbG9jKSkpO1xyXG4gICAgfVxyXG4gICAgLy8gMi4gSXRlcmF0ZSB0aHJvdWdoIGNoaWxkcmVuIGFuZCBjaGVjayBmb3IgdGVtcGxhdGUgc2xvdHNcclxuICAgIC8vICAgIDx0ZW1wbGF0ZSB2LXNsb3Q6Zm9vPVwieyBwcm9wIH1cIj5cclxuICAgIGxldCBoYXNUZW1wbGF0ZVNsb3RzID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzTmFtZWREZWZhdWx0U2xvdCA9IGZhbHNlO1xyXG4gICAgY29uc3QgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4gPSBbXTtcclxuICAgIGNvbnN0IHNlZW5TbG90TmFtZXMgPSBuZXcgU2V0KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2xvdEVsZW1lbnQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBsZXQgc2xvdERpcjtcclxuICAgICAgICBpZiAoIWlzVGVtcGxhdGVOb2RlKHNsb3RFbGVtZW50KSB8fFxyXG4gICAgICAgICAgICAhKHNsb3REaXIgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnc2xvdCcsIHRydWUpKSkge1xyXG4gICAgICAgICAgICAvLyBub3QgYSA8dGVtcGxhdGUgdi1zbG90Piwgc2tpcC5cclxuICAgICAgICAgICAgaWYgKHNsb3RFbGVtZW50LnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4ucHVzaChzbG90RWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSBoYXMgb24tY29tcG9uZW50IHNsb3QgLSB0aGlzIGlzIGluY29ycmVjdCB1c2FnZS5cclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzYgLyogWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRSAqLywgc2xvdERpci5sb2MpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhc1RlbXBsYXRlU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IHNsb3RDaGlsZHJlbiwgbG9jOiBzbG90TG9jIH0gPSBzbG90RWxlbWVudDtcclxuICAgICAgICBjb25zdCB7IGFyZzogc2xvdE5hbWUgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBkZWZhdWx0YCwgdHJ1ZSksIGV4cDogc2xvdFByb3BzLCBsb2M6IGRpckxvYyB9ID0gc2xvdERpcjtcclxuICAgICAgICAvLyBjaGVjayBpZiBuYW1lIGlzIGR5bmFtaWMuXHJcbiAgICAgICAgbGV0IHN0YXRpY1Nsb3ROYW1lO1xyXG4gICAgICAgIGlmIChpc1N0YXRpY0V4cChzbG90TmFtZSkpIHtcclxuICAgICAgICAgICAgc3RhdGljU2xvdE5hbWUgPSBzbG90TmFtZSA/IHNsb3ROYW1lLmNvbnRlbnQgOiBgZGVmYXVsdGA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzbG90RnVuY3Rpb24gPSBidWlsZFNsb3RGbihzbG90UHJvcHMsIHNsb3RDaGlsZHJlbiwgc2xvdExvYyk7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBzbG90IGlzIGNvbmRpdGlvbmFsICh2LWlmL3YtZm9yKVxyXG4gICAgICAgIGxldCB2SWY7XHJcbiAgICAgICAgbGV0IHZFbHNlO1xyXG4gICAgICAgIGxldCB2Rm9yO1xyXG4gICAgICAgIGlmICgodklmID0gZmluZERpcihzbG90RWxlbWVudCwgJ2lmJykpKSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2SWYuZXhwLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pLCBkZWZhdWx0RmFsbGJhY2spKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHZFbHNlID0gZmluZERpcihzbG90RWxlbWVudCwgL15lbHNlKC1pZik/JC8sIHRydWUgLyogYWxsb3dFbXB0eSAqLykpKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgYWRqYWNlbnQgdi1pZlxyXG4gICAgICAgICAgICBsZXQgaiA9IGk7XHJcbiAgICAgICAgICAgIGxldCBwcmV2O1xyXG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2ID0gY2hpbGRyZW5bal07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldi50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldiAmJiBpc1RlbXBsYXRlTm9kZShwcmV2KSAmJiBmaW5kRGlyKHByZXYsICdpZicpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbm9kZVxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIHRoaXMgc2xvdCB0byBwcmV2aW91cyBjb25kaXRpb25hbFxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbmFsID0gZHluYW1pY1Nsb3RzW2R5bmFtaWNTbG90cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb25kaXRpb25hbC5hbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuYWx0ZXJuYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uYWwuYWx0ZXJuYXRlID0gdkVsc2UuZXhwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odkVsc2UuZXhwLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pLCBkZWZhdWx0RmFsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgOiBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjkgLyogWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIHZFbHNlLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh2Rm9yID0gZmluZERpcihzbG90RWxlbWVudCwgJ2ZvcicpKSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHZGb3IucGFyc2VSZXN1bHQgfHxcclxuICAgICAgICAgICAgICAgIHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBkeW5hbWljIHNsb3RzIGFzIGFuIGFycmF5IGFuZCBhZGQgaXQgdG8gdGhlIGNyZWF0ZVNsb3QoKVxyXG4gICAgICAgICAgICAgICAgLy8gYXJncy4gVGhlIHJ1bnRpbWUga25vd3MgaG93IHRvIGhhbmRsZSBpdCBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVOREVSX0xJU1QpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKHBhcnNlUmVzdWx0KSwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgdHJ1ZSAvKiBmb3JjZSBuZXdsaW5lICovKVxyXG4gICAgICAgICAgICAgICAgXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzEgLyogWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgdkZvci5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgZHVwbGljYXRlIHN0YXRpYyBuYW1lc1xyXG4gICAgICAgICAgICBpZiAoc3RhdGljU2xvdE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWVuU2xvdE5hbWVzLmhhcyhzdGF0aWNTbG90TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNyAvKiBYX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FUyAqLywgZGlyTG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWVuU2xvdE5hbWVzLmFkZChzdGF0aWNTbG90TmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljU2xvdE5hbWUgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc05hbWVkRGVmYXVsdFNsb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgICAgIGlmICghaGFzVGVtcGxhdGVTbG90cykge1xyXG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG9uIGNvbXBvbmVudClcclxuICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5KHVuZGVmaW5lZCwgY2hpbGRyZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIGltcGxpY2l0IGRlZmF1bHQgc2xvdCAobWl4ZWQgd2l0aCBuYW1lZCBzbG90cylcclxuICAgICAgICAgICAgaWYgKGhhc05hbWVkRGVmYXVsdFNsb3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM4IC8qIFhfVl9TTE9UX0VYVFJBTkVPVVNfREVGQVVMVF9TTE9UX0NISUxEUkVOICovLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlblswXS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSh1bmRlZmluZWQsIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzbG90RmxhZyA9IGhhc0R5bmFtaWNTbG90c1xyXG4gICAgICAgID8gMiAvKiBEWU5BTUlDICovXHJcbiAgICAgICAgOiBoYXNGb3J3YXJkZWRTbG90cyhub2RlLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICA/IDMgLyogRk9SV0FSREVEICovXHJcbiAgICAgICAgICAgIDogMSAvKiBTVEFCTEUgKi87XHJcbiAgICBsZXQgc2xvdHMgPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHNsb3RzUHJvcGVydGllcy5jb25jYXQoY3JlYXRlT2JqZWN0UHJvcGVydHkoYF9gLCBcclxuICAgIC8vIDIgPSBjb21waWxlZCBidXQgZHluYW1pYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24sIGJ1dCBtdXN0IHJ1biBkaWZmXHJcbiAgICAvLyAxID0gY29tcGlsZWQgYW5kIHN0YXRpYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24gQU5EIGRpZmYgYXMgb3B0aW1pemVkXHJcbiAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHNsb3RGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtzbG90RmxhZ3NUZXh0W3Nsb3RGbGFnXX0gKi9gIDogYGApLCBmYWxzZSkpKSwgbG9jKTtcclxuICAgIGlmIChkeW5hbWljU2xvdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgc2xvdHMgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfU0xPVFMpLCBbXHJcbiAgICAgICAgICAgIHNsb3RzLFxyXG4gICAgICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oZHluYW1pY1Nsb3RzKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzbG90cyxcclxuICAgICAgICBoYXNEeW5hbWljU2xvdHNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYnVpbGREeW5hbWljU2xvdChuYW1lLCBmbikge1xyXG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW1xyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBuYW1lYCwgbmFtZSksXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYGZuYCwgZm4pXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZHJlbikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQudGFnVHlwZSA9PT0gMiAvKiBTTE9UICovIHx8XHJcbiAgICAgICAgICAgICAgICAoY2hpbGQudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuLy8gc29tZSBkaXJlY3RpdmUgdHJhbnNmb3JtcyAoZS5nLiB2LW1vZGVsKSBtYXkgcmV0dXJuIGEgc3ltYm9sIGZvciBydW50aW1lXHJcbi8vIGltcG9ydCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBhIHJlc29sdmVEaXJlY3RpdmUgY2FsbC5cclxuY29uc3QgZGlyZWN0aXZlSW1wb3J0TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuLy8gZ2VuZXJhdGUgYSBKYXZhU2NyaXB0IEFTVCBmb3IgdGhpcyBlbGVtZW50J3MgY29kZWdlblxyXG5jb25zdCB0cmFuc2Zvcm1FbGVtZW50ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmICghKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHBlcmZvcm0gdGhlIHdvcmsgb24gZXhpdCwgYWZ0ZXIgYWxsIGNoaWxkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxyXG4gICAgLy8gcHJvY2Vzc2VkIGFuZCBtZXJnZWQuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9zdFRyYW5zZm9ybUVsZW1lbnQoKSB7XHJcbiAgICAgICAgY29uc3QgeyB0YWcsIHByb3BzIH0gPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgICAgICAvLyBUaGUgZ29hbCBvZiB0aGUgdHJhbnNmb3JtIGlzIHRvIGNyZWF0ZSBhIGNvZGVnZW5Ob2RlIGltcGxlbWVudGluZyB0aGVcclxuICAgICAgICAvLyBWTm9kZUNhbGwgaW50ZXJmYWNlLlxyXG4gICAgICAgIGNvbnN0IHZub2RlVGFnID0gaXNDb21wb25lbnRcclxuICAgICAgICAgICAgPyByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0KVxyXG4gICAgICAgICAgICA6IGBcIiR7dGFnfVwiYDtcclxuICAgICAgICBjb25zdCBpc0R5bmFtaWNDb21wb25lbnQgPSBpc09iamVjdCh2bm9kZVRhZykgJiYgdm5vZGVUYWcuY2FsbGVlID09PSBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UO1xyXG4gICAgICAgIGxldCB2bm9kZVByb3BzO1xyXG4gICAgICAgIGxldCB2bm9kZUNoaWxkcmVuO1xyXG4gICAgICAgIGxldCB2bm9kZVBhdGNoRmxhZztcclxuICAgICAgICBsZXQgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICBsZXQgdm5vZGVEeW5hbWljUHJvcHM7XHJcbiAgICAgICAgbGV0IGR5bmFtaWNQcm9wTmFtZXM7XHJcbiAgICAgICAgbGV0IHZub2RlRGlyZWN0aXZlcztcclxuICAgICAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBcclxuICAgICAgICAvLyBkeW5hbWljIGNvbXBvbmVudCBtYXkgcmVzb2x2ZSB0byBwbGFpbiBlbGVtZW50c1xyXG4gICAgICAgIGlzRHluYW1pY0NvbXBvbmVudCB8fFxyXG4gICAgICAgICAgICB2bm9kZVRhZyA9PT0gVEVMRVBPUlQgfHxcclxuICAgICAgICAgICAgdm5vZGVUYWcgPT09IFNVU1BFTlNFIHx8XHJcbiAgICAgICAgICAgICghaXNDb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIC8vIDxzdmc+IGFuZCA8Zm9yZWlnbk9iamVjdD4gbXVzdCBiZSBmb3JjZWQgaW50byBibG9ja3Mgc28gdGhhdCBibG9ja1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyBpbnNpZGUgZ2V0IHByb3BlciBpc1NWRyBmbGFnIGF0IHJ1bnRpbWUuICgjNjM5LCAjNjQzKVxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSB3ZWItc3BlY2lmaWMsIGJ1dCBzcGxpdHRpbmcgdGhlIGxvZ2ljIG91dCBvZiBjb3JlXHJcbiAgICAgICAgICAgICAgICAvLyBsZWFkcyB0byB0b28gbXVjaCB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4gICAgICAgICAgICAgICAgKHRhZyA9PT0gJ3N2ZycgfHxcclxuICAgICAgICAgICAgICAgICAgICB0YWcgPT09ICdmb3JlaWduT2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICM5Mzg6IGVsZW1lbnRzIHdpdGggZHluYW1pYyBrZXlzIHNob3VsZCBiZSBmb3JjZWQgaW50byBibG9ja3NcclxuICAgICAgICAgICAgICAgICAgICBmaW5kUHJvcChub2RlLCAna2V5JywgdHJ1ZSkpKTtcclxuICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzQnVpbGRSZXN1bHQgPSBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2bm9kZVByb3BzID0gcHJvcHNCdWlsZFJlc3VsdC5wcm9wcztcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gcHJvcHNCdWlsZFJlc3VsdC5wYXRjaEZsYWc7XHJcbiAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmR5bmFtaWNQcm9wTmFtZXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmRpcmVjdGl2ZXM7XHJcbiAgICAgICAgICAgIHZub2RlRGlyZWN0aXZlcyA9XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVBcnJheUV4cHJlc3Npb24oZGlyZWN0aXZlcy5tYXAoZGlyID0+IGJ1aWxkRGlyZWN0aXZlQXJncyhkaXIsIGNvbnRleHQpKSlcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hpbGRyZW5cclxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZVRhZyA9PT0gS0VFUF9BTElWRSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggYSBidWlsdC1pbiBjb21wb25lbnQsIHdlIGNvbXBpbGUgS2VlcEFsaXZlIHdpdGggcmF3IGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHNsb3QgZnVuY3Rpb25zIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW5zaWRlIFRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgIC8vIG9yIG90aGVyIFRyYW5zaXRpb24td3JhcHBpbmcgSE9Dcy5cclxuICAgICAgICAgICAgICAgIC8vIFRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMgd2l0aCBibG9jayBvcHRpbWl6YXRpb25zLCB3ZSBuZWVkIHRvOlxyXG4gICAgICAgICAgICAgICAgLy8gMS4gRm9yY2Uga2VlcC1hbGl2ZSBpbnRvIGEgYmxvY2suIFRoaXMgYXZvaWRzIGl0cyBjaGlsZHJlbiBiZWluZ1xyXG4gICAgICAgICAgICAgICAgLy8gICAgY29sbGVjdGVkIGJ5IGEgcGFyZW50IGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gMi4gRm9yY2Uga2VlcC1hbGl2ZSB0byBhbHdheXMgYmUgdXBkYXRlZCwgc2luY2UgaXQgdXNlcyByYXcgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NCAvKiBYX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5jaGlsZHJlblswXS5sb2Muc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQnVpbGRBc1Nsb3RzID0gaXNDb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0IGlzIG5vdCBhIHJlYWwgY29tcG9uZW50IGFuZCBoYXMgZGVkaWNhdGVkIHJ1bnRpbWUgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgIHZub2RlVGFnICE9PSBURUxFUE9SVCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gZXhwbGFpbmVkIGFib3ZlLlxyXG4gICAgICAgICAgICAgICAgdm5vZGVUYWcgIT09IEtFRVBfQUxJVkU7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRCdWlsZEFzU2xvdHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2xvdHMsIGhhc0R5bmFtaWNTbG90cyB9ID0gYnVpbGRTbG90cyhub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBzbG90cztcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2xvdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHZub2RlVGFnICE9PSBURUxFUE9SVCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHluYW1pYyB0ZXh0IGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNEeW5hbWljVGV4dENoaWxkID0gdHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNUZXh0Q2hpbGQgJiZcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxIC8qIFRFWFQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwYXNzIGRpcmVjdGx5IGlmIHRoZSBvbmx5IGNoaWxkIGlzIGEgdGV4dCBub2RlXHJcbiAgICAgICAgICAgICAgICAvLyAocGxhaW4gLyBpbnRlcnBvbGF0aW9uIC8gZXhwcmVzc2lvbilcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkIHx8IHR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGF0Y2hGbGFnICYgZHluYW1pY1Byb3BOYW1lc1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGZsYWdzIChuZWdhdGl2ZSBhbmQgbXV0dWFsbHkgZXhjbHVzaXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlUGF0Y2hGbGFnID0gcGF0Y2hGbGFnICsgYCAvKiAke1BhdGNoRmxhZ05hbWVzW3BhdGNoRmxhZ119ICovYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHdpc2UgZmxhZ3NcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnTmFtZXMgPSBPYmplY3Qua2V5cyhQYXRjaEZsYWdOYW1lcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChOdW1iZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuID4gMCAmJiBwYXRjaEZsYWcgJiBuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKG4gPT4gUGF0Y2hGbGFnTmFtZXNbbl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKGAsIGApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlUGF0Y2hGbGFnID0gcGF0Y2hGbGFnICsgYCAvKiAke2ZsYWdOYW1lc30gKi9gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBTdHJpbmcocGF0Y2hGbGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZHluYW1pY1Byb3BOYW1lcyAmJiBkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVEeW5hbWljUHJvcHMgPSBzdHJpbmdpZnlEeW5hbWljUHJvcE5hbWVzKGR5bmFtaWNQcm9wTmFtZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgdm5vZGVUYWcsIHZub2RlUHJvcHMsIHZub2RlQ2hpbGRyZW4sIHZub2RlUGF0Y2hGbGFnLCB2bm9kZUR5bmFtaWNQcm9wcywgdm5vZGVEaXJlY3RpdmVzLCAhIXNob3VsZFVzZUJsb2NrLCBmYWxzZSAvKiBkaXNhYmxlVHJhY2tpbmcgKi8sIG5vZGUubG9jKTtcclxuICAgIH07XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQsIHNzciA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IHRhZyB9ID0gbm9kZTtcclxuICAgIC8vIDEuIGR5bmFtaWMgY29tcG9uZW50XHJcbiAgICBjb25zdCBpc1Byb3AgPSBub2RlLnRhZyA9PT0gJ2NvbXBvbmVudCcgPyBmaW5kUHJvcChub2RlLCAnaXMnKSA6IGZpbmREaXIobm9kZSwgJ2lzJyk7XHJcbiAgICBpZiAoaXNQcm9wKSB7XHJcbiAgICAgICAgY29uc3QgZXhwID0gaXNQcm9wLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovXHJcbiAgICAgICAgICAgID8gaXNQcm9wLnZhbHVlICYmIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oaXNQcm9wLnZhbHVlLmNvbnRlbnQsIHRydWUpXHJcbiAgICAgICAgICAgIDogaXNQcm9wLmV4cDtcclxuICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UKSwgW1xyXG4gICAgICAgICAgICAgICAgZXhwXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDIuIGJ1aWx0LWluIGNvbXBvbmVudHMgKFRlbGVwb3J0LCBUcmFuc2l0aW9uLCBLZWVwQWxpdmUsIFN1c3BlbnNlLi4uKVxyXG4gICAgY29uc3QgYnVpbHRJbiA9IGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8IGNvbnRleHQuaXNCdWlsdEluQ29tcG9uZW50KHRhZyk7XHJcbiAgICBpZiAoYnVpbHRJbikge1xyXG4gICAgICAgIC8vIGJ1aWx0LWlucyBhcmUgc2ltcGx5IGZhbGx0aHJvdWdocyAvIGhhdmUgc3BlY2lhbCBoYW5kbGluZyBkdXJpbmcgc3NyXHJcbiAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBpbXBvcnQgdGhlaXIgcnVudGltZSBlcXVpdmFsZW50c1xyXG4gICAgICAgIGlmICghc3NyKVxyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihidWlsdEluKTtcclxuICAgICAgICByZXR1cm4gYnVpbHRJbjtcclxuICAgIH1cclxuICAgIC8vIDUuIHVzZXIgY29tcG9uZW50IChyZXNvbHZlKVxyXG4gICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9DT01QT05FTlQpO1xyXG4gICAgY29udGV4dC5jb21wb25lbnRzLmFkZCh0YWcpO1xyXG4gICAgcmV0dXJuIHRvVmFsaWRBc3NldElkKHRhZywgYGNvbXBvbmVudGApO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgcHJvcHMgPSBub2RlLnByb3BzLCBzc3IgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgeyB0YWcsIGxvYzogZWxlbWVudExvYyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgIGxldCBwcm9wZXJ0aWVzID0gW107XHJcbiAgICBjb25zdCBtZXJnZUFyZ3MgPSBbXTtcclxuICAgIGNvbnN0IHJ1bnRpbWVEaXJlY3RpdmVzID0gW107XHJcbiAgICAvLyBwYXRjaEZsYWcgYW5hbHlzaXNcclxuICAgIGxldCBwYXRjaEZsYWcgPSAwO1xyXG4gICAgbGV0IGhhc1JlZiA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc0NsYXNzQmluZGluZyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc1N0eWxlQmluZGluZyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc0R5bmFtaWNLZXlzID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzVm5vZGVIb29rID0gZmFsc2U7XHJcbiAgICBjb25zdCBkeW5hbWljUHJvcE5hbWVzID0gW107XHJcbiAgICBjb25zdCBhbmFseXplUGF0Y2hGbGFnID0gKHsga2V5LCB2YWx1ZSB9KSA9PiB7XHJcbiAgICAgICAgaWYgKGlzU3RhdGljRXhwKGtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGtleS5jb250ZW50O1xyXG4gICAgICAgICAgICBjb25zdCBpc0V2ZW50SGFuZGxlciA9IGlzT24obmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNDb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIGlzRXZlbnRIYW5kbGVyICYmXHJcbiAgICAgICAgICAgICAgICAvLyBvbWl0IHRoZSBmbGFnIGZvciBjbGljayBoYW5kbGVycyBiZWNhdXNlIGh5ZHJhdGlvbiBnaXZlcyBjbGlja1xyXG4gICAgICAgICAgICAgICAgLy8gZGVkaWNhdGVkIGZhc3QgcGF0aC5cclxuICAgICAgICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29uY2xpY2snICYmXHJcbiAgICAgICAgICAgICAgICAvLyBvbWl0IHYtbW9kZWwgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIG5hbWUgIT09ICdvblVwZGF0ZTptb2RlbFZhbHVlJyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gb21pdCBvblZub2RlWFhYIGhvb2tzXHJcbiAgICAgICAgICAgICAgICAhaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVyICYmIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNWbm9kZUhvb2sgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgICAgICAoKHZhbHVlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHRoZSBwcm9wIGlzIGEgY2FjaGVkIGhhbmRsZXIgb3IgaGFzIGNvbnN0YW50IHZhbHVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdyZWYnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNSZWYgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBoYXNDbGFzc0JpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzdHlsZScgJiYgIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBoYXNTdHlsZUJpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT09ICdrZXknICYmICFkeW5hbWljUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNLZXlzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIHN0YXRpYyBhdHRyaWJ1dGVcclxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsb2MsIG5hbWUsIHZhbHVlIH0gPSBwcm9wO1xyXG4gICAgICAgICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlZicpIHtcclxuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCA6aXMgb24gPGNvbXBvbmVudD5cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgJiYgdGFnID09PSAnY29tcG9uZW50Jykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24obmFtZSwgdHJ1ZSwgZ2V0SW5uZXJSYW5nZShsb2MsIDAsIG5hbWUubGVuZ3RoKSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24odmFsdWUgPyB2YWx1ZS5jb250ZW50IDogJycsIGlzU3RhdGljLCB2YWx1ZSA/IHZhbHVlLmxvYyA6IGxvYykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXNcclxuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBhcmcsIGV4cCwgbG9jIH0gPSBwcm9wO1xyXG4gICAgICAgICAgICBjb25zdCBpc0JpbmQgPSBuYW1lID09PSAnYmluZCc7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzT24gPSBuYW1lID09PSAnb24nO1xyXG4gICAgICAgICAgICAvLyBza2lwIHYtc2xvdCAtIGl0IGlzIGhhbmRsZWQgYnkgaXRzIGRlZGljYXRlZCB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnc2xvdCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzOSAvKiBYX1ZfU0xPVF9NSVNQTEFDRUQgKi8sIGxvYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCB2LW9uY2UgLSBpdCBpcyBoYW5kbGVkIGJ5IGl0cyBkZWRpY2F0ZWQgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ29uY2UnKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtaXMgYW5kIDppcyBvbiA8Y29tcG9uZW50PlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyB8fFxyXG4gICAgICAgICAgICAgICAgKGlzQmluZCAmJiB0YWcgPT09ICdjb21wb25lbnQnICYmIGlzQmluZEtleShhcmcsICdpcycpKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCB2LW9uIGluIFNTUiBjb21waWxhdGlvblxyXG4gICAgICAgICAgICBpZiAoaXNPbiAmJiBzc3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igdi1iaW5kIGFuZCB2LW9uIHdpdGggbm8gYXJndW1lbnRcclxuICAgICAgICAgICAgaWYgKCFhcmcgJiYgKGlzQmluZCB8fCBpc09uKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzRHluYW1pY0tleXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCaW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2LW9uPVwib2JqXCIgLT4gdG9IYW5kbGVycyhvYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZTogY29udGV4dC5oZWxwZXIoVE9fSEFORExFUlMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbZXhwXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcihpc0JpbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAzMyAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMzQgLyogWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlVHJhbnNmb3JtID0gY29udGV4dC5kaXJlY3RpdmVUcmFuc2Zvcm1zW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBoYXMgYnVpbHQtaW4gZGlyZWN0aXZlIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIG5lZWRSdW50aW1lIH0gPSBkaXJlY3RpdmVUcmFuc2Zvcm0ocHJvcCwgbm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAhc3NyICYmIHByb3BzLmZvckVhY2goYW5hbHl6ZVBhdGNoRmxhZyk7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goLi4ucHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5lZWRSdW50aW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTeW1ib2wobmVlZFJ1bnRpbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZUltcG9ydE1hcC5zZXQocHJvcCwgbmVlZFJ1bnRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGJ1aWx0LWluIHRyYW5zZm9ybSwgdGhpcyBpcyBhIHVzZXIgY3VzdG9tIGRpcmVjdGl2ZS5cclxuICAgICAgICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgcHJvcHNFeHByZXNzaW9uID0gdW5kZWZpbmVkO1xyXG4gICAgLy8gaGFzIHYtYmluZD1cIm9iamVjdFwiIG9yIHYtb249XCJvYmplY3RcIiwgd3JhcCB3aXRoIG1lcmdlUHJvcHNcclxuICAgIGlmIChtZXJnZUFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgZWxlbWVudExvYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyZ2VBcmdzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBtZXJnZUFyZ3MsIGVsZW1lbnRMb2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIHYtYmluZCB3aXRoIG5vdGhpbmcgZWxzZSAtIG5vIG5lZWQgZm9yIGEgbWVyZ2VQcm9wcyBjYWxsXHJcbiAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IG1lcmdlQXJnc1swXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgZWxlbWVudExvYyk7XHJcbiAgICB9XHJcbiAgICAvLyBwYXRjaEZsYWcgYW5hbHlzaXNcclxuICAgIGlmIChoYXNEeW5hbWljS2V5cykge1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSAxNiAvKiBGVUxMX1BST1BTICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGhhc0NsYXNzQmluZGluZykge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMiAvKiBDTEFTUyAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc1N0eWxlQmluZGluZykge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gNCAvKiBTVFlMRSAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSA4IC8qIFBST1BTICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHBhdGNoRmxhZyA9PT0gMCB8fCBwYXRjaEZsYWcgPT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSAmJlxyXG4gICAgICAgIChoYXNSZWYgfHwgaGFzVm5vZGVIb29rIHx8IHJ1bnRpbWVEaXJlY3RpdmVzLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgcGF0Y2hGbGFnIHw9IDUxMiAvKiBORUVEX1BBVENIICovO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogcHJvcHNFeHByZXNzaW9uLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IHJ1bnRpbWVEaXJlY3RpdmVzLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcE5hbWVzXHJcbiAgICB9O1xyXG59XHJcbi8vIERlZHVwZSBwcm9wcyBpbiBhbiBvYmplY3QgbGl0ZXJhbC5cclxuLy8gTGl0ZXJhbCBkdXBsaWNhdGVkIGF0dHJpYnV0ZXMgd291bGQgaGF2ZSBiZWVuIHdhcm5lZCBkdXJpbmcgdGhlIHBhcnNlIHBoYXNlLFxyXG4vLyBob3dldmVyLCBpdCdzIHBvc3NpYmxlIHRvIGVuY291bnRlciBkdXBsaWNhdGVkIGBvblhYWGAgaGFuZGxlcnMgd2l0aCBkaWZmZXJlbnRcclxuLy8gbW9kaWZpZXJzLiBXZSBhbHNvIG5lZWQgdG8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIGNsYXNzIC8gc3R5bGUgYXR0cmlidXRlcy5cclxuLy8gLSBvblhYWCBoYW5kbGVycyAvIHN0eWxlOiBtZXJnZSBpbnRvIGFycmF5XHJcbi8vIC0gY2xhc3M6IG1lcmdlIGludG8gc2luZ2xlIGV4cHJlc3Npb24gd2l0aCBjb25jYXRlbmF0aW9uXHJcbmZ1bmN0aW9uIGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcykge1xyXG4gICAgY29uc3Qga25vd25Qcm9wcyA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IGRlZHVwZWQgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgIC8vIGR5bmFtaWMga2V5cyBhcmUgYWx3YXlzIGFsbG93ZWRcclxuICAgICAgICBpZiAocHJvcC5rZXkudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovIHx8ICFwcm9wLmtleS5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBkZWR1cGVkLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuYW1lID0gcHJvcC5rZXkuY29udGVudDtcclxuICAgICAgICBjb25zdCBleGlzdGluZyA9IGtub3duUHJvcHMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChleGlzdGluZykge1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJyB8fCBuYW1lID09PSAnY2xhc3MnIHx8IG5hbWUuc3RhcnRzV2l0aCgnb24nKSkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VBc0FycmF5KGV4aXN0aW5nLCBwcm9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB1bmV4cGVjdGVkIGR1cGxpY2F0ZSwgc2hvdWxkIGhhdmUgZW1pdHRlZCBlcnJvciBkdXJpbmcgcGFyc2VcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGtub3duUHJvcHMuc2V0KG5hbWUsIHByb3ApO1xyXG4gICAgICAgICAgICBkZWR1cGVkLnB1c2gocHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZHVwZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KGV4aXN0aW5nLCBpbmNvbWluZykge1xyXG4gICAgaWYgKGV4aXN0aW5nLnZhbHVlLnR5cGUgPT09IDE3IC8qIEpTX0FSUkFZX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBleGlzdGluZy52YWx1ZS5lbGVtZW50cy5wdXNoKGluY29taW5nLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV4aXN0aW5nLnZhbHVlID0gY3JlYXRlQXJyYXlFeHByZXNzaW9uKFtleGlzdGluZy52YWx1ZSwgaW5jb21pbmcudmFsdWVdLCBleGlzdGluZy5sb2MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkRGlyZWN0aXZlQXJncyhkaXIsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGRpckFyZ3MgPSBbXTtcclxuICAgIGNvbnN0IHJ1bnRpbWUgPSBkaXJlY3RpdmVJbXBvcnRNYXAuZ2V0KGRpcik7XHJcbiAgICBpZiAocnVudGltZSkge1xyXG4gICAgICAgIC8vIGJ1aWx0LWluIGRpcmVjdGl2ZSB3aXRoIHJ1bnRpbWVcclxuICAgICAgICBkaXJBcmdzLnB1c2goY29udGV4dC5oZWxwZXJTdHJpbmcocnVudGltZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBpbmplY3Qgc3RhdGVtZW50IGZvciByZXNvbHZpbmcgZGlyZWN0aXZlXHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfRElSRUNUSVZFKTtcclxuICAgICAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzLmFkZChkaXIubmFtZSk7XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaCh0b1ZhbGlkQXNzZXRJZChkaXIubmFtZSwgYGRpcmVjdGl2ZWApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGxvYyB9ID0gZGlyO1xyXG4gICAgaWYgKGRpci5leHApXHJcbiAgICAgICAgZGlyQXJncy5wdXNoKGRpci5leHApO1xyXG4gICAgaWYgKGRpci5hcmcpIHtcclxuICAgICAgICBpZiAoIWRpci5leHApIHtcclxuICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlyQXJncy5wdXNoKGRpci5hcmcpO1xyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMpLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICghZGlyLmFyZykge1xyXG4gICAgICAgICAgICBpZiAoIWRpci5leHApIHtcclxuICAgICAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJ1ZUV4cHJlc3Npb24gPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0cnVlYCwgZmFsc2UsIGxvYyk7XHJcbiAgICAgICAgZGlyQXJncy5wdXNoKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGlyLm1vZGlmaWVycy5tYXAobW9kaWZpZXIgPT4gY3JlYXRlT2JqZWN0UHJvcGVydHkobW9kaWZpZXIsIHRydWVFeHByZXNzaW9uKSksIGxvYykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkaXJBcmdzLCBkaXIubG9jKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlEeW5hbWljUHJvcE5hbWVzKHByb3BzKSB7XHJcbiAgICBsZXQgcHJvcHNOYW1lc1N0cmluZyA9IGBbYDtcclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcHJvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgcHJvcHNOYW1lc1N0cmluZyArPSBKU09OLnN0cmluZ2lmeShwcm9wc1tpXSk7XHJcbiAgICAgICAgaWYgKGkgPCBsIC0gMSlcclxuICAgICAgICAgICAgcHJvcHNOYW1lc1N0cmluZyArPSAnLCAnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzTmFtZXNTdHJpbmcgKyBgXWA7XHJcbn1cblxuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXHJcbiAgICA6IHt9O1xyXG4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKChzdHIpID0+IHtcclxuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcclxufSk7XG5cbmNvbnN0IHRyYW5zZm9ybVNsb3RPdXRsZXQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKGlzU2xvdE91dGxldChub2RlKSkge1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcclxuICAgICAgICBjb25zdCB7IHNsb3ROYW1lLCBzbG90UHJvcHMgfSA9IHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IHNsb3RBcmdzID0gW1xyXG4gICAgICAgICAgICBjb250ZXh0LnByZWZpeElkZW50aWZpZXJzID8gYF9jdHguJHNsb3RzYCA6IGAkc2xvdHNgLFxyXG4gICAgICAgICAgICBzbG90TmFtZVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKHNsb3RQcm9wcykge1xyXG4gICAgICAgICAgICBzbG90QXJncy5wdXNoKHNsb3RQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCFzbG90UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHNsb3RBcmdzLnB1c2goYHt9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2xvdEFyZ3MucHVzaChjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oW10sIGNoaWxkcmVuLCBmYWxzZSwgZmFsc2UsIGxvYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVOREVSX1NMT1QpLCBzbG90QXJncywgbG9jKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCkge1xyXG4gICAgbGV0IHNsb3ROYW1lID0gYFwiZGVmYXVsdFwiYDtcclxuICAgIGxldCBzbG90UHJvcHMgPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBub25OYW1lUHJvcHMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnbmFtZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90TmFtZSA9IEpTT04uc3RyaW5naWZ5KHAudmFsdWUuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwLm5hbWUgPSBjYW1lbGl6ZShwLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vbk5hbWVQcm9wcy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSAnYmluZCcgJiYgaXNCaW5kS2V5KHAuYXJnLCAnbmFtZScpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5leHApXHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBwLmV4cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJiBwLmFyZyAmJiBpc1N0YXRpY0V4cChwLmFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwLmFyZy5jb250ZW50ID0gY2FtZWxpemUocC5hcmcuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub25OYW1lUHJvcHMucHVzaChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub25OYW1lUHJvcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGRpcmVjdGl2ZXMgfSA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgbm9uTmFtZVByb3BzKTtcclxuICAgICAgICBzbG90UHJvcHMgPSBwcm9wcztcclxuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzUgLyogWF9WX1NMT1RfVU5FWFBFQ1RFRF9ESVJFQ1RJVkVfT05fU0xPVF9PVVRMRVQgKi8sIGRpcmVjdGl2ZXNbMF0ubG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzbG90TmFtZSxcclxuICAgICAgICBzbG90UHJvcHNcclxuICAgIH07XHJcbn1cblxuY29uc3QgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5cXHMqZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XHJcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCwgYXVnbWVudG9yKSA9PiB7XHJcbiAgICBjb25zdCB7IGxvYywgbW9kaWZpZXJzLCBhcmcgfSA9IGRpcjtcclxuICAgIGlmICghZGlyLmV4cCAmJiAhbW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM0IC8qIFhfVl9PTl9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgIH1cclxuICAgIGxldCBldmVudE5hbWU7XHJcbiAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd05hbWUgPSBhcmcuY29udGVudDtcclxuICAgICAgICAgICAgLy8gZm9yIGFsbCBldmVudCBsaXN0ZW5lcnMsIGF1dG8gY29udmVydCBpdCB0byBjYW1lbENhc2UuIFNlZSBpc3N1ZSAjMjI0OVxyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHRvSGFuZGxlcktleShjYW1lbGl6ZSQxKHJhd05hbWUpKSwgdHJ1ZSwgYXJnLmxvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAjMjM4OFxyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgLFxyXG4gICAgICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICAgICAgYClgXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGFscmVhZHkgYSBjb21wb3VuZCBleHByZXNzaW9uLlxyXG4gICAgICAgIGV2ZW50TmFtZSA9IGFyZztcclxuICAgICAgICBldmVudE5hbWUuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGApO1xyXG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgICB9XHJcbiAgICAvLyBoYW5kbGVyIHByb2Nlc3NpbmdcclxuICAgIGxldCBleHAgPSBkaXIuZXhwO1xyXG4gICAgaWYgKGV4cCAmJiAhZXhwLmNvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgZXhwID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgbGV0IHNob3VsZENhY2hlID0gY29udGV4dC5jYWNoZUhhbmRsZXJzICYmICFleHA7XHJcbiAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgY29uc3QgaXNNZW1iZXJFeHAgPSBpc01lbWJlckV4cHJlc3Npb24oZXhwLmNvbnRlbnQpO1xyXG4gICAgICAgIGNvbnN0IGlzSW5saW5lU3RhdGVtZW50ID0gIShpc01lbWJlckV4cCB8fCBmbkV4cFJFLnRlc3QoZXhwLmNvbnRlbnQpKTtcclxuICAgICAgICBjb25zdCBoYXNNdWx0aXBsZVN0YXRlbWVudHMgPSBleHAuY29udGVudC5pbmNsdWRlcyhgO2ApO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGV4cCwgY29udGV4dCwgZmFsc2UsIGhhc011bHRpcGxlU3RhdGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0lubGluZVN0YXRlbWVudCB8fCAoc2hvdWxkQ2FjaGUgJiYgaXNNZW1iZXJFeHApKSB7XHJcbiAgICAgICAgICAgIC8vIHdyYXAgaW5saW5lIHN0YXRlbWVudCBpbiBhIGZ1bmN0aW9uIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgZXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAke2lzSW5saW5lU3RhdGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgJGV2ZW50YFxyXG4gICAgICAgICAgICAgICAgICAgIDogYCR7YGB9KC4uLmFyZ3MpYH0gPT4gJHtoYXNNdWx0aXBsZVN0YXRlbWVudHMgPyBge2AgOiBgKGB9YCxcclxuICAgICAgICAgICAgICAgIGV4cCxcclxuICAgICAgICAgICAgICAgIGhhc011bHRpcGxlU3RhdGVtZW50cyA/IGB9YCA6IGApYFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgcmV0ID0ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGV2ZW50TmFtZSwgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCgpID0+IHt9YCwgZmFsc2UsIGxvYykpXHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxuICAgIC8vIGFwcGx5IGV4dGVuZGVkIGNvbXBpbGVyIGF1Z21lbnRvclxyXG4gICAgaWYgKGF1Z21lbnRvcikge1xyXG4gICAgICAgIHJldCA9IGF1Z21lbnRvcihyZXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNob3VsZENhY2hlKSB7XHJcbiAgICAgICAgLy8gY2FjaGUgaGFuZGxlcnMgc28gdGhhdCBpdCdzIGFsd2F5cyB0aGUgc2FtZSBoYW5kbGVyIGJlaW5nIHBhc3NlZCBkb3duLlxyXG4gICAgICAgIC8vIHRoaXMgYXZvaWRzIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgd2hlbiB1c2VycyB1c2UgaW5saW5lIGhhbmRsZXJzIG9uXHJcbiAgICAgICAgLy8gY29tcG9uZW50cy5cclxuICAgICAgICByZXQucHJvcHNbMF0udmFsdWUgPSBjb250ZXh0LmNhY2hlKHJldC5wcm9wc1swXS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xuXG4vLyB2LWJpbmQgd2l0aG91dCBhcmcgaXMgaGFuZGxlZCBkaXJlY3RseSBpbiAuL3RyYW5zZm9ybUVsZW1lbnRzLnRzIGR1ZSB0byBpdCBhZmZlY3RpbmdcclxuLy8gY29kZWdlbiBmb3IgdGhlIGVudGlyZSBwcm9wcyBvYmplY3QuIFRoaXMgdHJhbnNmb3JtIGhlcmUgaXMgb25seSBmb3Igdi1iaW5kXHJcbi8vICp3aXRoKiBhcmdzLlxyXG5jb25zdCB0cmFuc2Zvcm1CaW5kID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIG1vZGlmaWVycywgbG9jIH0gPSBkaXI7XHJcbiAgICBjb25zdCBhcmcgPSBkaXIuYXJnO1xyXG4gICAgaWYgKGFyZy50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYChgKTtcclxuICAgICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKSB8fCBcIlwiYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHthcmcuY29udGVudH0gfHwgXCJcImA7XHJcbiAgICB9XHJcbiAgICAvLyAucHJvcCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGR1ZSB0byBuZXcgcGF0Y2ggYmVoYXZpb3JcclxuICAgIC8vIC5zeW5jIGlzIHJlcGxhY2VkIGJ5IHYtbW9kZWw6YXJnXHJcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdjYW1lbCcpKSB7XHJcbiAgICAgICAgaWYgKGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgIGFyZy5jb250ZW50ID0gY2FtZWxpemUkMShhcmcuY29udGVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcmcuY29udGVudCA9IGAke2NvbnRleHQuaGVscGVyU3RyaW5nKENBTUVMSVpFKX0oJHthcmcuY29udGVudH0pYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfShgKTtcclxuICAgICAgICAgICAgYXJnLmNoaWxkcmVuLnB1c2goYClgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWV4cCB8fFxyXG4gICAgICAgIChleHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiAhZXhwLmNvbnRlbnQudHJpbSgpKSkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMzIC8qIFhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlLCBsb2MpKV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgZXhwKV1cclxuICAgIH07XHJcbn07XG5cbi8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgYW5kIGV4cHJlc3Npb25zIGludG8gYSBzaW5nbGUgZXhwcmVzc2lvblxyXG4vLyBlLmcuIDxkaXY+YWJjIHt7IGQgfX0ge3sgZSB9fTwvZGl2PiBzaG91bGQgaGF2ZSBhIHNpbmdsZSBleHByZXNzaW9uIG5vZGUgYXMgY2hpbGQuXHJcbmNvbnN0IHRyYW5zZm9ybVRleHQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMCAvKiBST09UICovIHx8XHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICBub2RlLnR5cGUgPT09IDExIC8qIEZPUiAqLyB8fFxyXG4gICAgICAgIG5vZGUudHlwZSA9PT0gMTAgLyogSUZfQlJBTkNIICovKSB7XHJcbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgdHJhbnNmb3JtIG9uIG5vZGUgZXhpdCBzbyB0aGF0IGFsbCBleHByZXNzaW9ucyBoYXZlIGFscmVhZHlcclxuICAgICAgICAvLyBiZWVuIHByb2Nlc3NlZC5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBsZXQgaGFzVGV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dChjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNUZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gY2hpbGRyZW5bal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RleHQobmV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSBjaGlsZHJlbltpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGNoaWxkLmxvYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtjaGlsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlIGludG8gY3VycmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGAgKyBgLCBuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShqLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWhhc1RleHQgfHxcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IHdpdGggYSBzaW5nbGUgdGV4dCBjaGlsZCwgbGVhdmUgaXRcclxuICAgICAgICAgICAgICAgIC8vIGFzLWlzIHNpbmNlIHRoZSBydW50aW1lIGhhcyBkZWRpY2F0ZWQgZmFzdCBwYXRoIGZvciB0aGlzIGJ5IGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHRleHRDb250ZW50IG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGNvbXBvbmVudCByb290IGl0J3MgYWx3YXlzIG5vcm1hbGl6ZWQgYW55d2F5LlxyXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChub2RlLnR5cGUgPT09IDAgLyogUk9PVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovKSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJlLWNvbnZlcnQgdGV4dCBub2RlcyBpbnRvIGNyZWF0ZVRleHRWTm9kZSh0ZXh0KSBjYWxscyB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyBydW50aW1lIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KGNoaWxkKSB8fCBjaGlsZC50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsQXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZVRleHRWTm9kZSBkZWZhdWx0cyB0byBzaW5nbGUgd2hpdGVzcGFjZSwgc28gaWYgaXQgaXMgYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBzcGFjZSB0aGUgY29kZSBjb3VsZCBiZSBhbiBlbXB0eSBjYWxsIHRvIHNhdmUgYnl0ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IDIgLyogVEVYVCAqLyB8fCBjaGlsZC5jb250ZW50ICE9PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFyZ3MucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgZHluYW1pYyB0ZXh0IHdpdGggZmxhZyBzbyBpdCBnZXRzIHBhdGNoZWQgaW5zaWRlIGEgYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzLnB1c2goMSAvKiBURVhUICovICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbMSAvKiBURVhUICovXX0gKi9gIDogYGApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDEyIC8qIFRFWFRfQ0FMTCAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY2hpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogY2hpbGQubG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZTogY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1RFWFQpLCBjYWxsQXJncylcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcblxuY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KCk7XHJcbmNvbnN0IHRyYW5zZm9ybU9uY2UgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIGZpbmREaXIobm9kZSwgJ29uY2UnLCB0cnVlKSkge1xyXG4gICAgICAgIGlmIChzZWVuLmhhcyhub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZW4uYWRkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRleHQuaGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3VyID0gY29udGV4dC5jdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgaWYgKGN1ci5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY3VyLmNvZGVnZW5Ob2RlID0gY29udGV4dC5jYWNoZShjdXIuY29kZWdlbk5vZGUsIHRydWUgLyogaXNWTm9kZSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBhcmcgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDAgLyogWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhd0V4cCA9IGV4cC5sb2Muc291cmNlO1xyXG4gICAgY29uc3QgZXhwU3RyaW5nID0gZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gPyBleHAuY29udGVudCA6IHJhd0V4cDtcclxuICAgIC8vIGltIFNGQyA8c2NyaXB0IHNldHVwPiBpbmxpbmUgbW9kZSwgdGhlIGV4cCBtYXkgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIGludG9cclxuICAgIC8vIF91bnJlZihleHApXHJcbiAgICBjb250ZXh0LmJpbmRpbmdNZXRhZGF0YVtyYXdFeHBdO1xyXG4gICAgY29uc3QgbWF5YmVSZWYgPSAhdHJ1ZSAgICAvKiBTRVRVUF9DT05TVCAqLztcclxuICAgIGlmICghaXNNZW1iZXJFeHByZXNzaW9uKGV4cFN0cmluZykgJiYgIW1heWJlUmVmKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDEgLyogWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCBleHAubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9wTmFtZSA9IGFyZyA/IGFyZyA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ21vZGVsVmFsdWUnLCB0cnVlKTtcclxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IGFyZ1xyXG4gICAgICAgID8gaXNTdGF0aWNFeHAoYXJnKVxyXG4gICAgICAgICAgICA/IGBvblVwZGF0ZToke2FyZy5jb250ZW50fWBcclxuICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oWydcIm9uVXBkYXRlOlwiICsgJywgYXJnXSlcclxuICAgICAgICA6IGBvblVwZGF0ZTptb2RlbFZhbHVlYDtcclxuICAgIGxldCBhc3NpZ25tZW50RXhwO1xyXG4gICAgY29uc3QgZXZlbnRBcmcgPSBjb250ZXh0LmlzVFMgPyBgKCRldmVudDogYW55KWAgOiBgJGV2ZW50YDtcclxuICAgIHtcclxuICAgICAgICBhc3NpZ25tZW50RXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgYCR7ZXZlbnRBcmd9ID0+IChgLFxyXG4gICAgICAgICAgICBleHAsXHJcbiAgICAgICAgICAgIGAgPSAkZXZlbnQpYFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvcHMgPSBbXHJcbiAgICAgICAgLy8gbW9kZWxWYWx1ZTogZm9vXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkocHJvcE5hbWUsIGRpci5leHApLFxyXG4gICAgICAgIC8vIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiAkZXZlbnQgPT4gKGZvbyA9ICRldmVudClcclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGFzc2lnbm1lbnRFeHApXHJcbiAgICBdO1xyXG4gICAgLy8gbW9kZWxNb2RpZmllcnM6IHsgZm9vOiB0cnVlLCBcImJhci1iYXpcIjogdHJ1ZSB9XHJcbiAgICBpZiAoZGlyLm1vZGlmaWVycy5sZW5ndGggJiYgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnNcclxuICAgICAgICAgICAgLm1hcChtID0+IChpc1NpbXBsZUlkZW50aWZpZXIobSkgPyBtIDogSlNPTi5zdHJpbmdpZnkobSkpICsgYDogdHJ1ZWApXHJcbiAgICAgICAgICAgIC5qb2luKGAsIGApO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGFyZ1xyXG4gICAgICAgICAgICA/IGlzU3RhdGljRXhwKGFyZylcclxuICAgICAgICAgICAgICAgID8gYCR7YXJnLmNvbnRlbnR9TW9kaWZpZXJzYFxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2FyZywgJyArIFwiTW9kaWZpZXJzXCInXSlcclxuICAgICAgICAgICAgOiBgbW9kZWxNb2RpZmllcnNgO1xyXG4gICAgICAgIHByb3BzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkobW9kaWZpZXJzS2V5LCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB7ICR7bW9kaWZpZXJzfSB9YCwgZmFsc2UsIGRpci5sb2MsIDIgLyogQ0FOX0hPSVNUICovKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzKTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMgPSBbXSkge1xyXG4gICAgcmV0dXJuIHsgcHJvcHMgfTtcclxufVxuXG5mdW5jdGlvbiBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KHByZWZpeElkZW50aWZpZXJzKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT25jZSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtSWYsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUZvcixcclxuICAgICAgICAgICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8gW3RyYW5zZm9ybUV4cHJlc3Npb25dXHJcbiAgICAgICAgICAgICAgICAgICAgOiBbXSksXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybVNsb3RPdXRsZXQsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUVsZW1lbnQsXHJcbiAgICAgICAgICAgIHRyYWNrU2xvdFNjb3BlcyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtVGV4dFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvbjogdHJhbnNmb3JtT24sXHJcbiAgICAgICAgICAgIGJpbmQ6IHRyYW5zZm9ybUJpbmQsXHJcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1Nb2RlbFxyXG4gICAgICAgIH1cclxuICAgIF07XHJcbn1cclxuLy8gd2UgbmFtZSBpdCBgYmFzZUNvbXBpbGVgIHNvIHRoYXQgaGlnaGVyIG9yZGVyIGNvbXBpbGVycyBsaWtlXHJcbi8vIEB2dWUvY29tcGlsZXItZG9tIGNhbiBleHBvcnQgYGNvbXBpbGVgIHdoaWxlIHJlLWV4cG9ydGluZyBldmVyeXRoaW5nIGVsc2UuXHJcbmZ1bmN0aW9uIGJhc2VDb21waWxlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IG9uRXJyb3IgPSBvcHRpb25zLm9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XHJcbiAgICBjb25zdCBpc01vZHVsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdtb2R1bGUnO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlZml4SWRlbnRpZmllcnMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ1IC8qIFhfUFJFRklYX0lEX05PVF9TVVBQT1JURUQgKi8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNNb2R1bGVNb2RlKSB7XHJcbiAgICAgICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NiAvKiBYX01PRFVMRV9NT0RFX05PVF9TVVBQT1JURUQgKi8pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcmVmaXhJZGVudGlmaWVycyA9ICF0cnVlIDtcclxuICAgIGlmIChvcHRpb25zLmNhY2hlSGFuZGxlcnMpIHtcclxuICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDcgLyogWF9DQUNIRV9IQU5ETEVSX05PVF9TVVBQT1JURUQgKi8pKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLnNjb3BlSWQgJiYgIWlzTW9kdWxlTW9kZSkge1xyXG4gICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0OCAvKiBYX1NDT1BFX0lEX05PVF9TVVBQT1JURUQgKi8pKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFzdCA9IGlzU3RyaW5nKHRlbXBsYXRlKSA/IGJhc2VQYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucykgOiB0ZW1wbGF0ZTtcclxuICAgIGNvbnN0IFtub2RlVHJhbnNmb3JtcywgZGlyZWN0aXZlVHJhbnNmb3Jtc10gPSBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KCk7XHJcbiAgICB0cmFuc2Zvcm0oYXN0LCBleHRlbmQoe30sIG9wdGlvbnMsIHtcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBub2RlVHJhbnNmb3JtczogW1xyXG4gICAgICAgICAgICAuLi5ub2RlVHJhbnNmb3JtcyxcclxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW10pIC8vIHVzZXIgdHJhbnNmb3Jtc1xyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogZXh0ZW5kKHt9LCBkaXJlY3RpdmVUcmFuc2Zvcm1zLCBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge30gLy8gdXNlciB0cmFuc2Zvcm1zXHJcbiAgICAgICAgKVxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlKGFzdCwgZXh0ZW5kKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnNcclxuICAgIH0pKTtcclxufVxuXG5jb25zdCBub29wRGlyZWN0aXZlVHJhbnNmb3JtID0gKCkgPT4gKHsgcHJvcHM6IFtdIH0pO1xuXG5leHBvcnQgeyBCQVNFX1RSQU5TSVRJT04sIENBTUVMSVpFLCBDQVBJVEFMSVpFLCBDUkVBVEVfQkxPQ0ssIENSRUFURV9DT01NRU5ULCBDUkVBVEVfU0xPVFMsIENSRUFURV9TVEFUSUMsIENSRUFURV9URVhULCBDUkVBVEVfVk5PREUsIEZSQUdNRU5ULCBJU19SRUYsIEtFRVBfQUxJVkUsIE1FUkdFX1BST1BTLCBPUEVOX0JMT0NLLCBQT1BfU0NPUEVfSUQsIFBVU0hfU0NPUEVfSUQsIFJFTkRFUl9MSVNULCBSRU5ERVJfU0xPVCwgUkVTT0xWRV9DT01QT05FTlQsIFJFU09MVkVfRElSRUNUSVZFLCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5ULCBTRVRfQkxPQ0tfVFJBQ0tJTkcsIFNVU1BFTlNFLCBURUxFUE9SVCwgVE9fRElTUExBWV9TVFJJTkcsIFRPX0hBTkRMRVJTLCBUT19IQU5ETEVSX0tFWSwgVU5SRUYsIFdJVEhfQ1RYLCBXSVRIX0RJUkVDVElWRVMsIFdJVEhfU0NPUEVfSUQsIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSwgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uLCBhc3NlcnQsIGJhc2VDb21waWxlLCBiYXNlUGFyc2UsIGJ1aWxkUHJvcHMsIGJ1aWxkU2xvdHMsIGNyZWF0ZUFycmF5RXhwcmVzc2lvbiwgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24sIGNyZWF0ZUJsb2NrU3RhdGVtZW50LCBjcmVhdGVDYWNoZUV4cHJlc3Npb24sIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBjcmVhdGVDb21waWxlckVycm9yLCBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24sIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiwgY3JlYXRlRm9yTG9vcFBhcmFtcywgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uLCBjcmVhdGVJZlN0YXRlbWVudCwgY3JlYXRlSW50ZXJwb2xhdGlvbiwgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbiwgY3JlYXRlT2JqZWN0UHJvcGVydHksIGNyZWF0ZVJldHVyblN0YXRlbWVudCwgY3JlYXRlUm9vdCwgY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uLCBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtLCBjcmVhdGVUZW1wbGF0ZUxpdGVyYWwsIGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQsIGNyZWF0ZVZOb2RlQ2FsbCwgZmluZERpciwgZmluZFByb3AsIGdlbmVyYXRlLCBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0LCBnZXRJbm5lclJhbmdlLCBoYXNEeW5hbWljS2V5VkJpbmQsIGhhc1Njb3BlUmVmLCBoZWxwZXJOYW1lTWFwLCBpbmplY3RQcm9wLCBpc0JpbmRLZXksIGlzQnVpbHRJblR5cGUsIGlzQ29yZUNvbXBvbmVudCwgaXNNZW1iZXJFeHByZXNzaW9uLCBpc1NpbXBsZUlkZW50aWZpZXIsIGlzU2xvdE91dGxldCwgaXNTdGF0aWNFeHAsIGlzVGVtcGxhdGVOb2RlLCBpc1RleHQsIGlzVlNsb3QsIGxvY1N0dWIsIG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sIHByb2Nlc3NFeHByZXNzaW9uLCBwcm9jZXNzRm9yLCBwcm9jZXNzSWYsIHByb2Nlc3NTbG90T3V0bGV0LCByZWdpc3RlclJ1bnRpbWVIZWxwZXJzLCByZXNvbHZlQ29tcG9uZW50VHlwZSwgdG9WYWxpZEFzc2V0SWQsIHRyYWNrU2xvdFNjb3BlcywgdHJhY2tWRm9yU2xvdFNjb3BlcywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1CaW5kLCB0cmFuc2Zvcm1FbGVtZW50LCB0cmFuc2Zvcm1FeHByZXNzaW9uLCB0cmFuc2Zvcm1Nb2RlbCwgdHJhbnNmb3JtT24sIHRyYXZlcnNlTm9kZSB9O1xuIiwiaW1wb3J0IHsgcmVnaXN0ZXJSdW50aW1lSGVscGVycywgaXNCdWlsdEluVHlwZSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbiwgY3JlYXRlQ29tcGlsZXJFcnJvciwgY3JlYXRlT2JqZWN0UHJvcGVydHksIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBUT19ESVNQTEFZX1NUUklORywgdHJhbnNmb3JtTW9kZWwgYXMgdHJhbnNmb3JtTW9kZWwkMSwgZmluZFByb3AsIGhhc0R5bmFtaWNLZXlWQmluZCwgdHJhbnNmb3JtT24gYXMgdHJhbnNmb3JtT24kMSwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBpc1N0YXRpY0V4cCwgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgYmFzZUNvbXBpbGUsIGJhc2VQYXJzZSB9IGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL2NvbXBpbGVyLWNvcmUnO1xuaW1wb3J0IHsgaXNWb2lkVGFnLCBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBtYWtlTWFwLCBwYXJzZVN0cmluZ1N0eWxlLCBjYXBpdGFsaXplLCBleHRlbmQgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IFZfTU9ERUxfUkFESU8gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFJhZGlvYCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9DSEVDS0JPWCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsQ2hlY2tib3hgIDogYGApO1xyXG5jb25zdCBWX01PREVMX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFRleHRgIDogYGApO1xyXG5jb25zdCBWX01PREVMX1NFTEVDVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsU2VsZWN0YCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9EWU5BTUlDID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxEeW5hbWljYCA6IGBgKTtcclxuY29uc3QgVl9PTl9XSVRIX01PRElGSUVSUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk9uTW9kaWZpZXJzR3VhcmRgIDogYGApO1xyXG5jb25zdCBWX09OX1dJVEhfS0VZUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk9uS2V5c0d1YXJkYCA6IGBgKTtcclxuY29uc3QgVl9TSE9XID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2U2hvd2AgOiBgYCk7XHJcbmNvbnN0IFRSQU5TSVRJT04gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRyYW5zaXRpb25gIDogYGApO1xyXG5jb25zdCBUUkFOU0lUSU9OX0dST1VQID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUcmFuc2l0aW9uR3JvdXBgIDogYGApO1xyXG5yZWdpc3RlclJ1bnRpbWVIZWxwZXJzKHtcclxuICAgIFtWX01PREVMX1JBRElPXTogYHZNb2RlbFJhZGlvYCxcclxuICAgIFtWX01PREVMX0NIRUNLQk9YXTogYHZNb2RlbENoZWNrYm94YCxcclxuICAgIFtWX01PREVMX1RFWFRdOiBgdk1vZGVsVGV4dGAsXHJcbiAgICBbVl9NT0RFTF9TRUxFQ1RdOiBgdk1vZGVsU2VsZWN0YCxcclxuICAgIFtWX01PREVMX0RZTkFNSUNdOiBgdk1vZGVsRHluYW1pY2AsXHJcbiAgICBbVl9PTl9XSVRIX01PRElGSUVSU106IGB3aXRoTW9kaWZpZXJzYCxcclxuICAgIFtWX09OX1dJVEhfS0VZU106IGB3aXRoS2V5c2AsXHJcbiAgICBbVl9TSE9XXTogYHZTaG93YCxcclxuICAgIFtUUkFOU0lUSU9OXTogYFRyYW5zaXRpb25gLFxyXG4gICAgW1RSQU5TSVRJT05fR1JPVVBdOiBgVHJhbnNpdGlvbkdyb3VwYFxyXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbmxldCBkZWNvZGVyO1xyXG5mdW5jdGlvbiBkZWNvZGVIdG1sQnJvd3NlcihyYXcpIHtcclxuICAgIChkZWNvZGVyIHx8IChkZWNvZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpKS5pbm5lckhUTUwgPSByYXc7XHJcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudDtcclxufVxuXG5jb25zdCBpc1Jhd1RleHRDb250YWluZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3N0eWxlLGlmcmFtZSxzY3JpcHQsbm9zY3JpcHQnLCB0cnVlKTtcclxuY29uc3QgcGFyc2VyT3B0aW9ucyA9IHtcclxuICAgIGlzVm9pZFRhZyxcclxuICAgIGlzTmF0aXZlVGFnOiB0YWcgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgIGlzUHJlVGFnOiB0YWcgPT4gdGFnID09PSAncHJlJyxcclxuICAgIGRlY29kZUVudGl0aWVzOiBkZWNvZGVIdG1sQnJvd3NlciAsXHJcbiAgICBpc0J1aWx0SW5Db21wb25lbnQ6ICh0YWcpID0+IHtcclxuICAgICAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsIGBUcmFuc2l0aW9uYCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT047XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbkdyb3VwYCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT05fR1JPVVA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0cmVlLWNvbnN0cnVjdGlvbi1kaXNwYXRjaGVyXHJcbiAgICBnZXROYW1lc3BhY2UodGFnLCBwYXJlbnQpIHtcclxuICAgICAgICBsZXQgbnMgPSBwYXJlbnQgPyBwYXJlbnQubnMgOiAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiBucyA9PT0gMiAvKiBNQVRIX01MICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQudGFnID09PSAnYW5ub3RhdGlvbi14bWwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNWRyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucHJvcHMuc29tZShhID0+IGEudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICBhLm5hbWUgPT09ICdlbmNvZGluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBhLnZhbHVlICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICAoYS52YWx1ZS5jb250ZW50ID09PSAndGV4dC9odG1sJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnZhbHVlLmNvbnRlbnQgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBucyA9IDAgLyogSFRNTCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgvXm0oPzpbaW9uc118dGV4dCkkLy50ZXN0KHBhcmVudC50YWcpICYmXHJcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtZ2x5cGgnICYmXHJcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtYWxpZ25tYXJrJykge1xyXG4gICAgICAgICAgICAgICAgbnMgPSAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyZW50ICYmIG5zID09PSAxIC8qIFNWRyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAnZGVzYycgfHxcclxuICAgICAgICAgICAgICAgIHBhcmVudC50YWcgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBIVE1MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChucyA9PT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTVkcgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBNQVRIX01MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBucztcclxuICAgIH0sXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcGFyc2luZy1odG1sLWZyYWdtZW50c1xyXG4gICAgZ2V0VGV4dE1vZGUoeyB0YWcsIG5zIH0pIHtcclxuICAgICAgICBpZiAobnMgPT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICBpZiAodGFnID09PSAndGV4dGFyZWEnIHx8IHRhZyA9PT0gJ3RpdGxlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogUkNEQVRBICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Jhd1RleHRDb250YWluZXIodGFnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogUkFXVEVYVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMCAvKiBEQVRBICovO1xyXG4gICAgfVxyXG59O1xuXG4vLyBQYXJzZSBpbmxpbmUgQ1NTIHN0cmluZ3MgZm9yIHN0YXRpYyBzdHlsZSBhdHRyaWJ1dGVzIGludG8gYW4gb2JqZWN0LlxyXG4vLyBUaGlzIGlzIGEgTm9kZVRyYW5zZm9ybSBzaW5jZSBpdCB3b3JrcyBvbiB0aGUgc3RhdGljIGBzdHlsZWAgYXR0cmlidXRlIGFuZFxyXG4vLyBjb252ZXJ0cyBpdCBpbnRvIGEgZHluYW1pYyBlcXVpdmFsZW50OlxyXG4vLyBzdHlsZT1cImNvbG9yOiByZWRcIiAtPiA6c3R5bGU9J3sgXCJjb2xvclwiOiBcInJlZFwiIH0nXHJcbi8vIEl0IGlzIHRoZW4gcHJvY2Vzc2VkIGJ5IGB0cmFuc2Zvcm1FbGVtZW50YCBhbmQgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZFxyXG4vLyBwcm9wcy5cclxuY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBub2RlID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdzdHlsZScgJiYgcC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwIHdpdGggYW4gZXhwcmVzc2lvbiBub2RlXHJcbiAgICAgICAgICAgICAgICBub2RlLnByb3BzW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogRElSRUNUSVZFICovLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGBiaW5kYCxcclxuICAgICAgICAgICAgICAgICAgICBhcmc6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHN0eWxlYCwgdHJ1ZSwgcC5sb2MpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cDogcGFyc2VJbmxpbmVDU1MocC52YWx1ZS5jb250ZW50LCBwLmxvYyksXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBsb2M6IHAubG9jXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHBhcnNlSW5saW5lQ1NTID0gKGNzc1RleHQsIGxvYykgPT4ge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCk7XHJcbiAgICByZXR1cm4gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihKU09OLnN0cmluZ2lmeShub3JtYWxpemVkKSwgZmFsc2UsIGxvYywgMyAvKiBDQU5fU1RSSU5HSUZZICovKTtcclxufTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MpIHtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlID8gRE9NRXJyb3JNZXNzYWdlcyA6IHVuZGVmaW5lZCk7XHJcbn1cclxuY29uc3QgRE9NRXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIFs0OSAvKiBYX1ZfSFRNTF9OT19FWFBSRVNTSU9OICovXTogYHYtaHRtbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1MCAvKiBYX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovXTogYHYtaHRtbCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcclxuICAgIFs1MSAvKiBYX1ZfVEVYVF9OT19FWFBSRVNTSU9OICovXTogYHYtdGV4dCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1MiAvKiBYX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovXTogYHYtdGV4dCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcclxuICAgIFs1MyAvKiBYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2FuIG9ubHkgYmUgdXNlZCBvbiA8aW5wdXQ+LCA8dGV4dGFyZWE+IGFuZCA8c2VsZWN0PiBlbGVtZW50cy5gLFxyXG4gICAgWzU0IC8qIFhfVl9NT0RFTF9BUkdfT05fRUxFTUVOVCAqL106IGB2LW1vZGVsIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gcGxhaW4gZWxlbWVudHMuYCxcclxuICAgIFs1NSAvKiBYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gZmlsZSBpbnB1dHMgc2luY2UgdGhleSBhcmUgcmVhZC1vbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLmAsXHJcbiAgICBbNTYgLyogWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovXTogYFVubmVjZXNzYXJ5IHZhbHVlIGJpbmRpbmcgdXNlZCBhbG9uZ3NpZGUgdi1tb2RlbC4gSXQgd2lsbCBpbnRlcmZlcmUgd2l0aCB2LW1vZGVsJ3MgYmVoYXZpb3IuYCxcclxuICAgIFs1NyAvKiBYX1ZfU0hPV19OT19FWFBSRVNTSU9OICovXTogYHYtc2hvdyBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1OCAvKiBYX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqL106IGA8VHJhbnNpdGlvbj4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50IG9yIGNvbXBvbmVudC5gLFxyXG4gICAgWzU5IC8qIFhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUcgKi9dOiBgVGFncyB3aXRoIHNpZGUgZWZmZWN0ICg8c2NyaXB0PiBhbmQgPHN0eWxlPikgYXJlIGlnbm9yZWQgaW4gY2xpZW50IGNvbXBvbmVudCB0ZW1wbGF0ZXMuYFxyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WSHRtbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNDkgLyogWF9WX0hUTUxfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MCAvKiBYX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGlubmVySFRNTGAsIHRydWUsIGxvYyksIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WVGV4dCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTEgLyogWF9WX1RFWFRfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MiAvKiBYX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRleHRDb250ZW50YCwgdHJ1ZSksIGV4cFxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlclN0cmluZyhUT19ESVNQTEFZX1NUUklORyksIFtleHBdLCBsb2MpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUpKVxyXG4gICAgICAgIF1cclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHRyYW5zZm9ybU1vZGVsID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgYmFzZVJlc3VsdCA9IHRyYW5zZm9ybU1vZGVsJDEoZGlyLCBub2RlLCBjb250ZXh0KTtcclxuICAgIC8vIGJhc2UgdHJhbnNmb3JtIGhhcyBlcnJvcnMgT1IgY29tcG9uZW50IHYtbW9kZWwgKG9ubHkgbmVlZCBwcm9wcylcclxuICAgIGlmICghYmFzZVJlc3VsdC5wcm9wcy5sZW5ndGggfHwgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaWYgKGRpci5hcmcpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NCAvKiBYX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi8sIGRpci5hcmcubG9jKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGZpbmRQcm9wKG5vZGUsICd2YWx1ZScpO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NiAvKiBYX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUUgKi8sIHZhbHVlLmxvYykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHsgdGFnIH0gPSBub2RlO1xyXG4gICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gY29udGV4dC5pc0N1c3RvbUVsZW1lbnQodGFnKTtcclxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHxcclxuICAgICAgICB0YWcgPT09ICd0ZXh0YXJlYScgfHxcclxuICAgICAgICB0YWcgPT09ICdzZWxlY3QnIHx8XHJcbiAgICAgICAgaXNDdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9URVhUO1xyXG4gICAgICAgIGxldCBpc0ludmFsaWRUeXBlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGZpbmRQcm9wKG5vZGUsIGB0eXBlYCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZS50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDp0eXBlPVwiZm9vXCJcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUudmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfUkFESU87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0NIRUNLQk9YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkVHlwZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NSAvKiBYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRleHQgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGhhcyBiaW5kaW5ncyB3aXRoIGR5bmFtaWMga2V5cywgd2hpY2ggY2FuIHBvc3NpYmx5IGNvbnRhaW5cclxuICAgICAgICAgICAgICAgIC8vIFwidHlwZVwiLlxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0ZXh0IHR5cGVcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1NFTEVDVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRleHRhcmVhXHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgcnVudGltZSBkaXJlY3RpdmVcclxuICAgICAgICAvLyBieSByZXR1cm5pbmcgdGhlIGhlbHBlciBzeW1ib2wgdmlhIG5lZWRSdW50aW1lXHJcbiAgICAgICAgLy8gdGhlIGltcG9ydCB3aWxsIHJlcGxhY2VkIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxyXG4gICAgICAgIGlmICghaXNJbnZhbGlkVHlwZSkge1xyXG4gICAgICAgICAgICBiYXNlUmVzdWx0Lm5lZWRSdW50aW1lID0gY29udGV4dC5oZWxwZXIoZGlyZWN0aXZlVG9Vc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUzIC8qIFhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlQgKi8sIGRpci5sb2MpKTtcclxuICAgIH1cclxuICAgIC8vIG5hdGl2ZSB2bW9kZWwgZG9lc24ndCBuZWVkIHRoZSBgbW9kZWxWYWx1ZWAgcHJvcHMgc2luY2UgdGhleSBhcmUgYWxzb1xyXG4gICAgLy8gcGFzc2VkIHRvIHRoZSBydW50aW1lIGFzIGBiaW5kaW5nLnZhbHVlYC4gcmVtb3ZpbmcgaXQgcmVkdWNlcyBjb2RlIHNpemUuXHJcbiAgICBiYXNlUmVzdWx0LnByb3BzID0gYmFzZVJlc3VsdC5wcm9wcy5maWx0ZXIocCA9PiAhKHAua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICBwLmtleS5jb250ZW50ID09PSAnbW9kZWxWYWx1ZScpKTtcclxuICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG59O1xuXG5jb25zdCBpc0V2ZW50T3B0aW9uTW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHBhc3NpdmUsb25jZSxjYXB0dXJlYCk7XHJcbmNvbnN0IGlzTm9uS2V5TW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIGV2ZW50IHByb3BhZ2F0aW9uIG1hbmFnZW1lbnRcclxuYHN0b3AscHJldmVudCxzZWxmLGAgK1xyXG4gICAgLy8gc3lzdGVtIG1vZGlmaWVycyArIGV4YWN0XHJcbiAgICBgY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCxgICtcclxuICAgIC8vIG1vdXNlXHJcbiAgICBgbWlkZGxlYCk7XHJcbi8vIGxlZnQgJiByaWdodCBjb3VsZCBiZSBtb3VzZSBvciBrZXkgbW9kaWZpZXJzIGJhc2VkIG9uIGV2ZW50IHR5cGVcclxuY29uc3QgbWF5YmVLZXlNb2RpZmllciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnbGVmdCxyaWdodCcpO1xyXG5jb25zdCBpc0tleWJvYXJkRXZlbnQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYG9ua2V5dXAsb25rZXlkb3duLG9ua2V5cHJlc3NgLCB0cnVlKTtcclxuY29uc3QgcmVzb2x2ZU1vZGlmaWVycyA9IChrZXksIG1vZGlmaWVycykgPT4ge1xyXG4gICAgY29uc3Qga2V5TW9kaWZpZXJzID0gW107XHJcbiAgICBjb25zdCBub25LZXlNb2RpZmllcnMgPSBbXTtcclxuICAgIGNvbnN0IGV2ZW50T3B0aW9uTW9kaWZpZXJzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gbW9kaWZpZXJzW2ldO1xyXG4gICAgICAgIGlmIChpc0V2ZW50T3B0aW9uTW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgIC8vIGV2ZW50T3B0aW9uTW9kaWZpZXJzOiBtb2RpZmllcnMgZm9yIGFkZEV2ZW50TGlzdGVuZXIoKSBvcHRpb25zLFxyXG4gICAgICAgICAgICAvLyBlLmcuIC5wYXNzaXZlICYgLmNhcHR1cmVcclxuICAgICAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBydW50aW1lTW9kaWZpZXJzOiBtb2RpZmllcnMgdGhhdCBuZWVkcyBydW50aW1lIGd1YXJkc1xyXG4gICAgICAgICAgICBpZiAobWF5YmVLZXlNb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOb25LZXlNb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGtleU1vZGlmaWVycyxcclxuICAgICAgICBub25LZXlNb2RpZmllcnMsXHJcbiAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnNcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IHRyYW5zZm9ybUNsaWNrID0gKGtleSwgZXZlbnQpID0+IHtcclxuICAgIGNvbnN0IGlzU3RhdGljQ2xpY2sgPSBpc1N0YXRpY0V4cChrZXkpICYmIGtleS5jb250ZW50LnRvTG93ZXJDYXNlKCkgPT09ICdvbmNsaWNrJztcclxuICAgIHJldHVybiBpc1N0YXRpY0NsaWNrXHJcbiAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGV2ZW50LCB0cnVlKVxyXG4gICAgICAgIDoga2V5LnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi9cclxuICAgICAgICAgICAgPyBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgYChgLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgYCkgPT09IFwib25DbGlja1wiID8gXCIke2V2ZW50fVwiIDogKGAsXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBgKWBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgOiBrZXk7XHJcbn07XHJcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHRyYW5zZm9ybU9uJDEoZGlyLCBub2RlLCBjb250ZXh0LCBiYXNlUmVzdWx0ID0+IHtcclxuICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0gZGlyO1xyXG4gICAgICAgIGlmICghbW9kaWZpZXJzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIGJhc2VSZXN1bHQ7XHJcbiAgICAgICAgbGV0IHsga2V5LCB2YWx1ZTogaGFuZGxlckV4cCB9ID0gYmFzZVJlc3VsdC5wcm9wc1swXTtcclxuICAgICAgICBjb25zdCB7IGtleU1vZGlmaWVycywgbm9uS2V5TW9kaWZpZXJzLCBldmVudE9wdGlvbk1vZGlmaWVycyB9ID0gcmVzb2x2ZU1vZGlmaWVycyhrZXksIG1vZGlmaWVycyk7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXHJcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5pbmNsdWRlcygncmlnaHQnKSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbkNvbnRleHRtZW51YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ21pZGRsZScpKSB7XHJcbiAgICAgICAgICAgIGtleSA9IHRyYW5zZm9ybUNsaWNrKGtleSwgYG9uTW91c2V1cGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoVl9PTl9XSVRIX01PRElGSUVSUyksIFtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShub25LZXlNb2RpZmllcnMpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyBpZiBldmVudCBuYW1lIGlzIGR5bmFtaWMsIGFsd2F5cyB3cmFwIHdpdGgga2V5cyBndWFyZFxyXG4gICAgICAgICAgICAoIWlzU3RhdGljRXhwKGtleSkgfHwgaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50KSkpIHtcclxuICAgICAgICAgICAgaGFuZGxlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9LRVlTKSwgW1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlckV4cCxcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGtleU1vZGlmaWVycylcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudE9wdGlvbk1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXJQb3N0Zml4ID0gZXZlbnRPcHRpb25Nb2RpZmllcnMubWFwKGNhcGl0YWxpemUpLmpvaW4oJycpO1xyXG4gICAgICAgICAgICBrZXkgPSBpc1N0YXRpY0V4cChrZXkpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5LmNvbnRlbnR9JHttb2RpZmllclBvc3RmaXh9YCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtgKGAsIGtleSwgYCkgKyBcIiR7bW9kaWZpZXJQb3N0Zml4fVwiYF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgaGFuZGxlckV4cCldXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1TaG93ID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xyXG4gICAgaWYgKCFleHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NyAvKiBYX1ZfU0hPV19OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtdLFxyXG4gICAgICAgIG5lZWRSdW50aW1lOiBjb250ZXh0LmhlbHBlcihWX1NIT1cpXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB3YXJuVHJhbnNpdGlvbkNoaWxkcmVuID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudChub2RlLnRhZyk7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gVFJBTlNJVElPTikge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmIGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1OCAvKiBYX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5jaGlsZHJlblswXS5sb2Muc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpIHtcclxuICAgIC8vICMxMzUyIGZpbHRlciBvdXQgcG90ZW50aWFsIGNvbW1lbnQgbm9kZXMuXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IChub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5maWx0ZXIoYyA9PiBjLnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykpO1xyXG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8XHJcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovIHx8XHJcbiAgICAgICAgKGNoaWxkLnR5cGUgPT09IDkgLyogSUYgKi8gJiYgY2hpbGQuYnJhbmNoZXMuc29tZShoYXNNdWx0aXBsZUNoaWxkcmVuKSkpO1xyXG59XG5cbmNvbnN0IGlnbm9yZVNpZGVFZmZlY3RUYWdzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgKG5vZGUudGFnID09PSAnc2NyaXB0JyB8fCBub2RlLnRhZyA9PT0gJ3N0eWxlJykpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1OSAvKiBYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHICovLCBub2RlLmxvYykpO1xyXG4gICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCBET01Ob2RlVHJhbnNmb3JtcyA9IFtcclxuICAgIHRyYW5zZm9ybVN0eWxlLFxyXG4gICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IFt3YXJuVHJhbnNpdGlvbkNoaWxkcmVuXSA6IFtdKVxyXG5dO1xyXG5jb25zdCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zID0ge1xyXG4gICAgY2xvYWs6IG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sXHJcbiAgICBodG1sOiB0cmFuc2Zvcm1WSHRtbCxcclxuICAgIHRleHQ6IHRyYW5zZm9ybVZUZXh0LFxyXG4gICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsLFxyXG4gICAgb246IHRyYW5zZm9ybU9uLFxyXG4gICAgc2hvdzogdHJhbnNmb3JtU2hvd1xyXG59O1xyXG5mdW5jdGlvbiBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZXh0ZW5kKHt9LCBwYXJzZXJPcHRpb25zLCBvcHRpb25zLCB7XHJcbiAgICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcclxuICAgICAgICAgICAgLy8gaWdub3JlIDxzY3JpcHQ+IGFuZCA8dGFnPlxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBwdXQgaW5zaWRlIERPTU5vZGVUcmFuc2Zvcm1zIGJlY2F1c2UgdGhhdCBsaXN0IGlzIHVzZWRcclxuICAgICAgICAgICAgLy8gYnkgY29tcGlsZXItc3NyIHRvIGdlbmVyYXRlIHZub2RlIGZhbGxiYWNrIGJyYW5jaGVzXHJcbiAgICAgICAgICAgIGlnbm9yZVNpZGVFZmZlY3RUYWdzLFxyXG4gICAgICAgICAgICAuLi5ET01Ob2RlVHJhbnNmb3JtcyxcclxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW10pXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBleHRlbmQoe30sIERPTURpcmVjdGl2ZVRyYW5zZm9ybXMsIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fSksXHJcbiAgICAgICAgdHJhbnNmb3JtSG9pc3Q6IG51bGwgXHJcbiAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIGJhc2VQYXJzZSh0ZW1wbGF0ZSwgZXh0ZW5kKHt9LCBwYXJzZXJPcHRpb25zLCBvcHRpb25zKSk7XHJcbn1cblxuZXhwb3J0IHsgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcywgRE9NTm9kZVRyYW5zZm9ybXMsIFRSQU5TSVRJT04sIFRSQU5TSVRJT05fR1JPVVAsIFZfTU9ERUxfQ0hFQ0tCT1gsIFZfTU9ERUxfRFlOQU1JQywgVl9NT0RFTF9SQURJTywgVl9NT0RFTF9TRUxFQ1QsIFZfTU9ERUxfVEVYVCwgVl9PTl9XSVRIX0tFWVMsIFZfT05fV0lUSF9NT0RJRklFUlMsIFZfU0hPVywgY29tcGlsZSwgY3JlYXRlRE9NQ29tcGlsZXJFcnJvciwgcGFyc2UsIHBhcnNlck9wdGlvbnMsIHRyYW5zZm9ybVN0eWxlIH07XG4iLCJpbXBvcnQgKiBhcyBydW50aW1lRG9tIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuaW1wb3J0IHsgaW5pdEN1c3RvbUZvcm1hdHRlciwgd2FybiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuaW1wb3J0IHsgY29tcGlsZSB9IGZyb20gJ0B2dWUvY29tcGlsZXItZG9tJztcbmltcG9ydCB7IGlzU3RyaW5nLCBOT09QLCBleHRlbmQsIGdlbmVyYXRlQ29kZUZyYW1lIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiBpbml0RGV2KCkge1xyXG4gICAge1xyXG4gICAgICAgIGluaXRDdXN0b21Gb3JtYXR0ZXIoKTtcclxuICAgIH1cclxufVxuXG4vLyBUaGlzIGVudHJ5IGlzIHRoZSBcImZ1bGwtYnVpbGRcIiB0aGF0IGluY2x1ZGVzIGJvdGggdGhlIHJ1bnRpbWVcclxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgaW5pdERldigpO1xyXG59XHJcbmNvbnN0IGNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9uKHRlbXBsYXRlLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoIWlzU3RyaW5nKHRlbXBsYXRlKSkge1xyXG4gICAgICAgIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjogYCwgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gTk9PUDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXkgPSB0ZW1wbGF0ZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNvbXBpbGVDYWNoZVtrZXldO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAodGVtcGxhdGVbMF0gPT09ICcjJykge1xyXG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0ZW1wbGF0ZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZWwpIHtcclxuICAgICAgICAgICAgd2FybihgVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6ICR7dGVtcGxhdGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIF9fVU5TQUZFX19cclxuICAgICAgICAvLyBSZWFzb246IHBvdGVudGlhbCBleGVjdXRpb24gb2YgSlMgZXhwcmVzc2lvbnMgaW4gaW4tRE9NIHRlbXBsYXRlLlxyXG4gICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQncyByZW5kZXJlZFxyXG4gICAgICAgIC8vIGJ5IHRoZSBzZXJ2ZXIsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgbm90IGNvbnRhaW4gYW55IHVzZXIgZGF0YS5cclxuICAgICAgICB0ZW1wbGF0ZSA9IGVsID8gZWwuaW5uZXJIVE1MIDogYGA7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGNvZGUgfSA9IGNvbXBpbGUodGVtcGxhdGUsIGV4dGVuZCh7XHJcbiAgICAgICAgaG9pc3RTdGF0aWM6IHRydWUsXHJcbiAgICAgICAgb25FcnJvcihlcnIpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBUZW1wbGF0ZSBjb21waWxhdGlvbiBlcnJvcjogJHtlcnIubWVzc2FnZX1gO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZUZyYW1lID0gZXJyLmxvYyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlcnIubG9jLnN0YXJ0Lm9mZnNldCwgZXJyLmxvYy5lbmQub2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHdhcm4oY29kZUZyYW1lID8gYCR7bWVzc2FnZX1cXG4ke2NvZGVGcmFtZX1gIDogbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgb3B0aW9ucykpO1xyXG4gICAgLy8gVGhlIHdpbGRjYXJkIGltcG9ydCByZXN1bHRzIGluIGEgaHVnZSBvYmplY3Qgd2l0aCBldmVyeSBleHBvcnRcclxuICAgIC8vIHdpdGgga2V5cyB0aGF0IGNhbm5vdCBiZSBtYW5nbGVkLCBhbmQgY2FuIGJlIHF1aXRlIGhlYXZ5IHNpemUtd2lzZS5cclxuICAgIC8vIEluIHRoZSBnbG9iYWwgYnVpbGQgd2Uga25vdyBgVnVlYCBpcyBhdmFpbGFibGUgZ2xvYmFsbHkgc28gd2UgY2FuIGF2b2lkXHJcbiAgICAvLyB0aGUgd2lsZGNhcmQgb2JqZWN0LlxyXG4gICAgY29uc3QgcmVuZGVyID0gKG5ldyBGdW5jdGlvbignVnVlJywgY29kZSkocnVudGltZURvbSkpO1xyXG4gICAgcmVuZGVyLl9yYyA9IHRydWU7XHJcbiAgICByZXR1cm4gKGNvbXBpbGVDYWNoZVtrZXldID0gcmVuZGVyKTtcclxufVxyXG5yZWdpc3RlclJ1bnRpbWVDb21waWxlcihjb21waWxlVG9GdW5jdGlvbik7XG5cbmV4cG9ydCB7IGNvbXBpbGVUb0Z1bmN0aW9uIGFzIGNvbXBpbGUgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return EMPTY_ARR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return EMPTY_OBJ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return NO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return NOOP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return PatchFlagNames; });\n/* unused harmony export babelParserDefaultPlugins */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return camelize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return capitalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return def; });\n/* unused harmony export escapeHtml */\n/* unused harmony export escapeHtmlComment */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return extend; });\n/* unused harmony export generateCodeFrame */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return getGlobalThis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return hasChanged; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return hasOwn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return hyphenate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return invokeArrayFns; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return isArray; });\n/* unused harmony export isBooleanAttr */\n/* unused harmony export isDate */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return isGloballyWhitelisted; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return isHTMLTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return isIntegerKey; });\n/* unused harmony export isKnownAttr */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return isMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return isModelListener; });\n/* unused harmony export isNoUnitNumericStyleProp */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return isOn; });\n/* unused harmony export isPlainObject */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return isPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return isReservedProp; });\n/* unused harmony export isSSRSafeAttrName */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return isSVGTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return isSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return isSpecialBooleanAttr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return isSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return isVoidTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return looseEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return looseIndexOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return makeMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I\", function() { return normalizeClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"J\", function() { return normalizeStyle; });\n/* unused harmony export objectToString */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"K\", function() { return parseStringStyle; });\n/* unused harmony export propsToAttrMap */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"L\", function() { return remove; });\n/* unused harmony export slotFlagsText */\n/* unused harmony export stringifyStyle */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"M\", function() { return toDisplayString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N\", function() { return toHandlerKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"O\", function() { return toNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"P\", function() { return toRawType; });\n/* unused harmony export toTypeString */\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    const lines = source.split(/\\r?\\n/);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - lineLength) + 1;\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.substring(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|\x3c!--|--\x3e|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isObject(val)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nconst babelParserDefaultPlugins = [\r\n    'bigInt',\r\n    'optionalChaining',\r\n    'nullishCoalescingOperator'\r\n];\r\nconst EMPTY_OBJ = ( false)\r\n    ? undefined\r\n    : {};\r\nconst EMPTY_ARR = ( false) ? undefined : [];\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => val instanceof Date;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanM/OWZmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxFQUFFLGlEQUFpRCxLQUFLLFNBQVM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRW92QiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxyXG4gKiBpcyBpbiB0aGF0IG1hcC5cclxuICogSU1QT1JUQU5UOiBhbGwgY2FsbHMgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHByZWZpeGVkIHdpdGhcclxuICogXFwvXFwqI1xcX1xcX1BVUkVcXF9cXF9cXCpcXC9cclxuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xyXG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gISFtYXBbdmFsXTtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcclxuICovXHJcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xyXG4gICAgWzEgLyogVEVYVCAqL106IGBURVhUYCxcclxuICAgIFsyIC8qIENMQVNTICovXTogYENMQVNTYCxcclxuICAgIFs0IC8qIFNUWUxFICovXTogYFNUWUxFYCxcclxuICAgIFs4IC8qIFBST1BTICovXTogYFBST1BTYCxcclxuICAgIFsxNiAvKiBGVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxyXG4gICAgWzMyIC8qIEhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcclxuICAgIFs2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcclxuICAgIFsxMjggLyogS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzUxMiAvKiBORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxyXG4gICAgWzEwMjQgLyogRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcclxuICAgIFsyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcclxuICAgIFstMSAvKiBIT0lTVEVEICovXTogYEhPSVNURURgLFxyXG4gICAgWy0yIC8qIEJBSUwgKi9dOiBgQkFJTGBcclxufTtcblxuLyoqXHJcbiAqIERldiBvbmx5XHJcbiAqL1xyXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xyXG4gICAgWzEgLyogU1RBQkxFICovXTogJ1NUQUJMRScsXHJcbiAgICBbMiAvKiBEWU5BTUlDICovXTogJ0RZTkFNSUMnLFxyXG4gICAgWzMgLyogRk9SV0FSREVEICovXTogJ0ZPUldBUkRFRCdcclxufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSwnICtcclxuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xyXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcclxuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xyXG4gICAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtsaW5lfSR7JyAnLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KDEsIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XHJcbn1cblxuLyoqXHJcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XHJcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcclxuICogLSBpdGVtc2NvcGUgLT4gTi9BXHJcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxyXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXHJcbiAqIC0gaXNtYXAgLT4gaXNNYXBcclxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxyXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxyXG4gKiAtIHJlYWRvbmx5IC0+IHJlYWRPbmx5XHJcbiAqL1xyXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XHJcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xyXG4vKipcclxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxyXG4gKi9cclxuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcclxuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xyXG4gICAgYGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsYCArXHJcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xyXG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XHJcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xyXG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xyXG4gICAgaWYgKGlzVW5zYWZlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xyXG59XHJcbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xyXG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcclxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcclxuICAgIGh0bWxGb3I6ICdmb3InLFxyXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcclxufTtcclxuLyoqXHJcbiAqIENTUyBwcm9wZXJ0aWVzIHRoYXQgYWNjZXB0IHBsYWluIG51bWJlcnNcclxuICovXHJcbmNvbnN0IGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCxib3JkZXItaW1hZ2Utb3V0c2V0LGJvcmRlci1pbWFnZS1zbGljZSxgICtcclxuICAgIGBib3JkZXItaW1hZ2Utd2lkdGgsYm94LWZsZXgsYm94LWZsZXgtZ3JvdXAsYm94LW9yZGluYWwtZ3JvdXAsY29sdW1uLWNvdW50LGAgK1xyXG4gICAgYGNvbHVtbnMsZmxleCxmbGV4LWdyb3csZmxleC1wb3NpdGl2ZSxmbGV4LXNocmluayxmbGV4LW5lZ2F0aXZlLGZsZXgtb3JkZXIsYCArXHJcbiAgICBgZ3JpZC1yb3csZ3JpZC1yb3ctZW5kLGdyaWQtcm93LXNwYW4sZ3JpZC1yb3ctc3RhcnQsZ3JpZC1jb2x1bW4sYCArXHJcbiAgICBgZ3JpZC1jb2x1bW4tZW5kLGdyaWQtY29sdW1uLXNwYW4sZ3JpZC1jb2x1bW4tc3RhcnQsZm9udC13ZWlnaHQsbGluZS1jbGFtcCxgICtcclxuICAgIGBsaW5lLWhlaWdodCxvcGFjaXR5LG9yZGVyLG9ycGhhbnMsdGFiLXNpemUsd2lkb3dzLHotaW5kZXgsem9vbSxgICtcclxuICAgIC8vIFNWR1xyXG4gICAgYGZpbGwtb3BhY2l0eSxmbG9vZC1vcGFjaXR5LHN0b3Atb3BhY2l0eSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LGAgK1xyXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aGApO1xyXG4vKipcclxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcclxuICogc28gdGhhdCB3ZSBkb24ndCBzdHJpbmdpZnkgYmluZGluZ3MgdGhhdCBjYW5ub3QgYmUgc2V0IGZyb20gSFRNTC5cclxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcclxuICovXHJcbmNvbnN0IGlzS25vd25BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYCArXHJcbiAgICBgYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYCArXHJcbiAgICBgYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsYCArXHJcbiAgICBgY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGAgK1xyXG4gICAgYGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGAgK1xyXG4gICAgYGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxgICtcclxuICAgIGBmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGAgK1xyXG4gICAgYGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGludGVncml0eSxgICtcclxuICAgIGBpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csYCArXHJcbiAgICBgbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxgICtcclxuICAgIGBvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHksYCArXHJcbiAgICBgcmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxgICtcclxuICAgIGBzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsYCArXHJcbiAgICBgc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsYCArXHJcbiAgICBgdmFsdWUsd2lkdGgsd3JhcGApO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHlsZShpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBpdGVtKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XHJcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOiguKykvO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcclxuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcclxuICAgIGxldCByZXQgPSAnJztcclxuICAgIGlmICghc3R5bGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05vVW5pdE51bWVyaWNTdHlsZVByb3Aobm9ybWFsaXplZEtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xyXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcclxufVxuXG4vLyBUaGVzZSB0YWcgY29uZmlncyBhcmUgc2hhcmVkIGJldHdlZW4gY29tcGlsZXItZG9tIGFuZCBydW50aW1lLWRvbSwgc28gdGhleVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcclxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXHJcbiAgICAnaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbiwnICtcclxuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcclxuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXHJcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcclxuICAgICdjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsJyArXHJcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xyXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXHJcbiAgICAnc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCc7XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XHJcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcclxuICAgICdkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLCcgK1xyXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXHJcbiAgICAnZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXHJcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcclxuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xyXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcclxuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXHJcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcclxuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xyXG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xyXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcclxuY29uc3QgaXNTVkdUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoU1ZHX1RBR1MpO1xyXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xyXG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XHJcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgbGV0IGh0bWwgPSAnJztcclxuICAgIGxldCBlc2NhcGVkO1xyXG4gICAgbGV0IGluZGV4O1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XHJcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgaHRtbCArPSBlc2NhcGVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XHJcbn1cclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1Mi9zeW50YXguaHRtbCNjb21tZW50c1xyXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcclxuICAgIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgJycpO1xyXG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XHJcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBlcXVhbCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXF1YWw7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xyXG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXHJcbiAgICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xyXG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xyXG4gICAgICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAoIWFIYXNLZXkgJiYgYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoaXRlbSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiB2YWwgPT0gbnVsbFxyXG4gICAgICAgID8gJydcclxuICAgICAgICA6IGlzT2JqZWN0KHZhbClcclxuICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxyXG4gICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xyXG59O1xyXG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcclxuICAgIGlmIChpc01hcCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcblxuLyoqXHJcbiAqIExpc3Qgb2YgQGJhYmVsL3BhcnNlciBwbHVnaW5zIHRoYXQgYXJlIHVzZWQgZm9yIHRlbXBsYXRlIGV4cHJlc3Npb25cclxuICogdHJhbnNmb3JtcyBhbmQgU0ZDIHNjcmlwdCB0cmFuc2Zvcm1zLiBCeSBkZWZhdWx0IHdlIGVuYWJsZSBwcm9wb3NhbHMgc2xhdGVkXHJcbiAqIGZvciBFUzIwMjAuIFRoaXMgd2lsbCBuZWVkIHRvIGJlIHVwZGF0ZWQgYXMgdGhlIHNwZWMgbW92ZXMgZm9yd2FyZC5cclxuICogRnVsbCBsaXN0IGF0IGh0dHBzOi8vYmFiZWxqcy5pby9kb2NzL2VuL25leHQvYmFiZWwtcGFyc2VyI3BsdWdpbnNcclxuICovXHJcbmNvbnN0IGJhYmVsUGFyc2VyRGVmYXVsdFBsdWdpbnMgPSBbXHJcbiAgICAnYmlnSW50JyxcclxuICAgICdvcHRpb25hbENoYWluaW5nJyxcclxuICAgICdudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yJ1xyXG5dO1xyXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XHJcbi8qKlxyXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcclxuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xyXG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XHJcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcclxuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcclxuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcclxuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xyXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgTWFwXSc7XHJcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xyXG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB2YWwgaW5zdGFuY2VvZiBEYXRlO1xyXG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcclxuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcclxuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJztcclxuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XHJcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcclxufTtcclxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcclxuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcclxuICAgIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxufTtcclxuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcclxuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJlxyXG4gICAga2V5ICE9PSAnTmFOJyAmJlxyXG4gICAga2V5WzBdICE9PSAnLScgJiZcclxuICAgICcnICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcclxuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcclxuJyxrZXkscmVmLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCwnICtcclxuICAgICdvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWQnKTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiAoc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKSk7XHJcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXHJcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiB2YWx1ZSAhPT0gb2xkVmFsdWUgJiYgKHZhbHVlID09PSB2YWx1ZSB8fCBvbGRWYWx1ZSA9PT0gb2xkVmFsdWUpO1xyXG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbnNbaV0oYXJnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufTtcclxubGV0IF9nbG9iYWxUaGlzO1xyXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxyXG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcclxufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/layouts/Main.vue?vue&type=template&id=1642422d\n\nvar _hoisted_1 = {\n  "class": "navbar-container"\n};\nvar _hoisted_2 = {\n  "class": "navbar"\n};\n\nvar _hoisted_3 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createTextVNode */])("Home");\n\nvar _hoisted_4 = {\n  style: {\n    "float": "right"\n  }\n};\n\nvar _hoisted_5 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createTextVNode */])("About");\n\nvar _hoisted_6 = {\n  "class": "main-layout"\n};\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_v_link = Object(vue_esm_bundler["k" /* resolveComponent */])("v-link");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(vue_esm_bundler["a" /* Fragment */], null, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [Object(vue_esm_bundler["f" /* createVNode */])("ul", _hoisted_2, [Object(vue_esm_bundler["f" /* createVNode */])("li", null, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n    href: "/"\n  }, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [_hoisted_3];\n    }),\n    _: 1\n    /* STABLE */\n\n  })]), Object(vue_esm_bundler["f" /* createVNode */])("li", _hoisted_4, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n    href: "/about"\n  }, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [_hoisted_5];\n    }),\n    _: 1\n    /* STABLE */\n\n  })])])]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_6, [Object(vue_esm_bundler["j" /* renderSlot */])(_ctx.$slots, "default")])], 64\n  /* STABLE_FRAGMENT */\n  );\n}\n// CONCATENATED MODULE: ./src/layouts/Main.vue?vue&type=template&id=1642422d\n\n// EXTERNAL MODULE: ./src/components/VLink.vue + 4 modules\nvar VLink = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/layouts/Main.vue?vue&type=script&lang=js\n\n/* harmony default export */ var Mainvue_type_script_lang_js = ({\n  components: {\n    VLink: VLink["a" /* default */]\n  }\n});\n// CONCATENATED MODULE: ./src/layouts/Main.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/layouts/Main.vue\n\n\n\nMainvue_type_script_lang_js.render = render\n\n/* harmony default export */ var Main = __webpack_exports__["a"] = (Mainvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5b3V0cy9NYWluLnZ1ZT84ZTMxIiwid2VicGFjazovLy8uL3NyYy9sYXlvdXRzL01haW4udnVlP2FhZDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xheW91dHMvTWFpbi52dWU/MWFmOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ08sV0FBTTs7O0FBQ0wsV0FBTTs7O2lGQUNhLE07OztBQUNqQixPQUFvQixFQUFwQjtBQUFBO0FBQUE7OztpRkFBMkMsTzs7O0FBRzlDLFdBQU07Ozs7O29KQU5YLCtDQUtNLEtBTE4sY0FLTSxDQUpKLCtDQUdLLElBSEwsY0FHSyxDQUZILCtDQUF1QyxJQUF2QyxFQUF1QyxJQUF2QyxFQUF1QyxDQUFuQywrQ0FBOEIsaUJBQTlCLEVBQThCO0FBQXRCLFFBQUksRUFBQztBQUFpQixHQUE5QixFQUFnQjswREFBQztBQUFBLGFBQUksQyxVQUFBLENBQUo7QUFBQSxLLENBQUQ7Ozs7QUFBQSxHQUFoQixDQUFtQyxDQUF2QyxDQUVHLEVBREgsK0NBQWtFLElBQWxFLGNBQWtFLENBQXpDLCtDQUFvQyxpQkFBcEMsRUFBb0M7QUFBNUIsUUFBSSxFQUFDO0FBQXVCLEdBQXBDLEVBQXFCOzBEQUFDO0FBQUEsYUFBSyxDLFVBQUEsQ0FBTDtBQUFBLEssQ0FBRDs7OztBQUFBLEdBQXJCLENBQXlDLENBQWxFLENBQ0csQ0FITCxDQUlJLENBTE4sQyxFQU1BLCtDQUVNLEtBRk4sY0FFTSxDQURKLDhDQUFhLFdBQWIsRUFBYSxTQUFiLENBQ0ksQ0FGTixDOzs7Ozs7Ozs7O0FBTUY7QUFFZTtBQUNiLFlBQVUsRUFBRTtBQUNWLFNBQUksRUFBSix3QkFBSztBQURLO0FBREMsQ0FBZixFOztBQ2ZrSyxDOztBQ0FqRztBQUNWO0FBQ0w7QUFDbEQsMkJBQU0sVUFBVSxNQUFNOztBQUVQLCtGIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJuYXZiYXItY29udGFpbmVyXCI+XG4gICAgPHVsIGNsYXNzPVwibmF2YmFyXCI+XG4gICAgICA8bGk+PHYtbGluayBocmVmPVwiL1wiPkhvbWU8L3YtbGluaz48L2xpPlxuICAgICAgPGxpIHN0eWxlPVwiZmxvYXQ6cmlnaHQ7XCI+PHYtbGluayBocmVmPVwiL2Fib3V0XCI+QWJvdXQ8L3YtbGluaz48L2xpPlxuICAgIDwvdWw+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPSdtYWluLWxheW91dCc+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgVkxpbmsgZnJvbSAnLi4vY29tcG9uZW50cy9WTGluay52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIFZMaW5rXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOS0wIS4vTWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vTWFpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTY0MjQyMmRcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  '/': 'Home',\n  '/about': 'About',\n  '/numbermemory': \"NumberMemory\",\n  '/reactiontime': \"ReactionTime\",\n  '/verbalmemory': \"VerbalMemory\",\n  '/visualmemory': \"VisualMemory\",\n  '/hearingtest': \"FreqHearing\",\n  '/typingspeed': \"SpeedTyper\",\n  '/aimpractice': \"AimBooster\",\n  '/clickingtest': \"ClickingTest\"\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcm91dGVzLmpzPzU2NjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWU7QUFDYixPQUFJLE1BRFM7QUFFYixZQUFVLE9BRkc7QUFHYixtQkFBZ0IsY0FISDtBQUliLG1CQUFnQixjQUpIO0FBS2IsbUJBQWdCLGNBTEg7QUFNYixtQkFBZ0IsY0FOSDtBQU9iLGtCQUFlLGFBUEY7QUFRYixrQkFBZSxZQVJGO0FBU2Isa0JBQWUsWUFURjtBQVViLG1CQUFnQjtBQVZILENBQWYiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcbiAgJy8nOidIb21lJyxcbiAgJy9hYm91dCc6ICdBYm91dCcsXG4gICcvbnVtYmVybWVtb3J5JzpcIk51bWJlck1lbW9yeVwiLFxuICAnL3JlYWN0aW9udGltZSc6XCJSZWFjdGlvblRpbWVcIixcbiAgJy92ZXJiYWxtZW1vcnknOlwiVmVyYmFsTWVtb3J5XCIsXG4gICcvdmlzdWFsbWVtb3J5JzpcIlZpc3VhbE1lbW9yeVwiLFxuICAnL2hlYXJpbmd0ZXN0JzpcIkZyZXFIZWFyaW5nXCIsXG4gICcvdHlwaW5nc3BlZWQnOlwiU3BlZWRUeXBlclwiLFxuICAnL2FpbXByYWN0aWNlJzpcIkFpbUJvb3N0ZXJcIixcbiAgJy9jbGlja2luZ3Rlc3QnOlwiQ2xpY2tpbmdUZXN0XCJcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony default export */ __webpack_exports__[\"a\"] = (['a', 'abandon', 'ability', 'able', 'abortion', 'about', 'above', 'abroad', 'absence', 'absolute', 'absolutely', 'absorb', 'abuse', 'academic', 'accept', 'access', 'accident', 'accompany', 'accomplish', 'according', 'account', 'accurate', 'accuse', 'achieve', 'achievement', 'acid', 'acknowledge', 'acquire', 'across', 'act', 'action', 'active', 'activist', 'activity', 'actor', 'actress', 'actual', 'actually', 'ad', 'adapt', 'add', 'addition', 'additional', 'address', 'adequate', 'adjust', 'adjustment', 'administration', 'administrator', 'admire', 'admission', 'admit', 'adolescent', 'adopt', 'adult', 'advance', 'advanced', 'advantage', 'adventure', 'advertising', 'advice', 'advise', 'adviser', 'advocate', 'affair', 'affect', 'afford', 'afraid', 'African', 'African-American', 'after', 'afternoon', 'again', 'against', 'age', 'agency', 'agenda', 'agent', 'aggressive', 'ago', 'agree', 'agreement', 'agricultural', 'ah', 'ahead', 'aid', 'aide', 'AIDS', 'aim', 'air', 'aircraft', 'airline', 'airport', 'album', 'alcohol', 'alive', 'all', 'alliance', 'allow', 'ally', 'almost', 'alone', 'along', 'already', 'also', 'alter', 'alternative', 'although', 'always', 'AM', 'amazing', 'American', 'among', 'amount', 'analysis', 'analyst', 'analyze', 'ancient', 'and', 'anger', 'angle', 'angry', 'animal', 'anniversary', 'announce', 'annual', 'another', 'answer', 'anticipate', 'anxiety', 'any', 'anybody', 'anymore', 'anyone', 'anything', 'anyway', 'anywhere', 'apart', 'apartment', 'apparent', 'apparently', 'appeal', 'appear', 'appearance', 'apple', 'application', 'apply', 'appoint', 'appointment', 'appreciate', 'approach', 'appropriate', 'approval', 'approve', 'approximately', 'Arab', 'architect', 'area', 'argue', 'argument', 'arise', 'arm', 'armed', 'army', 'around', 'arrange', 'arrangement', 'arrest', 'arrival', 'arrive', 'art', 'article', 'artist', 'artistic', 'as', 'Asian', 'aside', 'ask', 'asleep', 'aspect', 'assault', 'assert', 'assess', 'assessment', 'asset', 'assign', 'assignment', 'assist', 'assistance', 'assistant', 'associate', 'association', 'assume', 'assumption', 'assure', 'at', 'athlete', 'athletic', 'atmosphere', 'attach', 'attack', 'attempt', 'attend', 'attention', 'attitude', 'attorney', 'attract', 'attractive', 'attribute', 'audience', 'author', 'authority', 'auto', 'available', 'average', 'avoid', 'award', 'aware', 'awareness', 'away', 'awful', 'baby', 'back', 'background', 'bad', 'badly', 'bag', 'bake', 'balance', 'ball', 'ban', 'band', 'bank', 'bar', 'barely', 'barrel', 'barrier', 'base', 'baseball', 'basic', 'basically', 'basis', 'basket', 'basketball', 'bathroom', 'battery', 'battle', 'be', 'beach', 'bean', 'bear', 'beat', 'beautiful', 'beauty', 'because', 'become', 'bed', 'bedroom', 'beer', 'before', 'begin', 'beginning', 'behavior', 'behind', 'being', 'belief', 'believe', 'bell', 'belong', 'below', 'belt', 'bench', 'bend', 'beneath', 'benefit', 'beside', 'besides', 'best', 'bet', 'better', 'between', 'beyond', 'Bible', 'big', 'bike', 'bill', 'billion', 'bind', 'biological', 'bird', 'birth', 'birthday', 'bit', 'bite', 'black', 'blade', 'blame', 'blanket', 'blind', 'block', 'blood', 'blow', 'blue', 'board', 'boat', 'body', 'bomb', 'bombing', 'bond', 'bone', 'book', 'boom', 'boot', 'border', 'born', 'borrow', 'boss', 'both', 'bother', 'bottle', 'bottom', 'boundary', 'bowl', 'box', 'boy', 'boyfriend', 'brain', 'branch', 'brand', 'bread', 'break', 'breakfast', 'breast', 'breath', 'breathe', 'brick', 'bridge', 'brief', 'briefly', 'bright', 'brilliant', 'bring', 'British', 'broad', 'broken', 'brother', 'brown', 'brush', 'buck', 'budget', 'build', 'building', 'bullet', 'bunch', 'burden', 'burn', 'bury', 'bus', 'business', 'busy', 'but', 'butter', 'button', 'buy', 'buyer', 'by', 'cabin', 'cabinet', 'cable', 'cake', 'calculate', 'call', 'camera', 'camp', 'campaign', 'campus', 'can', 'Canadian', 'cancer', 'candidate', 'cap', 'capability', 'capable', 'capacity', 'capital', 'captain', 'capture', 'car', 'carbon', 'card', 'care', 'career', 'careful', 'carefully', 'carrier', 'carry', 'case', 'cash', 'cast', 'cat', 'catch', 'category', 'Catholic', 'cause', 'ceiling', 'celebrate', 'celebration', 'celebrity', 'cell', 'center', 'central', 'century', 'CEO', 'ceremony', 'certain', 'certainly', 'chain', 'chair', 'chairman', 'challenge', 'chamber', 'champion', 'championship', 'chance', 'change', 'changing', 'channel', 'chapter', 'character', 'characteristic', 'characterize', 'charge', 'charity', 'chart', 'chase', 'cheap', 'check', 'cheek', 'cheese', 'chef', 'chemical', 'chest', 'chicken', 'chief', 'child', 'childhood', 'Chinese', 'chip', 'chocolate', 'choice', 'cholesterol', 'choose', 'Christian', 'Christmas', 'church', 'cigarette', 'circle', 'circumstance', 'cite', 'citizen', 'city', 'civil', 'civilian', 'claim', 'class', 'classic', 'classroom', 'clean', 'clear', 'clearly', 'client', 'climate', 'climb', 'clinic', 'clinical', 'clock', 'close', 'closely', 'closer', 'clothes', 'clothing', 'cloud', 'club', 'clue', 'cluster', 'coach', 'coal', 'coalition', 'coast', 'coat', 'code', 'coffee', 'cognitive', 'cold', 'collapse', 'colleague', 'collect', 'collection', 'collective', 'college', 'colonial', 'color', 'column', 'combination', 'combine', 'come', 'comedy', 'comfort', 'comfortable', 'command', 'commander', 'comment', 'commercial', 'commission', 'commit', 'commitment', 'committee', 'common', 'communicate', 'communication', 'community', 'company', 'compare', 'comparison', 'compete', 'competition', 'competitive', 'competitor', 'complain', 'complaint', 'complete', 'completely', 'complex', 'complicated', 'component', 'compose', 'composition', 'comprehensive', 'computer', 'concentrate', 'concentration', 'concept', 'concern', 'concerned', 'concert', 'conclude', 'conclusion', 'concrete', 'condition', 'conduct', 'conference', 'confidence', 'confident', 'confirm', 'conflict', 'confront', 'confusion', 'Congress', 'congressional', 'connect', 'connection', 'consciousness', 'consensus', 'consequence', 'conservative', 'consider', 'considerable', 'consideration', 'consist', 'consistent', 'constant', 'constantly', 'constitute', 'constitutional', 'construct', 'construction', 'consultant', 'consume', 'consumer', 'consumption', 'contact', 'contain', 'container', 'contemporary', 'content', 'contest', 'context', 'continue', 'continued', 'contract', 'contrast', 'contribute', 'contribution', 'control', 'controversial', 'controversy', 'convention', 'conventional', 'conversation', 'convert', 'conviction', 'convince', 'cook', 'cookie', 'cooking', 'cool', 'cooperation', 'cop', 'cope', 'copy', 'core', 'corn', 'corner', 'corporate', 'corporation', 'correct', 'correspondent', 'cost', 'cotton', 'couch', 'could', 'council', 'counselor', 'count', 'counter', 'country', 'county', 'couple', 'courage', 'course', 'court', 'cousin', 'cover', 'coverage', 'cow', 'crack', 'craft', 'crash', 'crazy', 'cream', 'create', 'creation', 'creative', 'creature', 'credit', 'crew', 'crime', 'criminal', 'crisis', 'criteria', 'critic', 'critical', 'criticism', 'criticize', 'crop', 'cross', 'crowd', 'crucial', 'cry', 'cultural', 'culture', 'cup', 'curious', 'current', 'currently', 'curriculum', 'custom', 'customer', 'cut', 'cycle', 'dad', 'daily', 'damage', 'dance', 'danger', 'dangerous', 'dare', 'dark', 'darkness', 'data', 'date', 'daughter', 'day', 'dead', 'deal', 'dealer', 'dear', 'death', 'debate', 'debt', 'decade', 'decide', 'decision', 'deck', 'declare', 'decline', 'decrease', 'deep', 'deeply', 'deer', 'defeat', 'defend', 'defendant', 'defense', 'defensive', 'deficit', 'define', 'definitely', 'definition', 'degree', 'delay', 'deliver', 'delivery', 'demand', 'democracy', 'Democrat', 'democratic', 'demonstrate', 'demonstration', 'deny', 'department', 'depend', 'dependent', 'depending', 'depict', 'depression', 'depth', 'deputy', 'derive', 'describe', 'description', 'desert', 'deserve', 'design', 'designer', 'desire', 'desk', 'desperate', 'despite', 'destroy', 'destruction', 'detail', 'detailed', 'detect', 'determine', 'develop', 'developing', 'development', 'device', 'devote', 'dialogue', 'die', 'diet', 'differ', 'difference', 'different', 'differently', 'difficult', 'difficulty', 'dig', 'digital', 'dimension', 'dining', 'dinner', 'direct', 'direction', 'directly', 'director', 'dirt', 'dirty', 'disability', 'disagree', 'disappear', 'disaster', 'discipline', 'discourse', 'discover', 'discovery', 'discrimination', 'discuss', 'discussion', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'dispute', 'distance', 'distant', 'distinct', 'distinction', 'distinguish', 'distribute', 'distribution', 'district', 'diverse', 'diversity', 'divide', 'division', 'divorce', 'DNA', 'do', 'doctor', 'document', 'dog', 'domestic', 'dominant', 'dominate', 'door', 'double', 'doubt', 'down', 'downtown', 'dozen', 'draft', 'drag', 'drama', 'dramatic', 'dramatically', 'draw', 'drawing', 'dream', 'dress', 'drink', 'drive', 'driver', 'drop', 'drug', 'dry', 'due', 'during', 'dust', 'duty', 'each', 'eager', 'ear', 'early', 'earn', 'earnings', 'earth', 'ease', 'easily', 'east', 'eastern', 'easy', 'eat', 'economic', 'economics', 'economist', 'economy', 'edge', 'edition', 'editor', 'educate', 'education', 'educational', 'educator', 'effect', 'effective', 'effectively', 'efficiency', 'efficient', 'effort', 'egg', 'eight', 'either', 'elderly', 'elect', 'election', 'electric', 'electricity', 'electronic', 'element', 'elementary', 'eliminate', 'elite', 'else', 'elsewhere', 'e-mail', 'embrace', 'emerge', 'emergency', 'emission', 'emotion', 'emotional', 'emphasis', 'emphasize', 'employ', 'employee', 'employer', 'employment', 'empty', 'enable', 'encounter', 'encourage', 'end', 'enemy', 'energy', 'enforcement', 'engage', 'engine', 'engineer', 'engineering', 'English', 'enhance', 'enjoy', 'enormous', 'enough', 'ensure', 'enter', 'enterprise', 'entertainment', 'entire', 'entirely', 'entrance', 'entry', 'environment', 'environmental', 'episode', 'equal', 'equally', 'equipment', 'era', 'error', 'escape', 'especially', 'essay', 'essential', 'essentially', 'establish', 'establishment', 'estate', 'estimate', 'etc', 'ethics', 'ethnic', 'European', 'evaluate', 'evaluation', 'even', 'evening', 'event', 'eventually', 'ever', 'every', 'everybody', 'everyday', 'everyone', 'everything', 'everywhere', 'evidence', 'evolution', 'evolve', 'exact', 'exactly', 'examination', 'examine', 'example', 'exceed', 'excellent', 'except', 'exception', 'exchange', 'exciting', 'executive', 'exercise', 'exhibit', 'exhibition', 'exist', 'existence', 'existing', 'expand', 'expansion', 'expect', 'expectation', 'expense', 'expensive', 'experience', 'experiment', 'expert', 'explain', 'explanation', 'explode', 'explore', 'explosion', 'expose', 'exposure', 'express', 'expression', 'extend', 'extension', 'extensive', 'extent', 'external', 'extra', 'extraordinary', 'extreme', 'extremely', 'eye', 'fabric', 'face', 'facility', 'fact', 'factor', 'factory', 'faculty', 'fade', 'fail', 'failure', 'fair', 'fairly', 'faith', 'fall', 'false', 'familiar', 'family', 'famous', 'fan', 'fantasy', 'far', 'farm', 'farmer', 'fashion', 'fast', 'fat', 'fate', 'father', 'fault', 'favor', 'favorite', 'fear', 'feature', 'federal', 'fee', 'feed', 'feel', 'feeling', 'fellow', 'female', 'fence', 'few', 'fewer', 'fiber', 'fiction', 'field', 'fifteen', 'fifth', 'fifty', 'fight', 'fighter', 'fighting', 'figure', 'file', 'fill', 'film', 'final', 'finally', 'finance', 'financial', 'find', 'finding', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fish', 'fishing', 'fit', 'fitness', 'five', 'fix', 'flag', 'flame', 'flat', 'flavor', 'flee', 'flesh', 'flight', 'float', 'floor', 'flow', 'flower', 'fly', 'focus', 'folk', 'follow', 'following', 'food', 'foot', 'football', 'for', 'force', 'foreign', 'forest', 'forever', 'forget', 'form', 'formal', 'formation', 'former', 'formula', 'forth', 'fortune', 'forward', 'found', 'foundation', 'founder', 'four', 'fourth', 'frame', 'framework', 'free', 'freedom', 'freeze', 'French', 'frequency', 'frequent', 'frequently', 'fresh', 'friend', 'friendly', 'friendship', 'from', 'front', 'fruit', 'frustration', 'fuel', 'full', 'fully', 'fun', 'function', 'fund', 'fundamental', 'funding', 'funeral', 'funny', 'furniture', 'furthermore', 'future', 'gain', 'galaxy', 'gallery', 'game', 'gang', 'gap', 'garage', 'garden', 'garlic', 'gas', 'gate', 'gather', 'gay', 'gaze', 'gear', 'gender', 'gene', 'general', 'generally', 'generate', 'generation', 'genetic', 'gentleman', 'gently', 'German', 'gesture', 'get', 'ghost', 'giant', 'gift', 'gifted', 'girl', 'girlfriend', 'give', 'given', 'glad', 'glance', 'glass', 'global', 'glove', 'go', 'goal', 'God', 'gold', 'golden', 'golf', 'good', 'government', 'governor', 'grab', 'grade', 'gradually', 'graduate', 'grain', 'grand', 'grandfather', 'grandmother', 'grant', 'grass', 'grave', 'gray', 'great', 'greatest', 'green', 'grocery', 'ground', 'group', 'grow', 'growing', 'growth', 'guarantee', 'guard', 'guess', 'guest', 'guide', 'guideline', 'guilty', 'gun', 'guy', 'habit', 'habitat', 'hair', 'half', 'hall', 'hand', 'handful', 'handle', 'hang', 'happen', 'happy', 'hard', 'hardly', 'hat', 'hate', 'have', 'he', 'head', 'headline', 'headquarters', 'health', 'healthy', 'hear', 'hearing', 'heart', 'heat', 'heaven', 'heavily', 'heavy', 'heel', 'height', 'helicopter', 'hell', 'hello', 'help', 'helpful', 'her', 'here', 'heritage', 'hero', 'herself', 'hey', 'hi', 'hide', 'high', 'highlight', 'highly', 'highway', 'hill', 'him', 'himself', 'hip', 'hire', 'his', 'historian', 'historic', 'historical', 'history', 'hit', 'hold', 'hole', 'holiday', 'holy', 'home', 'homeless', 'honest', 'honey', 'honor', 'hope', 'horizon', 'horror', 'horse', 'hospital', 'host', 'hot', 'hotel', 'hour', 'house', 'household', 'housing', 'how', 'however', 'huge', 'human', 'humor', 'hundred', 'hungry', 'hunter', 'hunting', 'hurt', 'husband', 'hypothesis', 'I', 'ice', 'idea', 'ideal', 'identification', 'identify', 'identity', 'ie', 'if', 'ignore', 'ill', 'illegal', 'illness', 'illustrate', 'image', 'imagination', 'imagine', 'immediate', 'immediately', 'immigrant', 'immigration', 'impact', 'implement', 'implication', 'imply', 'importance', 'important', 'impose', 'impossible', 'impress', 'impression', 'impressive', 'improve', 'improvement', 'in', 'incentive', 'incident', 'include', 'including', 'income', 'incorporate', 'increase', 'increased', 'increasing', 'increasingly', 'incredible', 'indeed', 'independence', 'independent', 'index', 'Indian', 'indicate', 'indication', 'individual', 'industrial', 'industry', 'infant', 'infection', 'inflation', 'influence', 'inform', 'information', 'ingredient', 'initial', 'initially', 'initiative', 'injury', 'inner', 'innocent', 'inquiry', 'inside', 'insight', 'insist', 'inspire', 'install', 'instance', 'instead', 'institution', 'institutional', 'instruction', 'instructor', 'instrument', 'insurance', 'intellectual', 'intelligence', 'intend', 'intense', 'intensity', 'intention', 'interaction', 'interest', 'interested', 'interesting', 'internal', 'international', 'Internet', 'interpret', 'interpretation', 'intervention', 'interview', 'into', 'introduce', 'introduction', 'invasion', 'invest', 'investigate', 'investigation', 'investigator', 'investment', 'investor', 'invite', 'involve', 'involved', 'involvement', 'Iraqi', 'Irish', 'iron', 'Islamic', 'island', 'Israeli', 'issue', 'it', 'Italian', 'item', 'its', 'itself', 'jacket', 'jail', 'Japanese', 'jet', 'Jew', 'Jewish', 'job', 'join', 'joint', 'joke', 'journal', 'journalist', 'journey', 'joy', 'judge', 'judgment', 'juice', 'jump', 'junior', 'jury', 'just', 'justice', 'justify', 'keep', 'key', 'kick', 'kid', 'kill', 'killer', 'killing', 'kind', 'king', 'kiss', 'kitchen', 'knee', 'knife', 'knock', 'know', 'knowledge', 'lab', 'label', 'labor', 'laboratory', 'lack', 'lady', 'lake', 'land', 'landscape', 'language', 'lap', 'large', 'largely', 'last', 'late', 'later', 'Latin', 'latter', 'laugh', 'launch', 'law', 'lawn', 'lawsuit', 'lawyer', 'lay', 'layer', 'lead', 'leader', 'leadership', 'leading', 'leaf', 'league', 'lean', 'learn', 'learning', 'least', 'leather', 'leave', 'left', 'leg', 'legacy', 'legal', 'legend', 'legislation', 'legitimate', 'lemon', 'length', 'less', 'lesson', 'let', 'letter', 'level', 'liberal', 'library', 'license', 'lie', 'life', 'lifestyle', 'lifetime', 'lift', 'light', 'like', 'likely', 'limit', 'limitation', 'limited', 'line', 'link', 'lip', 'list', 'listen', 'literally', 'literary', 'literature', 'little', 'live', 'living', 'load', 'loan', 'local', 'locate', 'location', 'lock', 'long', 'long-term', 'look', 'loose', 'lose', 'loss', 'lost', 'lot', 'lots', 'loud', 'love', 'lovely', 'lover', 'low', 'lower', 'luck', 'lucky', 'lunch', 'lung', 'machine', 'mad', 'magazine', 'mail', 'main', 'mainly', 'maintain', 'maintenance', 'major', 'majority', 'make', 'maker', 'makeup', 'male', 'mall', 'man', 'manage', 'management', 'manager', 'manner', 'manufacturer', 'manufacturing', 'many', 'map', 'margin', 'mark', 'market', 'marketing', 'marriage', 'married', 'marry', 'mask', 'mass', 'massive', 'master', 'match', 'material', 'math', 'matter', 'may', 'maybe', 'mayor', 'me', 'meal', 'mean', 'meaning', 'meanwhile', 'measure', 'measurement', 'meat', 'mechanism', 'media', 'medical', 'medication', 'medicine', 'medium', 'meet', 'meeting', 'member', 'membership', 'memory', 'mental', 'mention', 'menu', 'mere', 'merely', 'mess', 'message', 'metal', 'meter', 'method', 'Mexican', 'middle', 'might', 'military', 'milk', 'million', 'mind', 'mine', 'minister', 'minor', 'minority', 'minute', 'miracle', 'mirror', 'miss', 'missile', 'mission', 'mistake', 'mix', 'mixture', 'mm-hmm', 'mode', 'model', 'moderate', 'modern', 'modest', 'mom', 'moment', 'money', 'monitor', 'month', 'mood', 'moon', 'moral', 'more', 'moreover', 'morning', 'mortgage', 'most', 'mostly', 'mother', 'motion', 'motivation', 'motor', 'mount', 'mountain', 'mouse', 'mouth', 'move', 'movement', 'movie', 'Mr', 'Mrs', 'Ms', 'much', 'multiple', 'murder', 'muscle', 'museum', 'music', 'musical', 'musician', 'Muslim', 'must', 'mutual', 'my', 'myself', 'mystery', 'myth', 'naked', 'name', 'narrative', 'narrow', 'nation', 'national', 'native', 'natural', 'naturally', 'nature', 'near', 'nearby', 'nearly', 'necessarily', 'necessary', 'neck', 'need', 'negative', 'negotiate', 'negotiation', 'neighbor', 'neighborhood', 'neither', 'nerve', 'nervous', 'net', 'network', 'never', 'nevertheless', 'new', 'newly', 'news', 'newspaper', 'next', 'nice', 'night', 'nine', 'no', 'nobody', 'nod', 'noise', 'nomination', 'none', 'nonetheless', 'nor', 'normal', 'normally', 'north', 'northern', 'nose', 'not', 'note', 'nothing', 'notice', 'notion', 'novel', 'now', 'nowhere', 'nuclear', 'number', 'numerous', 'nurse', 'nut', 'object', 'objective', 'obligation', 'observation', 'observe', 'observer', 'obtain', 'obvious', 'obviously', 'occasion', 'occasionally', 'occupation', 'occupy', 'occur', 'ocean', 'odd', 'odds', 'of', 'off', 'offense', 'offensive', 'offer', 'office', 'officer', 'official', 'often', 'oh', 'oil', 'ok', 'okay', 'old', 'Olympic', 'on', 'once', 'one', 'ongoing', 'onion', 'online', 'only', 'onto', 'open', 'opening', 'operate', 'operating', 'operation', 'operator', 'opinion', 'opponent', 'opportunity', 'oppose', 'opposite', 'opposition', 'option', 'or', 'orange', 'order', 'ordinary', 'organic', 'organization', 'organize', 'orientation', 'origin', 'original', 'originally', 'other', 'others', 'otherwise', 'ought', 'our', 'ourselves', 'out', 'outcome', 'outside', 'oven', 'over', 'overall', 'overcome', 'overlook', 'owe', 'own', 'owner', 'pace', 'pack', 'package', 'page', 'pain', 'painful', 'paint', 'painter', 'painting', 'pair', 'pale', 'Palestinian', 'palm', 'pan', 'panel', 'pant', 'paper', 'parent', 'park', 'parking', 'part', 'participant', 'participate', 'participation', 'particular', 'particularly', 'partly', 'partner', 'partnership', 'party', 'pass', 'passage', 'passenger', 'passion', 'past', 'patch', 'path', 'patient', 'pattern', 'pause', 'pay', 'payment', 'PC', 'peace', 'peak', 'peer', 'penalty', 'people', 'pepper', 'per', 'perceive', 'percentage', 'perception', 'perfect', 'perfectly', 'perform', 'performance', 'perhaps', 'period', 'permanent', 'permission', 'permit', 'person', 'personal', 'personality', 'personally', 'personnel', 'perspective', 'persuade', 'pet', 'phase', 'phenomenon', 'philosophy', 'phone', 'photo', 'photograph', 'photographer', 'phrase', 'physical', 'physically', 'physician', 'piano', 'pick', 'picture', 'pie', 'piece', 'pile', 'pilot', 'pine', 'pink', 'pipe', 'pitch', 'place', 'plan', 'plane', 'planet', 'planning', 'plant', 'plastic', 'plate', 'platform', 'play', 'player', 'please', 'pleasure', 'plenty', 'plot', 'plus', 'PM', 'pocket', 'poem', 'poet', 'poetry', 'point', 'pole', 'police', 'policy', 'political', 'politically', 'politician', 'politics', 'poll', 'pollution', 'pool', 'poor', 'pop', 'popular', 'population', 'porch', 'port', 'portion', 'portrait', 'portray', 'pose', 'position', 'positive', 'possess', 'possibility', 'possible', 'possibly', 'post', 'pot', 'potato', 'potential', 'potentially', 'pound', 'pour', 'poverty', 'powder', 'power', 'powerful', 'practical', 'practice', 'pray', 'prayer', 'precisely', 'predict', 'prefer', 'preference', 'pregnancy', 'pregnant', 'preparation', 'prepare', 'prescription', 'presence', 'present', 'presentation', 'preserve', 'president', 'presidential', 'press', 'pressure', 'pretend', 'pretty', 'prevent', 'previous', 'previously', 'price', 'pride', 'priest', 'primarily', 'primary', 'prime', 'principal', 'principle', 'print', 'prior', 'priority', 'prison', 'prisoner', 'privacy', 'private', 'probably', 'problem', 'procedure', 'proceed', 'process', 'produce', 'producer', 'product', 'production', 'profession', 'professional', 'professor', 'profile', 'profit', 'program', 'progress', 'project', 'prominent', 'promise', 'promote', 'prompt', 'proof', 'proper', 'properly', 'property', 'proportion', 'proposal', 'propose', 'proposed', 'prosecutor', 'prospect', 'protect', 'protection', 'protein', 'protest', 'proud', 'prove', 'provide', 'provider', 'province', 'provision', 'psychological', 'psychologist', 'psychology', 'public', 'publication', 'publicly', 'publish', 'publisher', 'pull', 'punishment', 'purchase', 'pure', 'purpose', 'pursue', 'push', 'put', 'qualify', 'quality', 'quarter', 'quarterback', 'question', 'quick', 'quickly', 'quiet', 'quietly', 'quit', 'quite', 'quote', 'race', 'racial', 'radical', 'radio', 'rail', 'rain', 'raise', 'range', 'rank', 'rapid', 'rapidly', 'rare', 'rarely', 'rate', 'rather', 'rating', 'ratio', 'raw', 'reach', 'react', 'reaction', 'read', 'reader', 'reading', 'ready', 'real', 'reality', 'realize', 'really', 'reason', 'reasonable', 'recall', 'receive', 'recent', 'recently', 'recipe', 'recognition', 'recognize', 'recommend', 'recommendation', 'record', 'recording', 'recover', 'recovery', 'recruit', 'red', 'reduce', 'reduction', 'refer', 'reference', 'reflect', 'reflection', 'reform', 'refugee', 'refuse', 'regard', 'regarding', 'regardless', 'regime', 'region', 'regional', 'register', 'regular', 'regularly', 'regulate', 'regulation', 'reinforce', 'reject', 'relate', 'relation', 'relationship', 'relative', 'relatively', 'relax', 'release', 'relevant', 'relief', 'religion', 'religious', 'rely', 'remain', 'remaining', 'remarkable', 'remember', 'remind', 'remote', 'remove', 'repeat', 'repeatedly', 'replace', 'reply', 'report', 'reporter', 'represent', 'representation', 'representative', 'Republican', 'reputation', 'request', 'require', 'requirement', 'research', 'researcher', 'resemble', 'reservation', 'resident', 'resist', 'resistance', 'resolution', 'resolve', 'resort', 'resource', 'respect', 'respond', 'respondent', 'response', 'responsibility', 'responsible', 'rest', 'restaurant', 'restore', 'restriction', 'result', 'retain', 'retire', 'retirement', 'return', 'reveal', 'revenue', 'review', 'revolution', 'rhythm', 'rice', 'rich', 'rid', 'ride', 'rifle', 'right', 'ring', 'rise', 'risk', 'river', 'road', 'rock', 'role', 'roll', 'romantic', 'roof', 'room', 'root', 'rope', 'rose', 'rough', 'roughly', 'round', 'route', 'routine', 'row', 'rub', 'rule', 'run', 'running', 'rural', 'rush', 'Russian', 'sacred', 'sad', 'safe', 'safety', 'sake', 'salad', 'salary', 'sale', 'sales', 'salt', 'same', 'sample', 'sanction', 'sand', 'satellite', 'satisfaction', 'satisfy', 'sauce', 'save', 'saving', 'say', 'scale', 'scandal', 'scared', 'scenario', 'scene', 'schedule', 'scheme', 'scholar', 'scholarship', 'school', 'science', 'scientific', 'scientist', 'scope', 'score', 'scream', 'screen', 'script', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'secretary', 'section', 'sector', 'secure', 'security', 'see', 'seed', 'seek', 'seem', 'segment', 'seize', 'select', 'selection', 'self', 'sell', 'Senate', 'senator', 'send', 'senior', 'sense', 'sensitive', 'sentence', 'separate', 'sequence', 'series', 'serious', 'seriously', 'serve', 'service', 'session', 'set', 'setting', 'settle', 'settlement', 'seven', 'several', 'severe', 'sex', 'sexual', 'shade', 'shadow', 'shake', 'shall', 'shape', 'share', 'sharp', 'she', 'sheet', 'shelf', 'shell', 'shelter', 'shift', 'shine', 'ship', 'shirt', 'shit', 'shock', 'shoe', 'shoot', 'shooting', 'shop', 'shopping', 'shore', 'short', 'shortly', 'shot', 'should', 'shoulder', 'shout', 'show', 'shower', 'shrug', 'shut', 'sick', 'side', 'sigh', 'sight', 'sign', 'signal', 'significance', 'significant', 'significantly', 'silence', 'silent', 'silver', 'similar', 'similarly', 'simple', 'simply', 'sin', 'since', 'sing', 'singer', 'single', 'sink', 'sir', 'sister', 'sit', 'site', 'situation', 'six', 'size', 'ski', 'skill', 'skin', 'sky', 'slave', 'sleep', 'slice', 'slide', 'slight', 'slightly', 'slip', 'slow', 'slowly', 'small', 'smart', 'smell', 'smile', 'smoke', 'smooth', 'snap', 'snow', 'so', 'so-called', 'soccer', 'social', 'society', 'soft', 'software', 'soil', 'solar', 'soldier', 'solid', 'solution', 'solve', 'some', 'somebody', 'somehow', 'someone', 'something', 'sometimes', 'somewhat', 'somewhere', 'son', 'song', 'soon', 'sophisticated', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'southern', 'Soviet', 'space', 'Spanish', 'speak', 'speaker', 'special', 'specialist', 'species', 'specific', 'specifically', 'speech', 'speed', 'spend', 'spending', 'spin', 'spirit', 'spiritual', 'split', 'spokesman', 'sport', 'spot', 'spread', 'spring', 'square', 'squeeze', 'stability', 'stable', 'staff', 'stage', 'stair', 'stake', 'stand', 'standard', 'standing', 'star', 'stare', 'start', 'state', 'statement', 'station', 'statistics', 'status', 'stay', 'steady', 'steal', 'steel', 'step', 'stick', 'still', 'stir', 'stock', 'stomach', 'stone', 'stop', 'storage', 'store', 'storm', 'story', 'straight', 'strange', 'stranger', 'strategic', 'strategy', 'stream', 'street', 'strength', 'strengthen', 'stress', 'stretch', 'strike', 'string', 'strip', 'stroke', 'strong', 'strongly', 'structure', 'struggle', 'student', 'studio', 'study', 'stuff', 'stupid', 'style', 'subject', 'submit', 'subsequent', 'substance', 'substantial', 'succeed', 'success', 'successful', 'successfully', 'such', 'sudden', 'suddenly', 'sue', 'suffer', 'sufficient', 'sugar', 'suggest', 'suggestion', 'suicide', 'suit', 'summer', 'summit', 'sun', 'super', 'supply', 'support', 'supporter', 'suppose', 'supposed', 'Supreme', 'sure', 'surely', 'surface', 'surgery', 'surprise', 'surprised', 'surprising', 'surprisingly', 'surround', 'survey', 'survival', 'survive', 'survivor', 'suspect', 'sustain', 'swear', 'sweep', 'sweet', 'swim', 'swing', 'switch', 'symbol', 'symptom', 'system', 'table', 'tablespoon', 'tactic', 'tail', 'take', 'tale', 'talent', 'talk', 'tall', 'tank', 'tap', 'tape', 'target', 'task', 'taste', 'tax', 'taxpayer', 'tea', 'teach', 'teacher', 'teaching', 'team', 'tear', 'teaspoon', 'technical', 'technique', 'technology', 'teen', 'teenager', 'telephone', 'telescope', 'television', 'tell', 'temperature', 'temporary', 'ten', 'tend', 'tendency', 'tennis', 'tension', 'tent', 'term', 'terms', 'terrible', 'territory', 'terror', 'terrorism', 'terrorist', 'test', 'testify', 'testimony', 'testing', 'text', 'than', 'thank', 'thanks', 'that', 'the', 'theater', 'their', 'them', 'theme', 'themselves', 'then', 'theory', 'therapy', 'there', 'therefore', 'these', 'they', 'thick', 'thin', 'thing', 'think', 'thinking', 'third', 'thirty', 'this', 'those', 'though', 'thought', 'thousand', 'threat', 'threaten', 'three', 'throat', 'through', 'throughout', 'throw', 'thus', 'ticket', 'tie', 'tight', 'time', 'tiny', 'tip', 'tire', 'tired', 'tissue', 'title', 'to', 'tobacco', 'today', 'toe', 'together', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'too', 'tool', 'tooth', 'top', 'topic', 'toss', 'total', 'totally', 'touch', 'tough', 'tour', 'tourist', 'tournament', 'toward', 'towards', 'tower', 'town', 'toy', 'trace', 'track', 'trade', 'tradition', 'traditional', 'traffic', 'tragedy', 'trail', 'train', 'training', 'transfer', 'transform', 'transformation', 'transition', 'translate', 'transportation', 'travel', 'treat', 'treatment', 'treaty', 'tree', 'tremendous', 'trend', 'trial', 'tribe', 'trick', 'trip', 'troop', 'trouble', 'truck', 'true', 'truly', 'trust', 'truth', 'try', 'tube', 'tunnel', 'turn', 'TV', 'twelve', 'twenty', 'twice', 'twin', 'two', 'type', 'typical', 'typically', 'ugly', 'ultimate', 'ultimately', 'unable', 'uncle', 'under', 'undergo', 'understand', 'understanding', 'unfortunately', 'uniform', 'union', 'unique', 'unit', 'United', 'universal', 'universe', 'university', 'unknown', 'unless', 'unlike', 'unlikely', 'until', 'unusual', 'up', 'upon', 'upper', 'urban', 'urge', 'us', 'use', 'used', 'useful', 'user', 'usual', 'usually', 'utility', 'vacation', 'valley', 'valuable', 'value', 'variable', 'variation', 'variety', 'various', 'vary', 'vast', 'vegetable', 'vehicle', 'venture', 'version', 'versus', 'very', 'vessel', 'veteran', 'via', 'victim', 'victory', 'video', 'view', 'viewer', 'village', 'violate', 'violation', 'violence', 'violent', 'virtually', 'virtue', 'virus', 'visible', 'vision', 'visit', 'visitor', 'visual', 'vital', 'voice', 'volume', 'volunteer', 'vote', 'voter', 'vs', 'vulnerable', 'wage', 'wait', 'wake', 'walk', 'wall', 'wander', 'want', 'war', 'warm', 'warn', 'warning', 'wash', 'waste', 'watch', 'water', 'wave', 'way', 'we', 'weak', 'wealth', 'wealthy', 'weapon', 'wear', 'weather', 'wedding', 'week', 'weekend', 'weekly', 'weigh', 'weight', 'welcome', 'welfare', 'well', 'west', 'western', 'wet', 'what', 'whatever', 'wheel', 'when', 'whenever', 'where', 'whereas', 'whether', 'which', 'while', 'whisper', 'white', 'who', 'whole', 'whom', 'whose', 'why', 'wide', 'widely', 'widespread', 'wife', 'wild', 'will', 'willing', 'win', 'wind', 'window', 'wine', 'wing', 'winner', 'winter', 'wipe', 'wire', 'wisdom', 'wise', 'wish', 'with', 'withdraw', 'within', 'without', 'witness', 'woman', 'wonder', 'wonderful', 'wood', 'wooden', 'word', 'work', 'worker', 'working', 'works', 'workshop', 'world', 'worried', 'worry', 'worth', 'would', 'wound', 'wrap', 'write', 'writer', 'writing', 'wrong', 'yard', 'yeah', 'year', 'yell', 'yellow', 'yes', 'yesterday', 'yet', 'yield', 'you', 'young', 'your', 'yours', 'yourself', 'youth', 'zone']);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvd29yZHMuanM/NjJmMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBZSwwREFBQyxHQUFELEVBQUssU0FBTCxFQUFlLFNBQWYsRUFBeUIsTUFBekIsRUFBZ0MsVUFBaEMsRUFBMkMsT0FBM0MsRUFBbUQsT0FBbkQsRUFBMkQsUUFBM0QsRUFBb0UsU0FBcEUsRUFBOEUsVUFBOUUsRUFBeUYsWUFBekYsRUFBc0csUUFBdEcsRUFBK0csT0FBL0csRUFBdUgsVUFBdkgsRUFBa0ksUUFBbEksRUFBMkksUUFBM0ksRUFBb0osVUFBcEosRUFBK0osV0FBL0osRUFBMkssWUFBM0ssRUFBd0wsV0FBeEwsRUFBb00sU0FBcE0sRUFBOE0sVUFBOU0sRUFBeU4sUUFBek4sRUFBa08sU0FBbE8sRUFBNE8sYUFBNU8sRUFBMFAsTUFBMVAsRUFBaVEsYUFBalEsRUFBK1EsU0FBL1EsRUFBeVIsUUFBelIsRUFBa1MsS0FBbFMsRUFBd1MsUUFBeFMsRUFBaVQsUUFBalQsRUFBMFQsVUFBMVQsRUFBcVUsVUFBclUsRUFBZ1YsT0FBaFYsRUFBd1YsU0FBeFYsRUFBa1csUUFBbFcsRUFBMlcsVUFBM1csRUFBc1gsSUFBdFgsRUFBMlgsT0FBM1gsRUFBbVksS0FBblksRUFBeVksVUFBelksRUFBb1osWUFBcFosRUFBaWEsU0FBamEsRUFBMmEsVUFBM2EsRUFBc2IsUUFBdGIsRUFBK2IsWUFBL2IsRUFBNGMsZ0JBQTVjLEVBQTZkLGVBQTdkLEVBQTZlLFFBQTdlLEVBQXNmLFdBQXRmLEVBQWtnQixPQUFsZ0IsRUFBMGdCLFlBQTFnQixFQUF1aEIsT0FBdmhCLEVBQStoQixPQUEvaEIsRUFBdWlCLFNBQXZpQixFQUFpakIsVUFBampCLEVBQTRqQixXQUE1akIsRUFBd2tCLFdBQXhrQixFQUFvbEIsYUFBcGxCLEVBQWttQixRQUFsbUIsRUFBMm1CLFFBQTNtQixFQUFvbkIsU0FBcG5CLEVBQThuQixVQUE5bkIsRUFBeW9CLFFBQXpvQixFQUFrcEIsUUFB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RUFFMDRQLE9BRjE0UCxFQUVrNVAsT0FGbDVQLEVBRTA1UCxNQUYxNVAsRUFFaTZQLE9BRmo2UCxFQUV5NlAsUUFGejZQLEVBRWs3UCxTQUZsN1AsRUFFNDdQLE9BRjU3UCxFQUVvOFAsTUFGcDhQLEVBRTI4UCxNQUYzOFAsRUFFazlQLE1BRmw5UCxFQUV5OVAsTUFGejlQLEVBRWcrUCxRQUZoK1AsRUFFeStQLEtBRnorUCxFQUUrK1AsV0FGLytQLEVBRTIvUCxLQUYzL1AsRUFFaWdRLE9BRmpnUSxFQUV5Z1EsS0FGemdRLEVBRStnUSxPQUYvZ1EsRUFFdWhRLE1BRnZoUSxFQUU4aFEsT0FGOWhRLEVBRXNpUSxVQUZ0aVEsRUFFaWpRLE9BRmpqUSxFQUV5alEsTUFGempRLENBQWYiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFsnYScsJ2FiYW5kb24nLCdhYmlsaXR5JywnYWJsZScsJ2Fib3J0aW9uJywnYWJvdXQnLCdhYm92ZScsJ2Ficm9hZCcsJ2Fic2VuY2UnLCdhYnNvbHV0ZScsJ2Fic29sdXRlbHknLCdhYnNvcmInLCdhYnVzZScsJ2FjYWRlbWljJywnYWNjZXB0JywnYWNjZXNzJywnYWNjaWRlbnQnLCdhY2NvbXBhbnknLCdhY2NvbXBsaXNoJywnYWNjb3JkaW5nJywnYWNjb3VudCcsJ2FjY3VyYXRlJywnYWNjdXNlJywnYWNoaWV2ZScsJ2FjaGlldmVtZW50JywnYWNpZCcsJ2Fja25vd2xlZGdlJywnYWNxdWlyZScsJ2Fjcm9zcycsJ2FjdCcsJ2FjdGlvbicsJ2FjdGl2ZScsJ2FjdGl2aXN0JywnYWN0aXZpdHknLCdhY3RvcicsJ2FjdHJlc3MnLCdhY3R1YWwnLCdhY3R1YWxseScsJ2FkJywnYWRhcHQnLCdhZGQnLCdhZGRpdGlvbicsJ2FkZGl0aW9uYWwnLCdhZGRyZXNzJywnYWRlcXVhdGUnLCdhZGp1c3QnLCdhZGp1c3RtZW50JywnYWRtaW5pc3RyYXRpb24nLCdhZG1pbmlzdHJhdG9yJywnYWRtaXJlJywnYWRtaXNzaW9uJywnYWRtaXQnLCdhZG9sZXNjZW50JywnYWRvcHQnLCdhZHVsdCcsJ2FkdmFuY2UnLCdhZHZhbmNlZCcsJ2FkdmFudGFnZScsJ2FkdmVudHVyZScsJ2FkdmVydGlzaW5nJywnYWR2aWNlJywnYWR2aXNlJywnYWR2aXNlcicsJ2Fkdm9jYXRlJywnYWZmYWlyJywnYWZmZWN0JywnYWZmb3JkJywnYWZyYWlkJywnQWZyaWNhbicsJ0FmcmljYW4tQW1lcmljYW4nLCdhZnRlcicsJ2FmdGVybm9vbicsJ2FnYWluJywnYWdhaW5zdCcsJ2FnZScsJ2FnZW5jeScsJ2FnZW5kYScsJ2FnZW50JywnYWdncmVzc2l2ZScsJ2FnbycsJ2FncmVlJywnYWdyZWVtZW50JywnYWdyaWN1bHR1cmFsJywnYWgnLCdhaGVhZCcsJ2FpZCcsJ2FpZGUnLCdBSURTJywnYWltJywnYWlyJywnYWlyY3JhZnQnLCdhaXJsaW5lJywnYWlycG9ydCcsJ2FsYnVtJywnYWxjb2hvbCcsJ2FsaXZlJywnYWxsJywnYWxsaWFuY2UnLCdhbGxvdycsJ2FsbHknLCdhbG1vc3QnLCdhbG9uZScsJ2Fsb25nJywnYWxyZWFkeScsJ2Fsc28nLCdhbHRlcicsJ2FsdGVybmF0aXZlJywnYWx0aG91Z2gnLCdhbHdheXMnLCdBTScsJ2FtYXppbmcnLCdBbWVyaWNhbicsJ2Ftb25nJywnYW1vdW50JywnYW5hbHlzaXMnLCdhbmFseXN0JywnYW5hbHl6ZScsJ2FuY2llbnQnLCdhbmQnLCdhbmdlcicsJ2FuZ2xlJywnYW5ncnknLCdhbmltYWwnLCdhbm5pdmVyc2FyeScsJ2Fubm91bmNlJywnYW5udWFsJywnYW5vdGhlcicsJ2Fuc3dlcicsJ2FudGljaXBhdGUnLCdhbnhpZXR5JywnYW55JywnYW55Ym9keScsJ2FueW1vcmUnLCdhbnlvbmUnLCdhbnl0aGluZycsJ2FueXdheScsJ2FueXdoZXJlJywnYXBhcnQnLCdhcGFydG1lbnQnLCdhcHBhcmVudCcsJ2FwcGFyZW50bHknLCdhcHBlYWwnLCdhcHBlYXInLCdhcHBlYXJhbmNlJywnYXBwbGUnLCdhcHBsaWNhdGlvbicsJ2FwcGx5JywnYXBwb2ludCcsJ2FwcG9pbnRtZW50JywnYXBwcmVjaWF0ZScsJ2FwcHJvYWNoJywnYXBwcm9wcmlhdGUnLCdhcHByb3ZhbCcsJ2FwcHJvdmUnLCdhcHByb3hpbWF0ZWx5JywnQXJhYicsJ2FyY2hpdGVjdCcsJ2FyZWEnLCdhcmd1ZScsJ2FyZ3VtZW50JywnYXJpc2UnLCdhcm0nLCdhcm1lZCcsJ2FybXknLCdhcm91bmQnLCdhcnJhbmdlJywnYXJyYW5nZW1lbnQnLCdhcnJlc3QnLCdhcnJpdmFsJywnYXJyaXZlJywnYXJ0JywnYXJ0aWNsZScsJ2FydGlzdCcsJ2FydGlzdGljJywnYXMnLCdBc2lhbicsJ2FzaWRlJywnYXNrJywnYXNsZWVwJywnYXNwZWN0JywnYXNzYXVsdCcsJ2Fzc2VydCcsJ2Fzc2VzcycsJ2Fzc2Vzc21lbnQnLCdhc3NldCcsJ2Fzc2lnbicsJ2Fzc2lnbm1lbnQnLCdhc3Npc3QnLCdhc3Npc3RhbmNlJywnYXNzaXN0YW50JywnYXNzb2NpYXRlJywnYXNzb2NpYXRpb24nLCdhc3N1bWUnLCdhc3N1bXB0aW9uJywnYXNzdXJlJywnYXQnLCdhdGhsZXRlJywnYXRobGV0aWMnLCdhdG1vc3BoZXJlJywnYXR0YWNoJywnYXR0YWNrJywnYXR0ZW1wdCcsJ2F0dGVuZCcsJ2F0dGVudGlvbicsJ2F0dGl0dWRlJywnYXR0b3JuZXknLCdhdHRyYWN0JywnYXR0cmFjdGl2ZScsJ2F0dHJpYnV0ZScsJ2F1ZGllbmNlJywnYXV0aG9yJywnYXV0aG9yaXR5JywnYXV0bycsJ2F2YWlsYWJsZScsJ2F2ZXJhZ2UnLCdhdm9pZCcsJ2F3YXJkJywnYXdhcmUnLCdhd2FyZW5lc3MnLCdhd2F5JywnYXdmdWwnLCdiYWJ5JywnYmFjaycsJ2JhY2tncm91bmQnLCdiYWQnLCdiYWRseScsJ2JhZycsJ2Jha2UnLCdiYWxhbmNlJywnYmFsbCcsJ2JhbicsJ2JhbmQnLCdiYW5rJywnYmFyJywnYmFyZWx5JywnYmFycmVsJywnYmFycmllcicsJ2Jhc2UnLCdiYXNlYmFsbCcsJ2Jhc2ljJywnYmFzaWNhbGx5JywnYmFzaXMnLCdiYXNrZXQnLCdiYXNrZXRiYWxsJywnYmF0aHJvb20nLCdiYXR0ZXJ5JywnYmF0dGxlJywnYmUnLCdiZWFjaCcsJ2JlYW4nLCdiZWFyJywnYmVhdCcsJ2JlYXV0aWZ1bCcsJ2JlYXV0eScsJ2JlY2F1c2UnLCdiZWNvbWUnLCdiZWQnLCdiZWRyb29tJywnYmVlcicsJ2JlZm9yZScsJ2JlZ2luJywnYmVnaW5uaW5nJywnYmVoYXZpb3InLCdiZWhpbmQnLCdiZWluZycsJ2JlbGllZicsJ2JlbGlldmUnLCdiZWxsJywnYmVsb25nJywnYmVsb3cnLCdiZWx0JywnYmVuY2gnLCdiZW5kJywnYmVuZWF0aCcsJ2JlbmVmaXQnLCdiZXNpZGUnLCdiZXNpZGVzJywnYmVzdCcsJ2JldCcsJ2JldHRlcicsJ2JldHdlZW4nLCdiZXlvbmQnLCdCaWJsZScsJ2JpZycsJ2Jpa2UnLCdiaWxsJywnYmlsbGlvbicsJ2JpbmQnLCdiaW9sb2dpY2FsJywnYmlyZCcsJ2JpcnRoJywnYmlydGhkYXknLCdiaXQnLCdiaXRlJywnYmxhY2snLCdibGFkZScsJ2JsYW1lJywnYmxhbmtldCcsJ2JsaW5kJywnYmxvY2snLCdibG9vZCcsJ2Jsb3cnLCdibHVlJywnYm9hcmQnLCdib2F0JywnYm9keScsJ2JvbWInLCdib21iaW5nJywnYm9uZCcsJ2JvbmUnLCdib29rJywnYm9vbScsJ2Jvb3QnLCdib3JkZXInLCdib3JuJywnYm9ycm93JywnYm9zcycsJ2JvdGgnLCdib3RoZXInLCdib3R0bGUnLCdib3R0b20nLCdib3VuZGFyeScsJ2Jvd2wnLCdib3gnLCdib3knLCdib3lmcmllbmQnLCdicmFpbicsJ2JyYW5jaCcsJ2JyYW5kJywnYnJlYWQnLCdicmVhaycsJ2JyZWFrZmFzdCcsJ2JyZWFzdCcsJ2JyZWF0aCcsJ2JyZWF0aGUnLCdicmljaycsJ2JyaWRnZScsJ2JyaWVmJywnYnJpZWZseScsJ2JyaWdodCcsJ2JyaWxsaWFudCcsJ2JyaW5nJywnQnJpdGlzaCcsJ2Jyb2FkJywnYnJva2VuJywnYnJvdGhlcicsJ2Jyb3duJywnYnJ1c2gnLCdidWNrJywnYnVkZ2V0JywnYnVpbGQnLCdidWlsZGluZycsJ2J1bGxldCcsJ2J1bmNoJywnYnVyZGVuJywnYnVybicsJ2J1cnknLCdidXMnLCdidXNpbmVzcycsJ2J1c3knLCdidXQnLCdidXR0ZXInLCdidXR0b24nLCdidXknLCdidXllcicsJ2J5JywnY2FiaW4nLCdjYWJpbmV0JywnY2FibGUnLCdjYWtlJywnY2FsY3VsYXRlJywnY2FsbCcsJ2NhbWVyYScsJ2NhbXAnLCdjYW1wYWlnbicsJ2NhbXB1cycsJ2NhbicsJ0NhbmFkaWFuJywnY2FuY2VyJywnY2FuZGlkYXRlJywnY2FwJywnY2FwYWJpbGl0eScsJ2NhcGFibGUnLCdjYXBhY2l0eScsJ2NhcGl0YWwnLCdjYXB0YWluJywnY2FwdHVyZScsJ2NhcicsJ2NhcmJvbicsJ2NhcmQnLCdjYXJlJywnY2FyZWVyJywnY2FyZWZ1bCcsJ2NhcmVmdWxseScsJ2NhcnJpZXInLCdjYXJyeScsJ2Nhc2UnLCdjYXNoJywnY2FzdCcsJ2NhdCcsJ2NhdGNoJywnY2F0ZWdvcnknLCdDYXRob2xpYycsJ2NhdXNlJywnY2VpbGluZycsJ2NlbGVicmF0ZScsJ2NlbGVicmF0aW9uJywnY2VsZWJyaXR5JywnY2VsbCcsJ2NlbnRlcicsJ2NlbnRyYWwnLCdjZW50dXJ5JywnQ0VPJywnY2VyZW1vbnknLCdjZXJ0YWluJywnY2VydGFpbmx5JywnY2hhaW4nLCdjaGFpcicsJ2NoYWlybWFuJywnY2hhbGxlbmdlJywnY2hhbWJlcicsJ2NoYW1waW9uJywnY2hhbXBpb25zaGlwJywnY2hhbmNlJywnY2hhbmdlJywnY2hhbmdpbmcnLCdjaGFubmVsJywnY2hhcHRlcicsJ2NoYXJhY3RlcicsJ2NoYXJhY3RlcmlzdGljJywnY2hhcmFjdGVyaXplJywnY2hhcmdlJywnY2hhcml0eScsJ2NoYXJ0JywnY2hhc2UnLCdjaGVhcCcsJ2NoZWNrJywnY2hlZWsnLCdjaGVlc2UnLCdjaGVmJywnY2hlbWljYWwnLCdjaGVzdCcsJ2NoaWNrZW4nLCdjaGllZicsJ2NoaWxkJywnY2hpbGRob29kJywnQ2hpbmVzZScsJ2NoaXAnLCdjaG9jb2xhdGUnLCdjaG9pY2UnLCdjaG9sZXN0ZXJvbCcsJ2Nob29zZScsJ0NocmlzdGlhbicsJ0NocmlzdG1hcycsJ2NodXJjaCcsJ2NpZ2FyZXR0ZScsJ2NpcmNsZScsJ2NpcmN1bXN0YW5jZScsJ2NpdGUnLCdjaXRpemVuJywnY2l0eScsJ2NpdmlsJywnY2l2aWxpYW4nLCdjbGFpbScsJ2NsYXNzJywnY2xhc3NpYycsJ2NsYXNzcm9vbScsJ2NsZWFuJywnY2xlYXInLCdjbGVhcmx5JywnY2xpZW50JywnY2xpbWF0ZScsJ2NsaW1iJywnY2xpbmljJywnY2xpbmljYWwnLCdjbG9jaycsJ2Nsb3NlJywnY2xvc2VseScsJ2Nsb3NlcicsJ2Nsb3RoZXMnLCdjbG90aGluZycsJ2Nsb3VkJywnY2x1YicsJ2NsdWUnLCdjbHVzdGVyJywnY29hY2gnLCdjb2FsJywnY29hbGl0aW9uJywnY29hc3QnLCdjb2F0JywnY29kZScsJ2NvZmZlZScsJ2NvZ25pdGl2ZScsJ2NvbGQnLCdjb2xsYXBzZScsJ2NvbGxlYWd1ZScsJ2NvbGxlY3QnLCdjb2xsZWN0aW9uJywnY29sbGVjdGl2ZScsJ2NvbGxlZ2UnLCdjb2xvbmlhbCcsJ2NvbG9yJywnY29sdW1uJywnY29tYmluYXRpb24nLCdjb21iaW5lJywnY29tZScsJ2NvbWVkeScsJ2NvbWZvcnQnLCdjb21mb3J0YWJsZScsJ2NvbW1hbmQnLCdjb21tYW5kZXInLCdjb21tZW50JywnY29tbWVyY2lhbCcsJ2NvbW1pc3Npb24nLCdjb21taXQnLCdjb21taXRtZW50JywnY29tbWl0dGVlJywnY29tbW9uJywnY29tbXVuaWNhdGUnLCdjb21tdW5pY2F0aW9uJywnY29tbXVuaXR5JywnY29tcGFueScsJ2NvbXBhcmUnLCdjb21wYXJpc29uJywnY29tcGV0ZScsJ2NvbXBldGl0aW9uJywnY29tcGV0aXRpdmUnLCdjb21wZXRpdG9yJywnY29tcGxhaW4nLCdjb21wbGFpbnQnLCdjb21wbGV0ZScsJ2NvbXBsZXRlbHknLCdjb21wbGV4JywnY29tcGxpY2F0ZWQnLCdjb21wb25lbnQnLCdjb21wb3NlJywnY29tcG9zaXRpb24nLCdjb21wcmVoZW5zaXZlJywnY29tcHV0ZXInLCdjb25jZW50cmF0ZScsJ2NvbmNlbnRyYXRpb24nLCdjb25jZXB0JywnY29uY2VybicsJ2NvbmNlcm5lZCcsJ2NvbmNlcnQnLCdjb25jbHVkZScsJ2NvbmNsdXNpb24nLCdjb25jcmV0ZScsJ2NvbmRpdGlvbicsJ2NvbmR1Y3QnLCdjb25mZXJlbmNlJywnY29uZmlkZW5jZScsJ2NvbmZpZGVudCcsJ2NvbmZpcm0nLCdjb25mbGljdCcsJ2NvbmZyb250JywnY29uZnVzaW9uJywnQ29uZ3Jlc3MnLCdjb25ncmVzc2lvbmFsJywnY29ubmVjdCcsJ2Nvbm5lY3Rpb24nLCdjb25zY2lvdXNuZXNzJywnY29uc2Vuc3VzJywnY29uc2VxdWVuY2UnLCdjb25zZXJ2YXRpdmUnLCdjb25zaWRlcicsJ2NvbnNpZGVyYWJsZScsJ2NvbnNpZGVyYXRpb24nLCdjb25zaXN0JywnY29uc2lzdGVudCcsJ2NvbnN0YW50JywnY29uc3RhbnRseScsJ2NvbnN0aXR1dGUnLCdjb25zdGl0dXRpb25hbCcsJ2NvbnN0cnVjdCcsJ2NvbnN0cnVjdGlvbicsJ2NvbnN1bHRhbnQnLCdjb25zdW1lJywnY29uc3VtZXInLCdjb25zdW1wdGlvbicsJ2NvbnRhY3QnLCdjb250YWluJywnY29udGFpbmVyJywnY29udGVtcG9yYXJ5JywnY29udGVudCcsJ2NvbnRlc3QnLCdjb250ZXh0JywnY29udGludWUnLCdjb250aW51ZWQnLCdjb250cmFjdCcsJ2NvbnRyYXN0JywnY29udHJpYnV0ZScsJ2NvbnRyaWJ1dGlvbicsJ2NvbnRyb2wnLCdjb250cm92ZXJzaWFsJywnY29udHJvdmVyc3knLCdjb252ZW50aW9uJywnY29udmVudGlvbmFsJywnY29udmVyc2F0aW9uJywnY29udmVydCcsJ2NvbnZpY3Rpb24nLCdjb252aW5jZScsJ2Nvb2snLCdjb29raWUnLCdjb29raW5nJywnY29vbCcsJ2Nvb3BlcmF0aW9uJywnY29wJywnY29wZScsJ2NvcHknLCdjb3JlJywnY29ybicsJ2Nvcm5lcicsJ2NvcnBvcmF0ZScsJ2NvcnBvcmF0aW9uJywnY29ycmVjdCcsJ2NvcnJlc3BvbmRlbnQnLCdjb3N0JywnY290dG9uJywnY291Y2gnLCdjb3VsZCcsJ2NvdW5jaWwnLCdjb3Vuc2Vsb3InLCdjb3VudCcsJ2NvdW50ZXInLCdjb3VudHJ5JywnY291bnR5JywnY291cGxlJywnY291cmFnZScsJ2NvdXJzZScsJ2NvdXJ0JywnY291c2luJywnY292ZXInLCdjb3ZlcmFnZScsJ2NvdycsJ2NyYWNrJywnY3JhZnQnLCdjcmFzaCcsJ2NyYXp5JywnY3JlYW0nLCdjcmVhdGUnLCdjcmVhdGlvbicsJ2NyZWF0aXZlJywnY3JlYXR1cmUnLCdjcmVkaXQnLCdjcmV3JywnY3JpbWUnLCdjcmltaW5hbCcsJ2NyaXNpcycsJ2NyaXRlcmlhJywnY3JpdGljJywnY3JpdGljYWwnLCdjcml0aWNpc20nLCdjcml0aWNpemUnLCdjcm9wJywnY3Jvc3MnLCdjcm93ZCcsJ2NydWNpYWwnLCdjcnknLCdjdWx0dXJhbCcsJ2N1bHR1cmUnLCdjdXAnLCdjdXJpb3VzJywnY3VycmVudCcsJ2N1cnJlbnRseScsJ2N1cnJpY3VsdW0nLCdjdXN0b20nLCdjdXN0b21lcicsJ2N1dCcsJ2N5Y2xlJywnZGFkJywnZGFpbHknLCdkYW1hZ2UnLCdkYW5jZScsJ2RhbmdlcicsJ2Rhbmdlcm91cycsJ2RhcmUnLCdkYXJrJywnZGFya25lc3MnLCdkYXRhJywnZGF0ZScsJ2RhdWdodGVyJywnZGF5JywnZGVhZCcsJ2RlYWwnLCdkZWFsZXInLCdkZWFyJywnZGVhdGgnLCdkZWJhdGUnLCdkZWJ0JywnZGVjYWRlJywnZGVjaWRlJywnZGVjaXNpb24nLCdkZWNrJywnZGVjbGFyZScsJ2RlY2xpbmUnLCdkZWNyZWFzZScsJ2RlZXAnLCdkZWVwbHknLCdkZWVyJywnZGVmZWF0JywnZGVmZW5kJywnZGVmZW5kYW50JywnZGVmZW5zZScsJ2RlZmVuc2l2ZScsJ2RlZmljaXQnLCdkZWZpbmUnLCdkZWZpbml0ZWx5JywnZGVmaW5pdGlvbicsJ2RlZ3JlZScsJ2RlbGF5JywnZGVsaXZlcicsJ2RlbGl2ZXJ5JywnZGVtYW5kJywnZGVtb2NyYWN5JywnRGVtb2NyYXQnLCdkZW1vY3JhdGljJywnZGVtb25zdHJhdGUnLCdkZW1vbnN0cmF0aW9uJywnZGVueScsJ2RlcGFydG1lbnQnLCdkZXBlbmQnLCdkZXBlbmRlbnQnLCdkZXBlbmRpbmcnLCdkZXBpY3QnLCdkZXByZXNzaW9uJywnZGVwdGgnLCdkZXB1dHknLCdkZXJpdmUnLCdkZXNjcmliZScsJ2Rlc2NyaXB0aW9uJywnZGVzZXJ0JywnZGVzZXJ2ZScsJ2Rlc2lnbicsJ2Rlc2lnbmVyJywnZGVzaXJlJywnZGVzaycsJ2Rlc3BlcmF0ZScsJ2Rlc3BpdGUnLCdkZXN0cm95JywnZGVzdHJ1Y3Rpb24nLCdkZXRhaWwnLCdkZXRhaWxlZCcsJ2RldGVjdCcsJ2RldGVybWluZScsJ2RldmVsb3AnLCdkZXZlbG9waW5nJywnZGV2ZWxvcG1lbnQnLCdkZXZpY2UnLCdkZXZvdGUnLCdkaWFsb2d1ZScsJ2RpZScsJ2RpZXQnLCdkaWZmZXInLCdkaWZmZXJlbmNlJywnZGlmZmVyZW50JywnZGlmZmVyZW50bHknLCdkaWZmaWN1bHQnLCdkaWZmaWN1bHR5JywnZGlnJywnZGlnaXRhbCcsJ2RpbWVuc2lvbicsJ2RpbmluZycsJ2Rpbm5lcicsJ2RpcmVjdCcsJ2RpcmVjdGlvbicsJ2RpcmVjdGx5JywnZGlyZWN0b3InLCdkaXJ0JywnZGlydHknLCdkaXNhYmlsaXR5JywnZGlzYWdyZWUnLCdkaXNhcHBlYXInLCdkaXNhc3RlcicsJ2Rpc2NpcGxpbmUnLCdkaXNjb3Vyc2UnLCdkaXNjb3ZlcicsJ2Rpc2NvdmVyeScsJ2Rpc2NyaW1pbmF0aW9uJywnZGlzY3VzcycsJ2Rpc2N1c3Npb24nLCdkaXNlYXNlJywnZGlzaCcsJ2Rpc21pc3MnLCdkaXNvcmRlcicsJ2Rpc3BsYXknLCdkaXNwdXRlJywnZGlzdGFuY2UnLCdkaXN0YW50JywnZGlzdGluY3QnLCdkaXN0aW5jdGlvbicsJ2Rpc3Rpbmd1aXNoJywnZGlzdHJpYnV0ZScsJ2Rpc3RyaWJ1dGlvbicsJ2Rpc3RyaWN0JywnZGl2ZXJzZScsJ2RpdmVyc2l0eScsJ2RpdmlkZScsJ2RpdmlzaW9uJywnZGl2b3JjZScsJ0ROQScsJ2RvJywnZG9jdG9yJywnZG9jdW1lbnQnLCdkb2cnLCdkb21lc3RpYycsJ2RvbWluYW50JywnZG9taW5hdGUnLCdkb29yJywnZG91YmxlJywnZG91YnQnLCdkb3duJywnZG93bnRvd24nLCdkb3plbicsJ2RyYWZ0JywnZHJhZycsJ2RyYW1hJywnZHJhbWF0aWMnLCdkcmFtYXRpY2FsbHknLCdkcmF3JywnZHJhd2luZycsJ2RyZWFtJywnZHJlc3MnLCdkcmluaycsJ2RyaXZlJywnZHJpdmVyJywnZHJvcCcsJ2RydWcnLCdkcnknLCdkdWUnLCdkdXJpbmcnLCdkdXN0JywnZHV0eScsJ2VhY2gnLCdlYWdlcicsJ2VhcicsJ2Vhcmx5JywnZWFybicsJ2Vhcm5pbmdzJywnZWFydGgnLCdlYXNlJywnZWFzaWx5JywnZWFzdCcsJ2Vhc3Rlcm4nLCdlYXN5JywnZWF0JywnZWNvbm9taWMnLCdlY29ub21pY3MnLCdlY29ub21pc3QnLCdlY29ub215JywnZWRnZScsJ2VkaXRpb24nLCdlZGl0b3InLCdlZHVjYXRlJywnZWR1Y2F0aW9uJywnZWR1Y2F0aW9uYWwnLCdlZHVjYXRvcicsJ2VmZmVjdCcsJ2VmZmVjdGl2ZScsJ2VmZmVjdGl2ZWx5JywnZWZmaWNpZW5jeScsJ2VmZmljaWVudCcsJ2VmZm9ydCcsJ2VnZycsJ2VpZ2h0JywnZWl0aGVyJywnZWxkZXJseScsJ2VsZWN0JywnZWxlY3Rpb24nLCdlbGVjdHJpYycsJ2VsZWN0cmljaXR5JywnZWxlY3Ryb25pYycsJ2VsZW1lbnQnLCdlbGVtZW50YXJ5JywnZWxpbWluYXRlJywnZWxpdGUnLCdlbHNlJywnZWxzZXdoZXJlJywnZS1tYWlsJywnZW1icmFjZScsJ2VtZXJnZScsJ2VtZXJnZW5jeScsJ2VtaXNzaW9uJywnZW1vdGlvbicsJ2Vtb3Rpb25hbCcsJ2VtcGhhc2lzJywnZW1waGFzaXplJywnZW1wbG95JywnZW1wbG95ZWUnLCdlbXBsb3llcicsJ2VtcGxveW1lbnQnLCdlbXB0eScsJ2VuYWJsZScsJ2VuY291bnRlcicsJ2VuY291cmFnZScsJ2VuZCcsJ2VuZW15JywnZW5lcmd5JywnZW5mb3JjZW1lbnQnLCdlbmdhZ2UnLCdlbmdpbmUnLCdlbmdpbmVlcicsJ2VuZ2luZWVyaW5nJywnRW5nbGlzaCcsJ2VuaGFuY2UnLCdlbmpveScsJ2Vub3Jtb3VzJywnZW5vdWdoJywnZW5zdXJlJywnZW50ZXInLCdlbnRlcnByaXNlJywnZW50ZXJ0YWlubWVudCcsJ2VudGlyZScsJ2VudGlyZWx5JywnZW50cmFuY2UnLCdlbnRyeScsJ2Vudmlyb25tZW50JywnZW52aXJvbm1lbnRhbCcsJ2VwaXNvZGUnLCdlcXVhbCcsJ2VxdWFsbHknLCdlcXVpcG1lbnQnLCdlcmEnLCdlcnJvcicsJ2VzY2FwZScsJ2VzcGVjaWFsbHknLCdlc3NheScsJ2Vzc2VudGlhbCcsJ2Vzc2VudGlhbGx5JywnZXN0YWJsaXNoJywnZXN0YWJsaXNobWVudCcsJ2VzdGF0ZScsJ2VzdGltYXRlJywnZXRjJywnZXRoaWNzJywnZXRobmljJywnRXVyb3BlYW4nLCdldmFsdWF0ZScsJ2V2YWx1YXRpb24nLCdldmVuJywnZXZlbmluZycsJ2V2ZW50JywnZXZlbnR1YWxseScsJ2V2ZXInLCdldmVyeScsJ2V2ZXJ5Ym9keScsJ2V2ZXJ5ZGF5JywnZXZlcnlvbmUnLCdldmVyeXRoaW5nJywnZXZlcnl3aGVyZScsJ2V2aWRlbmNlJywnZXZvbHV0aW9uJywnZXZvbHZlJywnZXhhY3QnLCdleGFjdGx5JywnZXhhbWluYXRpb24nLCdleGFtaW5lJywnZXhhbXBsZScsJ2V4Y2VlZCcsJ2V4Y2VsbGVudCcsJ2V4Y2VwdCcsJ2V4Y2VwdGlvbicsJ2V4Y2hhbmdlJywnZXhjaXRpbmcnLCdleGVjdXRpdmUnLCdleGVyY2lzZScsJ2V4aGliaXQnLCdleGhpYml0aW9uJywnZXhpc3QnLCdleGlzdGVuY2UnLCdleGlzdGluZycsJ2V4cGFuZCcsJ2V4cGFuc2lvbicsJ2V4cGVjdCcsJ2V4cGVjdGF0aW9uJywnZXhwZW5zZScsJ2V4cGVuc2l2ZScsJ2V4cGVyaWVuY2UnLCdleHBlcmltZW50JywnZXhwZXJ0JywnZXhwbGFpbicsJ2V4cGxhbmF0aW9uJywnZXhwbG9kZScsJ2V4cGxvcmUnLCdleHBsb3Npb24nLCdleHBvc2UnLCdleHBvc3VyZScsJ2V4cHJlc3MnLCdleHByZXNzaW9uJywnZXh0ZW5kJywnZXh0ZW5zaW9uJywnZXh0ZW5zaXZlJywnZXh0ZW50JywnZXh0ZXJuYWwnLCdleHRyYScsJ2V4dHJhb3JkaW5hcnknLCdleHRyZW1lJywnZXh0cmVtZWx5JywnZXllJywnZmFicmljJywnZmFjZScsJ2ZhY2lsaXR5JywnZmFjdCcsJ2ZhY3RvcicsJ2ZhY3RvcnknLCdmYWN1bHR5JywnZmFkZScsJ2ZhaWwnLCdmYWlsdXJlJywnZmFpcicsJ2ZhaXJseScsJ2ZhaXRoJywnZmFsbCcsXG4nZmFsc2UnLCdmYW1pbGlhcicsJ2ZhbWlseScsJ2ZhbW91cycsJ2ZhbicsJ2ZhbnRhc3knLCdmYXInLCdmYXJtJywnZmFybWVyJywnZmFzaGlvbicsJ2Zhc3QnLCdmYXQnLCdmYXRlJywnZmF0aGVyJywnZmF1bHQnLCdmYXZvcicsJ2Zhdm9yaXRlJywnZmVhcicsJ2ZlYXR1cmUnLCdmZWRlcmFsJywnZmVlJywnZmVlZCcsJ2ZlZWwnLCdmZWVsaW5nJywnZmVsbG93JywnZmVtYWxlJywnZmVuY2UnLCdmZXcnLCdmZXdlcicsJ2ZpYmVyJywnZmljdGlvbicsJ2ZpZWxkJywnZmlmdGVlbicsJ2ZpZnRoJywnZmlmdHknLCdmaWdodCcsJ2ZpZ2h0ZXInLCdmaWdodGluZycsJ2ZpZ3VyZScsJ2ZpbGUnLCdmaWxsJywnZmlsbScsJ2ZpbmFsJywnZmluYWxseScsJ2ZpbmFuY2UnLCdmaW5hbmNpYWwnLCdmaW5kJywnZmluZGluZycsJ2ZpbmUnLCdmaW5nZXInLCdmaW5pc2gnLCdmaXJlJywnZmlybScsJ2ZpcnN0JywnZmlzaCcsJ2Zpc2hpbmcnLCdmaXQnLCdmaXRuZXNzJywnZml2ZScsJ2ZpeCcsJ2ZsYWcnLCdmbGFtZScsJ2ZsYXQnLCdmbGF2b3InLCdmbGVlJywnZmxlc2gnLCdmbGlnaHQnLCdmbG9hdCcsJ2Zsb29yJywnZmxvdycsJ2Zsb3dlcicsJ2ZseScsJ2ZvY3VzJywnZm9saycsJ2ZvbGxvdycsJ2ZvbGxvd2luZycsJ2Zvb2QnLCdmb290JywnZm9vdGJhbGwnLCdmb3InLCdmb3JjZScsJ2ZvcmVpZ24nLCdmb3Jlc3QnLCdmb3JldmVyJywnZm9yZ2V0JywnZm9ybScsJ2Zvcm1hbCcsJ2Zvcm1hdGlvbicsJ2Zvcm1lcicsJ2Zvcm11bGEnLCdmb3J0aCcsJ2ZvcnR1bmUnLCdmb3J3YXJkJywnZm91bmQnLCdmb3VuZGF0aW9uJywnZm91bmRlcicsJ2ZvdXInLCdmb3VydGgnLCdmcmFtZScsJ2ZyYW1ld29yaycsJ2ZyZWUnLCdmcmVlZG9tJywnZnJlZXplJywnRnJlbmNoJywnZnJlcXVlbmN5JywnZnJlcXVlbnQnLCdmcmVxdWVudGx5JywnZnJlc2gnLCdmcmllbmQnLCdmcmllbmRseScsJ2ZyaWVuZHNoaXAnLCdmcm9tJywnZnJvbnQnLCdmcnVpdCcsJ2ZydXN0cmF0aW9uJywnZnVlbCcsJ2Z1bGwnLCdmdWxseScsJ2Z1bicsJ2Z1bmN0aW9uJywnZnVuZCcsJ2Z1bmRhbWVudGFsJywnZnVuZGluZycsJ2Z1bmVyYWwnLCdmdW5ueScsJ2Z1cm5pdHVyZScsJ2Z1cnRoZXJtb3JlJywnZnV0dXJlJywnZ2FpbicsJ2dhbGF4eScsJ2dhbGxlcnknLCdnYW1lJywnZ2FuZycsJ2dhcCcsJ2dhcmFnZScsJ2dhcmRlbicsJ2dhcmxpYycsJ2dhcycsJ2dhdGUnLCdnYXRoZXInLCdnYXknLCdnYXplJywnZ2VhcicsJ2dlbmRlcicsJ2dlbmUnLCdnZW5lcmFsJywnZ2VuZXJhbGx5JywnZ2VuZXJhdGUnLCdnZW5lcmF0aW9uJywnZ2VuZXRpYycsJ2dlbnRsZW1hbicsJ2dlbnRseScsJ0dlcm1hbicsJ2dlc3R1cmUnLCdnZXQnLCdnaG9zdCcsJ2dpYW50JywnZ2lmdCcsJ2dpZnRlZCcsJ2dpcmwnLCdnaXJsZnJpZW5kJywnZ2l2ZScsJ2dpdmVuJywnZ2xhZCcsJ2dsYW5jZScsJ2dsYXNzJywnZ2xvYmFsJywnZ2xvdmUnLCdnbycsJ2dvYWwnLCdHb2QnLCdnb2xkJywnZ29sZGVuJywnZ29sZicsJ2dvb2QnLCdnb3Zlcm5tZW50JywnZ292ZXJub3InLCdncmFiJywnZ3JhZGUnLCdncmFkdWFsbHknLCdncmFkdWF0ZScsJ2dyYWluJywnZ3JhbmQnLCdncmFuZGZhdGhlcicsJ2dyYW5kbW90aGVyJywnZ3JhbnQnLCdncmFzcycsJ2dyYXZlJywnZ3JheScsJ2dyZWF0JywnZ3JlYXRlc3QnLCdncmVlbicsJ2dyb2NlcnknLCdncm91bmQnLCdncm91cCcsJ2dyb3cnLCdncm93aW5nJywnZ3Jvd3RoJywnZ3VhcmFudGVlJywnZ3VhcmQnLCdndWVzcycsJ2d1ZXN0JywnZ3VpZGUnLCdndWlkZWxpbmUnLCdndWlsdHknLCdndW4nLCdndXknLCdoYWJpdCcsJ2hhYml0YXQnLCdoYWlyJywnaGFsZicsJ2hhbGwnLCdoYW5kJywnaGFuZGZ1bCcsJ2hhbmRsZScsJ2hhbmcnLCdoYXBwZW4nLCdoYXBweScsJ2hhcmQnLCdoYXJkbHknLCdoYXQnLCdoYXRlJywnaGF2ZScsJ2hlJywnaGVhZCcsJ2hlYWRsaW5lJywnaGVhZHF1YXJ0ZXJzJywnaGVhbHRoJywnaGVhbHRoeScsJ2hlYXInLCdoZWFyaW5nJywnaGVhcnQnLCdoZWF0JywnaGVhdmVuJywnaGVhdmlseScsJ2hlYXZ5JywnaGVlbCcsJ2hlaWdodCcsJ2hlbGljb3B0ZXInLCdoZWxsJywnaGVsbG8nLCdoZWxwJywnaGVscGZ1bCcsJ2hlcicsJ2hlcmUnLCdoZXJpdGFnZScsJ2hlcm8nLCdoZXJzZWxmJywnaGV5JywnaGknLCdoaWRlJywnaGlnaCcsJ2hpZ2hsaWdodCcsJ2hpZ2hseScsJ2hpZ2h3YXknLCdoaWxsJywnaGltJywnaGltc2VsZicsJ2hpcCcsJ2hpcmUnLCdoaXMnLCdoaXN0b3JpYW4nLCdoaXN0b3JpYycsJ2hpc3RvcmljYWwnLCdoaXN0b3J5JywnaGl0JywnaG9sZCcsJ2hvbGUnLCdob2xpZGF5JywnaG9seScsJ2hvbWUnLCdob21lbGVzcycsJ2hvbmVzdCcsJ2hvbmV5JywnaG9ub3InLCdob3BlJywnaG9yaXpvbicsJ2hvcnJvcicsJ2hvcnNlJywnaG9zcGl0YWwnLCdob3N0JywnaG90JywnaG90ZWwnLCdob3VyJywnaG91c2UnLCdob3VzZWhvbGQnLCdob3VzaW5nJywnaG93JywnaG93ZXZlcicsJ2h1Z2UnLCdodW1hbicsJ2h1bW9yJywnaHVuZHJlZCcsJ2h1bmdyeScsJ2h1bnRlcicsJ2h1bnRpbmcnLCdodXJ0JywnaHVzYmFuZCcsJ2h5cG90aGVzaXMnLCdJJywnaWNlJywnaWRlYScsJ2lkZWFsJywnaWRlbnRpZmljYXRpb24nLCdpZGVudGlmeScsJ2lkZW50aXR5JywnaWUnLCdpZicsJ2lnbm9yZScsJ2lsbCcsJ2lsbGVnYWwnLCdpbGxuZXNzJywnaWxsdXN0cmF0ZScsJ2ltYWdlJywnaW1hZ2luYXRpb24nLCdpbWFnaW5lJywnaW1tZWRpYXRlJywnaW1tZWRpYXRlbHknLCdpbW1pZ3JhbnQnLCdpbW1pZ3JhdGlvbicsJ2ltcGFjdCcsJ2ltcGxlbWVudCcsJ2ltcGxpY2F0aW9uJywnaW1wbHknLCdpbXBvcnRhbmNlJywnaW1wb3J0YW50JywnaW1wb3NlJywnaW1wb3NzaWJsZScsJ2ltcHJlc3MnLCdpbXByZXNzaW9uJywnaW1wcmVzc2l2ZScsJ2ltcHJvdmUnLCdpbXByb3ZlbWVudCcsJ2luJywnaW5jZW50aXZlJywnaW5jaWRlbnQnLCdpbmNsdWRlJywnaW5jbHVkaW5nJywnaW5jb21lJywnaW5jb3Jwb3JhdGUnLCdpbmNyZWFzZScsJ2luY3JlYXNlZCcsJ2luY3JlYXNpbmcnLCdpbmNyZWFzaW5nbHknLCdpbmNyZWRpYmxlJywnaW5kZWVkJywnaW5kZXBlbmRlbmNlJywnaW5kZXBlbmRlbnQnLCdpbmRleCcsJ0luZGlhbicsJ2luZGljYXRlJywnaW5kaWNhdGlvbicsJ2luZGl2aWR1YWwnLCdpbmR1c3RyaWFsJywnaW5kdXN0cnknLCdpbmZhbnQnLCdpbmZlY3Rpb24nLCdpbmZsYXRpb24nLCdpbmZsdWVuY2UnLCdpbmZvcm0nLCdpbmZvcm1hdGlvbicsJ2luZ3JlZGllbnQnLCdpbml0aWFsJywnaW5pdGlhbGx5JywnaW5pdGlhdGl2ZScsJ2luanVyeScsJ2lubmVyJywnaW5ub2NlbnQnLCdpbnF1aXJ5JywnaW5zaWRlJywnaW5zaWdodCcsJ2luc2lzdCcsJ2luc3BpcmUnLCdpbnN0YWxsJywnaW5zdGFuY2UnLCdpbnN0ZWFkJywnaW5zdGl0dXRpb24nLCdpbnN0aXR1dGlvbmFsJywnaW5zdHJ1Y3Rpb24nLCdpbnN0cnVjdG9yJywnaW5zdHJ1bWVudCcsJ2luc3VyYW5jZScsJ2ludGVsbGVjdHVhbCcsJ2ludGVsbGlnZW5jZScsJ2ludGVuZCcsJ2ludGVuc2UnLCdpbnRlbnNpdHknLCdpbnRlbnRpb24nLCdpbnRlcmFjdGlvbicsJ2ludGVyZXN0JywnaW50ZXJlc3RlZCcsJ2ludGVyZXN0aW5nJywnaW50ZXJuYWwnLCdpbnRlcm5hdGlvbmFsJywnSW50ZXJuZXQnLCdpbnRlcnByZXQnLCdpbnRlcnByZXRhdGlvbicsJ2ludGVydmVudGlvbicsJ2ludGVydmlldycsJ2ludG8nLCdpbnRyb2R1Y2UnLCdpbnRyb2R1Y3Rpb24nLCdpbnZhc2lvbicsJ2ludmVzdCcsJ2ludmVzdGlnYXRlJywnaW52ZXN0aWdhdGlvbicsJ2ludmVzdGlnYXRvcicsJ2ludmVzdG1lbnQnLCdpbnZlc3RvcicsJ2ludml0ZScsJ2ludm9sdmUnLCdpbnZvbHZlZCcsJ2ludm9sdmVtZW50JywnSXJhcWknLCdJcmlzaCcsJ2lyb24nLCdJc2xhbWljJywnaXNsYW5kJywnSXNyYWVsaScsJ2lzc3VlJywnaXQnLCdJdGFsaWFuJywnaXRlbScsJ2l0cycsJ2l0c2VsZicsJ2phY2tldCcsJ2phaWwnLCdKYXBhbmVzZScsJ2pldCcsJ0pldycsJ0pld2lzaCcsJ2pvYicsJ2pvaW4nLCdqb2ludCcsJ2pva2UnLCdqb3VybmFsJywnam91cm5hbGlzdCcsJ2pvdXJuZXknLCdqb3knLCdqdWRnZScsJ2p1ZGdtZW50JywnanVpY2UnLCdqdW1wJywnanVuaW9yJywnanVyeScsJ2p1c3QnLCdqdXN0aWNlJywnanVzdGlmeScsJ2tlZXAnLCdrZXknLCdraWNrJywna2lkJywna2lsbCcsJ2tpbGxlcicsJ2tpbGxpbmcnLCdraW5kJywna2luZycsJ2tpc3MnLCdraXRjaGVuJywna25lZScsJ2tuaWZlJywna25vY2snLCdrbm93Jywna25vd2xlZGdlJywnbGFiJywnbGFiZWwnLCdsYWJvcicsJ2xhYm9yYXRvcnknLCdsYWNrJywnbGFkeScsJ2xha2UnLCdsYW5kJywnbGFuZHNjYXBlJywnbGFuZ3VhZ2UnLCdsYXAnLCdsYXJnZScsJ2xhcmdlbHknLCdsYXN0JywnbGF0ZScsJ2xhdGVyJywnTGF0aW4nLCdsYXR0ZXInLCdsYXVnaCcsJ2xhdW5jaCcsJ2xhdycsJ2xhd24nLCdsYXdzdWl0JywnbGF3eWVyJywnbGF5JywnbGF5ZXInLCdsZWFkJywnbGVhZGVyJywnbGVhZGVyc2hpcCcsJ2xlYWRpbmcnLCdsZWFmJywnbGVhZ3VlJywnbGVhbicsJ2xlYXJuJywnbGVhcm5pbmcnLCdsZWFzdCcsJ2xlYXRoZXInLCdsZWF2ZScsJ2xlZnQnLCdsZWcnLCdsZWdhY3knLCdsZWdhbCcsJ2xlZ2VuZCcsJ2xlZ2lzbGF0aW9uJywnbGVnaXRpbWF0ZScsJ2xlbW9uJywnbGVuZ3RoJywnbGVzcycsJ2xlc3NvbicsJ2xldCcsJ2xldHRlcicsJ2xldmVsJywnbGliZXJhbCcsJ2xpYnJhcnknLCdsaWNlbnNlJywnbGllJywnbGlmZScsJ2xpZmVzdHlsZScsJ2xpZmV0aW1lJywnbGlmdCcsJ2xpZ2h0JywnbGlrZScsJ2xpa2VseScsJ2xpbWl0JywnbGltaXRhdGlvbicsJ2xpbWl0ZWQnLCdsaW5lJywnbGluaycsJ2xpcCcsJ2xpc3QnLCdsaXN0ZW4nLCdsaXRlcmFsbHknLCdsaXRlcmFyeScsJ2xpdGVyYXR1cmUnLCdsaXR0bGUnLCdsaXZlJywnbGl2aW5nJywnbG9hZCcsJ2xvYW4nLCdsb2NhbCcsJ2xvY2F0ZScsJ2xvY2F0aW9uJywnbG9jaycsJ2xvbmcnLCdsb25nLXRlcm0nLCdsb29rJywnbG9vc2UnLCdsb3NlJywnbG9zcycsJ2xvc3QnLCdsb3QnLCdsb3RzJywnbG91ZCcsJ2xvdmUnLCdsb3ZlbHknLCdsb3ZlcicsJ2xvdycsJ2xvd2VyJywnbHVjaycsJ2x1Y2t5JywnbHVuY2gnLCdsdW5nJywnbWFjaGluZScsJ21hZCcsJ21hZ2F6aW5lJywnbWFpbCcsJ21haW4nLCdtYWlubHknLCdtYWludGFpbicsJ21haW50ZW5hbmNlJywnbWFqb3InLCdtYWpvcml0eScsJ21ha2UnLCdtYWtlcicsJ21ha2V1cCcsJ21hbGUnLCdtYWxsJywnbWFuJywnbWFuYWdlJywnbWFuYWdlbWVudCcsJ21hbmFnZXInLCdtYW5uZXInLCdtYW51ZmFjdHVyZXInLCdtYW51ZmFjdHVyaW5nJywnbWFueScsJ21hcCcsJ21hcmdpbicsJ21hcmsnLCdtYXJrZXQnLCdtYXJrZXRpbmcnLCdtYXJyaWFnZScsJ21hcnJpZWQnLCdtYXJyeScsJ21hc2snLCdtYXNzJywnbWFzc2l2ZScsJ21hc3RlcicsJ21hdGNoJywnbWF0ZXJpYWwnLCdtYXRoJywnbWF0dGVyJywnbWF5JywnbWF5YmUnLCdtYXlvcicsJ21lJywnbWVhbCcsJ21lYW4nLCdtZWFuaW5nJywnbWVhbndoaWxlJywnbWVhc3VyZScsJ21lYXN1cmVtZW50JywnbWVhdCcsJ21lY2hhbmlzbScsJ21lZGlhJywnbWVkaWNhbCcsJ21lZGljYXRpb24nLCdtZWRpY2luZScsJ21lZGl1bScsJ21lZXQnLCdtZWV0aW5nJywnbWVtYmVyJywnbWVtYmVyc2hpcCcsJ21lbW9yeScsJ21lbnRhbCcsJ21lbnRpb24nLCdtZW51JywnbWVyZScsJ21lcmVseScsJ21lc3MnLCdtZXNzYWdlJywnbWV0YWwnLCdtZXRlcicsJ21ldGhvZCcsJ01leGljYW4nLCdtaWRkbGUnLCdtaWdodCcsJ21pbGl0YXJ5JywnbWlsaycsJ21pbGxpb24nLCdtaW5kJywnbWluZScsJ21pbmlzdGVyJywnbWlub3InLCdtaW5vcml0eScsJ21pbnV0ZScsJ21pcmFjbGUnLCdtaXJyb3InLCdtaXNzJywnbWlzc2lsZScsJ21pc3Npb24nLCdtaXN0YWtlJywnbWl4JywnbWl4dHVyZScsJ21tLWhtbScsJ21vZGUnLCdtb2RlbCcsJ21vZGVyYXRlJywnbW9kZXJuJywnbW9kZXN0JywnbW9tJywnbW9tZW50JywnbW9uZXknLCdtb25pdG9yJywnbW9udGgnLCdtb29kJywnbW9vbicsJ21vcmFsJywnbW9yZScsJ21vcmVvdmVyJywnbW9ybmluZycsJ21vcnRnYWdlJywnbW9zdCcsJ21vc3RseScsJ21vdGhlcicsJ21vdGlvbicsJ21vdGl2YXRpb24nLCdtb3RvcicsJ21vdW50JywnbW91bnRhaW4nLCdtb3VzZScsJ21vdXRoJywnbW92ZScsJ21vdmVtZW50JywnbW92aWUnLCdNcicsJ01ycycsJ01zJywnbXVjaCcsJ211bHRpcGxlJywnbXVyZGVyJywnbXVzY2xlJywnbXVzZXVtJywnbXVzaWMnLCdtdXNpY2FsJywnbXVzaWNpYW4nLCdNdXNsaW0nLCdtdXN0JywnbXV0dWFsJywnbXknLCdteXNlbGYnLCdteXN0ZXJ5JywnbXl0aCcsJ25ha2VkJywnbmFtZScsJ25hcnJhdGl2ZScsJ25hcnJvdycsJ25hdGlvbicsJ25hdGlvbmFsJywnbmF0aXZlJywnbmF0dXJhbCcsJ25hdHVyYWxseScsJ25hdHVyZScsJ25lYXInLCduZWFyYnknLCduZWFybHknLCduZWNlc3NhcmlseScsJ25lY2Vzc2FyeScsJ25lY2snLCduZWVkJywnbmVnYXRpdmUnLCduZWdvdGlhdGUnLCduZWdvdGlhdGlvbicsJ25laWdoYm9yJywnbmVpZ2hib3Job29kJywnbmVpdGhlcicsJ25lcnZlJywnbmVydm91cycsJ25ldCcsJ25ldHdvcmsnLCduZXZlcicsJ25ldmVydGhlbGVzcycsJ25ldycsJ25ld2x5JywnbmV3cycsJ25ld3NwYXBlcicsJ25leHQnLCduaWNlJywnbmlnaHQnLCduaW5lJywnbm8nLCdub2JvZHknLCdub2QnLCdub2lzZScsJ25vbWluYXRpb24nLCdub25lJywnbm9uZXRoZWxlc3MnLCdub3InLCdub3JtYWwnLCdub3JtYWxseScsJ25vcnRoJywnbm9ydGhlcm4nLCdub3NlJywnbm90Jywnbm90ZScsJ25vdGhpbmcnLCdub3RpY2UnLCdub3Rpb24nLCdub3ZlbCcsJ25vdycsJ25vd2hlcmUnLCdudWNsZWFyJywnbnVtYmVyJywnbnVtZXJvdXMnLCdudXJzZScsJ251dCcsJ29iamVjdCcsJ29iamVjdGl2ZScsJ29ibGlnYXRpb24nLCdvYnNlcnZhdGlvbicsJ29ic2VydmUnLCdvYnNlcnZlcicsJ29idGFpbicsJ29idmlvdXMnLCdvYnZpb3VzbHknLCdvY2Nhc2lvbicsJ29jY2FzaW9uYWxseScsJ29jY3VwYXRpb24nLCdvY2N1cHknLCdvY2N1cicsJ29jZWFuJywnb2RkJywnb2RkcycsJ29mJywnb2ZmJywnb2ZmZW5zZScsJ29mZmVuc2l2ZScsJ29mZmVyJywnb2ZmaWNlJywnb2ZmaWNlcicsJ29mZmljaWFsJywnb2Z0ZW4nLCdvaCcsJ29pbCcsJ29rJywnb2theScsJ29sZCcsJ09seW1waWMnLCdvbicsJ29uY2UnLCdvbmUnLCdvbmdvaW5nJywnb25pb24nLCdvbmxpbmUnLCdvbmx5Jywnb250bycsJ29wZW4nLCdvcGVuaW5nJywnb3BlcmF0ZScsJ29wZXJhdGluZycsJ29wZXJhdGlvbicsJ29wZXJhdG9yJywnb3BpbmlvbicsJ29wcG9uZW50Jywnb3Bwb3J0dW5pdHknLCdvcHBvc2UnLCdvcHBvc2l0ZScsJ29wcG9zaXRpb24nLCdvcHRpb24nLCdvcicsJ29yYW5nZScsJ29yZGVyJywnb3JkaW5hcnknLCdvcmdhbmljJywnb3JnYW5pemF0aW9uJywnb3JnYW5pemUnLCdvcmllbnRhdGlvbicsJ29yaWdpbicsJ29yaWdpbmFsJywnb3JpZ2luYWxseScsJ290aGVyJywnb3RoZXJzJywnb3RoZXJ3aXNlJywnb3VnaHQnLCdvdXInLCdvdXJzZWx2ZXMnLCdvdXQnLCdvdXRjb21lJywnb3V0c2lkZScsJ292ZW4nLCdvdmVyJywnb3ZlcmFsbCcsJ292ZXJjb21lJywnb3Zlcmxvb2snLCdvd2UnLCdvd24nLCdvd25lcicsJ3BhY2UnLCdwYWNrJywncGFja2FnZScsJ3BhZ2UnLCdwYWluJywncGFpbmZ1bCcsJ3BhaW50JywncGFpbnRlcicsJ3BhaW50aW5nJywncGFpcicsJ3BhbGUnLCdQYWxlc3RpbmlhbicsJ3BhbG0nLCdwYW4nLCdwYW5lbCcsJ3BhbnQnLCdwYXBlcicsJ3BhcmVudCcsJ3BhcmsnLCdwYXJraW5nJywncGFydCcsJ3BhcnRpY2lwYW50JywncGFydGljaXBhdGUnLCdwYXJ0aWNpcGF0aW9uJywncGFydGljdWxhcicsJ3BhcnRpY3VsYXJseScsJ3BhcnRseScsJ3BhcnRuZXInLCdwYXJ0bmVyc2hpcCcsJ3BhcnR5JywncGFzcycsJ3Bhc3NhZ2UnLCdwYXNzZW5nZXInLCdwYXNzaW9uJywncGFzdCcsJ3BhdGNoJywncGF0aCcsJ3BhdGllbnQnLCdwYXR0ZXJuJywncGF1c2UnLCdwYXknLCdwYXltZW50JywnUEMnLCdwZWFjZScsJ3BlYWsnLCdwZWVyJywncGVuYWx0eScsJ3Blb3BsZScsJ3BlcHBlcicsJ3BlcicsJ3BlcmNlaXZlJywncGVyY2VudGFnZScsJ3BlcmNlcHRpb24nLCdwZXJmZWN0JywncGVyZmVjdGx5JywncGVyZm9ybScsJ3BlcmZvcm1hbmNlJywncGVyaGFwcycsJ3BlcmlvZCcsJ3Blcm1hbmVudCcsJ3Blcm1pc3Npb24nLCdwZXJtaXQnLCdwZXJzb24nLCdwZXJzb25hbCcsJ3BlcnNvbmFsaXR5JywncGVyc29uYWxseScsJ3BlcnNvbm5lbCcsJ3BlcnNwZWN0aXZlJywncGVyc3VhZGUnLCdwZXQnLCdwaGFzZScsJ3BoZW5vbWVub24nLCdwaGlsb3NvcGh5JywncGhvbmUnLCdwaG90bycsJ3Bob3RvZ3JhcGgnLCdwaG90b2dyYXBoZXInLCdwaHJhc2UnLCdwaHlzaWNhbCcsJ3BoeXNpY2FsbHknLCdwaHlzaWNpYW4nLCdwaWFubycsJ3BpY2snLCdwaWN0dXJlJywncGllJywncGllY2UnLCdwaWxlJywncGlsb3QnLCdwaW5lJywncGluaycsJ3BpcGUnLCdwaXRjaCcsJ3BsYWNlJywncGxhbicsJ3BsYW5lJywncGxhbmV0JywncGxhbm5pbmcnLCdwbGFudCcsJ3BsYXN0aWMnLCdwbGF0ZScsJ3BsYXRmb3JtJywncGxheScsJ3BsYXllcicsJ3BsZWFzZScsJ3BsZWFzdXJlJywncGxlbnR5JywncGxvdCcsJ3BsdXMnLCdQTScsJ3BvY2tldCcsJ3BvZW0nLCdwb2V0JywncG9ldHJ5JywncG9pbnQnLCdwb2xlJywncG9saWNlJywncG9saWN5JywncG9saXRpY2FsJywncG9saXRpY2FsbHknLCdwb2xpdGljaWFuJywncG9saXRpY3MnLCdwb2xsJywncG9sbHV0aW9uJywncG9vbCcsJ3Bvb3InLCdwb3AnLCdwb3B1bGFyJywncG9wdWxhdGlvbicsJ3BvcmNoJywncG9ydCcsJ3BvcnRpb24nLCdwb3J0cmFpdCcsJ3BvcnRyYXknLCdwb3NlJywncG9zaXRpb24nLCdwb3NpdGl2ZScsJ3Bvc3Nlc3MnLCdwb3NzaWJpbGl0eScsJ3Bvc3NpYmxlJywncG9zc2libHknLCdwb3N0JywncG90JywncG90YXRvJywncG90ZW50aWFsJywncG90ZW50aWFsbHknLCdwb3VuZCcsJ3BvdXInLCdwb3ZlcnR5JywncG93ZGVyJywncG93ZXInLCdwb3dlcmZ1bCcsJ3ByYWN0aWNhbCcsJ3ByYWN0aWNlJywncHJheScsJ3ByYXllcicsJ3ByZWNpc2VseScsJ3ByZWRpY3QnLCdwcmVmZXInLCdwcmVmZXJlbmNlJywncHJlZ25hbmN5JywncHJlZ25hbnQnLCdwcmVwYXJhdGlvbicsJ3ByZXBhcmUnLCdwcmVzY3JpcHRpb24nLCdwcmVzZW5jZScsJ3ByZXNlbnQnLCdwcmVzZW50YXRpb24nLCdwcmVzZXJ2ZScsJ3ByZXNpZGVudCcsJ3ByZXNpZGVudGlhbCcsJ3ByZXNzJywncHJlc3N1cmUnLCdwcmV0ZW5kJywncHJldHR5JywncHJldmVudCcsJ3ByZXZpb3VzJywncHJldmlvdXNseScsJ3ByaWNlJywncHJpZGUnLCdwcmllc3QnLCdwcmltYXJpbHknLCdwcmltYXJ5JywncHJpbWUnLCdwcmluY2lwYWwnLCdwcmluY2lwbGUnLCdwcmludCcsJ3ByaW9yJywncHJpb3JpdHknLCdwcmlzb24nLCdwcmlzb25lcicsJ3ByaXZhY3knLCdwcml2YXRlJywncHJvYmFibHknLCdwcm9ibGVtJywncHJvY2VkdXJlJywncHJvY2VlZCcsJ3Byb2Nlc3MnLCdwcm9kdWNlJywncHJvZHVjZXInLCdwcm9kdWN0JywncHJvZHVjdGlvbicsJ3Byb2Zlc3Npb24nLCdwcm9mZXNzaW9uYWwnLCdwcm9mZXNzb3InLCdwcm9maWxlJywncHJvZml0JywncHJvZ3JhbScsJ3Byb2dyZXNzJywncHJvamVjdCcsJ3Byb21pbmVudCcsJ3Byb21pc2UnLCdwcm9tb3RlJywncHJvbXB0JywncHJvb2YnLCdwcm9wZXInLCdwcm9wZXJseScsJ3Byb3BlcnR5JywncHJvcG9ydGlvbicsJ3Byb3Bvc2FsJywncHJvcG9zZScsJ3Byb3Bvc2VkJywncHJvc2VjdXRvcicsJ3Byb3NwZWN0JywncHJvdGVjdCcsJ3Byb3RlY3Rpb24nLCdwcm90ZWluJywncHJvdGVzdCcsJ3Byb3VkJywncHJvdmUnLFxuJ3Byb3ZpZGUnLCdwcm92aWRlcicsJ3Byb3ZpbmNlJywncHJvdmlzaW9uJywncHN5Y2hvbG9naWNhbCcsJ3BzeWNob2xvZ2lzdCcsJ3BzeWNob2xvZ3knLCdwdWJsaWMnLCdwdWJsaWNhdGlvbicsJ3B1YmxpY2x5JywncHVibGlzaCcsJ3B1Ymxpc2hlcicsJ3B1bGwnLCdwdW5pc2htZW50JywncHVyY2hhc2UnLCdwdXJlJywncHVycG9zZScsJ3B1cnN1ZScsJ3B1c2gnLCdwdXQnLCdxdWFsaWZ5JywncXVhbGl0eScsJ3F1YXJ0ZXInLCdxdWFydGVyYmFjaycsJ3F1ZXN0aW9uJywncXVpY2snLCdxdWlja2x5JywncXVpZXQnLCdxdWlldGx5JywncXVpdCcsJ3F1aXRlJywncXVvdGUnLCdyYWNlJywncmFjaWFsJywncmFkaWNhbCcsJ3JhZGlvJywncmFpbCcsJ3JhaW4nLCdyYWlzZScsJ3JhbmdlJywncmFuaycsJ3JhcGlkJywncmFwaWRseScsJ3JhcmUnLCdyYXJlbHknLCdyYXRlJywncmF0aGVyJywncmF0aW5nJywncmF0aW8nLCdyYXcnLCdyZWFjaCcsJ3JlYWN0JywncmVhY3Rpb24nLCdyZWFkJywncmVhZGVyJywncmVhZGluZycsJ3JlYWR5JywncmVhbCcsJ3JlYWxpdHknLCdyZWFsaXplJywncmVhbGx5JywncmVhc29uJywncmVhc29uYWJsZScsJ3JlY2FsbCcsJ3JlY2VpdmUnLCdyZWNlbnQnLCdyZWNlbnRseScsJ3JlY2lwZScsJ3JlY29nbml0aW9uJywncmVjb2duaXplJywncmVjb21tZW5kJywncmVjb21tZW5kYXRpb24nLCdyZWNvcmQnLCdyZWNvcmRpbmcnLCdyZWNvdmVyJywncmVjb3ZlcnknLCdyZWNydWl0JywncmVkJywncmVkdWNlJywncmVkdWN0aW9uJywncmVmZXInLCdyZWZlcmVuY2UnLCdyZWZsZWN0JywncmVmbGVjdGlvbicsJ3JlZm9ybScsJ3JlZnVnZWUnLCdyZWZ1c2UnLCdyZWdhcmQnLCdyZWdhcmRpbmcnLCdyZWdhcmRsZXNzJywncmVnaW1lJywncmVnaW9uJywncmVnaW9uYWwnLCdyZWdpc3RlcicsJ3JlZ3VsYXInLCdyZWd1bGFybHknLCdyZWd1bGF0ZScsJ3JlZ3VsYXRpb24nLCdyZWluZm9yY2UnLCdyZWplY3QnLCdyZWxhdGUnLCdyZWxhdGlvbicsJ3JlbGF0aW9uc2hpcCcsJ3JlbGF0aXZlJywncmVsYXRpdmVseScsJ3JlbGF4JywncmVsZWFzZScsJ3JlbGV2YW50JywncmVsaWVmJywncmVsaWdpb24nLCdyZWxpZ2lvdXMnLCdyZWx5JywncmVtYWluJywncmVtYWluaW5nJywncmVtYXJrYWJsZScsJ3JlbWVtYmVyJywncmVtaW5kJywncmVtb3RlJywncmVtb3ZlJywncmVwZWF0JywncmVwZWF0ZWRseScsJ3JlcGxhY2UnLCdyZXBseScsJ3JlcG9ydCcsJ3JlcG9ydGVyJywncmVwcmVzZW50JywncmVwcmVzZW50YXRpb24nLCdyZXByZXNlbnRhdGl2ZScsJ1JlcHVibGljYW4nLCdyZXB1dGF0aW9uJywncmVxdWVzdCcsJ3JlcXVpcmUnLCdyZXF1aXJlbWVudCcsJ3Jlc2VhcmNoJywncmVzZWFyY2hlcicsJ3Jlc2VtYmxlJywncmVzZXJ2YXRpb24nLCdyZXNpZGVudCcsJ3Jlc2lzdCcsJ3Jlc2lzdGFuY2UnLCdyZXNvbHV0aW9uJywncmVzb2x2ZScsJ3Jlc29ydCcsJ3Jlc291cmNlJywncmVzcGVjdCcsJ3Jlc3BvbmQnLCdyZXNwb25kZW50JywncmVzcG9uc2UnLCdyZXNwb25zaWJpbGl0eScsJ3Jlc3BvbnNpYmxlJywncmVzdCcsJ3Jlc3RhdXJhbnQnLCdyZXN0b3JlJywncmVzdHJpY3Rpb24nLCdyZXN1bHQnLCdyZXRhaW4nLCdyZXRpcmUnLCdyZXRpcmVtZW50JywncmV0dXJuJywncmV2ZWFsJywncmV2ZW51ZScsJ3JldmlldycsJ3Jldm9sdXRpb24nLCdyaHl0aG0nLCdyaWNlJywncmljaCcsJ3JpZCcsJ3JpZGUnLCdyaWZsZScsJ3JpZ2h0JywncmluZycsJ3Jpc2UnLCdyaXNrJywncml2ZXInLCdyb2FkJywncm9jaycsJ3JvbGUnLCdyb2xsJywncm9tYW50aWMnLCdyb29mJywncm9vbScsJ3Jvb3QnLCdyb3BlJywncm9zZScsJ3JvdWdoJywncm91Z2hseScsJ3JvdW5kJywncm91dGUnLCdyb3V0aW5lJywncm93JywncnViJywncnVsZScsJ3J1bicsJ3J1bm5pbmcnLCdydXJhbCcsJ3J1c2gnLCdSdXNzaWFuJywnc2FjcmVkJywnc2FkJywnc2FmZScsJ3NhZmV0eScsJ3Nha2UnLCdzYWxhZCcsJ3NhbGFyeScsJ3NhbGUnLCdzYWxlcycsJ3NhbHQnLCdzYW1lJywnc2FtcGxlJywnc2FuY3Rpb24nLCdzYW5kJywnc2F0ZWxsaXRlJywnc2F0aXNmYWN0aW9uJywnc2F0aXNmeScsJ3NhdWNlJywnc2F2ZScsJ3NhdmluZycsJ3NheScsJ3NjYWxlJywnc2NhbmRhbCcsJ3NjYXJlZCcsJ3NjZW5hcmlvJywnc2NlbmUnLCdzY2hlZHVsZScsJ3NjaGVtZScsJ3NjaG9sYXInLCdzY2hvbGFyc2hpcCcsJ3NjaG9vbCcsJ3NjaWVuY2UnLCdzY2llbnRpZmljJywnc2NpZW50aXN0Jywnc2NvcGUnLCdzY29yZScsJ3NjcmVhbScsJ3NjcmVlbicsJ3NjcmlwdCcsJ3NlYScsJ3NlYXJjaCcsJ3NlYXNvbicsJ3NlYXQnLCdzZWNvbmQnLCdzZWNyZXQnLCdzZWNyZXRhcnknLCdzZWN0aW9uJywnc2VjdG9yJywnc2VjdXJlJywnc2VjdXJpdHknLCdzZWUnLCdzZWVkJywnc2VlaycsJ3NlZW0nLCdzZWdtZW50Jywnc2VpemUnLCdzZWxlY3QnLCdzZWxlY3Rpb24nLCdzZWxmJywnc2VsbCcsJ1NlbmF0ZScsJ3NlbmF0b3InLCdzZW5kJywnc2VuaW9yJywnc2Vuc2UnLCdzZW5zaXRpdmUnLCdzZW50ZW5jZScsJ3NlcGFyYXRlJywnc2VxdWVuY2UnLCdzZXJpZXMnLCdzZXJpb3VzJywnc2VyaW91c2x5Jywnc2VydmUnLCdzZXJ2aWNlJywnc2Vzc2lvbicsJ3NldCcsJ3NldHRpbmcnLCdzZXR0bGUnLCdzZXR0bGVtZW50Jywnc2V2ZW4nLCdzZXZlcmFsJywnc2V2ZXJlJywnc2V4Jywnc2V4dWFsJywnc2hhZGUnLCdzaGFkb3cnLCdzaGFrZScsJ3NoYWxsJywnc2hhcGUnLCdzaGFyZScsJ3NoYXJwJywnc2hlJywnc2hlZXQnLCdzaGVsZicsJ3NoZWxsJywnc2hlbHRlcicsJ3NoaWZ0Jywnc2hpbmUnLCdzaGlwJywnc2hpcnQnLCdzaGl0Jywnc2hvY2snLCdzaG9lJywnc2hvb3QnLCdzaG9vdGluZycsJ3Nob3AnLCdzaG9wcGluZycsJ3Nob3JlJywnc2hvcnQnLCdzaG9ydGx5Jywnc2hvdCcsJ3Nob3VsZCcsJ3Nob3VsZGVyJywnc2hvdXQnLCdzaG93Jywnc2hvd2VyJywnc2hydWcnLCdzaHV0Jywnc2ljaycsJ3NpZGUnLCdzaWdoJywnc2lnaHQnLCdzaWduJywnc2lnbmFsJywnc2lnbmlmaWNhbmNlJywnc2lnbmlmaWNhbnQnLCdzaWduaWZpY2FudGx5Jywnc2lsZW5jZScsJ3NpbGVudCcsJ3NpbHZlcicsJ3NpbWlsYXInLCdzaW1pbGFybHknLCdzaW1wbGUnLCdzaW1wbHknLCdzaW4nLCdzaW5jZScsJ3NpbmcnLCdzaW5nZXInLCdzaW5nbGUnLCdzaW5rJywnc2lyJywnc2lzdGVyJywnc2l0Jywnc2l0ZScsJ3NpdHVhdGlvbicsJ3NpeCcsJ3NpemUnLCdza2knLCdza2lsbCcsJ3NraW4nLCdza3knLCdzbGF2ZScsJ3NsZWVwJywnc2xpY2UnLCdzbGlkZScsJ3NsaWdodCcsJ3NsaWdodGx5Jywnc2xpcCcsJ3Nsb3cnLCdzbG93bHknLCdzbWFsbCcsJ3NtYXJ0Jywnc21lbGwnLCdzbWlsZScsJ3Ntb2tlJywnc21vb3RoJywnc25hcCcsJ3Nub3cnLCdzbycsJ3NvLWNhbGxlZCcsJ3NvY2NlcicsJ3NvY2lhbCcsJ3NvY2lldHknLCdzb2Z0Jywnc29mdHdhcmUnLCdzb2lsJywnc29sYXInLCdzb2xkaWVyJywnc29saWQnLCdzb2x1dGlvbicsJ3NvbHZlJywnc29tZScsJ3NvbWVib2R5Jywnc29tZWhvdycsJ3NvbWVvbmUnLCdzb21ldGhpbmcnLCdzb21ldGltZXMnLCdzb21ld2hhdCcsJ3NvbWV3aGVyZScsJ3NvbicsJ3NvbmcnLCdzb29uJywnc29waGlzdGljYXRlZCcsJ3NvcnJ5Jywnc29ydCcsJ3NvdWwnLCdzb3VuZCcsJ3NvdXAnLCdzb3VyY2UnLCdzb3V0aCcsJ3NvdXRoZXJuJywnU292aWV0Jywnc3BhY2UnLCdTcGFuaXNoJywnc3BlYWsnLCdzcGVha2VyJywnc3BlY2lhbCcsJ3NwZWNpYWxpc3QnLCdzcGVjaWVzJywnc3BlY2lmaWMnLCdzcGVjaWZpY2FsbHknLCdzcGVlY2gnLCdzcGVlZCcsJ3NwZW5kJywnc3BlbmRpbmcnLCdzcGluJywnc3Bpcml0Jywnc3Bpcml0dWFsJywnc3BsaXQnLCdzcG9rZXNtYW4nLCdzcG9ydCcsJ3Nwb3QnLCdzcHJlYWQnLCdzcHJpbmcnLCdzcXVhcmUnLCdzcXVlZXplJywnc3RhYmlsaXR5Jywnc3RhYmxlJywnc3RhZmYnLCdzdGFnZScsJ3N0YWlyJywnc3Rha2UnLCdzdGFuZCcsJ3N0YW5kYXJkJywnc3RhbmRpbmcnLCdzdGFyJywnc3RhcmUnLCdzdGFydCcsJ3N0YXRlJywnc3RhdGVtZW50Jywnc3RhdGlvbicsJ3N0YXRpc3RpY3MnLCdzdGF0dXMnLCdzdGF5Jywnc3RlYWR5Jywnc3RlYWwnLCdzdGVlbCcsJ3N0ZXAnLCdzdGljaycsJ3N0aWxsJywnc3RpcicsJ3N0b2NrJywnc3RvbWFjaCcsJ3N0b25lJywnc3RvcCcsJ3N0b3JhZ2UnLCdzdG9yZScsJ3N0b3JtJywnc3RvcnknLCdzdHJhaWdodCcsJ3N0cmFuZ2UnLCdzdHJhbmdlcicsJ3N0cmF0ZWdpYycsJ3N0cmF0ZWd5Jywnc3RyZWFtJywnc3RyZWV0Jywnc3RyZW5ndGgnLCdzdHJlbmd0aGVuJywnc3RyZXNzJywnc3RyZXRjaCcsJ3N0cmlrZScsJ3N0cmluZycsJ3N0cmlwJywnc3Ryb2tlJywnc3Ryb25nJywnc3Ryb25nbHknLCdzdHJ1Y3R1cmUnLCdzdHJ1Z2dsZScsJ3N0dWRlbnQnLCdzdHVkaW8nLCdzdHVkeScsJ3N0dWZmJywnc3R1cGlkJywnc3R5bGUnLCdzdWJqZWN0Jywnc3VibWl0Jywnc3Vic2VxdWVudCcsJ3N1YnN0YW5jZScsJ3N1YnN0YW50aWFsJywnc3VjY2VlZCcsJ3N1Y2Nlc3MnLCdzdWNjZXNzZnVsJywnc3VjY2Vzc2Z1bGx5Jywnc3VjaCcsJ3N1ZGRlbicsJ3N1ZGRlbmx5Jywnc3VlJywnc3VmZmVyJywnc3VmZmljaWVudCcsJ3N1Z2FyJywnc3VnZ2VzdCcsJ3N1Z2dlc3Rpb24nLCdzdWljaWRlJywnc3VpdCcsJ3N1bW1lcicsJ3N1bW1pdCcsJ3N1bicsJ3N1cGVyJywnc3VwcGx5Jywnc3VwcG9ydCcsJ3N1cHBvcnRlcicsJ3N1cHBvc2UnLCdzdXBwb3NlZCcsJ1N1cHJlbWUnLCdzdXJlJywnc3VyZWx5Jywnc3VyZmFjZScsJ3N1cmdlcnknLCdzdXJwcmlzZScsJ3N1cnByaXNlZCcsJ3N1cnByaXNpbmcnLCdzdXJwcmlzaW5nbHknLCdzdXJyb3VuZCcsJ3N1cnZleScsJ3N1cnZpdmFsJywnc3Vydml2ZScsJ3N1cnZpdm9yJywnc3VzcGVjdCcsJ3N1c3RhaW4nLCdzd2VhcicsJ3N3ZWVwJywnc3dlZXQnLCdzd2ltJywnc3dpbmcnLCdzd2l0Y2gnLCdzeW1ib2wnLCdzeW1wdG9tJywnc3lzdGVtJywndGFibGUnLCd0YWJsZXNwb29uJywndGFjdGljJywndGFpbCcsJ3Rha2UnLCd0YWxlJywndGFsZW50JywndGFsaycsJ3RhbGwnLCd0YW5rJywndGFwJywndGFwZScsJ3RhcmdldCcsJ3Rhc2snLCd0YXN0ZScsJ3RheCcsJ3RheHBheWVyJywndGVhJywndGVhY2gnLCd0ZWFjaGVyJywndGVhY2hpbmcnLCd0ZWFtJywndGVhcicsJ3RlYXNwb29uJywndGVjaG5pY2FsJywndGVjaG5pcXVlJywndGVjaG5vbG9neScsJ3RlZW4nLCd0ZWVuYWdlcicsJ3RlbGVwaG9uZScsJ3RlbGVzY29wZScsJ3RlbGV2aXNpb24nLCd0ZWxsJywndGVtcGVyYXR1cmUnLCd0ZW1wb3JhcnknLCd0ZW4nLCd0ZW5kJywndGVuZGVuY3knLCd0ZW5uaXMnLCd0ZW5zaW9uJywndGVudCcsJ3Rlcm0nLCd0ZXJtcycsJ3RlcnJpYmxlJywndGVycml0b3J5JywndGVycm9yJywndGVycm9yaXNtJywndGVycm9yaXN0JywndGVzdCcsJ3Rlc3RpZnknLCd0ZXN0aW1vbnknLCd0ZXN0aW5nJywndGV4dCcsJ3RoYW4nLCd0aGFuaycsJ3RoYW5rcycsJ3RoYXQnLCd0aGUnLCd0aGVhdGVyJywndGhlaXInLCd0aGVtJywndGhlbWUnLCd0aGVtc2VsdmVzJywndGhlbicsJ3RoZW9yeScsJ3RoZXJhcHknLCd0aGVyZScsJ3RoZXJlZm9yZScsJ3RoZXNlJywndGhleScsJ3RoaWNrJywndGhpbicsJ3RoaW5nJywndGhpbmsnLCd0aGlua2luZycsJ3RoaXJkJywndGhpcnR5JywndGhpcycsJ3Rob3NlJywndGhvdWdoJywndGhvdWdodCcsJ3Rob3VzYW5kJywndGhyZWF0JywndGhyZWF0ZW4nLCd0aHJlZScsJ3Rocm9hdCcsJ3Rocm91Z2gnLCd0aHJvdWdob3V0JywndGhyb3cnLCd0aHVzJywndGlja2V0JywndGllJywndGlnaHQnLCd0aW1lJywndGlueScsJ3RpcCcsJ3RpcmUnLCd0aXJlZCcsJ3Rpc3N1ZScsJ3RpdGxlJywndG8nLCd0b2JhY2NvJywndG9kYXknLCd0b2UnLCd0b2dldGhlcicsJ3RvbWF0bycsJ3RvbW9ycm93JywndG9uZScsJ3Rvbmd1ZScsJ3RvbmlnaHQnLCd0b28nLCd0b29sJywndG9vdGgnLCd0b3AnLCd0b3BpYycsJ3Rvc3MnLCd0b3RhbCcsJ3RvdGFsbHknLCd0b3VjaCcsJ3RvdWdoJywndG91cicsJ3RvdXJpc3QnLCd0b3VybmFtZW50JywndG93YXJkJywndG93YXJkcycsJ3Rvd2VyJywndG93bicsJ3RveScsJ3RyYWNlJywndHJhY2snLCd0cmFkZScsJ3RyYWRpdGlvbicsJ3RyYWRpdGlvbmFsJywndHJhZmZpYycsJ3RyYWdlZHknLCd0cmFpbCcsJ3RyYWluJywndHJhaW5pbmcnLCd0cmFuc2ZlcicsJ3RyYW5zZm9ybScsJ3RyYW5zZm9ybWF0aW9uJywndHJhbnNpdGlvbicsJ3RyYW5zbGF0ZScsJ3RyYW5zcG9ydGF0aW9uJywndHJhdmVsJywndHJlYXQnLCd0cmVhdG1lbnQnLCd0cmVhdHknLCd0cmVlJywndHJlbWVuZG91cycsJ3RyZW5kJywndHJpYWwnLCd0cmliZScsJ3RyaWNrJywndHJpcCcsJ3Ryb29wJywndHJvdWJsZScsJ3RydWNrJywndHJ1ZScsJ3RydWx5JywndHJ1c3QnLCd0cnV0aCcsJ3RyeScsJ3R1YmUnLCd0dW5uZWwnLCd0dXJuJywnVFYnLCd0d2VsdmUnLCd0d2VudHknLCd0d2ljZScsJ3R3aW4nLCd0d28nLCd0eXBlJywndHlwaWNhbCcsJ3R5cGljYWxseScsJ3VnbHknLCd1bHRpbWF0ZScsJ3VsdGltYXRlbHknLCd1bmFibGUnLCd1bmNsZScsJ3VuZGVyJywndW5kZXJnbycsJ3VuZGVyc3RhbmQnLCd1bmRlcnN0YW5kaW5nJywndW5mb3J0dW5hdGVseScsJ3VuaWZvcm0nLCd1bmlvbicsJ3VuaXF1ZScsJ3VuaXQnLCdVbml0ZWQnLCd1bml2ZXJzYWwnLCd1bml2ZXJzZScsJ3VuaXZlcnNpdHknLCd1bmtub3duJywndW5sZXNzJywndW5saWtlJywndW5saWtlbHknLCd1bnRpbCcsJ3VudXN1YWwnLCd1cCcsJ3Vwb24nLCd1cHBlcicsJ3VyYmFuJywndXJnZScsJ3VzJywndXNlJywndXNlZCcsJ3VzZWZ1bCcsJ3VzZXInLCd1c3VhbCcsJ3VzdWFsbHknLCd1dGlsaXR5JywndmFjYXRpb24nLCd2YWxsZXknLCd2YWx1YWJsZScsJ3ZhbHVlJywndmFyaWFibGUnLCd2YXJpYXRpb24nLCd2YXJpZXR5JywndmFyaW91cycsJ3ZhcnknLCd2YXN0JywndmVnZXRhYmxlJywndmVoaWNsZScsJ3ZlbnR1cmUnLCd2ZXJzaW9uJywndmVyc3VzJywndmVyeScsJ3Zlc3NlbCcsJ3ZldGVyYW4nLCd2aWEnLCd2aWN0aW0nLCd2aWN0b3J5JywndmlkZW8nLCd2aWV3Jywndmlld2VyJywndmlsbGFnZScsJ3Zpb2xhdGUnLCd2aW9sYXRpb24nLCd2aW9sZW5jZScsJ3Zpb2xlbnQnLCd2aXJ0dWFsbHknLCd2aXJ0dWUnLCd2aXJ1cycsJ3Zpc2libGUnLCd2aXNpb24nLCd2aXNpdCcsJ3Zpc2l0b3InLCd2aXN1YWwnLCd2aXRhbCcsJ3ZvaWNlJywndm9sdW1lJywndm9sdW50ZWVyJywndm90ZScsJ3ZvdGVyJywndnMnLCd2dWxuZXJhYmxlJywnd2FnZScsJ3dhaXQnLCd3YWtlJywnd2FsaycsJ3dhbGwnLCd3YW5kZXInLCd3YW50Jywnd2FyJywnd2FybScsJ3dhcm4nLCd3YXJuaW5nJywnd2FzaCcsJ3dhc3RlJywnd2F0Y2gnLCd3YXRlcicsJ3dhdmUnLCd3YXknLCd3ZScsJ3dlYWsnLCd3ZWFsdGgnLCd3ZWFsdGh5Jywnd2VhcG9uJywnd2VhcicsJ3dlYXRoZXInLCd3ZWRkaW5nJywnd2VlaycsJ3dlZWtlbmQnLCd3ZWVrbHknLCd3ZWlnaCcsJ3dlaWdodCcsJ3dlbGNvbWUnLCd3ZWxmYXJlJywnd2VsbCcsJ3dlc3QnLCd3ZXN0ZXJuJywnd2V0Jywnd2hhdCcsJ3doYXRldmVyJywnd2hlZWwnLCd3aGVuJywnd2hlbmV2ZXInLCd3aGVyZScsJ3doZXJlYXMnLCd3aGV0aGVyJywnd2hpY2gnLCd3aGlsZScsJ3doaXNwZXInLCd3aGl0ZScsJ3dobycsJ3dob2xlJywnd2hvbScsJ3dob3NlJywnd2h5Jywnd2lkZScsJ3dpZGVseScsJ3dpZGVzcHJlYWQnLCd3aWZlJywnd2lsZCcsJ3dpbGwnLCd3aWxsaW5nJywnd2luJywnd2luZCcsJ3dpbmRvdycsJ3dpbmUnLCd3aW5nJywnd2lubmVyJywnd2ludGVyJywnd2lwZScsJ3dpcmUnLCd3aXNkb20nLCd3aXNlJywnd2lzaCcsJ3dpdGgnLCd3aXRoZHJhdycsJ3dpdGhpbicsJ3dpdGhvdXQnLCd3aXRuZXNzJywnd29tYW4nLCd3b25kZXInLCd3b25kZXJmdWwnLCd3b29kJywnd29vZGVuJywnd29yZCcsJ3dvcmsnLCd3b3JrZXInLCd3b3JraW5nJywnd29ya3MnLCd3b3Jrc2hvcCcsJ3dvcmxkJywnd29ycmllZCcsJ3dvcnJ5Jywnd29ydGgnLCd3b3VsZCcsJ3dvdW5kJywnd3JhcCcsJ3dyaXRlJywnd3JpdGVyJywnd3JpdGluZycsJ3dyb25nJywneWFyZCcsJ3llYWgnLCd5ZWFyJywneWVsbCcsJ3llbGxvdycsJ3llcycsJ3llc3RlcmRheScsJ3lldCcsJ3lpZWxkJywneW91JywneW91bmcnLCd5b3VyJywneW91cnMnLCd5b3Vyc2VsZicsJ3lvdXRoJywnem9uZSddXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/components/VLink.vue?vue&type=template&id=19fc4ad4\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("a", {\n    href: $props.href,\n    onClick: _cache[1] || (_cache[1] = Object(vue_esm_bundler["r" /* withModifiers */])(function () {\n      return $options.go && $options.go.apply($options, arguments);\n    }, ["prevent"]))\n  }, [Object(vue_esm_bundler["j" /* renderSlot */])(_ctx.$slots, "default")], 8\n  /* PROPS */\n  , ["href"]);\n}\n// CONCATENATED MODULE: ./src/components/VLink.vue?vue&type=template&id=19fc4ad4\n\n// EXTERNAL MODULE: ./src/routes.js\nvar routes = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/components/VLink.vue?vue&type=script&lang=js\n\n/* harmony default export */ var VLinkvue_type_script_lang_js = ({\n  props: {\n    href: {\n      type: String,\n      required: true\n    }\n  },\n  methods: {\n    go: function go() {\n      this.$root.currentRoute = this.href;\n      window.history.pushState(null, routes["a" /* default */][this.href], this.href);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/VLink.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/components/VLink.vue\n\n\n\nVLinkvue_type_script_lang_js.render = render\n\n/* harmony default export */ var VLink = __webpack_exports__["a"] = (VLinkvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9WTGluay52dWU/M2Q3YyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9WTGluay52dWU/NDVkYSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9WTGluay52dWU/ZjI2YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O3lEQUNFLCtDQUtJLEdBTEosRUFLSTtBQUpELFFBQUksRUFBRSxXQUlMO0FBSEQsV0FBSztBQUFBLGFBQVUscURBQVY7QUFBQSxPQUFZLFdBQVo7QUFHSixHQUxKLEUsQ0FJRSw4Q0FBYSxXQUFiLEVBQWEsU0FBYixDLENBSkYsRTs7QUFBQSxJLFFBQUEsQzs7Ozs7Ozs7QUFTRjtBQUVlO0FBQ2IsT0FBSyxFQUFFO0FBQ0wsUUFBSSxFQUFFO0FBQ0osVUFBSSxFQUFDLE1BREQ7QUFFSixjQUFRLEVBQUU7QUFGTjtBQURELEdBRE07QUFRYixTQUFPLEVBQUU7QUFDUCxNQURPLGdCQUNEO0FBQ0osV0FBSyxLQUFMLENBQVcsWUFBWCxHQUEwQixLQUFLLElBQS9CO0FBQ0EsWUFBTSxDQUFDLE9BQVAsQ0FBZSxTQUFmLENBQXlCLElBQXpCLEVBQStCLHlCQUFNLENBQUMsS0FBSyxJQUFOLENBQXJDLEVBQWtELEtBQUssSUFBdkQ7QUFDRjtBQUpPO0FBUkksQ0FBZixFOztBQ1ptSyxDOztBQ0FqRztBQUNWO0FBQ0w7QUFDbkQsNEJBQU0sVUFBVSxNQUFNOztBQUVQLGlHIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxhXG4gICAgOmhyZWY9XCJocmVmXCJcbiAgICBAY2xpY2sucHJldmVudD1cImdvXCJcbiAgPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCByb3V0ZXMgZnJvbSAnLi4vcm91dGVzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgaHJlZjoge1xuICAgICAgdHlwZTpTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgZ28gKCkge1xuICAgICAgdGhpcy4kcm9vdC5jdXJyZW50Um91dGUgPSB0aGlzLmhyZWZcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCByb3V0ZXNbdGhpcy5ocmVmXSwgdGhpcy5ocmVmKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9WTGluay52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9WTGluay52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1ZMaW5rLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xOWZjNGFkNFwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1ZMaW5rLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9WTGluay52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuc2NyaXB0LnJlbmRlciA9IHJlbmRlclxuXG5leHBvcnQgZGVmYXVsdCBzY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,exports,__webpack_require__){eval('var map = {\n\t"./404.vue": 8,\n\t"./About.vue": 9,\n\t"./AimBooster.vue": 10,\n\t"./ClickingTest.vue": 11,\n\t"./FreqHearing.vue": 12,\n\t"./Home.vue": 13,\n\t"./NumberMemory.vue": 14,\n\t"./ReactionTime.vue": 15,\n\t"./SpeedTyper.vue": 16,\n\t"./VerbalMemory.vue": 17,\n\t"./VisualMemory.vue": 18\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error("Cannot find module \'" + req + "\'");\n\t\te.code = \'MODULE_NOT_FOUND\';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 7;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMgc3luYyBeXFwuXFwvLipcXC52dWUkP2MxN2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcCA9IHtcblx0XCIuLzQwNC52dWVcIjogOCxcblx0XCIuL0Fib3V0LnZ1ZVwiOiA5LFxuXHRcIi4vQWltQm9vc3Rlci52dWVcIjogMTAsXG5cdFwiLi9DbGlja2luZ1Rlc3QudnVlXCI6IDExLFxuXHRcIi4vRnJlcUhlYXJpbmcudnVlXCI6IDEyLFxuXHRcIi4vSG9tZS52dWVcIjogMTMsXG5cdFwiLi9OdW1iZXJNZW1vcnkudnVlXCI6IDE0LFxuXHRcIi4vUmVhY3Rpb25UaW1lLnZ1ZVwiOiAxNSxcblx0XCIuL1NwZWVkVHlwZXIudnVlXCI6IDE2LFxuXHRcIi4vVmVyYmFsTWVtb3J5LnZ1ZVwiOiAxNyxcblx0XCIuL1Zpc3VhbE1lbW9yeS52dWVcIjogMThcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSA3OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/404.vue?vue&type=template&id=3c782a54\n\n\nvar _hoisted_1 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", null, "Page not found.", -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [_hoisted_1];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/404.vue?vue&type=template&id=3c782a54\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/404.vue?vue&type=script&lang=js\n\n/* harmony default export */ var _404vue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  }\n});\n// CONCATENATED MODULE: ./src/pages/404.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/404.vue\n\n\n\n_404vue_type_script_lang_js.render = render\n\n/* harmony default export */ var _404 = __webpack_exports__["default"] = (_404vue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvNDA0LnZ1ZT9lZTVkIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy80MDQudnVlPzQwNmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzLzQwNC52dWU/ZjlmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OEJBRUksK0NBQXNCLEdBQXRCLEVBQXNCLElBQXRCLEVBQUcsaUJBQUgsRUFBa0I7QUFBQTtBQUFsQixDOzs7Ozt5REFERiwrQ0FFYyxzQkFGZCxFQUVjLElBRmQsRUFFYzswREFEWjtBQUFBLGFBQXNCLENBQXRCLFVBQXNCLENBQXRCO0FBQUEsSyxDQUNZOzs7O0FBQUEsR0FGZCxDOzs7Ozs7OztBQU1GO0FBRWU7QUFDYixZQUFVLEVBQUU7QUFDVixjQUFTLEVBQVQsdUJBQVU7QUFEQTtBQURDLENBQWYsRTs7QUNUaUssQzs7QUNBakc7QUFDVjtBQUNMO0FBQ2pELDJCQUFNLFVBQVUsTUFBTTs7QUFFUCxxRyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8bWFpbi1sYXlvdXQ+XG4gICAgPHA+UGFnZSBub3QgZm91bmQuPC9wPlxuICA8L21haW4tbGF5b3V0PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNYWluTGF5b3V0IGZyb20gJy4uL2xheW91dHMvTWFpbi52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIE1haW5MYXlvdXRcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi80MDQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOS0wIS4vNDA0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vNDA0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zYzc4MmE1NFwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuLzQwNC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vNDA0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/About.vue?vue&type=template&id=0733d9ab\n\n\nvar _hoisted_1 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", null, "About page.", -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [_hoisted_1];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/About.vue?vue&type=template&id=0733d9ab\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/About.vue?vue&type=script&lang=js\n\n/* harmony default export */ var Aboutvue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  }\n});\n// CONCATENATED MODULE: ./src/pages/About.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/About.vue\n\n\n\nAboutvue_type_script_lang_js.render = render\n\n/* harmony default export */ var About = __webpack_exports__["default"] = (Aboutvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvQWJvdXQudnVlP2ExZDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL0Fib3V0LnZ1ZT8yYTcwIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9BYm91dC52dWU/MmI1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OEJBRUksK0NBQWtCLEdBQWxCLEVBQWtCLElBQWxCLEVBQUcsYUFBSCxFQUFjO0FBQUE7QUFBZCxDOzs7Ozt5REFERiwrQ0FFYyxzQkFGZCxFQUVjLElBRmQsRUFFYzswREFEWjtBQUFBLGFBQWtCLENBQWxCLFVBQWtCLENBQWxCO0FBQUEsSyxDQUNZOzs7O0FBQUEsR0FGZCxDOzs7Ozs7OztBQU1GO0FBRWU7QUFDYixZQUFVLEVBQUU7QUFDVixjQUFTLEVBQVQsdUJBQVU7QUFEQTtBQURDLENBQWYsRTs7QUNUbUssQzs7QUNBakc7QUFDVjtBQUNMO0FBQ25ELDRCQUFNLFVBQVUsTUFBTTs7QUFFUCx1RyIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8bWFpbi1sYXlvdXQ+XG4gICAgPHA+QWJvdXQgcGFnZS48L3A+XG4gIDwvbWFpbi1sYXlvdXQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1haW5MYXlvdXQgZnJvbSAnLi4vbGF5b3V0cy9NYWluLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgTWFpbkxheW91dFxuICB9XG59XG48L3NjcmlwdD5cbiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL0Fib3V0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL0Fib3V0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQWJvdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTA3MzNkOWFiXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQWJvdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0Fib3V0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/AimBooster.vue?vue&type=template&id=023aae34\n\nvar _hoisted_1 = {\n  "class": "reaction-game-wrapper"\n};\nvar _hoisted_2 = {\n  key: 0,\n  style: {\n    "transform": "translateY(100px)"\n  }\n};\n\nvar _hoisted_3 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Mouse Accuracy", -1\n/* HOISTED */\n);\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Memorize and recreate the patterns shown", -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = {\n  key: 1\n};\nvar _hoisted_6 = {\n  style: {\n    "max-width": "590px",\n    "margin-left": "auto",\n    "margin-right": "auto"\n  }\n};\nvar _hoisted_7 = {\n  "class": "visual-memory-container"\n};\nvar _hoisted_8 = {\n  "class": "score-text"\n};\nvar _hoisted_9 = {\n  key: 2,\n  style: {\n    "transform": "translateY(100px)"\n  }\n};\nvar _hoisted_10 = {\n  "class": "header"\n};\n\nvar _hoisted_11 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "wrapper"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "container noselect",\n        style: {\n          "padding-top": "10px"\n        },\n        onClick: _cache[3] || (_cache[3] = function () {\n          return $options.missedTarget && $options.missedTarget.apply($options, arguments);\n        })\n      }, [$data.state == $data.gameState.BeforeGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_2, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        "class": "center game-icon-size",\n        style: {\n          "filter": "drop-shadow(2px 4px 6px black) brightness(10)"\n        },\n        src: _ctx.Icons.cursor_icon,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_3, _hoisted_4, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[1] || (_cache[1] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Play")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.AfterGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_5, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_6, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_7, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_8, Object(vue_esm_bundler["l" /* toDisplayString */])($options.computedScore), 1\n      /* TEXT */\n      ), (Object(vue_esm_bundler["h" /* openBlock */])(true), Object(vue_esm_bundler["c" /* createBlock */])(vue_esm_bundler["a" /* Fragment */], null, Object(vue_esm_bundler["i" /* renderList */])($data.targets, function (target) {\n        return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", {\n          "class": "circle",\n          key: target.id,\n          style: {\n            transform: "scale(".concat(target.scale, ")"),\n            width: \'15%\',\n            height: \'15%\',\n            top: target.y + \'%\',\n            left: target.x + \'%\'\n          }\n        }, [Object(vue_esm_bundler["f" /* createVNode */])("div", {\n          "class": "aim-button-style",\n          style: {\n            "width": "100%",\n            "height": "100%"\n          },\n          onMousedown: function onMousedown($event) {\n            return $options.targetClicked(target);\n          }\n        }, null, 40\n        /* PROPS, HYDRATE_EVENTS */\n        , ["onMousedown"])], 4\n        /* STYLE */\n        );\n      }), 128\n      /* KEYED_FRAGMENT */\n      ))])])])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.GameOver ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_9, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_10, "Score: " + Object(vue_esm_bundler["l" /* toDisplayString */])($options.computedScore), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[2] || (_cache[2] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])]), _hoisted_11];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/AimBooster.vue?vue&type=template&id=023aae34\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/AimBooster.vue?vue&type=script&lang=js\n\nvar gameState = {\n  BeforeGameStart: 1,\n  AfterGameStart: 2,\n  GameOver: 3\n};\n/* harmony default export */ var AimBoostervue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  },\n  mounted: function mounted() {},\n  data: function data() {\n    return {\n      gameState: gameState,\n      state: gameState.BeforeGameStart,\n      sizeSpeed: 0.02,\n      spawnSpeed: 1000,\n      lastSpawn: Date.now(),\n      lives: 3,\n      score: 0,\n      misses: 0,\n      gameInterval: null,\n      targets: []\n    };\n  },\n  computed: {\n    computedScore: function computedScore() {\n      return (Math.max(0, this.score - this.misses) || 0).toFixed(0); //return (Math.max((this.score * 1-((this.misses/this.score)*20)),0) || 0).toFixed(0)\n    }\n  },\n  methods: {\n    onStartButtonClick: function onStartButtonClick() {\n      this.state = this.gameState.AfterGameStart;\n      this.lives = 3;\n      this.lastSpawn = Date.now();\n      this.sizeSpeed = 0.02;\n      this.spawnSpeed = 1000;\n      this.targets = [];\n      this.score = 0;\n      this.misses = 0;\n      this.startGame();\n    },\n    missedTarget: function missedTarget() {\n      if (this.state == this.gameState.AfterGameStart && this.score > 0) {\n        this.misses += 1;\n      }\n    },\n    targetClicked: function targetClicked(target) {\n      this.targets = this.targets.filter(function (ele) {\n        return ele != target;\n      });\n      this.sizeSpeed *= 1.005;\n      this.score += 1;\n      this.spawnSpeed = Math.max(this.spawnSpeed * 0.97, 400);\n    },\n    gameOver: function gameOver() {\n      this.state = this.gameState.GameOver;\n      clearInterval(this.gameInterval);\n    },\n    startGame: function startGame() {\n      var _this = this;\n\n      this.gameInterval = setInterval(function () {\n        _this.targets.forEach(function (target) {\n          if (target.mode == "increase") {\n            target.scale += _this.sizeSpeed;\n            target.style.transform = "scale(".concat(target.scale, ")");\n\n            if (target.scale >= 1) {\n              target.mode = "decrease";\n            }\n          } else if (target.mode == "decrease") {\n            target.scale -= _this.sizeSpeed;\n            target.style.transform = "scale(".concat(target.scale, ")");\n\n            if (target.scale <= 0) {\n              _this.lives -= 1;\n              console.log("lost a life");\n              _this.targets = _this.targets.filter(function (ele) {\n                return ele != target;\n              });\n\n              if (_this.lives <= 0) {\n                _this.gameOver();\n              }\n            }\n          }\n        });\n\n        if (Date.now() - _this.lastSpawn > _this.spawnSpeed) {\n          _this.lastSpawn = Date.now();\n\n          _this.targets.push({\n            x: Math.random() * 80,\n            y: Math.random() * 80,\n            id: Math.random(),\n            mode: "increase",\n            scale: 0,\n            style: {\n              transform: \'scale(0)\',\n              height: "100%",\n              width: "100%"\n            }\n          });\n        }\n      }, 50);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/AimBooster.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/AimBooster.vue\n\n\n\nAimBoostervue_type_script_lang_js.render = render\n\n/* harmony default export */ var AimBooster = __webpack_exports__["default"] = (AimBoostervue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvQWltQm9vc3Rlci52dWU/ZmNjZSIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvQWltQm9vc3Rlci52dWU/YmQ5ZiIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvQWltQm9vc3Rlci52dWU/Y2MwMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFYSxXQUFNOzs7O0FBRXNDLE9BQW1DLEVBQW5DO0FBQUE7QUFBQTs7OzhCQUUzQywrQ0FBc0MsSUFBdEMsRUFBc0M7QUFBbEMsV0FBTTtBQUE0QixDQUF0QyxFQUFtQixnQkFBbkIsRUFBaUM7QUFBQTtBQUFqQyxDOzs4QkFDQSwrQ0FBNEQsR0FBNUQsRUFBNEQ7QUFBekQsV0FBTTtBQUFtRCxDQUE1RCxFQUFnQiwwQ0FBaEIsRUFBd0Q7QUFBQTtBQUF4RCxDOzs7Ozs7QUFLSyxPQUEyRCxFQUEzRDtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFDRSxXQUFNOzs7QUFDTCxXQUFNOzs7O0FBT3NCLE9BQW1DLEVBQW5DO0FBQUE7QUFBQTs7O0FBQ2hDLFdBQU07OzsrQkFLaEIsK0NBRU0sS0FGTixFQUVNO0FBRkQsV0FBTTtBQUVMLENBRk4sRUFBb0IsSUFBcEIsRUFBb0I7QUFBQTtBQUFwQixDOzs7Ozt5REExQkosK0NBNkJjLHNCQTdCZCxFQTZCYyxJQTdCZCxFQTZCYzswREE1QlY7QUFBQSxhQXdCTSxDQXhCTiwrQ0F3Qk0sS0F4Qk4sY0F3Qk0sQ0F2QkosK0NBc0JNLEtBdEJOLEVBc0JNO0FBdEJELGlCQUFNLG9CQXNCTDtBQXRCMEIsYUFBeUIsRUFBekI7QUFBQTtBQUFBLFNBc0IxQjtBQXRCeUQsZUFBSztBQUFBLGlCQUFFLHlFQUFGO0FBQUE7QUFzQjlELE9BdEJOLEUsQ0FDYSxlQUFPLGdCQUFVLGUsb0RBQTVCLCtDQUtNLEtBTE4sY0FLTSxDQUpKLCtDQUE2SSxLQUE3SSxFQUE2STtBQUF4SSxpQkFBTSx1QkFBa0k7QUFBMUcsYUFBOEQsRUFBOUQ7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QUFMLEVBQWpCOztBQUNBLGVBQUksQ0FBQyxPQUFMLENBQWEsSUFBYixDQUFrQjtBQUFDLGFBQUMsRUFBQyxJQUFJLENBQUMsTUFBTCxLQUFjLEVBQWpCO0FBQW9CLGFBQUMsRUFBQyxJQUFJLENBQUMsTUFBTCxLQUFjLEVBQXBDO0FBQXVDLGNBQUUsRUFBQyxJQUFJLENBQUMsTUFBTCxFQUExQztBQUF3RCxnQkFBSSxFQUFDLFVBQTdEO0FBQXdFLGlCQUFLLEVBQUMsQ0FBOUU7QUFBZ0YsaUJBQUssRUFBQztBQUFDLHVCQUFTLEVBQUMsVUFBWDtBQUFzQixvQkFBTSxFQUFDLE1BQTdCO0FBQW9DLG1CQUFLLEVBQUM7QUFBMUM7QUFBdEYsV0FBbEI7QUFDRjtBQUNELE9BN0I4QixFQTZCN0IsRUE3QjZCLENBQS9CO0FBOEJGO0FBNURNO0FBM0JLLENBQWYsRTs7QUMxQ3dLLEM7O0FDQWpHO0FBQ1Y7QUFDTDtBQUN4RCxpQ0FBTSxVQUFVLE1BQU07O0FBRVAsaUgiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8bWFpbi1sYXlvdXQ+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlYWN0aW9uLWdhbWUtd3JhcHBlclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz0nY29udGFpbmVyIG5vc2VsZWN0JyBzdHlsZT1cInBhZGRpbmctdG9wOjEwcHg7XCIgdi1vbjpjbGljaz1cIm1pc3NlZFRhcmdldFwiPlxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkJlZm9yZUdhbWVTdGFydFwiIHN0eWxlPVwidHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTAwcHgpXCI+XHJcbiAgICAgICAgICAgICAgPGltZyBjbGFzcz0nY2VudGVyIGdhbWUtaWNvbi1zaXplJyBzdHlsZT1cImZpbHRlcjogZHJvcC1zaGFkb3coMnB4IDRweCA2cHggYmxhY2spIGJyaWdodG5lc3MoMTApO1wiIDpzcmM9XCJJY29ucy5jdXJzb3JfaWNvblwiIGRyYWdnYWJsZT1cImZhbHNlXCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPSdoZWFkZXInPk1vdXNlIEFjY3VyYWN5PC9oMT5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz0nZm9udCc+TWVtb3JpemUgYW5kIHJlY3JlYXRlIHRoZSBwYXR0ZXJucyBzaG93bjwvcD5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LW9uOmNsaWNrPVwib25TdGFydEJ1dHRvbkNsaWNrXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5QbGF5PC9kaXY+ICAgICAgICAgXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkFmdGVyR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIm1heC13aWR0aDo1OTBweDttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvO1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZpc3VhbC1tZW1vcnktY29udGFpbmVyXCI+IFxyXG4gICAgICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJzY29yZS10ZXh0XCI+e3tjb21wdXRlZFNjb3JlfX08L2gxPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCIgdi1mb3I9XCJ0YXJnZXQgaW4gdGFyZ2V0c1wiIDprZXk9dGFyZ2V0LmlkIDpzdHlsZT1cInt0cmFuc2Zvcm06YHNjYWxlKCR7dGFyZ2V0LnNjYWxlfSlgLHdpZHRoOicxNSUnLCBoZWlnaHQ6JzE1JScsdG9wOnRhcmdldC55KyclJyxsZWZ0OnRhcmdldC54KyclJ31cIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWltLWJ1dHRvbi1zdHlsZVwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6MTAwJVwiIEBtb3VzZWRvd249XCJ0YXJnZXRDbGlja2VkKHRhcmdldClcIiA+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PiAgXHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+IFxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkdhbWVPdmVyXCIgc3R5bGU9XCJ0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMDBweClcIj5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9J2hlYWRlcic+U2NvcmU6IHt7Y29tcHV0ZWRTY29yZX19PC9oMT5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LW9uOmNsaWNrPVwib25TdGFydEJ1dHRvbkNsaWNrXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5SZXRyeTwvZGl2PiAgICAgICAgIFxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcclxuICAgICAgICAgIDwvZGl2PiAgICAgICAgXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIndyYXBwZXJcIj5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L21haW4tbGF5b3V0PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgTWFpbkxheW91dCBmcm9tICcuLi9sYXlvdXRzL01haW4udnVlJ1xyXG5cclxuY29uc3QgZ2FtZVN0YXRlPXtcclxuICBCZWZvcmVHYW1lU3RhcnQ6MSxcclxuICBBZnRlckdhbWVTdGFydDoyLFxyXG4gIEdhbWVPdmVyOjNcclxufVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICBNYWluTGF5b3V0XHJcbiAgfSxcclxuICBtb3VudGVkKCl7XHJcblxyXG4gIH0sXHJcbiAgZGF0YSgpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2FtZVN0YXRlOmdhbWVTdGF0ZSxcclxuICAgICAgc3RhdGU6Z2FtZVN0YXRlLkJlZm9yZUdhbWVTdGFydCxcclxuICAgICAgc2l6ZVNwZWVkOjAuMDIsXHJcbiAgICAgIHNwYXduU3BlZWQ6MTAwMCxcclxuICAgICAgbGFzdFNwYXduOiBEYXRlLm5vdygpLFxyXG4gICAgICBsaXZlczozLFxyXG4gICAgICBzY29yZTowLFxyXG4gICAgICBtaXNzZXM6MCwgXHJcbiAgICAgIGdhbWVJbnRlcnZhbDpudWxsLFxyXG4gICAgICB0YXJnZXRzOltdXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgY29tcHV0ZWRTY29yZSgpe1xyXG4gICAgICByZXR1cm4gKE1hdGgubWF4KDAsdGhpcy5zY29yZS10aGlzLm1pc3NlcykgfHwgMCkudG9GaXhlZCgwKVxyXG4gICAgICAvL3JldHVybiAoTWF0aC5tYXgoKHRoaXMuc2NvcmUgKiAxLSgodGhpcy5taXNzZXMvdGhpcy5zY29yZSkqMjApKSwwKSB8fCAwKS50b0ZpeGVkKDApXHJcbiAgICB9XHJcbiAgfSwgIFxyXG4gIG1ldGhvZHM6e1xyXG4gICAgb25TdGFydEJ1dHRvbkNsaWNrKCl7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5BZnRlckdhbWVTdGFydDtcclxuICAgICAgdGhpcy5saXZlcyA9IDM7XHJcbiAgICAgIHRoaXMubGFzdFNwYXduID0gRGF0ZS5ub3coKTtcclxuICAgICAgdGhpcy5zaXplU3BlZWQgPSAwLjAyO1xyXG4gICAgICB0aGlzLnNwYXduU3BlZWQgPSAxMDAwO1xyXG4gICAgICB0aGlzLnRhcmdldHMgPSBbXTtcclxuICAgICAgdGhpcy5zY29yZSA9IDA7XHJcbiAgICAgIHRoaXMubWlzc2VzID0gMDtcclxuICAgICAgdGhpcy5zdGFydEdhbWUoKVxyXG4gICAgfSxcclxuICAgIG1pc3NlZFRhcmdldCgpe1xyXG4gICAgICBpZih0aGlzLnN0YXRlID09IHRoaXMuZ2FtZVN0YXRlLkFmdGVyR2FtZVN0YXJ0ICYmIHRoaXMuc2NvcmUgPiAwKXtcclxuICAgICAgICB0aGlzLm1pc3NlcyArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGFyZ2V0Q2xpY2tlZCh0YXJnZXQpe1xyXG4gICAgICB0aGlzLnRhcmdldHMgPSB0aGlzLnRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uKGVsZSl7IFxyXG4gICAgICAgIHJldHVybiBlbGUgIT0gdGFyZ2V0OyBcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuc2l6ZVNwZWVkICo9MS4wMDVcclxuICAgICAgdGhpcy5zY29yZSArPSAxO1xyXG4gICAgICB0aGlzLnNwYXduU3BlZWQgPSBNYXRoLm1heCh0aGlzLnNwYXduU3BlZWQgKiAwLjk3LDQwMClcclxuICAgIH0sXHJcbiAgICBnYW1lT3Zlcigpe1xyXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuR2FtZU92ZXI7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5nYW1lSW50ZXJ2YWwpO1xyXG4gICAgfSxcclxuICAgIHN0YXJ0R2FtZSgpe1xyXG4gICAgICB0aGlzLmdhbWVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpPT57XHJcbiAgICAgICAgdGhpcy50YXJnZXRzLmZvckVhY2goKHRhcmdldCk9PntcclxuICAgICAgICAgIGlmKHRhcmdldC5tb2RlID09IFwiaW5jcmVhc2VcIil7XHJcbiAgICAgICAgICAgIHRhcmdldC5zY2FsZSArPSB0aGlzLnNpemVTcGVlZDtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke3RhcmdldC5zY2FsZX0pYDsgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZih0YXJnZXQuc2NhbGUgPj0gMSl7XHJcbiAgICAgICAgICAgICAgdGFyZ2V0Lm1vZGUgPSBcImRlY3JlYXNlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1lbHNlIGlmKHRhcmdldC5tb2RlID09IFwiZGVjcmVhc2VcIil7XHJcbiAgICAgICAgICAgIHRhcmdldC5zY2FsZSAtPSB0aGlzLnNpemVTcGVlZDtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke3RhcmdldC5zY2FsZX0pYDsgIFxyXG4gICAgICAgICAgICBpZih0YXJnZXQuc2NhbGUgPD0gMCl7XHJcbiAgICAgICAgICAgICAgdGhpcy5saXZlcyAtPSAxO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibG9zdCBhIGxpZmVcIilcclxuICAgICAgICAgICAgICB0aGlzLnRhcmdldHMgPSB0aGlzLnRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uKGVsZSl7IFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZSAhPSB0YXJnZXQ7IFxyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICBpZih0aGlzLmxpdmVzIDw9IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lT3ZlcigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGlmKERhdGUubm93KCktdGhpcy5sYXN0U3Bhd24gPiB0aGlzLnNwYXduU3BlZWQpe1xyXG4gICAgICAgICAgdGhpcy5sYXN0U3Bhd24gPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgdGhpcy50YXJnZXRzLnB1c2goe3g6TWF0aC5yYW5kb20oKSo4MCx5Ok1hdGgucmFuZG9tKCkqODAsaWQ6TWF0aC5yYW5kb20oKSxtb2RlOlwiaW5jcmVhc2VcIixzY2FsZTowLHN0eWxlOnt0cmFuc2Zvcm06J3NjYWxlKDApJyxoZWlnaHQ6XCIxMDAlXCIsd2lkdGg6XCIxMDAlXCJ9fSlcclxuICAgICAgICB9XHJcbiAgICAgIH0sNTApXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL0FpbUJvb3N0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOS0wIS4vQWltQm9vc3Rlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL0FpbUJvb3N0ZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTAyM2FhZTM0XCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQWltQm9vc3Rlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQWltQm9vc3Rlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuc2NyaXB0LnJlbmRlciA9IHJlbmRlclxuXG5leHBvcnQgZGVmYXVsdCBzY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/ClickingTest.vue?vue&type=template&id=5cb8ed13\n\nvar _hoisted_1 = {\n  "class": "container noselect",\n  style: {\n    "transform": "translateY(100px)"\n  }\n};\nvar _hoisted_2 = {\n  key: 0\n};\n\nvar _hoisted_3 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Clicking Test", -1\n/* HOISTED */\n);\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Click as fast as you can for 10 seconds.", -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = {\n  key: 1\n};\n\nvar _hoisted_6 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Get ready to click", -1\n/* HOISTED */\n);\n\nvar _hoisted_7 = {\n  "class": "header"\n};\nvar _hoisted_8 = {\n  key: 2\n};\n\nvar _hoisted_9 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Click Fast Now", -1\n/* HOISTED */\n);\n\nvar _hoisted_10 = {\n  "class": "header"\n};\nvar _hoisted_11 = {\n  key: 3\n};\nvar _hoisted_12 = {\n  "class": "header"\n};\n\nvar _hoisted_13 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "wrapper"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _this = this;\n\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "reaction-game-wrapper",\n        onClick: _cache[3] || (_cache[3] = function () {\n          return $options.backgroundClicked && $options.backgroundClicked.apply($options, arguments);\n        })\n      }, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [$data.state == $data.gameState.BeforeGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_2, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        "class": "center game-icon-size",\n        style: {\n          "filter": "drop-shadow(2px 4px 6px black) brightness(10)"\n        },\n        src: _ctx.Icons.cursor_icon,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_3, _hoisted_4, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[1] || (_cache[1] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Play")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.CountDown ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_5, [_hoisted_6, Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_7, Object(vue_esm_bundler["l" /* toDisplayString */])($data.timeRemaining), 1\n      /* TEXT */\n      )])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.AfterGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_8, [_hoisted_9, Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_10, Object(vue_esm_bundler["l" /* toDisplayString */])($options.computedCPS), 1\n      /* TEXT */\n      )])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.GameOver ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_11, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_12, Object(vue_esm_bundler["l" /* toDisplayString */])((Math.max(_this.totalClicks / ((Date.now() - _this.startTime) / 1000), 0) || 0).toFixed(2)) + " Clicks per second", 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[2] || (_cache[2] = function () {\n          return $options.onRetryButtonClick && $options.onRetryButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])]), _hoisted_13];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/ClickingTest.vue?vue&type=template&id=5cb8ed13\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/ClickingTest.vue?vue&type=script&lang=js\n\nvar gameState = {\n  BeforeGameStart: 1,\n  CountDown: 2,\n  AfterGameStart: 3,\n  GameOver: 4\n};\n/* harmony default export */ var ClickingTestvue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  },\n  mounted: function mounted() {},\n  data: function data() {\n    return {\n      gameState: gameState,\n      state: gameState.BeforeGameStart,\n      totalClicks: 0,\n      timeRemaining: 5,\n      startTime: null\n    };\n  },\n  computed: {\n    computedCPS: function computedCPS() {\n      return (Math.max(this.totalClicks / ((Date.now() - this.startTime) / 1000), 0) || 0).toFixed(2);\n    }\n  },\n  methods: {\n    onStartButtonClick: function onStartButtonClick() {\n      var _this = this;\n\n      this.timeRemaining = 5;\n      this.totalClicks = 0;\n      this.startTime = null;\n      this.state = this.gameState.CountDown;\n      var timer = setInterval(function () {\n        _this.timeRemaining -= 1;\n\n        if (_this.timeRemaining == 0) {\n          clearInterval(timer);\n          _this.state = _this.gameState.AfterGameStart;\n\n          _this.startGame();\n        }\n      }, 1000);\n    },\n    startGame: function startGame() {\n      var _this2 = this;\n\n      this.startTime = Date.now();\n      setTimeout(function () {\n        _this2.state = _this2.gameState.GameOver;\n      }, 10000);\n    },\n    backgroundClicked: function backgroundClicked() {\n      console.log(this.totalClicks);\n\n      if (this.state == this.gameState.AfterGameStart) {\n        this.totalClicks += 1;\n      }\n    },\n    onRetryButtonClick: function onRetryButtonClick() {\n      this.state = this.gameState.BeforeGameStart;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/ClickingTest.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/ClickingTest.vue\n\n\n\nClickingTestvue_type_script_lang_js.render = render\n\n/* harmony default export */ var ClickingTest = __webpack_exports__["default"] = (ClickingTestvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvQ2xpY2tpbmdUZXN0LnZ1ZT83NjU4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9DbGlja2luZ1Rlc3QudnVlPzY1YmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL0NsaWNraW5nVGVzdC52dWU/ZGE1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFHZSxXQUFNLG9CO0FBQXFCLE9BQXFDLEVBQXJDO0FBQUE7QUFBQTs7Ozs7OzhCQUc1QiwrQ0FBcUMsSUFBckMsRUFBcUM7QUFBakMsV0FBTTtBQUEyQixDQUFyQyxFQUFtQixlQUFuQixFQUFnQztBQUFBO0FBQWhDLEM7OzhCQUNBLCtDQUE0RCxHQUE1RCxFQUE0RDtBQUF6RCxXQUFNO0FBQW1ELENBQTVELEVBQWdCLDBDQUFoQixFQUF3RDtBQUFBO0FBQXhELEM7Ozs7Ozs4QkFJQSwrQ0FBMEMsSUFBMUMsRUFBMEM7QUFBdEMsV0FBTTtBQUFnQyxDQUExQyxFQUFtQixvQkFBbkIsRUFBcUM7QUFBQTtBQUFyQyxDOzs7QUFDSSxXQUFNOzs7Ozs7OEJBR1YsK0NBQXNDLElBQXRDLEVBQXNDO0FBQWxDLFdBQU07QUFBNEIsQ0FBdEMsRUFBbUIsZ0JBQW5CLEVBQWlDO0FBQUE7QUFBakMsQzs7O0FBQ0ksV0FBTTs7Ozs7O0FBR04sV0FBTTs7OytCQUtoQiwrQ0FFTSxLQUZOLEVBRU07QUFGRCxXQUFNO0FBRUwsQ0FGTixFQUFvQixJQUFwQixFQUFvQjtBQUFBO0FBQXBCLEM7Ozs7Ozs7eURBdkJKLCtDQTBCYyxzQkExQmQsRUEwQmMsSUExQmQsRUEwQmM7MERBekJWO0FBQUEsYUFxQk0sQ0FyQk4sK0NBcUJNLEtBckJOLEVBcUJNO0FBckJELGlCQUFNLHVCQXFCTDtBQXJCa0MsZUFBSztBQUFBLGlCQUFFLG1GQUFGO0FBQUE7QUFxQnZDLE9BckJOLEUsQ0FDRSwrQ0FtQk0sS0FuQk4sY0FtQk0sQ0FsQk8sZUFBTyxnQkFBVSxlLG9EQUE1QiwrQ0FL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QUFDQSxVQUFJLEtBQUksR0FBSSxXQUFXLENBQUMsWUFBSTtBQUMxQixhQUFJLENBQUMsYUFBTCxJQUFzQixDQUF0Qjs7QUFDQSxZQUFHLEtBQUksQ0FBQyxhQUFMLElBQXNCLENBQXpCLEVBQTJCO0FBQ3pCLHVCQUFhLENBQUMsS0FBRCxDQUFiO0FBQ0EsZUFBSSxDQUFDLEtBQUwsR0FBYSxLQUFJLENBQUMsU0FBTCxDQUFlLGNBQTVCOztBQUNBLGVBQUksQ0FBQyxTQUFMO0FBQ0Y7QUFDRCxPQVBzQixFQU9yQixJQVBxQixDQUF2QjtBQVFELEtBZks7QUFnQk4sYUFoQk0sdUJBZ0JLO0FBQUE7O0FBQ1QsV0FBSyxTQUFMLEdBQWlCLElBQUksQ0FBQyxHQUFMLEVBQWpCO0FBQ0EsZ0JBQVUsQ0FBQyxZQUFJO0FBQ2IsY0FBSSxDQUFDLEtBQUwsR0FBYSxNQUFJLENBQUMsU0FBTCxDQUFlLFFBQTVCO0FBQ0QsT0FGUyxFQUVSLEtBRlEsQ0FBVjtBQUdELEtBckJLO0FBc0JOLHFCQXRCTSwrQkFzQmE7QUFDakIsYUFBTyxDQUFDLEdBQVIsQ0FBWSxLQUFLLFdBQWpCOztBQUNBLFVBQUcsS0FBSyxLQUFMLElBQWMsS0FBSyxTQUFMLENBQWUsY0FBaEMsRUFBK0M7QUFDN0MsYUFBSyxXQUFMLElBQW9CLENBQXBCO0FBQ0Y7QUFDRCxLQTNCSztBQTRCTixzQkE1Qk0sZ0NBNEJjO0FBQ2xCLFdBQUssS0FBTCxHQUFhLEtBQUssU0FBTCxDQUFlLGVBQTVCO0FBQ0Y7QUE5Qk07QUFyQkssQ0FBZixFOztBQ3ZDMEssQzs7QUNBakc7QUFDVjtBQUNMO0FBQzFELG1DQUFNLFVBQVUsTUFBTTs7QUFFUCxxSCIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxtYWluLWxheW91dD5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwicmVhY3Rpb24tZ2FtZS13cmFwcGVyXCIgdi1vbjpjbGljaz1cImJhY2tncm91bmRDbGlja2VkXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPSdjb250YWluZXIgbm9zZWxlY3QnIHN0eWxlPVwidHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMHB4KTtcIiA+XHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgPGltZyBjbGFzcz0nY2VudGVyIGdhbWUtaWNvbi1zaXplJyBzdHlsZT1cImZpbHRlcjogZHJvcC1zaGFkb3coMnB4IDRweCA2cHggYmxhY2spIGJyaWdodG5lc3MoMTApO1wiIDpzcmM9XCJJY29ucy5jdXJzb3JfaWNvblwiIGRyYWdnYWJsZT1cImZhbHNlXCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPSdoZWFkZXInPkNsaWNraW5nIFRlc3Q8L2gxPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzPSdmb250Jz5DbGljayBhcyBmYXN0IGFzIHlvdSBjYW4gZm9yIDEwIHNlY29uZHMuPC9wPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnYW1lLXN0YXJ0LWJ0blwiIHYtb246Y2xpY2s9XCJvblN0YXJ0QnV0dG9uQ2xpY2tcIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlBsYXk8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuQ291bnREb3duXCIgPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz0naGVhZGVyJz5HZXQgcmVhZHkgdG8gY2xpY2s8L2gxPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz0naGVhZGVyJz57e3RpbWVSZW1haW5pbmd9fTwvaDE+XHJcbiAgICAgICAgICAgIDwvZGl2PiBcclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwic3RhdGU9PWdhbWVTdGF0ZS5BZnRlckdhbWVTdGFydFwiID5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9J2hlYWRlcic+Q2xpY2sgRmFzdCBOb3c8L2gxPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz0naGVhZGVyJz57e2NvbXB1dGVkQ1BTfX08L2gxPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwic3RhdGU9PWdhbWVTdGF0ZS5HYW1lT3ZlclwiID5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9J2hlYWRlcic+e3soTWF0aC5tYXgoKHRoaXMudG90YWxDbGlja3MvKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUpLzEwMDApKSwwKSB8fCAwKS50b0ZpeGVkKDIpfX0gQ2xpY2tzIHBlciBzZWNvbmQ8L2gxPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnYW1lLXN0YXJ0LWJ0blwiIHYtb246Y2xpY2s9XCJvblJldHJ5QnV0dG9uQ2xpY2tcIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlJldHJ5PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIndyYXBwZXJcIj5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L21haW4tbGF5b3V0PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgTWFpbkxheW91dCBmcm9tICcuLi9sYXlvdXRzL01haW4udnVlJ1xyXG5cclxuY29uc3QgZ2FtZVN0YXRlPXtcclxuICBCZWZvcmVHYW1lU3RhcnQ6MSxcclxuICBDb3VudERvd246MixcclxuICBBZnRlckdhbWVTdGFydDozLFxyXG4gIEdhbWVPdmVyOjRcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGNvbXBvbmVudHM6IHtcclxuICAgIE1haW5MYXlvdXRcclxuICB9LFxyXG4gIG1vdW50ZWQoKXtcclxuXHJcbiAgfSxcclxuICBkYXRhKCl7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnYW1lU3RhdGU6Z2FtZVN0YXRlLFxyXG4gICAgICBzdGF0ZTpnYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0LFxyXG4gICAgICB0b3RhbENsaWNrczowLFxyXG4gICAgICB0aW1lUmVtYWluaW5nOjUsXHJcbiAgICAgIHN0YXJ0VGltZTpudWxsXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgY29tcHV0ZWRDUFMoKXtcclxuICAgICAgcmV0dXJuIChNYXRoLm1heCgodGhpcy50b3RhbENsaWNrcy8oKERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZSkvMTAwMCkpLDApIHx8IDApLnRvRml4ZWQoMik7XHJcbiAgICB9XHJcbiAgfSwgIFxyXG4gIG1ldGhvZHM6e1xyXG4gICAgb25TdGFydEJ1dHRvbkNsaWNrKCl7XHJcbiAgICAgIHRoaXMudGltZVJlbWFpbmluZyA9IDVcclxuICAgICAgdGhpcy50b3RhbENsaWNrcyA9IDA7XHJcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5Db3VudERvd247XHJcbiAgICAgIHZhciB0aW1lciA9IHNldEludGVydmFsKCgpPT57XHJcbiAgICAgICAgdGhpcy50aW1lUmVtYWluaW5nIC09IDE7XHJcbiAgICAgICAgaWYodGhpcy50aW1lUmVtYWluaW5nID09IDApe1xyXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcilcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5BZnRlckdhbWVTdGFydDtcclxuICAgICAgICAgIHRoaXMuc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LDEwMDApXHJcbiAgICB9LFxyXG4gICAgc3RhcnRHYW1lKCl7XHJcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5HYW1lT3ZlclxyXG4gICAgICB9LDEwMDAwKVxyXG4gICAgfSxcclxuICAgIGJhY2tncm91bmRDbGlja2VkKCl7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMudG90YWxDbGlja3MpXHJcbiAgICAgIGlmKHRoaXMuc3RhdGUgPT0gdGhpcy5nYW1lU3RhdGUuQWZ0ZXJHYW1lU3RhcnQpe1xyXG4gICAgICAgIHRoaXMudG90YWxDbGlja3MgKz0gMTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG9uUmV0cnlCdXR0b25DbGljaygpe1xyXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL0NsaWNraW5nVGVzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9DbGlja2luZ1Rlc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9DbGlja2luZ1Rlc3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTVjYjhlZDEzXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQ2xpY2tpbmdUZXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9DbGlja2luZ1Rlc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbnNjcmlwdC5yZW5kZXIgPSByZW5kZXJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/FreqHearing.vue?vue&type=template&id=6093e736\n\nvar _hoisted_1 = {\n  "class": "reaction-game-wrapper"\n};\nvar _hoisted_2 = {\n  "class": "container noselect",\n  style: {\n    "transform": "translateY(100px)"\n  }\n};\nvar _hoisted_3 = {\n  key: 0\n};\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Frequency Hearing Test", -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "A frequency will get higher over time. Click when you hear it.", -1\n/* HOISTED */\n);\n\nvar _hoisted_6 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Recommended: Headphones or earbuds", -1\n/* HOISTED */\n);\n\nvar _hoisted_7 = {\n  key: 1\n};\nvar _hoisted_8 = {\n  "class": "header"\n};\nvar _hoisted_9 = {\n  "class": "font"\n};\n\nvar _hoisted_10 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createTextVNode */])("Click ");\n\nvar _hoisted_11 = /*#__PURE__*/Object(vue_esm_bundler["e" /* createTextVNode */])(" when the frequency can be heard.");\n\nvar _hoisted_12 = {\n  key: 2\n};\nvar _hoisted_13 = {\n  "class": "header"\n};\nvar _hoisted_14 = {\n  key: 3\n};\n\nvar _hoisted_15 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Technical Problems?", -1\n/* HOISTED */\n);\n\nvar _hoisted_16 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "You should be able to hear sound by now. Check your audio device.", -1\n/* HOISTED */\n);\n\nvar _hoisted_17 = {\n  key: 4\n};\n\nvar _hoisted_18 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Technical Problems or Tinnitus", -1\n/* HOISTED */\n);\n\nvar _hoisted_19 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "We were not playing any audio.", -1\n/* HOISTED */\n);\n\nvar _hoisted_20 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "You have a defective audio device or tinnitus.", -1\n/* HOISTED */\n);\n\nvar _hoisted_21 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "wrapper"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_2, [$data.state == $data.gameState.BeforeGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_3, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        "class": "center game-icon-size",\n        style: {\n          "filter": "drop-shadow(2px 4px 6px black) brightness(10)"\n        },\n        src: _ctx.Icons.hearing_icon,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_4, _hoisted_5, _hoisted_6, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[1] || (_cache[1] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Play")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.AfterGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_7, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_8, Object(vue_esm_bundler["l" /* toDisplayString */])($data.currentFreq) + " Hz", 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("p", _hoisted_9, [_hoisted_10, Object(vue_esm_bundler["f" /* createVNode */])("span", {\n        style: {\n          "background-color": "rgb(34 36 53)",\n          "border-radius": "5px",\n          "padding": "3px"\n        },\n        onClick: _cache[2] || (_cache[2] = function () {\n          return $options.stopAudioButtonClicked && $options.stopAudioButtonClicked.apply($options, arguments);\n        })\n      }, "I Can Hear"), _hoisted_11]), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[3] || (_cache[3] = function () {\n          return $options.stopAudioButtonClicked && $options.stopAudioButtonClicked.apply($options, arguments);\n        }),\n        draggable: "false",\n        style: {\n          "width": "127px"\n        }\n      }, "I Can Hear")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.GameOver ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_12, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_13, "Hearing Frequency: " + Object(vue_esm_bundler["l" /* toDisplayString */])($data.currentFreq) + " Hz", 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[4] || (_cache[4] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.TookTooLong ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_14, [_hoisted_15, _hoisted_16, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[5] || (_cache[5] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.Tinnitus ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_17, [_hoisted_18, _hoisted_19, _hoisted_20, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[6] || (_cache[6] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])]), _hoisted_21];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/FreqHearing.vue?vue&type=template&id=6093e736\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/FreqHearing.vue?vue&type=script&lang=js\n\nvar gameState = {\n  BeforeGameStart: 1,\n  AfterGameStart: 2,\n  GameOver: 3,\n  TookTooLong: 4,\n  NonCompatableBrower: 5,\n  Tinnitus: 6\n};\n/* harmony default export */ var FreqHearingvue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  },\n  mounted: function mounted() {},\n  unmounted: function unmounted() {\n    clearInterval(this.intervalRef);\n  },\n  data: function data() {\n    return {\n      gameState: gameState,\n      state: gameState.BeforeGameStart,\n      currentFreq: 26000,\n      oscillatorRef: null,\n      intervalRef: null,\n      isCompatable: window.AudioContext || window.webkitAudioContext || window.audioContext,\n      context: new (window.AudioContext || window.webkitAudioContext || window.audioContext)()\n    };\n  },\n  computed: {},\n  methods: {\n    onStartButtonClick: function onStartButtonClick() {\n      this.state = this.gameState.AfterGameStart;\n      this.currentFreq = 26000;\n      this.startAudio();\n    },\n    startAudio: function startAudio() {\n      var _this = this;\n\n      try {\n        if (!this.isCompatable) {\n          this.state = this.gameState.NonCompatableBrower;\n        } else {\n          var mycontext = this.context;\n          var vol = 100;\n          var oscillator = mycontext.createOscillator();\n          this.oscillatorRef = oscillator;\n          var gain = mycontext.createGain();\n          oscillator.connect(gain); //oscillator.frequency.value = this.currentFreq;\n\n          oscillator.start(mycontext.currentTime);\n          gain.connect(mycontext.destination);\n          gain.gain.value = 0; //vol * 0.01;\n\n          this.intervalRef = setInterval(function () {\n            _this.currentFreq = _this.currentFreq - 10;\n\n            if (_this.currentFreq < 24000) {\n              gain.gain.value = vol * 0.01;\n              oscillator.frequency.value = _this.currentFreq;\n            }\n\n            if (_this.currentFreq < 10000) {\n              _this.tooLong();\n            }\n          }, 50);\n        }\n      } catch (e) {\n        this.state = this.gameState.NonCompatableBrower;\n      }\n    },\n    stopAudioButtonClicked: function stopAudioButtonClicked() {\n      clearInterval(this.intervalRef);\n      this.oscillatorRef.stop();\n\n      if (this.currentFreq < 24000) {\n        this.state = this.gameState.GameOver;\n      } else {\n        this.state = this.gameState.Tinnitus;\n      }\n    },\n    tooLong: function tooLong() {\n      clearInterval(this.intervalRef);\n      this.oscillatorRef.stop();\n      this.state = this.gameState.TookTooLong;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/FreqHearing.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/FreqHearing.vue\n\n\n\nFreqHearingvue_type_script_lang_js.render = render\n\n/* harmony default export */ var FreqHearing = __webpack_exports__["default"] = (FreqHearingvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvRnJlcUhlYXJpbmcudnVlPzRiNzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL0ZyZXFIZWFyaW5nLnZ1ZT82MGQxIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9GcmVxSGVhcmluZy52dWU/NjZjOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFYSxXQUFNOzs7QUFDSixXQUFNLG9CO0FBQXFCLE9BQXFDLEVBQXJDO0FBQUE7QUFBQTs7Ozs7OzhCQUc1QiwrQ0FBOEMsSUFBOUMsRUFBOEM7QUFBMUMsV0FBTTtBQUFvQyxDQUE5QyxFQUFtQix3QkFBbkIsRUFBeUM7QUFBQTtBQUF6QyxDOzs4QkFDQSwrQ0FBa0YsR0FBbEYsRUFBa0Y7QUFBL0UsV0FBTTtBQUF5RSxDQUFsRixFQUFnQixnRUFBaEIsRUFBOEU7QUFBQTtBQUE5RSxDOzs4QkFDQSwrQ0FBc0QsR0FBdEQsRUFBc0Q7QUFBbkQsV0FBTTtBQUE2QyxDQUF0RCxFQUFnQixvQ0FBaEIsRUFBa0Q7QUFBQTtBQUFsRCxDOzs7Ozs7QUFJSSxXQUFNOzs7QUFDUCxXQUFNOzs7a0ZBQU8sUTs7a0ZBQXVJLG1DOzs7Ozs7QUFJbkosV0FBTTs7Ozs7OytCQUtWLCtDQUEyQyxJQUEzQyxFQUEyQztBQUF2QyxXQUFNO0FBQWlDLENBQTNDLEVBQW1CLHFCQUFuQixFQUFzQztBQUFBO0FBQXRDLEM7OytCQUNBLCtDQUFxRixHQUFyRixFQUFxRjtBQUFsRixXQUFNO0FBQTRFLENBQXJGLEVBQWdCLG1FQUFoQixFQUFpRjtBQUFBO0FBQWpGLEM7Ozs7OzsrQkFLQSwrQ0FBc0QsSUFBdEQsRUFBc0Q7QUFBbEQsV0FBTTtBQUE0QyxDQUF0RCxFQUFtQixnQ0FBbkIsRUFBaUQ7QUFBQTtBQUFqRCxDOzsrQkFDQSwrQ0FBa0QsR0FBbEQsRUFBa0Q7QUFBL0MsV0FBTTtBQUF5QyxDQUFsRCxFQUFnQixnQ0FBaEIsRUFBOEM7QUFBQTtBQUE5QyxDOzsrQkFDQSwr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QUN0QixtQkFBYSxDQUFDLEtBQUssV0FBTixDQUFiO0FBQ0EsV0FBSyxhQUFMLENBQW1CLElBQW5COztBQUNBLFVBQUcsS0FBSyxXQUFMLEdBQW1CLEtBQXRCLEVBQTRCO0FBQzFCLGFBQUssS0FBTCxHQUFhLEtBQUssU0FBTCxDQUFlLFFBQTVCO0FBQ0QsT0FGRCxNQUVLO0FBQ0gsYUFBSyxLQUFMLEdBQWEsS0FBSyxTQUFMLENBQWUsUUFBNUI7QUFDRjtBQUNELEtBL0NLO0FBZ0ROLFdBaERNLHFCQWdERztBQUNQLG1CQUFhLENBQUMsS0FBSyxXQUFOLENBQWI7QUFDQSxXQUFLLGFBQUwsQ0FBbUIsSUFBbkI7QUFDQSxXQUFLLEtBQUwsR0FBYSxLQUFLLFNBQUwsQ0FBZSxXQUE1QjtBQUNEO0FBcERLO0FBdkJLLENBQWYsRTs7QUNyRHlLLEM7O0FDQWpHO0FBQ1Y7QUFDTDtBQUN6RCxrQ0FBTSxVQUFVLE1BQU07O0FBRVAsbUgiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8bWFpbi1sYXlvdXQ+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlYWN0aW9uLWdhbWUtd3JhcHBlclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz0nY29udGFpbmVyIG5vc2VsZWN0JyBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDBweCk7XCI+XHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgPGltZyBjbGFzcz0nY2VudGVyIGdhbWUtaWNvbi1zaXplJyBzdHlsZT1cImZpbHRlcjogZHJvcC1zaGFkb3coMnB4IDRweCA2cHggYmxhY2spIGJyaWdodG5lc3MoMTApO1wiIDpzcmM9XCJJY29ucy5oZWFyaW5nX2ljb25cIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz0naGVhZGVyJz5GcmVxdWVuY3kgSGVhcmluZyBUZXN0PC9oMT5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz0nZm9udCc+QSBmcmVxdWVuY3kgd2lsbCBnZXQgaGlnaGVyIG92ZXIgdGltZS4gQ2xpY2sgd2hlbiB5b3UgaGVhciBpdC48L3A+XHJcbiAgICAgICAgICAgICAgPHAgY2xhc3M9XCJmb250XCI+UmVjb21tZW5kZWQ6IEhlYWRwaG9uZXMgb3IgZWFyYnVkczwvcD5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LW9uOmNsaWNrPVwib25TdGFydEJ1dHRvbkNsaWNrXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5QbGF5PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkFmdGVyR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPSdoZWFkZXInPnt7Y3VycmVudEZyZXF9fSBIejwvaDE+XHJcbiAgICAgICAgICAgICAgPHAgY2xhc3M9J2ZvbnQnPkNsaWNrIDxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpyZ2IoMzQgMzYgNTMpO2JvcmRlci1yYWRpdXM6NXB4O3BhZGRpbmc6M3B4O1wiIHYtb246Y2xpY2s9XCJzdG9wQXVkaW9CdXR0b25DbGlja2VkXCI+SSBDYW4gSGVhcjwvc3Bhbj4gd2hlbiB0aGUgZnJlcXVlbmN5IGNhbiBiZSBoZWFyZC48L3A+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImdhbWUtc3RhcnQtYnRuXCIgdi1vbjpjbGljaz1cInN0b3BBdWRpb0J1dHRvbkNsaWNrZWRcIiBkcmFnZ2FibGU9XCJmYWxzZVwiIHN0eWxlPVwid2lkdGg6MTI3cHg7XCI+SSBDYW4gSGVhcjwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgIFxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkdhbWVPdmVyXCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPSdoZWFkZXInPkhlYXJpbmcgRnJlcXVlbmN5OiB7e2N1cnJlbnRGcmVxfX0gSHo8L2gxPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnYW1lLXN0YXJ0LWJ0blwiIHYtb246Y2xpY2s9XCJvblN0YXJ0QnV0dG9uQ2xpY2tcIiBkcmFnZ2FibGU9XCJmYWxzZVwiID5SZXRyeTwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuVG9va1Rvb0xvbmdcIj5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9J2hlYWRlcic+VGVjaG5pY2FsIFByb2JsZW1zPzwvaDE+XHJcbiAgICAgICAgICAgICAgPHAgY2xhc3M9XCJmb250XCI+WW91IHNob3VsZCBiZSBhYmxlIHRvIGhlYXIgc291bmQgYnkgbm93LiBDaGVjayB5b3VyIGF1ZGlvIGRldmljZS48L3A+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImdhbWUtc3RhcnQtYnRuXCIgdi1vbjpjbGljaz1cIm9uU3RhcnRCdXR0b25DbGlja1wiIGRyYWdnYWJsZT1cImZhbHNlXCIgPlJldHJ5PC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICBcclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwic3RhdGU9PWdhbWVTdGF0ZS5UaW5uaXR1c1wiPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz0naGVhZGVyJz5UZWNobmljYWwgUHJvYmxlbXMgb3IgVGlubml0dXM8L2gxPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVwiZm9udFwiPldlIHdlcmUgbm90IHBsYXlpbmcgYW55IGF1ZGlvLjwvcD5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnRcIj5Zb3UgaGF2ZSBhIGRlZmVjdGl2ZSBhdWRpbyBkZXZpY2Ugb3IgdGlubml0dXMuPC9wPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnYW1lLXN0YXJ0LWJ0blwiIHYtb246Y2xpY2s9XCJvblN0YXJ0QnV0dG9uQ2xpY2tcIiBkcmFnZ2FibGU9XCJmYWxzZVwiID5SZXRyeTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICA8L2Rpdj4gICAgICAgIFxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyXCI+XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9tYWluLWxheW91dD5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1haW5MYXlvdXQgZnJvbSAnLi4vbGF5b3V0cy9NYWluLnZ1ZSdcclxuXHJcbmNvbnN0IGdhbWVTdGF0ZT17XHJcbiAgQmVmb3JlR2FtZVN0YXJ0OjEsXHJcbiAgQWZ0ZXJHYW1lU3RhcnQ6MixcclxuICBHYW1lT3ZlcjozLFxyXG4gIFRvb2tUb29Mb25nOjQsXHJcbiAgTm9uQ29tcGF0YWJsZUJyb3dlcjo1LFxyXG4gIFRpbm5pdHVzOjZcclxufVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICBNYWluTGF5b3V0XHJcbiAgfSxcclxuICBtb3VudGVkKCl7XHJcblxyXG4gIH0sXHJcbiAgdW5tb3VudGVkKCl7XHJcbiAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxSZWYpXHJcbiAgfSxcclxuICBkYXRhKCl7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnYW1lU3RhdGU6Z2FtZVN0YXRlLFxyXG4gICAgICBzdGF0ZTpnYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0LFxyXG4gICAgICBjdXJyZW50RnJlcToyNjAwMCxcclxuICAgICAgb3NjaWxsYXRvclJlZjpudWxsLFxyXG4gICAgICBpbnRlcnZhbFJlZjpudWxsLFxyXG4gICAgICBpc0NvbXBhdGFibGU6d2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0IHx8IHdpbmRvdy5hdWRpb0NvbnRleHQsXHJcbiAgICAgIGNvbnRleHQ6bmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHwgd2luZG93LmF1ZGlvQ29udGV4dClcclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgfSwgIFxyXG4gIG1ldGhvZHM6e1xyXG4gICAgb25TdGFydEJ1dHRvbkNsaWNrKCl7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5BZnRlckdhbWVTdGFydDtcclxuICAgICAgdGhpcy5jdXJyZW50RnJlcT0yNjAwMFxyXG4gICAgICB0aGlzLnN0YXJ0QXVkaW8oKTtcclxuICAgIH0sXHJcbiAgICBzdGFydEF1ZGlvKCl7XHJcbiAgICAgIHRyeXtcclxuICAgICAgaWYoIXRoaXMuaXNDb21wYXRhYmxlKXtcclxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuTm9uQ29tcGF0YWJsZUJyb3dlclxyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICB2YXIgbXljb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgIHZhciB2b2wgPSAxMDBcclxuICAgICAgICB2YXIgb3NjaWxsYXRvciA9IG15Y29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbiAgICAgICAgdGhpcy5vc2NpbGxhdG9yUmVmID0gb3NjaWxsYXRvcjtcclxuICAgICAgICB2YXIgZ2FpbiA9IG15Y29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgb3NjaWxsYXRvci5jb25uZWN0KGdhaW4pO1xyXG4gICAgICAgIC8vb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmN1cnJlbnRGcmVxO1xyXG4gICAgICAgIG9zY2lsbGF0b3Iuc3RhcnQobXljb250ZXh0LmN1cnJlbnRUaW1lKTtcclxuICAgICAgICBnYWluLmNvbm5lY3QobXljb250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICBnYWluLmdhaW4udmFsdWUgPSAwLy92b2wgKiAwLjAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxSZWYgPSBzZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgICAgdGhpcy5jdXJyZW50RnJlcSA9IHRoaXMuY3VycmVudEZyZXEgLSAxMCBcclxuICAgICAgICAgIGlmKHRoaXMuY3VycmVudEZyZXEgPCAyNDAwMCl7XHJcbiAgICAgICAgICAgIGdhaW4uZ2Fpbi52YWx1ZSA9IHZvbCAqIDAuMDE7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuY3VycmVudEZyZXE7ICAgICAgICAgICAgXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYodGhpcy5jdXJyZW50RnJlcSA8IDEwMDAwKXtcclxuICAgICAgICAgICAgdGhpcy50b29Mb25nKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSw1MClcclxuICAgICAgfVxyXG4gICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuTm9uQ29tcGF0YWJsZUJyb3dlcjtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHN0b3BBdWRpb0J1dHRvbkNsaWNrZWQoKXtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsUmVmKVxyXG4gICAgICB0aGlzLm9zY2lsbGF0b3JSZWYuc3RvcCgpO1xyXG4gICAgICBpZih0aGlzLmN1cnJlbnRGcmVxIDwgMjQwMDApe1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5HYW1lT3ZlcjtcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuZ2FtZVN0YXRlLlRpbm5pdHVzO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdG9vTG9uZygpe1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxSZWYpXHJcbiAgICAgIHRoaXMub3NjaWxsYXRvclJlZi5zdG9wKCk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5Ub29rVG9vTG9uZztcclxuICAgIH0sXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL0ZyZXFIZWFyaW5nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL0ZyZXFIZWFyaW5nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vRnJlcUhlYXJpbmcudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTYwOTNlNzM2XCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRnJlcUhlYXJpbmcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0ZyZXFIZWFyaW5nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/Home.vue?vue&type=template&id=0e4f80a4\n\n\nvar _hoisted_1 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  id: "particles-js",\n  "class": "splash-size"\n}, null, -1\n/* HOISTED */\n);\n\nvar _hoisted_2 = {\n  style: {\n    "position": "absolute",\n    "width": "100%"\n  },\n  "class": "splash-size"\n};\nvar _hoisted_3 = {\n  "class": "vertical-center"\n};\nvar _hoisted_4 = {\n  "class": "container noselect"\n};\n\nvar _hoisted_5 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Competitve Coginitve Games", -1\n/* HOISTED */\n);\n\nvar _hoisted_6 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Perform ful cognitive tests to assess how well your brain works. Compare yourself to the rest of the world.", -1\n/* HOISTED */\n);\n\nvar _hoisted_7 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("br", null, null, -1\n/* HOISTED */\n);\n\nvar _hoisted_8 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  onclick: "document.getElementById(\'game-list\').scrollIntoView({behavior:\'smooth\'})",\n  style: {},\n  draggable: "false",\n  "class": "start-btn"\n}, "Start Now", -1\n/* HOISTED */\n);\n\nvar _hoisted_9 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "splash-size"\n}, null, -1\n/* HOISTED */\n);\n\nvar _hoisted_10 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "homepage-transition",\n  id: "game-list"\n}, null, -1\n/* HOISTED */\n);\n\nvar _hoisted_11 = {\n  "class": "wrapper"\n};\nvar _hoisted_12 = {\n  "class": "column-container"\n};\nvar _hoisted_13 = {\n  "class": "row noselect"\n};\nvar _hoisted_14 = {\n  "class": "column"\n};\nvar _hoisted_15 = {\n  "class": "card"\n};\n\nvar _hoisted_16 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Number Memory", -1\n/* HOISTED */\n);\n\nvar _hoisted_17 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Memorize a sequence of numbers to test your memory with numbers.", -1\n/* HOISTED */\n);\n\nvar _hoisted_18 = {\n  "class": "column"\n};\nvar _hoisted_19 = {\n  "class": "card"\n};\n\nvar _hoisted_20 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Reaction Time", -1\n/* HOISTED */\n);\n\nvar _hoisted_21 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Identify your reaction time.", -1\n/* HOISTED */\n);\n\nvar _hoisted_22 = {\n  "class": "column"\n};\nvar _hoisted_23 = {\n  "class": "card"\n};\n\nvar _hoisted_24 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Verbal Memory", -1\n/* HOISTED */\n);\n\nvar _hoisted_25 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Memorize a list of words to test your shortterm word retention.", -1\n/* HOISTED */\n);\n\nvar _hoisted_26 = {\n  "class": "column"\n};\nvar _hoisted_27 = {\n  "class": "card"\n};\n\nvar _hoisted_28 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Visual Memory", -1\n/* HOISTED */\n);\n\nvar _hoisted_29 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Memorize a pattern and recreate it to test your visual memory.", -1\n/* HOISTED */\n);\n\nvar _hoisted_30 = {\n  "class": "column"\n};\nvar _hoisted_31 = {\n  "class": "card"\n};\n\nvar _hoisted_32 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Hearing", -1\n/* HOISTED */\n);\n\nvar _hoisted_33 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Identify the frequency your ears can hear.", -1\n/* HOISTED */\n);\n\nvar _hoisted_34 = {\n  "class": "column"\n};\nvar _hoisted_35 = {\n  "class": "card"\n};\n\nvar _hoisted_36 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Typing Speed", -1\n/* HOISTED */\n);\n\nvar _hoisted_37 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Identify the words-per-minute rate you can type at.", -1\n/* HOISTED */\n);\n\nvar _hoisted_38 = {\n  "class": "column"\n};\nvar _hoisted_39 = {\n  "class": "card"\n};\n\nvar _hoisted_40 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Mouse Accuracy", -1\n/* HOISTED */\n);\n\nvar _hoisted_41 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Identify the accuracy of your hand-eye coordination.", -1\n/* HOISTED */\n);\n\nvar _hoisted_42 = {\n  "class": "column"\n};\nvar _hoisted_43 = {\n  "class": "card"\n};\n\nvar _hoisted_44 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Clicking Test", -1\n/* HOISTED */\n);\n\nvar _hoisted_45 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Identify your click per second speed", -1\n/* HOISTED */\n);\n\nvar _hoisted_46 = {\n  "class": "column"\n};\nvar _hoisted_47 = {\n  "class": "card"\n};\n\nvar _hoisted_48 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h3", null, "Line Tracing", -1\n/* HOISTED */\n);\n\nvar _hoisted_49 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "game-card-desc"\n}, "Identify the steadiness of your hand by tracing a line.", -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_v_link = Object(vue_esm_bundler["k" /* resolveComponent */])("v-link");\n\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [_hoisted_1, Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_2, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_3, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_4, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        width: "180",\n        height: "180",\n        src: _ctx.Icons.logo,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_5, _hoisted_6, _hoisted_7, _hoisted_8])])]), Object(vue_esm_bundler["d" /* createCommentVNode */])("padding to the end of the canvas"), _hoisted_9, _hoisted_10, Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_11, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_12, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_13, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_14, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "/numbermemory"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_15, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.number_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_16, _hoisted_17])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_18, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "/reactiontime"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_19, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.cursor_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_20, _hoisted_21])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_22, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "/verbalmemory"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_23, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.letter_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_24, _hoisted_25])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_26, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "/visualmemory"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_27, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.visual_grid_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_28, _hoisted_29])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_30, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "/hearingtest"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_31, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.hearing_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_32, _hoisted_33])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_34, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "/typingspeed"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_35, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.type_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_36, _hoisted_37])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_38, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "/aimpractice"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_39, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.cursor_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_40, _hoisted_41])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_42, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "/clickingtest"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_43, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.cursor_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_44, _hoisted_45])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })]), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_46, [Object(vue_esm_bundler["f" /* createVNode */])(_component_v_link, {\n        href: "./number_memory.html"\n      }, {\n        "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n          return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_47, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n            "class": "center game-icon-size",\n            src: _ctx.Icons.trace_icon,\n            draggable: "false"\n          }, null, 8\n          /* PROPS */\n          , ["src"]), _hoisted_48, _hoisted_49])];\n        }),\n        _: 1\n        /* STABLE */\n\n      })])])])])];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/Home.vue?vue&type=template&id=0e4f80a4\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./src/components/VLink.vue + 4 modules\nvar VLink = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/Home.vue?vue&type=script&lang=js\n\n\n/* harmony default export */ var Homevue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */],\n    VLink: VLink["a" /* default */]\n  },\n  data: function data() {\n    return {};\n  },\n  mounted: function mounted() {\n    particlesJS("particles-js", {\n      particles: {\n        number: {\n          value: 29,\n          density: {\n            enable: true,\n            value_area: 1278.7212787212786\n          }\n        },\n        color: {\n          value: "#1b1e34"\n        },\n        shape: {\n          type: "polygon",\n          stroke: {\n            width: 0,\n            color: "#000"\n          },\n          polygon: {\n            nb_sides: 6\n          }\n        },\n        opacity: {\n          value: 0.08,\n          random: false,\n          anim: {\n            enable: false,\n            speed: 1,\n            opacity_min: 0.1,\n            sync: false\n          }\n        },\n        size: {\n          value: 88.18766334760375,\n          random: true,\n          anim: {\n            enable: true,\n            speed: 10,\n            size_min: 40,\n            sync: false\n          }\n        },\n        line_linked: {\n          enable: false,\n          distance: 224.4776885211732,\n          color: "#ffffff",\n          opacity: 1,\n          width: 2\n        },\n        move: {\n          enable: true,\n          speed: 1,\n          direction: "bottom",\n          random: true,\n          straight: false,\n          out_mode: "out",\n          bounce: false,\n          attract: {\n            enable: false,\n            rotateX: 600,\n            rotateY: 2645.6299004281127\n          }\n        }\n      },\n      interactivity: {\n        detect_on: "canvas",\n        events: {\n          onhover: {\n            enable: false,\n            mode: "grab"\n          },\n          onclick: {\n            enable: false,\n            mode: "push"\n          },\n          resize: true\n        },\n        modes: {\n          grab: {\n            distance: 400,\n            line_linked: {\n              opacity: 1\n            }\n          },\n          bubble: {\n            distance: 400,\n            size: 40,\n            duration: 2,\n            opacity: 8,\n            speed: 3\n          },\n          repulse: {\n            distance: 200,\n            duration: 0.4\n          },\n          push: {\n            particles_nb: 4\n          },\n          remove: {\n            particles_nb: 2\n          }\n        }\n      },\n      retina_detect: true\n    });\n  },\n  computed: {},\n  methods: {}\n});\n// CONCATENATED MODULE: ./src/pages/Home.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/Home.vue\n\n\n\nHomevue_type_script_lang_js.render = render\n\n/* harmony default export */ var Home = __webpack_exports__["default"] = (Homevue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvSG9tZS52dWU/YmMxMyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvSG9tZS52dWU/ZjE5MCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvSG9tZS52dWU/ZDE0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OEJBRUUsK0NBQWlELEtBQWpELEVBQWlEO0FBQTVDLElBQUUsRUFBQyxjQUF5QztBQUExQixXQUFNO0FBQW9CLENBQWpELEUsSUFBQSxFOztBQUFBLEM7OztBQUNLLE9BQXFDLEVBQXJDO0FBQUE7QUFBQTtBQUFBLEc7QUFBc0MsV0FBTTs7O0FBRTNDLFdBQU07OztBQUNMLFdBQU07Ozs4QkFFViwrQ0FBa0QsSUFBbEQsRUFBa0Q7QUFBOUMsV0FBTTtBQUF3QyxDQUFsRCxFQUFtQiw0QkFBbkIsRUFBNkM7QUFBQTtBQUE3QyxDOzs4QkFDQSwrQ0FBK0gsR0FBL0gsRUFBK0g7QUFBNUgsV0FBTTtBQUFzSCxDQUEvSCxFQUFnQiw2R0FBaEIsRUFBMkg7QUFBQTtBQUEzSCxDOzs4QkFDQSwrQ0FBSSxJQUFKLEVBQUksSUFBSixFQUFJLElBQUosRUFBSTtBQUFBO0FBQUosQzs7OEJBQ0EsK0NBQW9KLEtBQXBKLEVBQW9KO0FBQS9JLFNBQU8sRUFBQywwRUFBdUk7QUFBNUQsT0FBUSxFQUFSLEVBQTREO0FBQW5ELFdBQVMsRUFBQyxPQUF5QztBQUFqQyxXQUFNO0FBQTJCLENBQXBKLEVBQXFJLFdBQXJJLEVBQThJO0FBQUE7QUFBOUksQzs7OEJBTUgsK0NBQStCLEtBQS9CLEVBQStCO0FBQTFCLFdBQU07QUFBb0IsQ0FBL0IsRUFBd0IsSUFBeEIsRUFBd0I7QUFBQTtBQUF4QixDOzsrQkFFQSwrQ0FBc0QsS0FBdEQsRUFBc0Q7QUFBakQsV0FBTSxxQkFBMkM7QUFBckIsSUFBRSxFQUFDO0FBQWtCLENBQXRELEUsSUFBQSxFOztBQUFBLEM7OztBQUVLLFdBQU07OztBQUNMLFdBQU07OztBQUNMLFdB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QUZIO0FBR04sZ0JBQU0sRUFBRTtBQUhGLFNBRks7QUFPYixhQUFLLEVBQUU7QUFDTCxjQUFJLEVBQUU7QUFBRSxvQkFBUSxFQUFFLEdBQVo7QUFBaUIsdUJBQVcsRUFBRTtBQUFFLHFCQUFPLEVBQUU7QUFBWDtBQUE5QixXQUREO0FBRUwsZ0JBQU0sRUFBRTtBQUFFLG9CQUFRLEVBQUUsR0FBWjtBQUFpQixnQkFBSSxFQUFFLEVBQXZCO0FBQTJCLG9CQUFRLEVBQUUsQ0FBckM7QUFBd0MsbUJBQU8sRUFBRSxDQUFqRDtBQUFvRCxpQkFBSyxFQUFFO0FBQTNELFdBRkg7QUFHTCxpQkFBTyxFQUFFO0FBQUUsb0JBQVEsRUFBRSxHQUFaO0FBQWlCLG9CQUFRLEVBQUU7QUFBM0IsV0FISjtBQUlMLGNBQUksRUFBRTtBQUFFLHdCQUFZLEVBQUU7QUFBaEIsV0FKRDtBQUtMLGdCQUFNLEVBQUU7QUFBRSx3QkFBWSxFQUFFO0FBQWhCO0FBTEg7QUFQTSxPQXpDVztBQXdEMUIsbUJBQWEsRUFBRTtBQXhEVyxLQUFqQixDQUFYO0FBMkRELEdBckVZO0FBc0ViLFVBQVEsRUFBRSxFQXRFRztBQXdFYixTQUFPLEVBQUM7QUF4RUssQ0FBZixFOztBQ3pIa0ssQzs7QUNBakc7QUFDVjtBQUNMO0FBQ2xELDJCQUFNLFVBQVUsTUFBTTs7QUFFUCxxRyIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPG1haW4tbGF5b3V0PlxuXHRcdDxkaXYgaWQ9XCJwYXJ0aWNsZXMtanNcIiBjbGFzcz0nc3BsYXNoLXNpemUnPjwvZGl2PlxuXHRcdDxkaXYgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7JyBjbGFzcz0nc3BsYXNoLXNpemUnPlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPSd2ZXJ0aWNhbC1jZW50ZXInPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPSdjb250YWluZXIgbm9zZWxlY3QnPlxuXHRcdFx0XHRcdDxpbWcgd2lkdGg9MTgwIGhlaWdodD0xODAgOnNyYz1cIkljb25zLmxvZ29cIiBkcmFnZ2FibGU9XCJmYWxzZVwiLz5cblx0XHRcdFx0XHQ8aDEgY2xhc3M9J2hlYWRlcic+Q29tcGV0aXR2ZSBDb2dpbml0dmUgR2FtZXM8L2gxPlxuXHRcdFx0XHRcdDxwIGNsYXNzPSdmb250Jz5QZXJmb3JtIGZ1bCBjb2duaXRpdmUgdGVzdHMgdG8gYXNzZXNzIGhvdyB3ZWxsIHlvdXIgYnJhaW4gd29ya3MuIENvbXBhcmUgeW91cnNlbGYgdG8gdGhlIHJlc3Qgb2YgdGhlIHdvcmxkLjwvcD5cblx0XHRcdFx0XHQ8YnI+XG5cdFx0XHRcdFx0PGRpdiBvbmNsaWNrPVwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dhbWUtbGlzdCcpLnNjcm9sbEludG9WaWV3KHtiZWhhdmlvcjonc21vb3RoJ30pXCIgc3R5bGU9JycgZHJhZ2dhYmxlPVwiZmFsc2VcIiBjbGFzcz1cInN0YXJ0LWJ0blwiPlN0YXJ0IE5vdzwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHRcdFxuXHRcdDwhLS1wYWRkaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGNhbnZhcy0tPlxuXHRcdDxkaXYgY2xhc3M9J3NwbGFzaC1zaXplJz48L2Rpdj5cblx0XHRcblx0XHQ8ZGl2IGNsYXNzPSdob21lcGFnZS10cmFuc2l0aW9uJyBpZD0nZ2FtZS1saXN0Jz48L2Rpdj5cblx0XHRcblx0XHQ8ZGl2IGNsYXNzPSd3cmFwcGVyJz5cblx0XHRcdDxkaXYgY2xhc3M9XCJjb2x1bW4tY29udGFpbmVyXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJyb3cgbm9zZWxlY3RcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbHVtblwiPlxuXHRcdFx0XHRcdDx2LWxpbmsgaHJlZj0nL251bWJlcm1lbW9yeSc+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuXHRcdFx0XHRcdFx0PGltZyBjbGFzcz0nY2VudGVyIGdhbWUtaWNvbi1zaXplJyA6c3JjPVwiSWNvbnMubnVtYmVyX2ljb25cIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlxuXHRcdFx0XHRcdFx0PGgzPk51bWJlciBNZW1vcnk8L2gzPlxuXHRcdFx0XHRcdFx0PHAgY2xhc3M9J2dhbWUtY2FyZC1kZXNjJz5NZW1vcml6ZSBhIHNlcXVlbmNlIG9mIG51bWJlcnMgdG8gdGVzdCB5b3VyIG1lbW9yeSB3aXRoIG51bWJlcnMuPC9wPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC92LWxpbms+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjb2x1bW5cIj5cblx0XHRcdFx0PHYtbGluayBocmVmPScvcmVhY3Rpb250aW1lJz5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuXHRcdFx0XHRcdDxpbWcgY2xhc3M9J2NlbnRlciBnYW1lLWljb24tc2l6ZScgOnNyYz1cIkljb25zLmN1cnNvcl9pY29uXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5cblx0XHRcdFx0XHQ8aDM+UmVhY3Rpb24gVGltZTwvaDM+XG5cdFx0XHRcdFx0PHAgY2xhc3M9J2dhbWUtY2FyZC1kZXNjJz5JZGVudGlmeSB5b3VyIHJlYWN0aW9uIHRpbWUuPC9wPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L3YtbGluaz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG5cdFx0XHRcdDx2LWxpbmsgaHJlZj0nL3ZlcmJhbG1lbW9yeSc+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNhcmRcIj5cblx0XHRcdFx0XHQ8aW1nIGNsYXNzPSdjZW50ZXIgZ2FtZS1pY29uLXNpemUnIDpzcmM9XCJJY29ucy5sZXR0ZXJfaWNvblwiIGRyYWdnYWJsZT1cImZhbHNlXCI+XG5cdFx0XHRcdFx0PGgzPlZlcmJhbCBNZW1vcnk8L2gzPlxuXHRcdFx0XHRcdDxwIGNsYXNzPSdnYW1lLWNhcmQtZGVzYyc+TWVtb3JpemUgYSBsaXN0IG9mIHdvcmRzIHRvIHRlc3QgeW91ciBzaG9ydHRlcm0gd29yZCByZXRlbnRpb24uPC9wPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L3YtbGluaz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG5cdFx0XHRcdDx2LWxpbmsgaHJlZj0nL3Zpc3VhbG1lbW9yeSc+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNhcmRcIj5cblx0XHRcdFx0XHQ8aW1nIGNsYXNzPSdjZW50ZXIgZ2FtZS1pY29uLXNpemUnIDpzcmM9XCJJY29ucy52aXN1YWxfZ3JpZF9pY29uXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5cblx0XHRcdFx0XHQ8aDM+VmlzdWFsIE1lbW9yeTwvaDM+XG5cdFx0XHRcdFx0PHAgY2xhc3M9J2dhbWUtY2FyZC1kZXNjJz5NZW1vcml6ZSBhIHBhdHRlcm4gYW5kIHJlY3JlYXRlIGl0IHRvIHRlc3QgeW91ciB2aXN1YWwgbWVtb3J5LjwvcD5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC92LWxpbms+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcblx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbHVtblwiPlxuXHRcdFx0XHQ8di1saW5rIGhyZWY9Jy9oZWFyaW5ndGVzdCc+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNhcmRcIj5cblx0XHRcdFx0XHQ8aW1nIGNsYXNzPSdjZW50ZXIgZ2FtZS1pY29uLXNpemUnIDpzcmM9XCJJY29ucy5oZWFyaW5nX2ljb25cIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlxuXHRcdFx0XHRcdDxoMz5IZWFyaW5nPC9oMz5cblx0XHRcdFx0XHQ8cCBjbGFzcz0nZ2FtZS1jYXJkLWRlc2MnPklkZW50aWZ5IHRoZSBmcmVxdWVuY3kgeW91ciBlYXJzIGNhbiBoZWFyLjwvcD5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC92LWxpbms+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcblx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbHVtblwiPlxuXHRcdFx0XHQ8di1saW5rIGhyZWY9Jy90eXBpbmdzcGVlZCc+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNhcmRcIj5cblx0XHRcdFx0XHQ8aW1nIGNsYXNzPSdjZW50ZXIgZ2FtZS1pY29uLXNpemUnIDpzcmM9XCJJY29ucy50eXBlX2ljb25cIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlxuXHRcdFx0XHRcdDxoMz5UeXBpbmcgU3BlZWQ8L2gzPlxuXHRcdFx0XHRcdDxwIGNsYXNzPSdnYW1lLWNhcmQtZGVzYyc+SWRlbnRpZnkgdGhlIHdvcmRzLXBlci1taW51dGUgcmF0ZSB5b3UgY2FuIHR5cGUgYXQuPC9wPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L3YtbGluaz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG5cdFx0XHRcdDx2LWxpbmsgaHJlZj0nL2FpbXByYWN0aWNlJz5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuXHRcdFx0XHRcdDxpbWcgY2xhc3M9J2NlbnRlciBnYW1lLWljb24tc2l6ZScgOnNyYz1cIkljb25zLmN1cnNvcl9pY29uXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5cblx0XHRcdFx0XHQ8aDM+TW91c2UgQWNjdXJhY3k8L2gzPlxuXHRcdFx0XHRcdDxwIGNsYXNzPSdnYW1lLWNhcmQtZGVzYyc+SWRlbnRpZnkgdGhlIGFjY3VyYWN5IG9mIHlvdXIgaGFuZC1leWUgY29vcmRpbmF0aW9uLjwvcD5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC92LWxpbms+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcblx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbHVtblwiPlxuXHRcdFx0XHQ8di1saW5rIGhyZWY9Jy9jbGlja2luZ3Rlc3QnPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjYXJkXCI+XG5cdFx0XHRcdFx0PGltZyBjbGFzcz0nY2VudGVyIGdhbWUtaWNvbi1zaXplJyA6c3JjPVwiSWNvbnMuY3Vyc29yX2ljb25cIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlxuXHRcdFx0XHRcdDxoMz5DbGlja2luZyBUZXN0PC9oMz5cblx0XHRcdFx0XHQ8cCBjbGFzcz0nZ2FtZS1jYXJkLWRlc2MnPklkZW50aWZ5IHlvdXIgY2xpY2sgcGVyIHNlY29uZCBzcGVlZDwvcD5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC92LWxpbms+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjb2x1bW5cIj5cblx0XHRcdFx0PHYtbGluayBocmVmPScuL251bWJlcl9tZW1vcnkuaHRtbCc+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNhcmRcIj5cblx0XHRcdFx0XHQ8aW1nIGNsYXNzPSdjZW50ZXIgZ2FtZS1pY29uLXNpemUnIDpzcmM9XCJJY29ucy50cmFjZV9pY29uXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5cblx0XHRcdFx0XHQ8aDM+TGluZSBUcmFjaW5nPC9oMz5cblx0XHRcdFx0XHQ8cCBjbGFzcz0nZ2FtZS1jYXJkLWRlc2MnPklkZW50aWZ5IHRoZSBzdGVhZGluZXNzIG9mIHlvdXIgaGFuZCBieSB0cmFjaW5nIGEgbGluZS48L3A+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvdi1saW5rPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+ICBcblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuICA8L21haW4tbGF5b3V0PlxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgTWFpbkxheW91dCBmcm9tICcuLi9sYXlvdXRzL01haW4udnVlJ1xuaW1wb3J0IFZMaW5rIGZyb20gJy4uL2NvbXBvbmVudHMvVkxpbmsudnVlJ1xuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgTWFpbkxheW91dCxcblx0VkxpbmtcbiAgfSxcbiAgZGF0YSgpe1xuXHQgIHJldHVybntcblx0ICB9XG4gIH0sXG4gIG1vdW50ZWQoKXtcbiAgICBwYXJ0aWNsZXNKUyhcInBhcnRpY2xlcy1qc1wiLCB7XG4gICAgICBwYXJ0aWNsZXM6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgdmFsdWU6IDI5LFxuICAgICAgICAgIGRlbnNpdHk6IHsgZW5hYmxlOiB0cnVlLCB2YWx1ZV9hcmVhOiAxMjc4LjcyMTI3ODcyMTI3ODYgfVxuICAgICAgICB9LFxuICAgICAgICBjb2xvcjogeyB2YWx1ZTogXCIjMWIxZTM0XCIgfSxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICB0eXBlOiBcInBvbHlnb25cIixcbiAgICAgICAgICBzdHJva2U6IHsgd2lkdGg6IDAsIGNvbG9yOiBcIiMwMDBcIiB9LFxuICAgICAgICAgIHBvbHlnb246IHsgbmJfc2lkZXM6IDYgfSxcbiAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIHZhbHVlOiAwLjA4LFxuICAgICAgICAgIHJhbmRvbTogZmFsc2UsXG4gICAgICAgICAgYW5pbTogeyBlbmFibGU6IGZhbHNlLCBzcGVlZDogMSwgb3BhY2l0eV9taW46IDAuMSwgc3luYzogZmFsc2UgfVxuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgdmFsdWU6IDg4LjE4NzY2MzM0NzYwMzc1LFxuICAgICAgICAgIHJhbmRvbTogdHJ1ZSxcbiAgICAgICAgICBhbmltOiB7IGVuYWJsZTogdHJ1ZSwgc3BlZWQ6IDEwLCBzaXplX21pbjogNDAsIHN5bmM6IGZhbHNlIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGluZV9saW5rZWQ6IHtcbiAgICAgICAgICBlbmFibGU6IGZhbHNlLFxuICAgICAgICAgIGRpc3RhbmNlOiAyMjQuNDc3Njg4NTIxMTczMixcbiAgICAgICAgICBjb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB3aWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiB7XG4gICAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICAgIHNwZWVkOiAxLFxuICAgICAgICAgIGRpcmVjdGlvbjogXCJib3R0b21cIixcbiAgICAgICAgICByYW5kb206IHRydWUsXG4gICAgICAgICAgc3RyYWlnaHQ6IGZhbHNlLFxuICAgICAgICAgIG91dF9tb2RlOiBcIm91dFwiLFxuICAgICAgICAgIGJvdW5jZTogZmFsc2UsXG4gICAgICAgICAgYXR0cmFjdDogeyBlbmFibGU6IGZhbHNlLCByb3RhdGVYOiA2MDAsIHJvdGF0ZVk6IDI2NDUuNjI5OTAwNDI4MTEyNyB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbnRlcmFjdGl2aXR5OiB7XG4gICAgICAgIGRldGVjdF9vbjogXCJjYW52YXNcIixcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgb25ob3ZlcjogeyBlbmFibGU6IGZhbHNlLCBtb2RlOiBcImdyYWJcIiB9LFxuICAgICAgICAgIG9uY2xpY2s6IHsgZW5hYmxlOiBmYWxzZSwgbW9kZTogXCJwdXNoXCIgfSxcbiAgICAgICAgICByZXNpemU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZXM6IHtcbiAgICAgICAgICBncmFiOiB7IGRpc3RhbmNlOiA0MDAsIGxpbmVfbGlua2VkOiB7IG9wYWNpdHk6IDEgfSB9LFxuICAgICAgICAgIGJ1YmJsZTogeyBkaXN0YW5jZTogNDAwLCBzaXplOiA0MCwgZHVyYXRpb246IDIsIG9wYWNpdHk6IDgsIHNwZWVkOiAzIH0sXG4gICAgICAgICAgcmVwdWxzZTogeyBkaXN0YW5jZTogMjAwLCBkdXJhdGlvbjogMC40IH0sXG4gICAgICAgICAgcHVzaDogeyBwYXJ0aWNsZXNfbmI6IDQgfSxcbiAgICAgICAgICByZW1vdmU6IHsgcGFydGljbGVzX25iOiAyIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJldGluYV9kZXRlY3Q6IHRydWVcbiAgICB9KTtcdFx0XG5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgfSwgIFxuICBtZXRob2RzOntcblxuICB9XG59XG48L3NjcmlwdD5cbiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL0hvbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOS0wIS4vSG9tZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL0hvbWUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBlNGY4MGE0XCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vSG9tZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vSG9tZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuc2NyaXB0LnJlbmRlciA9IHJlbmRlclxuXG5leHBvcnQgZGVmYXVsdCBzY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/NumberMemory.vue?vue&type=template&id=0baaa79e\n\nvar _hoisted_1 = {\n  "class": "number-memory-game-wrapper"\n};\nvar _hoisted_2 = {\n  "class": "container noselect",\n  style: {\n    "transform": "translateY(100px)"\n  }\n};\nvar _hoisted_3 = {\n  key: 0\n};\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Number Memory", -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "You will be presented with a number and you will have to memorize it.", -1\n/* HOISTED */\n);\n\nvar _hoisted_6 = {\n  key: 1\n};\nvar _hoisted_7 = {\n  key: 0\n};\nvar _hoisted_8 = {\n  "class": "large-number-font"\n};\nvar _hoisted_9 = {\n  "class": "progress-bar-container"\n};\nvar _hoisted_10 = {\n  "class": "progress-bar-outter"\n};\nvar _hoisted_11 = {\n  key: 1,\n  style: {}\n};\n\nvar _hoisted_12 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Enter The Number", -1\n/* HOISTED */\n);\n\nvar _hoisted_13 = {\n  key: 2\n};\n\nvar _hoisted_14 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Game Over", -1\n/* HOISTED */\n);\n\nvar _hoisted_15 = {\n  "class": "font"\n};\n\nvar _hoisted_16 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "wrapper"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_2, [!$data.isReady && !$data.isGameOver ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_3, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        "class": "center game-icon-size",\n        style: {\n          "filter": "drop-shadow(2px 4px 6px black) brightness(10)"\n        },\n        src: _ctx.Icons.number_icon,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_4, _hoisted_5, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[1] || (_cache[1] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Play")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.isReady ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_6, [$data.isShowingNumbers ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_7, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_8, Object(vue_esm_bundler["l" /* toDisplayString */])($data.memorizeNumber), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_9, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_10, [Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        style: {\n          height: \'10px\',\n          width: $data.progressbar + \'px\',\n          \'background-color\': \'#4d6b99\',\n          display: \'table-cell\'\n        }\n      }, null, 4\n      /* STYLE */\n      )])])])) : (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_11, [_hoisted_12, Object(vue_esm_bundler["p" /* withDirectives */])(Object(vue_esm_bundler["f" /* createVNode */])("input", {\n        ref: "guessinput",\n        "class": "guess-number-input",\n        "onUpdate:modelValue": _cache[2] || (_cache[2] = function ($event) {\n          return $data.guessedNumber = $event;\n        }),\n        onKeyup: _cache[3] || (_cache[3] = Object(vue_esm_bundler["q" /* withKeys */])(function () {\n          return $options.nextLevel && $options.nextLevel.apply($options, arguments);\n        }, ["enter"])),\n        type: "number"\n      }, null, 544\n      /* HYDRATE_EVENTS, NEED_PATCH */\n      ), [[vue_esm_bundler["m" /* vModelText */], $data.guessedNumber]]), Object(vue_esm_bundler["f" /* createVNode */])("div", null, [Object(vue_esm_bundler["p" /* withDirectives */])(Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[4] || (_cache[4] = function () {\n          return $options.nextLevel && $options.nextLevel.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Next", 512\n      /* NEED_PATCH */\n      ), [[vue_esm_bundler["n" /* vShow */], $data.guessedNumber != null]])])]))])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.isGameOver ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_13, [_hoisted_14, Object(vue_esm_bundler["f" /* createVNode */])("p", _hoisted_15, "You reached level " + Object(vue_esm_bundler["l" /* toDisplayString */])($data.level - 1) + ".", 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[5] || (_cache[5] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])]), _hoisted_16];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/NumberMemory.vue?vue&type=template&id=0baaa79e\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/NumberMemory.vue?vue&type=script&lang=js\n\n/* harmony default export */ var NumberMemoryvue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  },\n  mounted: function mounted() {},\n  data: function data() {\n    return {\n      isReady: false,\n      isGameOver: false,\n      isShowingNumbers: false,\n      memorizeNumber: null,\n      guessedNumber: null,\n      level: 0,\n      progressbar: 300\n    };\n  },\n  computed: {},\n  methods: {\n    onStartButtonClick: function onStartButtonClick() {\n      this.isShowingNumbers = true;\n      this.guessedNumber = null;\n      this.isReady = true;\n      this.isGameOver = false;\n      this.level = 0;\n      this.showNumbers();\n    },\n    nextLevel: function nextLevel() {\n      if (this.guessedNumber == this.memorizeNumber) {\n        this.guessedNumber = null;\n        this.showNumbers();\n      } else {\n        this.isReady = false;\n        this.isGameOver = true;\n        this.isShowingNumbers = false;\n        this.progressbar = 300;\n        this.guessedNumber = null;\n      }\n    },\n    showNumbers: function showNumbers() {\n      var _this = this;\n\n      this.level = this.level + 1;\n      this.isShowingNumbers = true;\n      this.progressbar = 300;\n      this.memorizeNumber = this.generateNumber(this.level);\n      var timer = setInterval(function () {\n        _this.progressbar = _this.progressbar - 1;\n\n        if (_this.progressbar == 0) {\n          clearInterval(timer);\n          _this.isShowingNumbers = false;\n\n          _this.$nextTick(function () {\n            this.$refs["guessinput"].focus();\n          });\n        }\n      }, 15 + this.level * 2);\n    },\n    generateNumber: function generateNumber(level) {\n      var result = \'\';\n      var characters = \'0123456789\';\n      var startcharacters = \'123456789\';\n\n      for (var i = 0; i < level; i++) {\n        if (i == 0) {\n          result += startcharacters.charAt(Math.floor(Math.random() * startcharacters.length));\n        } else {\n          result += characters.charAt(Math.floor(Math.random() * characters.length));\n        }\n      }\n\n      return result;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/NumberMemory.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/NumberMemory.vue\n\n\n\nNumberMemoryvue_type_script_lang_js.render = render\n\n/* harmony default export */ var NumberMemory = __webpack_exports__["default"] = (NumberMemoryvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvTnVtYmVyTWVtb3J5LnZ1ZT9jYTMzIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9OdW1iZXJNZW1vcnkudnVlP2RiNzIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL051bWJlck1lbW9yeS52dWU/YzM3OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFYSxXQUFNOzs7QUFDSixXQUFNLG9CO0FBQXFCLE9BQXFDLEVBQXJDO0FBQUE7QUFBQTs7Ozs7OzhCQUc1QiwrQ0FBcUMsSUFBckMsRUFBcUM7QUFBakMsV0FBTTtBQUEyQixDQUFyQyxFQUFtQixlQUFuQixFQUFnQztBQUFBO0FBQWhDLEM7OzhCQUNBLCtDQUF5RixHQUF6RixFQUF5RjtBQUF0RixXQUFNO0FBQWdGLENBQXpGLEVBQWdCLHVFQUFoQixFQUFxRjtBQUFBO0FBQXJGLEM7Ozs7Ozs7OztBQUtNLFdBQU07OztBQUNMLFdBQU07OztBQUNKLFdBQU07Ozs7QUFNSCxPQUFRLEVBQVI7OzsrQkFDViwrQ0FBd0MsSUFBeEMsRUFBd0M7QUFBcEMsV0FBTTtBQUE4QixDQUF4QyxFQUFtQixrQkFBbkIsRUFBbUM7QUFBQTtBQUFuQyxDOzs7Ozs7K0JBUUYsK0NBQWlDLElBQWpDLEVBQWlDO0FBQTdCLFdBQU07QUFBdUIsQ0FBakMsRUFBbUIsV0FBbkIsRUFBNEI7QUFBQTtBQUE1QixDOzs7QUFDRyxXQUFNOzs7K0JBS2YsK0NBRU0sS0FGTixFQUVNO0FBRkQsV0FBTTtBQUVMLENBRk4sRUFBb0IsSUFBcEIsRUFBb0I7QUFBQTtBQUFwQixDOzs7Ozt5REFsQ0osK0NBcUNjLHNCQXJDZCxFQXFDYyxJQXJDZCxFQXFDYzswREFwQ1Y7QUFBQSxhQWdDTSxDQWhDTiwrQ0FnQ00sS0FoQ04sY0FnQ00sQ0EvQkosK0NBOEJNLEtBOUJOLGNBOEJNLEMsQ0E3QlEsYSxJQUFPLENBQUssZ0Isb0RBQXhCLCtDQUtNLEtBTE4sRUFLTSxVQUxOLEVBS00sQ0FK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QVhzQixFQVdyQixLQUFJLEtBQUssS0FBTCxHQUFXLENBWE0sQ0FBdkI7QUFjRCxLQTFDSztBQTJDTixrQkEzQ00sMEJBMkNTLEtBM0NULEVBMkNnQjtBQUNwQixVQUFJLE1BQUssR0FBYyxFQUF2QjtBQUNBLFVBQUksVUFBUyxHQUFVLFlBQXZCO0FBQ0EsVUFBSSxlQUFjLEdBQUssV0FBdkI7O0FBQ0EsV0FBTSxJQUFJLElBQUksQ0FBZCxFQUFpQixJQUFJLEtBQXJCLEVBQTRCLENBQUMsRUFBN0IsRUFBa0M7QUFDOUIsWUFBRyxLQUFLLENBQVIsRUFBVztBQUNULGdCQUFLLElBQUssZUFBZSxDQUFDLE1BQWhCLENBQXVCLElBQUksQ0FBQyxLQUFMLENBQVksSUFBSSxDQUFDLE1BQUwsS0FBZ0IsZUFBZSxDQUFDLE1BQTVDLENBQXZCLENBQVY7QUFDRCxTQUZELE1BRUs7QUFDSCxnQkFBSyxJQUFLLFVBQVUsQ0FBQyxNQUFYLENBQWtCLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBSSxDQUFDLE1BQUwsS0FBZ0IsVUFBVSxDQUFDLE1BQXRDLENBQWxCLENBQVY7QUFDRjtBQUNKOztBQUNBLGFBQU8sTUFBUDtBQUNGO0FBdkRNO0FBdEJLLENBQWYsRTs7QUMxQzBLLEM7O0FDQWpHO0FBQ1Y7QUFDTDtBQUMxRCxtQ0FBTSxVQUFVLE1BQU07O0FBRVAscUgiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8bWFpbi1sYXlvdXQ+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm51bWJlci1tZW1vcnktZ2FtZS13cmFwcGVyXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPSdjb250YWluZXIgbm9zZWxlY3QnIHN0eWxlPVwidHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMHB4KTtcIj5cclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwiIWlzUmVhZHkgJiYgIWlzR2FtZU92ZXJcIj5cclxuICAgICAgICAgICAgICA8aW1nIGNsYXNzPSdjZW50ZXIgZ2FtZS1pY29uLXNpemUnIHN0eWxlPVwiZmlsdGVyOiBkcm9wLXNoYWRvdygycHggNHB4IDZweCBibGFjaykgYnJpZ2h0bmVzcygxMCk7XCIgOnNyYz1cIkljb25zLm51bWJlcl9pY29uXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJoZWFkZXJcIj5OdW1iZXIgTWVtb3J5PC9oMT5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnRcIj5Zb3Ugd2lsbCBiZSBwcmVzZW50ZWQgd2l0aCBhIG51bWJlciBhbmQgeW91IHdpbGwgaGF2ZSB0byBtZW1vcml6ZSBpdC48L3A+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImdhbWUtc3RhcnQtYnRuXCIgdi1vbjpjbGljaz1cIm9uU3RhcnRCdXR0b25DbGlja1wiIGRyYWdnYWJsZT1cImZhbHNlXCI+UGxheTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICBcclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwiaXNSZWFkeVwiPlxyXG4gICAgICAgICAgICAgIDxkaXYgdi1pZj1cImlzU2hvd2luZ051bWJlcnNcIj5cclxuICAgICAgICAgICAgICAgIDxoMSBjbGFzcz0nbGFyZ2UtbnVtYmVyLWZvbnQnPnt7bWVtb3JpemVOdW1iZXJ9fTwvaDE+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyLW91dHRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgdi1iaW5kOnN0eWxlPVwieyBoZWlnaHQ6ICcxMHB4Jywgd2lkdGg6IHByb2dyZXNzYmFyICsgJ3B4JywgJ2JhY2tncm91bmQtY29sb3InOicjNGQ2Yjk5JyxkaXNwbGF5Oid0YWJsZS1jZWxsJ31cIj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8ZGl2IHYtZWxzZSBzdHlsZT1cIlwiPlxyXG4gICAgICAgICAgICAgICAgPGgxIGNsYXNzPVwiaGVhZGVyXCI+RW50ZXIgVGhlIE51bWJlcjwvaDE+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgcmVmPVwiZ3Vlc3NpbnB1dFwiIGNsYXNzPVwiZ3Vlc3MtbnVtYmVyLWlucHV0XCIgdi1tb2RlbD1cImd1ZXNzZWROdW1iZXJcIiBAa2V5dXAuZW50ZXI9XCJuZXh0TGV2ZWxcIiB0eXBlPVwibnVtYmVyXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LXNob3c9XCJndWVzc2VkTnVtYmVyIT1udWxsXCIgdi1vbjpjbGljaz1cIm5leHRMZXZlbFwiIGRyYWdnYWJsZT1cImZhbHNlXCI+TmV4dDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJpc0dhbWVPdmVyXCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPVwiaGVhZGVyXCI+R2FtZSBPdmVyPC9oMT5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnRcIj5Zb3UgcmVhY2hlZCBsZXZlbCB7e2xldmVsLTF9fS48L3A+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImdhbWUtc3RhcnQtYnRuXCIgdi1vbjpjbGljaz1cIm9uU3RhcnRCdXR0b25DbGlja1wiIGRyYWdnYWJsZT1cImZhbHNlXCI+UmV0cnk8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwid3JhcHBlclwiPlxyXG4gICAgICAgICAgICBcclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvbWFpbi1sYXlvdXQ+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBNYWluTGF5b3V0IGZyb20gJy4uL2xheW91dHMvTWFpbi52dWUnXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICBNYWluTGF5b3V0XHJcbiAgfSxcclxuICBtb3VudGVkKCl7XHJcbiAgICBcclxuXHJcbiAgfSxcclxuICBkYXRhKCl7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc1JlYWR5OmZhbHNlLFxyXG4gICAgICBpc0dhbWVPdmVyOmZhbHNlLFxyXG4gICAgICBpc1Nob3dpbmdOdW1iZXJzOmZhbHNlLFxyXG4gICAgICBtZW1vcml6ZU51bWJlcjpudWxsLFxyXG4gICAgICBndWVzc2VkTnVtYmVyOm51bGwsXHJcbiAgICAgIGxldmVsOjAsXHJcbiAgICAgIHByb2dyZXNzYmFyOjMwMCxcclxuXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gIH0sICBcclxuICBtZXRob2RzOntcclxuICAgIG9uU3RhcnRCdXR0b25DbGljaygpe1xyXG5cclxuICAgICAgdGhpcy5pc1Nob3dpbmdOdW1iZXJzID0gdHJ1ZTtcclxuICAgICAgdGhpcy5ndWVzc2VkTnVtYmVyID0gbnVsbDtcclxuICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5pc0dhbWVPdmVyID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubGV2ZWwgPSAwXHJcbiAgICAgIHRoaXMuc2hvd051bWJlcnMoKTtcclxuICAgIH0sXHJcbiAgICBuZXh0TGV2ZWwoKXtcclxuICAgICAgaWYodGhpcy5ndWVzc2VkTnVtYmVyID09IHRoaXMubWVtb3JpemVOdW1iZXIpe1xyXG4gICAgICAgIHRoaXMuZ3Vlc3NlZE51bWJlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaG93TnVtYmVycygpO1xyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzR2FtZU92ZXIgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXNTaG93aW5nTnVtYmVycyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NiYXIgPSAzMDA7XHJcbiAgICAgICAgdGhpcy5ndWVzc2VkTnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICAgIH0gXHJcbiAgICB9LFxyXG4gICAgc2hvd051bWJlcnMoKXtcclxuICAgICAgdGhpcy5sZXZlbCA9IHRoaXMubGV2ZWwgKyAxO1xyXG4gICAgICB0aGlzLmlzU2hvd2luZ051bWJlcnMgPSB0cnVlO1xyXG4gICAgICB0aGlzLnByb2dyZXNzYmFyID0gMzAwO1xyXG4gICAgICB0aGlzLm1lbW9yaXplTnVtYmVyID0gdGhpcy5nZW5lcmF0ZU51bWJlcih0aGlzLmxldmVsKTtcclxuICAgICAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCk9PntcclxuICAgICAgICB0aGlzLnByb2dyZXNzYmFyID0gdGhpcy5wcm9ncmVzc2JhciAtIDFcclxuICAgICAgICBpZih0aGlzLnByb2dyZXNzYmFyID09IDApe1xyXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XHJcbiAgICAgICAgICB0aGlzLmlzU2hvd2luZ051bWJlcnMgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy4kcmVmc1tcImd1ZXNzaW5wdXRcIl0uZm9jdXMoKTtcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICB9LDE1Kyh0aGlzLmxldmVsKjIpKSAgICBcclxuXHJcbiAgICAgIFxyXG4gICAgfSxcclxuICAgIGdlbmVyYXRlTnVtYmVyKGxldmVsKSB7XHJcbiAgICAgIHZhciByZXN1bHQgICAgICAgICAgID0gJyc7XHJcbiAgICAgIHZhciBjaGFyYWN0ZXJzICAgICAgID0gJzAxMjM0NTY3ODknO1xyXG4gICAgICB2YXIgc3RhcnRjaGFyYWN0ZXJzICA9ICcxMjM0NTY3ODknO1xyXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZXZlbDsgaSsrICkge1xyXG4gICAgICAgICAgaWYoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdGFydGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiBzdGFydGNoYXJhY3RlcnMubGVuZ3RoKSkpO1xyXG4gICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzLmxlbmd0aCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL051bWJlck1lbW9yeS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9OdW1iZXJNZW1vcnkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9OdW1iZXJNZW1vcnkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBiYWFhNzllXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vTnVtYmVyTWVtb3J5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9OdW1iZXJNZW1vcnkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbnNjcmlwdC5yZW5kZXIgPSByZW5kZXJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/ReactionTime.vue?vue&type=template&id=607f5572\n\nvar _hoisted_1 = {\n  "class": "container noselect",\n  style: {\n    "transform": "translateY(100px)"\n  }\n};\nvar _hoisted_2 = {\n  key: 0\n};\n\nvar _hoisted_3 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Reaction Speed", -1\n/* HOISTED */\n);\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Click the screen as fast as you can when the screen turns green.", -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Click anywhere to start.", -1\n/* HOISTED */\n);\n\nvar _hoisted_6 = {\n  key: 1\n};\n\nvar _hoisted_7 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Wait For Green", -1\n/* HOISTED */\n);\n\nvar _hoisted_8 = {\n  key: 2\n};\n\nvar _hoisted_9 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Failed", -1\n/* HOISTED */\n);\n\nvar _hoisted_10 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Wait until the red changes to green.", -1\n/* HOISTED */\n);\n\nvar _hoisted_11 = {\n  "class": "font"\n};\n\nvar _hoisted_12 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Click to retry round.", -1\n/* HOISTED */\n);\n\nvar _hoisted_13 = {\n  key: 3\n};\nvar _hoisted_14 = {\n  "class": "header"\n};\nvar _hoisted_15 = {\n  "class": "font"\n};\n\nvar _hoisted_16 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Click for the next round.", -1\n/* HOISTED */\n);\n\nvar _hoisted_17 = {\n  key: 4\n};\nvar _hoisted_18 = {\n  "class": "header"\n};\n\nvar _hoisted_19 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Click to play again.", -1\n/* HOISTED */\n);\n\nvar _hoisted_20 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "wrapper"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "reaction-game-wrapper",\n        onMousedown: _cache[1] || (_cache[1] = function () {\n          return $options.onBackgroundClicked && $options.onBackgroundClicked.apply($options, arguments);\n        }),\n        style: {\n          \'background-color\': $data.backgroundColor,\n          \'cursor\': \'pointer\'\n        }\n      }, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [$data.state == $data.gameState.BeforeGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_2, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        "class": "center game-icon-size",\n        style: {\n          "filter": "drop-shadow(2px 4px 6px black) brightness(10)"\n        },\n        src: _ctx.Icons.cursor_icon,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_3, _hoisted_4, _hoisted_5])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.AfterGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_6, [_hoisted_7])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.WaitingForNextRoundInputFailed ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_8, [_hoisted_9, _hoisted_10, Object(vue_esm_bundler["f" /* createVNode */])("p", _hoisted_11, "Round " + Object(vue_esm_bundler["l" /* toDisplayString */])($data.sampleTimes.length) + "/5", 1\n      /* TEXT */\n      ), _hoisted_12])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.WaitingForNextRoundInputSucceed ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_13, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_14, Object(vue_esm_bundler["l" /* toDisplayString */])($data.recentReactionTime) + " ms", 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("p", _hoisted_15, "Round " + Object(vue_esm_bundler["l" /* toDisplayString */])($data.sampleTimes.length) + "/5", 1\n      /* TEXT */\n      ), _hoisted_16])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.CompletedAllRounds ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_17, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_18, "You Averaged " + Object(vue_esm_bundler["l" /* toDisplayString */])($options.averageReactionSpeed) + " ms", 1\n      /* TEXT */\n      ), _hoisted_19])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])], 36\n      /* STYLE, HYDRATE_EVENTS */\n      ), _hoisted_20];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/ReactionTime.vue?vue&type=template&id=607f5572\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/ReactionTime.vue?vue&type=script&lang=js\n\nvar gameState = {\n  BeforeGameStart: 1,\n  AfterGameStart: 2,\n  WaitingForReactionInput: 3,\n  WaitingForNextRoundInputSucceed: 4,\n  WaitingForNextRoundInputFailed: 5,\n  CompletedAllRounds: 6\n};\n/* harmony default export */ var ReactionTimevue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  },\n  mounted: function mounted() {},\n  data: function data() {\n    return {\n      gameState: gameState,\n      state: gameState.BeforeGameStart,\n      backgroundColor: "#2c2e43",\n      startTime: null,\n      sampleTimes: [],\n      recentReactionTime: null,\n      timeoutRef: null\n    };\n  },\n  computed: {\n    averageReactionSpeed: function averageReactionSpeed() {\n      return this.sampleTimes.reduce(function (a, b) {\n        return parseFloat(a) + parseFloat(b);\n      }, 0) / this.sampleTimes.length;\n    }\n  },\n  methods: {\n    onBackgroundClicked: function onBackgroundClicked() {\n      if (this.state == this.gameState.BeforeGameStart) {\n        this.backgroundColor = \'#c90000\';\n        this.executeRound();\n      } else if (this.state == this.gameState.WaitingForReactionInput) {\n        this.backgroundColor = "#2c2e43";\n\n        if (this.startTime) {\n          var recent = Date.now() - this.startTime;\n          console.log(recent);\n          this.recentReactionTime = recent;\n          this.sampleTimes.push(recent);\n          this.startTime = null;\n\n          if (this.sampleTimes.length < 5) {\n            this.state = this.gameState.WaitingForNextRoundInputSucceed;\n          } else {\n            this.state = this.gameState.CompletedAllRounds;\n          }\n        } else {\n          this.state = this.gameState.WaitingForNextRoundInputFailed;\n        }\n      } else if (this.state == this.gameState.WaitingForNextRoundInputSucceed || this.state == this.gameState.WaitingForNextRoundInputFailed) {\n        this.backgroundColor = \'#c90000\';\n        this.executeRound();\n      } else if (this.state == this.gameState.CompletedAllRounds) {\n        this.state = gameState.BeforeGameStart;\n        this.backgroundColor = "#2c2e43";\n        this.startTime = null;\n        this.sampleTimes = [];\n        this.recentReactionTime = null;\n      } else if (this.state == this.gameState.AfterGameStart) {\n        clearTimeout(this.timeoutRef);\n        this.state = this.gameState.WaitingForNextRoundInputFailed;\n      }\n    },\n    executeRound: function executeRound() {\n      var _this = this;\n\n      this.state = this.gameState.AfterGameStart;\n      this.timeoutRef = setTimeout(function () {\n        _this.state = _this.gameState.WaitingForReactionInput;\n        _this.backgroundColor = "#008d00";\n\n        _this.$nextTick(function () {\n          //debugger;\n          _this.startTime = Date.now();\n        });\n      }, 2000 + Math.random() * 4000);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/ReactionTime.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/ReactionTime.vue\n\n\n\nReactionTimevue_type_script_lang_js.render = render\n\n/* harmony default export */ var ReactionTime = __webpack_exports__["default"] = (ReactionTimevue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvUmVhY3Rpb25UaW1lLnZ1ZT9jMmU4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9SZWFjdGlvblRpbWUudnVlPzFmNDIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1JlYWN0aW9uVGltZS52dWU/YWJiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFHZSxXQUFNLG9CO0FBQXNCLE9BQXFDLEVBQXJDO0FBQUE7QUFBQTs7Ozs7OzhCQUc3QiwrQ0FBc0MsSUFBdEMsRUFBc0M7QUFBbEMsV0FBTTtBQUE0QixDQUF0QyxFQUFtQixnQkFBbkIsRUFBaUM7QUFBQTtBQUFqQyxDOzs4QkFDQSwrQ0FBb0YsR0FBcEYsRUFBb0Y7QUFBakYsV0FBTTtBQUEyRSxDQUFwRixFQUFnQixrRUFBaEIsRUFBZ0Y7QUFBQTtBQUFoRixDOzs4QkFDQSwrQ0FBNEMsR0FBNUMsRUFBNEM7QUFBekMsV0FBTTtBQUFtQyxDQUE1QyxFQUFnQiwwQkFBaEIsRUFBd0M7QUFBQTtBQUF4QyxDOzs7Ozs7OEJBR0EsK0NBQXNDLElBQXRDLEVBQXNDO0FBQWxDLFdBQU07QUFBNEIsQ0FBdEMsRUFBbUIsZ0JBQW5CLEVBQWlDO0FBQUE7QUFBakMsQzs7Ozs7OzhCQUdBLCtDQUE4QixJQUE5QixFQUE4QjtBQUExQixXQUFNO0FBQW9CLENBQTlCLEVBQW1CLFFBQW5CLEVBQXlCO0FBQUE7QUFBekIsQzs7K0JBQ0EsK0NBQXdELEdBQXhELEVBQXdEO0FBQXJELFdBQU07QUFBK0MsQ0FBeEQsRUFBZ0Isc0NBQWhCLEVBQW9EO0FBQUE7QUFBcEQsQzs7O0FBQ0csV0FBTTs7OytCQUNULCtDQUF5QyxHQUF6QyxFQUF5QztBQUF0QyxXQUFNO0FBQWdDLENBQXpDLEVBQWdCLHVCQUFoQixFQUFxQztBQUFBO0FBQXJDLEM7Ozs7OztBQUdJLFdBQU07OztBQUNQLFdBQU07OzsrQkFDVCwrQ0FBNkMsR0FBN0MsRUFBNkM7QUFBMUMsV0FBTTtBQUFvQyxDQUE3QyxFQUFnQiwyQkFBaEIsRUFBeUM7QUFBQTtBQUF6QyxDOzs7Ozs7QUFHSSxXQUFNOzs7K0JBQ1YsK0NBQXdDLEdBQXhDLEVBQXdDO0FBQXJDLFdBQU07QUFBK0IsQ0FBeEMsRUFBZ0Isc0JBQWhCLEVBQW9DO0FBQUE7QUFBcEMsQzs7K0JBSU4sK0NBRU0sS0FGTixFQUVNO0FBRkQsV0FBTTtBQUVMLENBRk4sRUFBb0IsSUFBcEIsRUFBb0I7QUFBQTtBQUFwQixDOzs7Ozt5REE3QkosK0NBZ0NjLHNCQWhDZCxFQWdDYyxJQWhDZCxFQWdDYzswREEvQlY7QUFBQSxhQTJCTSxDQTNCTiwrQ0EyQk0sS0EzQk4sRUEyQk07QUEzQkQsaUJBQU0sdUJBMkJMO0FBM0I4QixtQkFBUztBQUFBLGlCQUFFLHVGQUFGO0FBQUEsVUEyQnZDO0FBM0IrRCxhQUFLO0FBQUEsOEJBQXNCLHFCQUF0QjtBQUFxQztBQUFyQztBQTJCcEUsT0EzQk4sRSxDQUNFLCtDQXlCTSxLQXpCTixjQXlCTSxDQXhCTyxlQUFPLGdCQUFVLGUsb0RBQTVCLCtDQUtNLEtBTE4sRUFLTSxVQUxOLEVBS00sQ0FKSiwrQ0FBNkksS0FBN0ksRUFBNkk7QUFBeEksaUJBQU0sdUJBQWtJO0FBQTFHLGFBQThELEVBQTlEO0FBQUE7QUFBQSxTQUEwRztBQUExQyxXQUFHLEVBQUUsV0FBTSxXQUErQjtBQUFsQixpQkFBUyxFQUFDO0FBQVEsT0FBN0ksRSxJQUFBLEU7O0FBQUEsUSxPQUFBLENBSUksRUFISixVQUdJLEVBRkosVUFFSSxFQURKLFVBQ0ksQ0FMTixDLHVFQXdCSSxFQWxCTyxlQUFPLGdCQUFVLGMsb0RBQTVCLCtDQUVNLEtBRk4sRUFFTSxVQUZOLEVBRU0sQ0FESixVQUNJLENBRk4sQyx1RUFrQkksRUFmTyxlQUFPLGdCQUFVLDhCLG9EQUE1QiwrQ0FLTSxLQUxOLEVBS00sVUFMTixFQUtNLENBSkosVUFJSSxFQUhKLFdBR0ksRUFGSiwrQ0FBa0QsR0FBbEQsZUFBZ0IsV0FBTSxtREFBRSxrQkFBWSxNQUFkLENBQU4sR0FBNEIsSUFBNUMsRUFBOEM7QUFBQTtBQUE5QyxPQUVJLEVBREosV0FDSSxDQUxOLEMsdUVBZUksRUFUTyxlQUFPLGdCQUFVLCtCLG9EQUE1QiwrQ0FJTSxLQUpOLEVBSU0sV0FKTixFQUlNLENBSEosK0NBQWlELElBQWpELGVBQWlELG1EQUE1Qix3QkFBNEIsSUFBUixLQUF6QyxFQUE0QztBQUFBO0FBQTVDLE9BR0ksRUFGSiwrQ0FBa0QsR0FBbEQsZUFBZ0IsV0FBTSxtREFBRSxrQkFBWSxNQUFkLENBQU4sR0FBNEIsSUFBNUMsRUFBOEM7QUFBQTtBQUE5QyxPQUVJLEVBREosV0FDSSxDQUpOLEMsdUVBU0ksRUFKTyxlQUFPLGdCQUFVLGtCLG9EQUE1QiwrQ0FHTSxLQUhOLEVBR00sV0FITixFQUdNLENBRkosK0NBQWdFLElBQWhFLGVBQW1CLGtCQUFhLG1EQUFFLDZCQUFGLENBQWIsR0FBcUMsS0FBeEQsRUFBMkQ7QUFBQTtBQUEzRCxPQUVJLEVBREosV0FDSSxDQUhOLEMsdUVBSUksQ0F6Qk4sQyxDQURGLEU7O0FBQUEsT0EyQk0sRUFDTixXQURNLENBM0JOO0FBQUEsSyxDQStCVTs7OztBQUFBLEdBaENkLEM7Ozs7Ozs7O0FBbUNKO0FBRUEsSUFBTSxTQUFTLEdBQUM7QUFDZCxpQkFBZSxFQUFDLENBREY7QUFFZCxnQkFBYyxFQUFDLENBRkQ7QUFHZCx5QkFBdUIsRUFBQyxDQUhWO0FBSWQsaUNBQStCLEVBQUMsQ0FKbEI7QUFLZCxnQ0FBOEIsRUFBQyxDQUxqQjtBQU1kLG9CQUFrQixFQUFDO0FBTkwsQ0FBaEI7QUFTZTtBQUNiLFlBQVUsRUFBRTtBQUNWLGNBQVMsRUFBVCx1QkFBVTtBQURBLEdBREM7QUFJYixTQUphLHFCQUlKLENBR1IsQ0FQWTtBQVdiLE1BWGEsa0JBV1A7QUFDSixXQUFPO0FBQ0wsZUFBUyxFQUFDLFNBREw7QUFFTCxXQUFLLEVBQUMsU0FBUyxDQUFDLGVBRlg7QUFHTCxxQkFBZSxFQUFDLFNBSFg7QUFJTCxlQUFTLEVBQUMsSUFKTDtBQUtMLGlCQUFXLEVBQUMsRUFMUDtBQU1MLHdCQUFrQixFQUFDLElBTmQ7QUFPTCxnQkFBVSxFQUFDO0FBUE4sS0FBUDtBQVNELEdBckJZO0FBc0JiLFVBQVEsRUFBRTtBQUNSLHdCQURRLGtDQUNjO0FBQ3BCLGFBQU8sS0FBSyxXQUFMLENBQWlCLE1BQWpCLENBQXdCLFVBQUMsQ0FBRCxFQUFJLENBQUo7QUFBQSxlQUFVLFVBQVUsQ0FBQyxDQUFELENBQVYsR0FBZ0IsVUFBVSxDQUFDLENBQUQsQ0FBcEM7QUFBQSxPQUF4QixFQUFpRSxDQUFqRSxJQUFvRSxLQUFLLFdBQUwsQ0FBaUIsTUFBNUY7QUFDRjtBQUhRLEdBdEJHO0FBMkJiLFNBQU8sRUFBQztBQUNOLHVCQURNLGlDQUNlO0FBQ25CLFVBQUcsS0FBSyxLQUFMLElBQWMsS0FBSyxTQUFMLENBQWUsZUFBaEMsRUFBZ0Q7QUFDOUMsYUFBSyxlQUFMLEdBQXFCLFNBQXJCO0FBQ0EsYUFBSyxZQUFMO0FBQ0QsT0FIRCxNQUdNLElBQUcsS0FBSyxLQUFMLElBQWMsS0FBSyxTQUFMLENBQWUsdUJBQWhDLEVBQXdEO0FBQzVELGFBQUssZUFBTCxHQUF1QixTQUF2Qjs7QUFDQSxZQUFHLEtBQUssU0FBUixFQUFrQjtBQUNoQixjQUFJLE1BQUssR0FBSSxJQUFJLENBQUMsR0FBTCxLQUFXLEtBQUssU0FBN0I7QUFDQSxpQkFBTyxDQUFDLEdBQVIsQ0FBWSxNQUFaO0FBQ0EsZUFBSyxrQkFBTCxHQUEwQixNQUExQjtBQUNBLGVBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixNQUF0QjtBQUNBLGVBQUssU0FBTCxHQUFpQixJQUFqQjs7QUFDQSxjQUFHLEtBQUssV0FBTCxDQUFpQixNQUFqQixHQUEwQixDQUE3QixFQUErQjtBQUM3QixpQkFBSyxLQUFMLEdBQWEsS0FBSyxTQUFMLENBQWUsK0JBQTVCO0FBQ0QsV0FGRCxNQUVLO0FBQ0gsaUJBQUssS0FBTCxHQUFhLEtBQUssU0FBTCxDQUFlLGtCQUE1QjtBQUNGO0FBQ0QsU0FYRCxNQVdLO0FBQ0gsZUFBSyxLQUFMLEdBQWEsS0FBSyxTQUFMLENBQWUsOEJBQTVCO0FBQ0Y7QUFDRCxPQWhCSyxNQWdCQSxJQUFHLEtBQUssS0FBTCxJQUFjLEtBQUssU0FBTCxDQUFlLCtCQUE3QixJQUFnRSxLQUFLLEtBQUwsSUFBYyxLQUFLLFNBQUwsQ0FBZSw4QkFBaEcsRUFBK0g7QUFDbkksYUFBSyxlQUFMLEdBQXFCLFNBQXJCO0FBQ0EsYUFBSyxZQUFMO0FBQ0QsT0FISyxNQUdBLElBQUcsS0FBSyxLQUFMLElBQWMsS0FBSyxTQUFMLENBQWUsa0JBQWhDLEVBQW1EO0FBQ3ZELGFBQUssS0FBTCxHQUFXLFNBQVMsQ0FBQyxlQUFyQjtBQUNBLGFBQUssZUFBTCxHQUFxQixTQUFyQjtBQUNBLGFBQUssU0FBTCxHQUFlLElBQWY7QUFDQSxhQUFLLFdBQUwsR0FBaUIsRUFBakI7QUFDQSxhQUFLLGtCQUFMLEdBQXdCLElBQXhCO0FBQ0QsT0FOSyxNQU1BLElBQUcsS0FBSyxLQUFMLElBQWMsS0FBSyxTQUFMLENBQWUsY0FBaEMsRUFBK0M7QUFDbkQsb0JBQVksQ0FBQyxLQUFLLFVBQU4sQ0FBWjtBQUNBLGFBQUssS0FBTCxHQUFhLEtBQUssU0FBTCxDQUFlLDhCQUE1QjtBQUNGO0FBQ0QsS0FsQ0s7QUFtQ04sZ0JBbkNNLDBCQW1DUTtBQUFBOztBQUNaLFdBQUssS0FBTCxHQUFhLEtBQUssU0FBTCxDQUFlLGNBQTVCO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLFVBQVUsQ0FBQyxZQUFJO0FBQy9CLGFBQUksQ0FBQyxLQUFMLEdBQWEsS0FBSSxDQUFDLFNBQUwsQ0FBZSx1QkFBNUI7QUFDQSxhQUFJLENBQUMsZUFBTCxHQUFxQixTQUFyQjs7QUFDQSxhQUFJLENBQUMsU0FBTCxDQUFlLFlBQUk7QUFDakI7QUFDQSxlQUFJLENBQUMsU0FBTCxHQUFpQixJQUFJLENBQUMsR0FBTCxFQUFqQjtBQUNELFNBSEQ7QUFLRCxPQVIyQixFQVExQixPQUFPLElBQUksQ0FBQyxNQUFMLEtBQWMsSUFSSyxDQUE1QjtBQVNGO0FBOUNNO0FBM0JLLENBQWYsRTs7QUMvQzBLLEM7O0FDQWpHO0FBQ1Y7QUFDTDtBQUMxRCxtQ0FBTSxVQUFVLE1BQU07O0FBRVAscUgiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8bWFpbi1sYXlvdXQ+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlYWN0aW9uLWdhbWUtd3JhcHBlclwiIEBtb3VzZWRvd249XCJvbkJhY2tncm91bmRDbGlja2VkXCIgOnN0eWxlPVwieydiYWNrZ3JvdW5kLWNvbG9yJzpiYWNrZ3JvdW5kQ29sb3IsICdjdXJzb3InOidwb2ludGVyJ31cIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9J2NvbnRhaW5lciBub3NlbGVjdCcgIHN0eWxlPVwidHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMHB4KTtcIj5cclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwic3RhdGU9PWdhbWVTdGF0ZS5CZWZvcmVHYW1lU3RhcnRcIj5cclxuICAgICAgICAgICAgICA8aW1nIGNsYXNzPSdjZW50ZXIgZ2FtZS1pY29uLXNpemUnIHN0eWxlPVwiZmlsdGVyOiBkcm9wLXNoYWRvdygycHggNHB4IDZweCBibGFjaykgYnJpZ2h0bmVzcygxMCk7XCIgOnNyYz1cIkljb25zLmN1cnNvcl9pY29uXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJoZWFkZXJcIj5SZWFjdGlvbiBTcGVlZDwvaDE+XHJcbiAgICAgICAgICAgICAgPHAgY2xhc3M9XCJmb250XCI+Q2xpY2sgdGhlIHNjcmVlbiBhcyBmYXN0IGFzIHlvdSBjYW4gd2hlbiB0aGUgc2NyZWVuIHR1cm5zIGdyZWVuLjwvcD5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnRcIj5DbGljayBhbnl3aGVyZSB0byBzdGFydC48L3A+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkFmdGVyR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPVwiaGVhZGVyXCI+V2FpdCBGb3IgR3JlZW48L2gxPlxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgXHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuV2FpdGluZ0Zvck5leHRSb3VuZElucHV0RmFpbGVkXCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPVwiaGVhZGVyXCI+RmFpbGVkPC9oMT5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnRcIj5XYWl0IHVudGlsIHRoZSByZWQgY2hhbmdlcyB0byBncmVlbi48L3A+XHJcbiAgICAgICAgICAgICAgPHAgY2xhc3M9XCJmb250XCI+Um91bmQge3tzYW1wbGVUaW1lcy5sZW5ndGh9fS81PC9wPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVwiZm9udFwiPkNsaWNrIHRvIHJldHJ5IHJvdW5kLjwvcD5cclxuICAgICAgICAgICAgPC9kaXY+ICAgICAgXHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuV2FpdGluZ0Zvck5leHRSb3VuZElucHV0U3VjY2VlZFwiPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz1cImhlYWRlclwiPnt7cmVjZW50UmVhY3Rpb25UaW1lfX0gbXM8L2gxPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVwiZm9udFwiPlJvdW5kIHt7c2FtcGxlVGltZXMubGVuZ3RofX0vNTwvcD5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnRcIj5DbGljayBmb3IgdGhlIG5leHQgcm91bmQuPC9wPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwic3RhdGU9PWdhbWVTdGF0ZS5Db21wbGV0ZWRBbGxSb3VuZHNcIj4gIFxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz1cImhlYWRlclwiPllvdSBBdmVyYWdlZCB7e2F2ZXJhZ2VSZWFjdGlvblNwZWVkfX0gbXM8L2gxPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVwiZm9udFwiPkNsaWNrIHRvIHBsYXkgYWdhaW4uPC9wPlxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIndyYXBwZXJcIj5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L21haW4tbGF5b3V0PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgTWFpbkxheW91dCBmcm9tICcuLi9sYXlvdXRzL01haW4udnVlJ1xyXG5cclxuY29uc3QgZ2FtZVN0YXRlPXtcclxuICBCZWZvcmVHYW1lU3RhcnQ6MSxcclxuICBBZnRlckdhbWVTdGFydDoyLFxyXG4gIFdhaXRpbmdGb3JSZWFjdGlvbklucHV0OjMsXHJcbiAgV2FpdGluZ0Zvck5leHRSb3VuZElucHV0U3VjY2VlZDo0LFxyXG4gIFdhaXRpbmdGb3JOZXh0Um91bmRJbnB1dEZhaWxlZDo1LFxyXG4gIENvbXBsZXRlZEFsbFJvdW5kczo2XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICBNYWluTGF5b3V0XHJcbiAgfSxcclxuICBtb3VudGVkKCl7XHJcbiAgICBcclxuXHJcbiAgfSxcclxuXHJcblxyXG5cclxuICBkYXRhKCl7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnYW1lU3RhdGU6Z2FtZVN0YXRlLFxyXG4gICAgICBzdGF0ZTpnYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0LFxyXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6XCIjMmMyZTQzXCIsXHJcbiAgICAgIHN0YXJ0VGltZTpudWxsLFxyXG4gICAgICBzYW1wbGVUaW1lczpbXSxcclxuICAgICAgcmVjZW50UmVhY3Rpb25UaW1lOm51bGwsXHJcbiAgICAgIHRpbWVvdXRSZWY6bnVsbFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIGF2ZXJhZ2VSZWFjdGlvblNwZWVkKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnNhbXBsZVRpbWVzLnJlZHVjZSgoYSwgYikgPT4gcGFyc2VGbG9hdChhKSArIHBhcnNlRmxvYXQoYiksIDApL3RoaXMuc2FtcGxlVGltZXMubGVuZ3RoXHJcbiAgICB9XHJcbiAgfSwgIFxyXG4gIG1ldGhvZHM6e1xyXG4gICAgb25CYWNrZ3JvdW5kQ2xpY2tlZCgpe1xyXG4gICAgICBpZih0aGlzLnN0YXRlID09IHRoaXMuZ2FtZVN0YXRlLkJlZm9yZUdhbWVTdGFydCl7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3I9JyNjOTAwMDAnO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZVJvdW5kKCk7XHJcbiAgICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT0gdGhpcy5nYW1lU3RhdGUuV2FpdGluZ0ZvclJlYWN0aW9uSW5wdXQpe1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gXCIjMmMyZTQzXCJcclxuICAgICAgICBpZih0aGlzLnN0YXJ0VGltZSl7XHJcbiAgICAgICAgICB2YXIgcmVjZW50ID0gRGF0ZS5ub3coKS10aGlzLnN0YXJ0VGltZTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKHJlY2VudClcclxuICAgICAgICAgIHRoaXMucmVjZW50UmVhY3Rpb25UaW1lID0gcmVjZW50O1xyXG4gICAgICAgICAgdGhpcy5zYW1wbGVUaW1lcy5wdXNoKHJlY2VudCk7XHJcbiAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XHJcbiAgICAgICAgICBpZih0aGlzLnNhbXBsZVRpbWVzLmxlbmd0aCA8IDUpe1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuV2FpdGluZ0Zvck5leHRSb3VuZElucHV0U3VjY2VlZFxyXG4gICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5Db21wbGV0ZWRBbGxSb3VuZHNcclxuICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5XYWl0aW5nRm9yTmV4dFJvdW5kSW5wdXRGYWlsZWRcclxuICAgICAgICB9XHJcbiAgICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT0gdGhpcy5nYW1lU3RhdGUuV2FpdGluZ0Zvck5leHRSb3VuZElucHV0U3VjY2VlZCB8fCB0aGlzLnN0YXRlID09IHRoaXMuZ2FtZVN0YXRlLldhaXRpbmdGb3JOZXh0Um91bmRJbnB1dEZhaWxlZCl7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3I9JyNjOTAwMDAnO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZVJvdW5kKCk7XHJcbiAgICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT0gdGhpcy5nYW1lU3RhdGUuQ29tcGxldGVkQWxsUm91bmRzKXtcclxuICAgICAgICB0aGlzLnN0YXRlPWdhbWVTdGF0ZS5CZWZvcmVHYW1lU3RhcnRcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvcj1cIiMyYzJlNDNcIlxyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lPW51bGxcclxuICAgICAgICB0aGlzLnNhbXBsZVRpbWVzPVtdXHJcbiAgICAgICAgdGhpcy5yZWNlbnRSZWFjdGlvblRpbWU9bnVsbFxyXG4gICAgICB9ZWxzZSBpZih0aGlzLnN0YXRlID09IHRoaXMuZ2FtZVN0YXRlLkFmdGVyR2FtZVN0YXJ0KXtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuV2FpdGluZ0Zvck5leHRSb3VuZElucHV0RmFpbGVkXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBleGVjdXRlUm91bmQoKXtcclxuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuZ2FtZVN0YXRlLkFmdGVyR2FtZVN0YXJ0XHJcbiAgICAgIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuV2FpdGluZ0ZvclJlYWN0aW9uSW5wdXRcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvcj1cIiMwMDhkMDBcIjtcclxuICAgICAgICB0aGlzLiRuZXh0VGljaygoKT0+e1xyXG4gICAgICAgICAgLy9kZWJ1Z2dlcjtcclxuICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIFxyXG4gICAgICB9LDIwMDAgKyBNYXRoLnJhbmRvbSgpKjQwMDApXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9yZWYtLTktMCEuL1JlYWN0aW9uVGltZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9SZWFjdGlvblRpbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9SZWFjdGlvblRpbWUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTYwN2Y1NTcyXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vUmVhY3Rpb25UaW1lLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9SZWFjdGlvblRpbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbnNjcmlwdC5yZW5kZXIgPSByZW5kZXJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/SpeedTyper.vue?vue&type=template&id=54e7fe8a\n\nvar _hoisted_1 = {\n  "class": "reaction-game-wrapper"\n};\nvar _hoisted_2 = {\n  "class": "container noselect",\n  style: {\n    "transform": "translateY(100px)"\n  }\n};\nvar _hoisted_3 = {\n  key: 0\n};\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Speed Typer", -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "You will be presented with a list of random words.", -1\n/* HOISTED */\n);\n\nvar _hoisted_6 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "You need to type the words as fast as you can.", -1\n/* HOISTED */\n);\n\nvar _hoisted_7 = {\n  key: 1\n};\nvar _hoisted_8 = {\n  "class": "wordList"\n};\nvar _hoisted_9 = {\n  style: {\n    "color": "rgb(56 180 56)"\n  }\n};\nvar _hoisted_10 = {\n  style: {\n    "color": "rgb(56 180 56)"\n  }\n};\nvar _hoisted_11 = {\n  style: {\n    "color": "red"\n  }\n};\nvar _hoisted_12 = {\n  style: {\n    "color": "black"\n  }\n};\nvar _hoisted_13 = {\n  key: 0,\n  "class": "header"\n};\nvar _hoisted_14 = {\n  key: 2\n};\nvar _hoisted_15 = {\n  "class": "header"\n};\n\nvar _hoisted_16 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "wrapper"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _this = this;\n\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_2, [$data.state == $data.gameState.BeforeGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_3, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        "class": "center game-icon-size",\n        style: {\n          "filter": "drop-shadow(2px 4px 6px black) brightness(10)"\n        },\n        src: _ctx.Icons.type_icon,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_4, _hoisted_5, _hoisted_6, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[1] || (_cache[1] = function () {\n          return $options.startButtonPressed && $options.startButtonPressed.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Play")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.UserTyping || $data.state == _this.gameState.CountDown ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_7, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_8, [Object(vue_esm_bundler["f" /* createVNode */])("span", _hoisted_9, Object(vue_esm_bundler["l" /* toDisplayString */])($data.correctWords), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("span", _hoisted_10, Object(vue_esm_bundler["l" /* toDisplayString */])($options.getCorrectLetters), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("span", _hoisted_11, Object(vue_esm_bundler["l" /* toDisplayString */])($options.getIncorrectLetters), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("span", _hoisted_12, Object(vue_esm_bundler["l" /* toDisplayString */])($options.getUntypedLetters), 1\n      /* TEXT */\n      )]), Object(vue_esm_bundler["p" /* withDirectives */])(Object(vue_esm_bundler["f" /* createVNode */])("input", {\n        style: {\n          \'background-color\': $options.getIncorrectLetters.length > 0 ? \'#ffebeb\' : \'white\'\n        },\n        "class": "center speed-typer-input",\n        onKeydown: _cache[2] || (_cache[2] = function () {\n          return $options.inputDisabler && $options.inputDisabler.apply($options, arguments);\n        }),\n        type: "text",\n        onInput: _cache[3] || (_cache[3] = function ($event) {\n          return $options.onInput($event.target.value);\n        }),\n        "onUpdate:modelValue": _cache[4] || (_cache[4] = function ($event) {\n          return $data.inputBoxText = $event;\n        })\n      }, null, 36\n      /* STYLE, HYDRATE_EVENTS */\n      ), [[vue_esm_bundler["m" /* vModelText */], $data.inputBoxText]]), $data.state == $data.gameState.CountDown ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("h1", _hoisted_13, Object(vue_esm_bundler["l" /* toDisplayString */])($data.countDown), 1\n      /* TEXT */\n      )) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.FinishedParagraph ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_14, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_15, Object(vue_esm_bundler["l" /* toDisplayString */])($data.wpm.toFixed(1)) + " WPM", 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[5] || (_cache[5] = function () {\n          return $options.retryButtonPressed && $options.retryButtonPressed.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])]), _hoisted_16];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/SpeedTyper.vue?vue&type=template&id=54e7fe8a\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./src/words.js\nvar words = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/SpeedTyper.vue?vue&type=script&lang=js\n\n\nvar gameState = {\n  BeforeGameStart: 1,\n  CountDown: 2,\n  UserTyping: 3,\n  FinishedParagraph: 4\n};\n/* harmony default export */ var SpeedTypervue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  },\n  mounted: function mounted() {},\n  data: function data() {\n    return {\n      gameState: gameState,\n      state: gameState.BeforeGameStart,\n      words: words["a" /* default */],\n      chosenWords: "",\n      inputBoxText: "",\n      correctWords: "",\n      countDown: 5,\n      startTime: null,\n      wpm: null,\n      characterCount: 130\n    };\n  },\n  computed: {\n    getCorrectLetters: function getCorrectLetters() {\n      var letters = "";\n\n      for (var i = this.correctWords.length; i < this.chosenWords.length; i++) {\n        if ((this.correctWords + this.inputBoxText).charAt(i) == this.chosenWords.charAt(i)) {\n          letters += this.chosenWords.charAt(i);\n        } else {\n          break;\n        }\n      }\n\n      return letters;\n    },\n    getIncorrectLetters: function getIncorrectLetters() {\n      var correct = this.correctWords.length + this.getCorrectLetters.length;\n      var total = this.correctWords.length + this.inputBoxText.length;\n      var incorrect = this.chosenWords.substring(correct, total);\n      return incorrect;\n    },\n    getUntypedLetters: function getUntypedLetters() {\n      return this.chosenWords.substring((this.correctWords + this.inputBoxText).length);\n    }\n  },\n  methods: {\n    retryButtonPressed: function retryButtonPressed() {\n      this.state = gameState.BeforeGameStart, this.chosenWords = "";\n      this.inputBoxText = "";\n      this.correctWords = "";\n      this.countDown = 5;\n      this.startTime = null;\n      this.wpm = null;\n    },\n    startButtonPressed: function startButtonPressed() {\n      var _this = this;\n\n      this.chosenWords = this.generateWordList().join(" ");\n      this.state = this.gameState.CountDown;\n      var interval = setInterval(function () {\n        _this.countDown -= 1;\n\n        if (_this.countDown == 0) {\n          clearInterval(interval);\n          _this.startTime = Date.now();\n          _this.state = _this.gameState.UserTyping;\n        }\n      }, 1000);\n    },\n    finished: function finished() {\n      var duration = Date.now() - this.startTime;\n      var totalWords = this.characterCount / 5;\n      var wpms = totalWords / duration;\n      this.wpm = wpms * 1000 * 60;\n      this.state = this.gameState.FinishedParagraph;\n    },\n    onInput: function onInput(characters) {\n      if (characters.endsWith(" ") || (this.correctWords + characters).length == this.chosenWords.length) {\n        if (this.chosenWords.startsWith(this.correctWords + characters)) {\n          this.correctWords += characters;\n          this.inputBoxText = "";\n        }\n      }\n\n      if (this.correctWords == this.chosenWords) {\n        this.finished();\n      }\n    },\n    generateWordList: function generateWordList() {\n      var list = [];\n\n      while (list.join(\' \').length != this.characterCount) {\n        while (list.join(\' \').length < this.characterCount) {\n          var chosenWord = this.words[Math.floor(Math.random() * Math.floor(this.words.length))];\n\n          if (chosenWord.length <= 8) {\n            list.push(chosenWord);\n          }\n        }\n\n        if (list.join(\' \').length > this.characterCount) {\n          list.pop();\n          list.pop();\n          list.pop();\n        }\n      }\n\n      return list;\n    },\n    inputDisabler: function inputDisabler(e) {\n      if (this.state != this.gameState.UserTyping) {\n        e.preventDefault();\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/SpeedTyper.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/SpeedTyper.vue\n\n\n\nSpeedTypervue_type_script_lang_js.render = render\n\n/* harmony default export */ var SpeedTyper = __webpack_exports__["default"] = (SpeedTypervue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvU3BlZWRUeXBlci52dWU/NmRhMCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvU3BlZWRUeXBlci52dWU/OGVhMSIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvU3BlZWRUeXBlci52dWU/M2FlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFYSxXQUFNOzs7QUFDSixXQUFNLG9CO0FBQXFCLE9BQXFDLEVBQXJDO0FBQUE7QUFBQTs7Ozs7OzhCQUc1QiwrQ0FBbUMsSUFBbkMsRUFBbUM7QUFBL0IsV0FBTTtBQUF5QixDQUFuQyxFQUFtQixhQUFuQixFQUE4QjtBQUFBO0FBQTlCLEM7OzhCQUNBLCtDQUFzRSxHQUF0RSxFQUFzRTtBQUFuRSxXQUFNO0FBQTZELENBQXRFLEVBQWdCLG9EQUFoQixFQUFrRTtBQUFBO0FBQWxFLEM7OzhCQUNBLCtDQUFrRSxHQUFsRSxFQUFrRTtBQUEvRCxXQUFNO0FBQXlELENBQWxFLEVBQWdCLGdEQUFoQixFQUE4RDtBQUFBO0FBQTlELEM7Ozs7OztBQUlLLFdBQU07OztBQUNILE9BQTZCLEVBQTdCO0FBQUE7QUFBQTs7O0FBQTJELE9BQThCLEVBQTlCO0FBQUE7QUFBQTs7O0FBQWlFLE9BQWtCLEVBQWxCO0FBQUE7QUFBQTs7O0FBQXVELE9BQW9CLEVBQXBCO0FBQUE7QUFBQTs7OztBQUdySixXQUFNOzs7Ozs7QUFHeEMsV0FBTTs7OytCQUtoQiwrQ0FFTSxLQUZOLEVBRU07QUFGRCxXQUFNO0FBRUwsQ0FGTixFQUFvQixJQUFwQixFQUFvQjtBQUFBO0FBQXBCLEM7Ozs7Ozs7eURBdkJKLCtDQTBCYyxzQkExQmQsRUEwQmMsSUExQmQsRUEwQmM7MERBekJWO0FBQUEsYUFxQk0sQ0FyQk4sK0NBcUJNLEtBckJOLGNBcUJNLENBcEJKLCtDQW1CTSxLQW5CTixjQW1CTSxDQWxCTyxlQUFPLGdCQUFVLGUsb0RBQTVCLCtDQU1NLEtBTk4sRUFNTSxVQU5OLEVBTU0sQ0FM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Q0FBQyxHQUFMO0FBQ3hCO0FBQ0Y7O0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0F6REs7QUEwRE4saUJBMURNLHlCQTBEUSxDQTFEUixFQTBEVTtBQUNkLFVBQUcsS0FBSyxLQUFMLElBQWMsS0FBSyxTQUFMLENBQWUsVUFBaEMsRUFBMkM7QUFDekMsU0FBQyxDQUFDLGNBQUY7QUFDRjtBQUNGO0FBOURNO0FBN0NLLENBQWYsRTs7QUN2Q3dLLEM7O0FDQWpHO0FBQ1Y7QUFDTDtBQUN4RCxpQ0FBTSxVQUFVLE1BQU07O0FBRVAsaUgiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8bWFpbi1sYXlvdXQ+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlYWN0aW9uLWdhbWUtd3JhcHBlclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz0nY29udGFpbmVyIG5vc2VsZWN0JyBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDBweCk7XCI+XHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgPGltZyBjbGFzcz0nY2VudGVyIGdhbWUtaWNvbi1zaXplJyBzdHlsZT1cImZpbHRlcjogZHJvcC1zaGFkb3coMnB4IDRweCA2cHggYmxhY2spIGJyaWdodG5lc3MoMTApO1wiIDpzcmM9XCJJY29ucy50eXBlX2ljb25cIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz1cImhlYWRlclwiPlNwZWVkIFR5cGVyPC9oMT5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnRcIj5Zb3Ugd2lsbCBiZSBwcmVzZW50ZWQgd2l0aCBhIGxpc3Qgb2YgcmFuZG9tIHdvcmRzLjwvcD5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnRcIj5Zb3UgbmVlZCB0byB0eXBlIHRoZSB3b3JkcyBhcyBmYXN0IGFzIHlvdSBjYW4uPC9wPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnYW1lLXN0YXJ0LWJ0blwiIHYtb246Y2xpY2s9XCJzdGFydEJ1dHRvblByZXNzZWRcIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlBsYXk8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuVXNlclR5cGluZyB8fCBzdGF0ZT09dGhpcy5nYW1lU3RhdGUuQ291bnREb3duXCI+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIndvcmRMaXN0XCI+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOnJnYig1NiAxODAgNTYpO1wiPnt7Y29ycmVjdFdvcmRzfX08L3NwYW4+PHNwYW4gc3R5bGU9XCJjb2xvcjogcmdiKDU2IDE4MCA1Nik7XCI+e3tnZXRDb3JyZWN0TGV0dGVyc319PC9zcGFuPjxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPnt7Z2V0SW5jb3JyZWN0TGV0dGVyc319PC9zcGFuPjxzcGFuIHN0eWxlPVwiY29sb3I6YmxhY2s7XCI+e3tnZXRVbnR5cGVkTGV0dGVyc319PC9zcGFuPlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDxpbnB1dCA6c3R5bGU9XCJ7J2JhY2tncm91bmQtY29sb3InOihnZXRJbmNvcnJlY3RMZXR0ZXJzLmxlbmd0aCA+IDAgPycjZmZlYmViJzond2hpdGUnKX1cIiBjbGFzcz1cImNlbnRlciBzcGVlZC10eXBlci1pbnB1dFwiIHYtb246a2V5ZG93bj1cImlucHV0RGlzYWJsZXJcIiB0eXBlPVwidGV4dFwiIHYtb246aW5wdXQ9XCJvbklucHV0KCRldmVudC50YXJnZXQudmFsdWUpXCIgdi1tb2RlbD1cImlucHV0Qm94VGV4dFwiPlxyXG4gICAgICAgICAgICAgIDxoMSB2LWlmPVwic3RhdGU9PWdhbWVTdGF0ZS5Db3VudERvd25cIiBjbGFzcz1cImhlYWRlclwiPnt7Y291bnREb3dufX08L2gxPlxyXG4gICAgICAgICAgICA8L2Rpdj4gXHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuRmluaXNoZWRQYXJhZ3JhcGhcIj5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJoZWFkZXJcIj57e3dwbS50b0ZpeGVkKDEpfX0gV1BNPC9oMT5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LW9uOmNsaWNrPVwicmV0cnlCdXR0b25QcmVzc2VkXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5SZXRyeTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyXCI+XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9tYWluLWxheW91dD5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1haW5MYXlvdXQgZnJvbSAnLi4vbGF5b3V0cy9NYWluLnZ1ZSdcclxuaW1wb3J0IFdvcmRzIGZyb20gJy4uL3dvcmRzLmpzJ1xyXG5jb25zdCBnYW1lU3RhdGU9e1xyXG4gIEJlZm9yZUdhbWVTdGFydDoxLFxyXG4gIENvdW50RG93bjoyLFxyXG4gIFVzZXJUeXBpbmc6MyxcclxuICBGaW5pc2hlZFBhcmFncmFwaDo0LFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgY29tcG9uZW50czoge1xyXG4gICAgTWFpbkxheW91dFxyXG4gIH0sXHJcbiAgbW91bnRlZCgpe1xyXG4gICAgXHJcblxyXG4gIH0sXHJcbiAgZGF0YSgpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2FtZVN0YXRlOmdhbWVTdGF0ZSxcclxuICAgICAgc3RhdGU6Z2FtZVN0YXRlLkJlZm9yZUdhbWVTdGFydCxcclxuICAgICAgd29yZHM6V29yZHMsXHJcbiAgICAgIGNob3NlbldvcmRzOlwiXCIsXHJcbiAgICAgIGlucHV0Qm94VGV4dDpcIlwiLFxyXG4gICAgICBjb3JyZWN0V29yZHM6XCJcIixcclxuICAgICAgY291bnREb3duOjUsXHJcbiAgICAgIHN0YXJ0VGltZTpudWxsLFxyXG4gICAgICB3cG06bnVsbCxcclxuICAgICAgY2hhcmFjdGVyQ291bnQ6MTMwXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgZ2V0Q29ycmVjdExldHRlcnMoKXtcclxuICAgICAgdmFyIGxldHRlcnMgPSBcIlwiO1xyXG4gICAgICBmb3IodmFyIGkgPSB0aGlzLmNvcnJlY3RXb3Jkcy5sZW5ndGg7aTx0aGlzLmNob3NlbldvcmRzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIGlmKCh0aGlzLmNvcnJlY3RXb3JkcyArIHRoaXMuaW5wdXRCb3hUZXh0KS5jaGFyQXQoaSkgPT0gdGhpcy5jaG9zZW5Xb3Jkcy5jaGFyQXQoaSkpe1xyXG4gICAgICAgICAgbGV0dGVycyArPSB0aGlzLmNob3NlbldvcmRzLmNoYXJBdChpKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbGV0dGVycztcclxuICAgIH0sXHJcbiAgICBnZXRJbmNvcnJlY3RMZXR0ZXJzKCl7XHJcbiAgICAgIHZhciBjb3JyZWN0ID0gdGhpcy5jb3JyZWN0V29yZHMubGVuZ3RoICsgdGhpcy5nZXRDb3JyZWN0TGV0dGVycy5sZW5ndGg7XHJcbiAgICAgIHZhciB0b3RhbCA9IHRoaXMuY29ycmVjdFdvcmRzLmxlbmd0aCArIHRoaXMuaW5wdXRCb3hUZXh0Lmxlbmd0aDtcclxuICAgICAgXHJcbiAgICAgIHZhciBpbmNvcnJlY3QgPSAodGhpcy5jaG9zZW5Xb3Jkcykuc3Vic3RyaW5nKGNvcnJlY3QsdG90YWwpO1xyXG4gICAgICByZXR1cm4gaW5jb3JyZWN0O1xyXG4gICAgfSxcclxuICAgIGdldFVudHlwZWRMZXR0ZXJzKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLmNob3NlbldvcmRzLnN1YnN0cmluZygodGhpcy5jb3JyZWN0V29yZHMgKyB0aGlzLmlucHV0Qm94VGV4dCkubGVuZ3RoKVxyXG4gICAgfVxyXG4gIH0sICBcclxuICBtZXRob2RzOntcclxuICAgIHJldHJ5QnV0dG9uUHJlc3NlZCgpe1xyXG4gICAgICB0aGlzLnN0YXRlPWdhbWVTdGF0ZS5CZWZvcmVHYW1lU3RhcnQsXHJcbiAgICAgIHRoaXMuY2hvc2VuV29yZHM9XCJcIlxyXG4gICAgICB0aGlzLmlucHV0Qm94VGV4dD1cIlwiXHJcbiAgICAgIHRoaXMuY29ycmVjdFdvcmRzPVwiXCJcclxuICAgICAgdGhpcy5jb3VudERvd249NVxyXG4gICAgICB0aGlzLnN0YXJ0VGltZT1udWxsXHJcbiAgICAgIHRoaXMud3BtPW51bGxcclxuICAgIH0sXHJcbiAgICBzdGFydEJ1dHRvblByZXNzZWQoKXtcclxuICAgICAgdGhpcy5jaG9zZW5Xb3JkcyA9IHRoaXMuZ2VuZXJhdGVXb3JkTGlzdCgpLmpvaW4oXCIgXCIpO1xyXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuQ291bnREb3duO1xyXG4gICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgIHRoaXMuY291bnREb3duIC09IDE7XHJcbiAgICAgICAgaWYodGhpcy5jb3VudERvd24gPT0gMCl7XHJcblxyXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuVXNlclR5cGluZztcclxuICAgICAgICB9XHJcbiAgICAgIH0sMTAwMClcclxuICAgIH0sXHJcbiAgICBmaW5pc2hlZCgpe1xyXG4gICAgICB2YXIgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XHJcbiAgICAgIHZhciB0b3RhbFdvcmRzID0gdGhpcy5jaGFyYWN0ZXJDb3VudCAvIDU7XHJcbiAgICAgIHZhciB3cG1zID0gdG90YWxXb3Jkcy9kdXJhdGlvblxyXG4gICAgICB0aGlzLndwbSA9IHdwbXMqMTAwMCo2MFxyXG4gICAgICB0aGlzLnN0YXRlID10aGlzLmdhbWVTdGF0ZS5GaW5pc2hlZFBhcmFncmFwaDtcclxuXHJcbiAgICB9LFxyXG4gICAgb25JbnB1dChjaGFyYWN0ZXJzKXtcclxuICAgICAgaWYoY2hhcmFjdGVycy5lbmRzV2l0aChcIiBcIil8fCh0aGlzLmNvcnJlY3RXb3JkcyArIGNoYXJhY3RlcnMpLmxlbmd0aCA9PSB0aGlzLmNob3NlbldvcmRzLmxlbmd0aCl7XHJcbiAgICAgICAgaWYodGhpcy5jaG9zZW5Xb3Jkcy5zdGFydHNXaXRoKHRoaXMuY29ycmVjdFdvcmRzICsgY2hhcmFjdGVycykpe1xyXG4gICAgICAgICAgdGhpcy5jb3JyZWN0V29yZHMgKz0gY2hhcmFjdGVycztcclxuICAgICAgICAgIHRoaXMuaW5wdXRCb3hUZXh0ID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKHRoaXMuY29ycmVjdFdvcmRzID09IHRoaXMuY2hvc2VuV29yZHMpe1xyXG4gICAgICAgIHRoaXMuZmluaXNoZWQoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdlbmVyYXRlV29yZExpc3QoKXtcclxuICAgICAgdmFyIGxpc3QgPSBbXTtcclxuICAgICAgd2hpbGUobGlzdC5qb2luKCcgJykubGVuZ3RoICE9IHRoaXMuY2hhcmFjdGVyQ291bnQpe1xyXG4gICAgICAgIHdoaWxlKGxpc3Quam9pbignICcpLmxlbmd0aCA8IHRoaXMuY2hhcmFjdGVyQ291bnQpe1xyXG4gICAgICAgICAgdmFyIGNob3NlbldvcmQgPSB0aGlzLndvcmRzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGguZmxvb3IodGhpcy53b3Jkcy5sZW5ndGgpKV07XHJcbiAgICAgICAgICBpZihjaG9zZW5Xb3JkLmxlbmd0aCA8PSA4KXsgIFxyXG4gICAgICAgICAgICBsaXN0LnB1c2goY2hvc2VuV29yZClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobGlzdC5qb2luKCcgJykubGVuZ3RoID4gdGhpcy5jaGFyYWN0ZXJDb3VudCl7XHJcbiAgICAgICAgICBsaXN0LnBvcCgpO2xpc3QucG9wKCk7bGlzdC5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICB9LFxyXG4gICAgaW5wdXREaXNhYmxlcihlKXtcclxuICAgICAgaWYodGhpcy5zdGF0ZSAhPSB0aGlzLmdhbWVTdGF0ZS5Vc2VyVHlwaW5nKXtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOS0wIS4vU3BlZWRUeXBlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9TcGVlZFR5cGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vU3BlZWRUeXBlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTRlN2ZlOGFcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9TcGVlZFR5cGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9TcGVlZFR5cGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/VerbalMemory.vue?vue&type=template&id=bb9d6db2\n\nvar _hoisted_1 = {\n  "class": "reaction-game-wrapper"\n};\nvar _hoisted_2 = {\n  "class": "container noselect",\n  style: {\n    "transform": "translateY(100px)"\n  }\n};\nvar _hoisted_3 = {\n  key: 0\n};\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Verbal Memory", -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "You will be shown a sequence of words. You must answer if you have seen the word previously in the sequence.", -1\n/* HOISTED */\n);\n\nvar _hoisted_6 = {\n  key: 1\n};\nvar _hoisted_7 = {\n  "class": "header"\n};\nvar _hoisted_8 = {\n  "class": "font"\n};\nvar _hoisted_9 = {\n  key: 2\n};\n\nvar _hoisted_10 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "You ran out of lives", -1\n/* HOISTED */\n);\n\nvar _hoisted_11 = {\n  "class": "header"\n};\n\nvar _hoisted_12 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "wrapper"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_2, [$data.state == $data.gameState.BeforeGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_3, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        "class": "center game-icon-size",\n        style: {\n          "filter": "drop-shadow(2px 4px 6px black) brightness(10)"\n        },\n        src: _ctx.Icons.letter_icon,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_4, _hoisted_5, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[1] || (_cache[1] = function () {\n          return $options.startButtonPressed && $options.startButtonPressed.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Play")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.AfterGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_6, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_7, Object(vue_esm_bundler["l" /* toDisplayString */])($data.currentWord.charAt(0).toUpperCase() + $data.currentWord.slice(1)), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("p", _hoisted_8, "Lives: " + Object(vue_esm_bundler["l" /* toDisplayString */])($data.lives), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[2] || (_cache[2] = function () {\n          return $options.seenButtonPressed && $options.seenButtonPressed.apply($options, arguments);\n        }),\n        draggable: "false",\n        style: {\n          "margin-right": "10px"\n        }\n      }, "Seen"), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[3] || (_cache[3] = function () {\n          return $options.newButtonPressed && $options.newButtonPressed.apply($options, arguments);\n        }),\n        draggable: "false",\n        style: {\n          "margin-left": "10px"\n        }\n      }, "New")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.GameOver ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_9, [_hoisted_10, Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_11, "Round: " + Object(vue_esm_bundler["l" /* toDisplayString */])($data.round), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[4] || (_cache[4] = function () {\n          return $options.retryButtonPressed && $options.retryButtonPressed.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])]), _hoisted_12];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/VerbalMemory.vue?vue&type=template&id=bb9d6db2\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./src/words.js\nvar words = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/VerbalMemory.vue?vue&type=script&lang=js\n\n\nvar gameState = {\n  BeforeGameStart: 1,\n  AfterGameStart: 2,\n  GameOver: 3\n};\n/* harmony default export */ var VerbalMemoryvue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  },\n  mounted: function mounted() {},\n  data: function data() {\n    return {\n      gameState: gameState,\n      state: gameState.BeforeGameStart,\n      lives: 3,\n      round: 0,\n      seenWords: [],\n      unseenWords: words["a" /* default */],\n      currentWord: ""\n    };\n  },\n  computed: {},\n  methods: {\n    retryButtonPressed: function retryButtonPressed() {\n      this.state = this.gameState.BeforeGameStart;\n      this.lives = 3;\n      this.round = 0;\n      this.seenWords = [];\n      this.currentWord = "";\n    },\n    startButtonPressed: function startButtonPressed() {\n      this.state = this.gameState.AfterGameStart;\n      this.pickNewWord();\n    },\n    seenButtonPressed: function seenButtonPressed() {\n      if (this.seenWords.indexOf(this.currentWord) >= 0) {\n        this.round = this.round + 1;\n        this.pickNewWord();\n      } else {\n        this.seenWords.push(this.currentWord);\n        this.unseenWords.splice(this.unseenWords.indexOf(this.currentWord), 1);\n        this.lives = this.lives - 1; // Check if we are alive.\n\n        if (this.lives == 0) {\n          this.state = this.gameState.GameOver;\n        } else {\n          this.round = this.round + 1;\n          this.pickNewWord();\n        }\n      }\n    },\n    newButtonPressed: function newButtonPressed() {\n      if (this.seenWords.indexOf(this.currentWord) >= 0) {\n        this.lives = this.lives - 1;\n\n        if (this.lives == 0) {\n          this.state = this.gameState.GameOver;\n        } else {\n          this.round = this.round + 1;\n          this.pickNewWord();\n        }\n      } else {\n        this.seenWords.push(this.currentWord);\n        this.unseenWords.splice(this.unseenWords.indexOf(this.currentWord), 1);\n        this.round = this.round + 1;\n        this.pickNewWord();\n      }\n    },\n    pickNewWord: function pickNewWord() {\n      var shouldChooseSeenWord = Math.random() > .65 && this.round > 2;\n\n      if (shouldChooseSeenWord) {\n        var chosenWord = this.seenWords[Math.floor(Math.random() * this.seenWords.length)]; // We do not want to show the same word twice. In this case we will pick an unseen word instead to prevent this.\n\n        if (chosenWord != this.currentWord) {\n          //this.previousWord = this.currentWord\n          this.currentWord = chosenWord;\n        } else {\n          var chosenWord = this.unseenWords[Math.floor(Math.random() * this.unseenWords.length)]; // this.previousWord = this.currentWord\n\n          this.currentWord = chosenWord;\n        } //this.seenWords.splice(this.seenWords.indexOf(chosenWord), 1);\n\n      } else {\n        var chosenWord = this.unseenWords[Math.floor(Math.random() * this.unseenWords.length)]; //this.previousWord = this.currentWord\n\n        this.currentWord = chosenWord; //this.unseenWords.splice(this.unseenWords.indexOf(chosenWord), 1); \n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/VerbalMemory.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/VerbalMemory.vue\n\n\n\nVerbalMemoryvue_type_script_lang_js.render = render\n\n/* harmony default export */ var VerbalMemory = __webpack_exports__["default"] = (VerbalMemoryvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvVmVyYmFsTWVtb3J5LnZ1ZT8yNmVjIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9WZXJiYWxNZW1vcnkudnVlPzc4N2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1ZlcmJhbE1lbW9yeS52dWU/YzQzOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFYSxXQUFNOzs7QUFDSixXQUFNLG9CO0FBQXFCLE9BQXFDLEVBQXJDO0FBQUE7QUFBQTs7Ozs7OzhCQUc1QiwrQ0FBcUMsSUFBckMsRUFBcUM7QUFBakMsV0FBTTtBQUEyQixDQUFyQyxFQUFtQixlQUFuQixFQUFnQztBQUFBO0FBQWhDLEM7OzhCQUNBLCtDQUFnSSxHQUFoSSxFQUFnSTtBQUE3SCxXQUFNO0FBQXVILENBQWhJLEVBQWdCLDhHQUFoQixFQUE0SDtBQUFBO0FBQTVILEM7Ozs7OztBQUlJLFdBQU07OztBQUNQLFdBQU07Ozs7OzsrQkFLVCwrQ0FBNEMsSUFBNUMsRUFBNEM7QUFBeEMsV0FBTTtBQUFrQyxDQUE1QyxFQUFtQixzQkFBbkIsRUFBdUM7QUFBQTtBQUF2QyxDOzs7QUFDSSxXQUFNOzs7K0JBS2hCLCtDQUVNLEtBRk4sRUFFTTtBQUZELFdBQU07QUFFTCxDQUZOLEVBQW9CLElBQXBCLEVBQW9CO0FBQUE7QUFBcEIsQzs7Ozs7eURBdEJKLCtDQXlCYyxzQkF6QmQsRUF5QmMsSUF6QmQsRUF5QmM7MERBeEJWO0FBQUEsYUFvQk0sQ0FwQk4sK0NBb0JNLEtBcEJOLGNBb0JNLENBbkJKLCtDQWtCTSxLQWxCTixjQWtCTSxDQWpCTyxlQUFPLGdCQUFVLGUsb0RBQTVCLCtDQUtNLEtBTE4sRUFLTSxVQUxOLEVBS00sQ0FKSiwrQ0FBNkksS0FBN0ksRUFBNkk7QUFBeEksaUJBQU0sdUJBQWtJO0FBQTFHLGFBQThELEVBQTlEO0FBQUE7QUFBQSxTQUEwRztBQUExQyxXQUFHLEVBQUUsV0FBTSxXQUErQjtBQUFsQixpQkFBUyxFQUFD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WyI8dGVtcGxhdGU+XHJcbiAgICA8bWFpbi1sYXlvdXQ+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlYWN0aW9uLWdhbWUtd3JhcHBlclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz0nY29udGFpbmVyIG5vc2VsZWN0JyBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDBweCk7XCI+XHJcbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInN0YXRlPT1nYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgPGltZyBjbGFzcz0nY2VudGVyIGdhbWUtaWNvbi1zaXplJyBzdHlsZT1cImZpbHRlcjogZHJvcC1zaGFkb3coMnB4IDRweCA2cHggYmxhY2spIGJyaWdodG5lc3MoMTApO1wiIDpzcmM9J0ljb25zLmxldHRlcl9pY29uJyBkcmFnZ2FibGU9XCJmYWxzZVwiPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz1cImhlYWRlclwiPlZlcmJhbCBNZW1vcnk8L2gxPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVwiZm9udFwiPllvdSB3aWxsIGJlIHNob3duIGEgc2VxdWVuY2Ugb2Ygd29yZHMuIFlvdSBtdXN0IGFuc3dlciBpZiB5b3UgaGF2ZSBzZWVuIHRoZSB3b3JkIHByZXZpb3VzbHkgaW4gdGhlIHNlcXVlbmNlLjwvcD5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LW9uOmNsaWNrPVwic3RhcnRCdXR0b25QcmVzc2VkXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5QbGF5PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkFmdGVyR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPVwiaGVhZGVyXCI+e3tjdXJyZW50V29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGN1cnJlbnRXb3JkLnNsaWNlKDEpfX08L2gxPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVwiZm9udFwiPkxpdmVzOiB7e2xpdmVzfX08L3A+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImdhbWUtc3RhcnQtYnRuXCIgdi1vbjpjbGljaz1cInNlZW5CdXR0b25QcmVzc2VkXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDoxMHB4O1wiPlNlZW48L2Rpdj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LW9uOmNsaWNrPVwibmV3QnV0dG9uUHJlc3NlZFwiIGRyYWdnYWJsZT1cImZhbHNlXCIgc3R5bGU9XCJtYXJnaW4tbGVmdDoxMHB4O1wiPk5ldzwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj4gICBcclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwic3RhdGU9PWdhbWVTdGF0ZS5HYW1lT3ZlclwiPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz1cImhlYWRlclwiPllvdSByYW4gb3V0IG9mIGxpdmVzPC9oMT5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJoZWFkZXJcIj5Sb3VuZDoge3tyb3VuZH19PC9oMT5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LW9uOmNsaWNrPVwicmV0cnlCdXR0b25QcmVzc2VkXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5SZXRyeTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgIFxyXG4gICAgICAgICAgPC9kaXY+ICAgICAgICBcclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwid3JhcHBlclwiPlxyXG4gICAgICAgICAgICBcclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvbWFpbi1sYXlvdXQ+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBNYWluTGF5b3V0IGZyb20gJy4uL2xheW91dHMvTWFpbi52dWUnXHJcbmltcG9ydCBXb3JkcyBmcm9tICcuLi93b3Jkcy5qcydcclxuY29uc3QgZ2FtZVN0YXRlPXtcclxuICBCZWZvcmVHYW1lU3RhcnQ6MSxcclxuICBBZnRlckdhbWVTdGFydDoyLFxyXG4gIEdhbWVPdmVyOjNcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGNvbXBvbmVudHM6IHtcclxuICAgIE1haW5MYXlvdXRcclxuICB9LFxyXG4gIG1vdW50ZWQoKXtcclxuXHJcbiAgfSxcclxuICBkYXRhKCl7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnYW1lU3RhdGU6Z2FtZVN0YXRlLFxyXG4gICAgICBzdGF0ZTpnYW1lU3RhdGUuQmVmb3JlR2FtZVN0YXJ0LFxyXG4gICAgICBsaXZlczozLFxyXG4gICAgICByb3VuZDowLFxyXG4gICAgICBzZWVuV29yZHM6W10sXHJcbiAgICAgIHVuc2VlbldvcmRzOiBXb3JkcyxcclxuICAgICAgY3VycmVudFdvcmQ6XCJcIixcclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgfSwgIFxyXG4gIG1ldGhvZHM6e1xyXG4gICAgcmV0cnlCdXR0b25QcmVzc2VkKCl7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5CZWZvcmVHYW1lU3RhcnQ7XHJcbiAgICAgIHRoaXMubGl2ZXMgPSAzXHJcbiAgICAgIHRoaXMucm91bmQgPSAwO1xyXG4gICAgICB0aGlzLnNlZW5Xb3JkcyA9IFtdO1xyXG4gICAgICB0aGlzLiBjdXJyZW50V29yZCA9IFwiXCI7XHJcbiAgICB9LFxyXG4gICAgc3RhcnRCdXR0b25QcmVzc2VkKCl7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5BZnRlckdhbWVTdGFydDtcclxuICAgICAgdGhpcy5waWNrTmV3V29yZCgpO1xyXG4gICAgfSxcclxuICAgIHNlZW5CdXR0b25QcmVzc2VkKCl7XHJcblxyXG4gICAgICBpZih0aGlzLnNlZW5Xb3Jkcy5pbmRleE9mKHRoaXMuY3VycmVudFdvcmQpID49IDApe1xyXG4gICAgICAgIHRoaXMucm91bmQgPSB0aGlzLnJvdW5kICsgMTtcclxuICAgICAgICB0aGlzLnBpY2tOZXdXb3JkKCk7XHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMuc2VlbldvcmRzLnB1c2godGhpcy5jdXJyZW50V29yZCk7XHJcbiAgICAgICAgdGhpcy51bnNlZW5Xb3Jkcy5zcGxpY2UodGhpcy51bnNlZW5Xb3Jkcy5pbmRleE9mKHRoaXMuY3VycmVudFdvcmQpLCAxKTsgXHJcbiAgICAgICAgdGhpcy5saXZlcyA9IHRoaXMubGl2ZXMgLSAxO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgYWxpdmUuXHJcbiAgICAgICAgaWYodGhpcy5saXZlcyA9PSAwKXtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5HYW1lT3ZlclxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgdGhpcy5yb3VuZCA9IHRoaXMucm91bmQgKyAxO1xyXG4gICAgICAgICAgdGhpcy5waWNrTmV3V29yZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgIH0sXHJcbiAgICBuZXdCdXR0b25QcmVzc2VkKCl7XHJcbiAgICAgIGlmKHRoaXMuc2VlbldvcmRzLmluZGV4T2YodGhpcy5jdXJyZW50V29yZCkgPj0gMCl7XHJcbiAgICAgICAgdGhpcy5saXZlcyA9IHRoaXMubGl2ZXMgLSAxO1xyXG4gICAgICAgIGlmKHRoaXMubGl2ZXMgPT0gMCl7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5nYW1lU3RhdGUuR2FtZU92ZXJcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIHRoaXMucm91bmQgPSB0aGlzLnJvdW5kICsgMTtcclxuICAgICAgICAgIHRoaXMucGlja05ld1dvcmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMuc2VlbldvcmRzLnB1c2godGhpcy5jdXJyZW50V29yZCk7XHJcbiAgICAgICAgdGhpcy51bnNlZW5Xb3Jkcy5zcGxpY2UodGhpcy51bnNlZW5Xb3Jkcy5pbmRleE9mKHRoaXMuY3VycmVudFdvcmQpLCAxKTsgXHJcbiAgICAgICAgdGhpcy5yb3VuZCA9IHRoaXMucm91bmQgKyAxO1xyXG4gICAgICAgIHRoaXMucGlja05ld1dvcmQoKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuXHJcbiAgICB9LFxyXG4gICAgcGlja05ld1dvcmQoKXtcclxuICAgICAgdmFyIHNob3VsZENob29zZVNlZW5Xb3JkID0gTWF0aC5yYW5kb20oKSA+IC42NSAmJiB0aGlzLnJvdW5kID4gMjtcclxuICAgICAgaWYoc2hvdWxkQ2hvb3NlU2VlbldvcmQpe1xyXG4gICAgICAgIHZhciBjaG9zZW5Xb3JkID0gdGhpcy5zZWVuV29yZHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zZWVuV29yZHMubGVuZ3RoKV07XHJcbiAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gc2hvdyB0aGUgc2FtZSB3b3JkIHR3aWNlLiBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBwaWNrIGFuIHVuc2VlbiB3b3JkIGluc3RlYWQgdG8gcHJldmVudCB0aGlzLlxyXG4gICAgICAgIGlmKGNob3NlbldvcmQgIT0gdGhpcy5jdXJyZW50V29yZCl7XHJcbiAgICAgICAgICAvL3RoaXMucHJldmlvdXNXb3JkID0gdGhpcy5jdXJyZW50V29yZFxyXG4gICAgICAgICAgdGhpcy5jdXJyZW50V29yZCA9IGNob3NlbldvcmQ7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICB2YXIgY2hvc2VuV29yZCA9IHRoaXMudW5zZWVuV29yZHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy51bnNlZW5Xb3Jkcy5sZW5ndGgpXTtcclxuICAgICAgICAgLy8gdGhpcy5wcmV2aW91c1dvcmQgPSB0aGlzLmN1cnJlbnRXb3JkXHJcbiAgICAgICAgICB0aGlzLmN1cnJlbnRXb3JkID0gY2hvc2VuV29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy90aGlzLnNlZW5Xb3Jkcy5zcGxpY2UodGhpcy5zZWVuV29yZHMuaW5kZXhPZihjaG9zZW5Xb3JkKSwgMSk7XHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIHZhciBjaG9zZW5Xb3JkID0gdGhpcy51bnNlZW5Xb3Jkc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnVuc2VlbldvcmRzLmxlbmd0aCldO1xyXG4gICAgICAgIC8vdGhpcy5wcmV2aW91c1dvcmQgPSB0aGlzLmN1cnJlbnRXb3JkXHJcbiAgICAgICAgdGhpcy5jdXJyZW50V29yZCA9IGNob3NlbldvcmQ7XHJcbiAgICAgICAgLy90aGlzLnVuc2VlbldvcmRzLnNwbGljZSh0aGlzLnVuc2VlbldvcmRzLmluZGV4T2YoY2hvc2VuV29yZCksIDEpOyBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9WZXJiYWxNZW1vcnkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOS0wIS4vVmVyYmFsTWVtb3J5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vVmVyYmFsTWVtb3J5LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1iYjlkNmRiMlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1ZlcmJhbE1lbW9yeS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vVmVyYmFsTWVtb3J5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--9-0!./src/pages/VisualMemory.vue?vue&type=template&id=2ee00e1f\n\nvar _hoisted_1 = {\n  "class": "reaction-game-wrapper"\n};\nvar _hoisted_2 = {\n  "class": "container noselect",\n  style: {\n    "transform": "translateY(50px)"\n  }\n};\nvar _hoisted_3 = {\n  key: 0,\n  style: {\n    "transform": "translateY(50px)"\n  }\n};\n\nvar _hoisted_4 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("h1", {\n  "class": "header"\n}, "Visual Memory", -1\n/* HOISTED */\n);\n\nvar _hoisted_5 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("p", {\n  "class": "font"\n}, "Memorize and recreate the patterns shown", -1\n/* HOISTED */\n);\n\nvar _hoisted_6 = {\n  key: 1\n};\nvar _hoisted_7 = {\n  style: {\n    "max-width": "450px",\n    "margin-left": "auto",\n    "margin-right": "auto"\n  }\n};\nvar _hoisted_8 = {\n  "class": "visual-memory-container"\n};\nvar _hoisted_9 = {\n  "class": "title"\n};\nvar _hoisted_10 = {\n  key: 2\n};\nvar _hoisted_11 = {\n  "class": "header"\n};\n\nvar _hoisted_12 = /*#__PURE__*/Object(vue_esm_bundler["f" /* createVNode */])("div", {\n  "class": "wrapper"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _this = this;\n\n  var _component_main_layout = Object(vue_esm_bundler["k" /* resolveComponent */])("main-layout");\n\n  return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])(_component_main_layout, null, {\n    "default": Object(vue_esm_bundler["o" /* withCtx */])(function () {\n      return [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_1, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_2, [$data.state == $data.gameState.BeforeGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_3, [Object(vue_esm_bundler["f" /* createVNode */])("img", {\n        "class": "center game-icon-size",\n        style: {\n          "filter": "drop-shadow(2px 4px 6px black) brightness(10)"\n        },\n        src: _ctx.Icons.visual_grid_icon,\n        draggable: "false"\n      }, null, 8\n      /* PROPS */\n      , ["src"]), _hoisted_4, _hoisted_5, Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[1] || (_cache[1] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Play")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.AfterGameStart ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_6, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_7, [Object(vue_esm_bundler["f" /* createVNode */])("div", _hoisted_8, [(Object(vue_esm_bundler["h" /* openBlock */])(true), Object(vue_esm_bundler["c" /* createBlock */])(vue_esm_bundler["a" /* Fragment */], null, Object(vue_esm_bundler["i" /* renderList */])($data.gridData, function (square) {\n        return Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", {\n          "class": "square",\n          key: square.id,\n          style: {\n            width: 100 / Math.sqrt($data.gridData.length) + \'%\',\n            height: 100 / Math.sqrt($data.gridData.length) + \'%\',\n            top: 100 / Math.sqrt($data.gridData.length) * square.y + \'%\',\n            left: 100 / Math.sqrt($data.gridData.length) * square.x + \'%\'\n          }\n        }, [Object(vue_esm_bundler["f" /* createVNode */])("div", {\n          "class": "visual-button-style",\n          style: square.style,\n          onClick: function onClick($event) {\n            return $options.tileClicked(square);\n          }\n        }, null, 12\n        /* STYLE, PROPS */\n        , ["onClick"])], 4\n        /* STYLE */\n        );\n      }), 128\n      /* KEYED_FRAGMENT */\n      ))])]), Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_9, "Level: " + Object(vue_esm_bundler["l" /* toDisplayString */])(_this.level) + "      Lives: " + Object(vue_esm_bundler["l" /* toDisplayString */])(_this.totalLives), 1\n      /* TEXT */\n      )])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true), $data.state == $data.gameState.GameOver ? (Object(vue_esm_bundler["h" /* openBlock */])(), Object(vue_esm_bundler["c" /* createBlock */])("div", _hoisted_10, [Object(vue_esm_bundler["f" /* createVNode */])("h1", _hoisted_11, "You got to level " + Object(vue_esm_bundler["l" /* toDisplayString */])(_this.level), 1\n      /* TEXT */\n      ), Object(vue_esm_bundler["f" /* createVNode */])("div", {\n        "class": "game-start-btn",\n        onClick: _cache[2] || (_cache[2] = function () {\n          return $options.onStartButtonClick && $options.onStartButtonClick.apply($options, arguments);\n        }),\n        draggable: "false"\n      }, "Retry")])) : Object(vue_esm_bundler["d" /* createCommentVNode */])("v-if", true)])]), _hoisted_12];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n// CONCATENATED MODULE: ./src/pages/VisualMemory.vue?vue&type=template&id=2ee00e1f\n\n// EXTERNAL MODULE: ./src/layouts/Main.vue + 4 modules\nvar Main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/dist??ref--9-0!./src/pages/VisualMemory.vue?vue&type=script&lang=js\n\nvar gameState = {\n  BeforeGameStart: 1,\n  AfterGameStart: 2,\n  GameOver: 3\n};\nvar tileState = {\n  ShowingToUser: 1,\n  WaitingForUserToGuess: 2\n};\n/* harmony default export */ var VisualMemoryvue_type_script_lang_js = ({\n  components: {\n    MainLayout: Main["a" /* default */]\n  },\n  mounted: function mounted() {},\n  data: function data() {\n    return {\n      gameState: gameState,\n      state: gameState.BeforeGameStart,\n      tileState: tileState.ShowingToUser,\n      gridData: [],\n      level: 0,\n      tileCount: 3,\n      totalLives: 3,\n      roundLives: 3,\n      timeout1Ref: null,\n      timeout2Ref: null,\n      gridSizeLevels: [3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,, 8, 8, 8, 8]\n    };\n  },\n  computed: {},\n  methods: {\n    onStartButtonClick: function onStartButtonClick() {\n      this.tileState = tileState.ShowingToUser, this.level = 0;\n      this.tileCount = 3;\n      this.totalLives = 3;\n      this.roundLives = 3;\n      this.state = this.gameState.AfterGameStart;\n      this.gridData = this.nested(this.gridSizeLevels[this.level]);\n      this.renderRound();\n    },\n    isGameCompleted: function isGameCompleted() {\n      var won = true;\n\n      for (var i = 0; i < this.gridData.length; i++) {\n        var tile = this.gridData[i];\n\n        if (tile.isCorrect && !tile.isSelected) {\n          won = false;\n          break;\n        }\n      }\n\n      return won;\n    },\n    tileClicked: function tileClicked(tileObj) {\n      var _this = this;\n\n      if (this.tileState == tileState.WaitingForUserToGuess) {\n        if (tileObj.isCorrect) {\n          tileObj.isSelected = true;\n          tileObj.style["background-color"] = "white";\n          tileObj.style["animation"] = "transition-correct .3s";\n        } else {\n          this.roundLives = this.roundLives - 1;\n          tileObj.style["background-color"] = "#484848";\n          tileObj.style["animation"] = "transition-incorrect .3s";\n        }\n\n        if (this.roundLives == 0) {\n          this.tileState = tileState.ShowingToUser;\n          this.totalLives = this.totalLives - 1;\n          this.timeout2Ref = setTimeout(function () {\n            _this.renderRound();\n          }, 1000);\n        } else if (this.isGameCompleted()) {\n          this.tileCount = this.tileCount + 1;\n          this.level += 1;\n          this.tileState = tileState.ShowingToUser;\n          this.timeout1Ref = setTimeout(function () {\n            _this.renderRound();\n          }, 1000);\n        }\n\n        if (this.totalLives == 0) {\n          this.state = this.gameState.GameOver;\n          clearTimeout(this.timeout1Ref);\n          clearTimeout(this.timeout2Ref);\n        }\n      }\n    },\n    renderRound: function renderRound() {\n      var _this2 = this;\n\n      for (var i = 0; i < this.gridData.length; i++) {\n        var tile = this.gridData[i];\n\n        if (tile.style["background-color"] == "white") {\n          tile.style["animation"] = "transition-white-default .3s";\n          tile.style["background-color"] = "#662cf3";\n        } else if (tile.style["background-color"] == "#484848") {\n          tile.style["animation"] = "transition-black-default .3s";\n          tile.style["background-color"] = "#662cf3";\n        }\n      }\n\n      setTimeout(function () {\n        _this2.gridData = _this2.nested(_this2.gridSizeLevels[_this2.level]);\n        _this2.roundLives = 3;\n        var seenTiles = new Set();\n        _this2.tileState = tileState.ShowingToUser;\n\n        while (seenTiles.size < _this2.tileCount) {\n          var selectedTile = _this2.gridData[Math.floor(Math.random() * _this2.gridData.length)];\n\n          selectedTile.isCorrect = true;\n          selectedTile.style["background-color"] = "white";\n          selectedTile.style["animation"] = "transition-correct .3s";\n          seenTiles.add(selectedTile.id);\n        }\n\n        setTimeout(function () {\n          // set all tiles to purple\n          for (var _i = 0; _i < _this2.gridData.length; _i++) {\n            var _tile = _this2.gridData[_i];\n\n            if (_tile.isCorrect) {\n              _tile.style["animation"] = "transition-white-default .3s";\n              _tile.style["background-color"] = "#662cf3";\n            }\n          }\n\n          _this2.tileState = tileState.WaitingForUserToGuess;\n        }, 2000 + _this2.level * 400);\n      }, 2000);\n    },\n    nested: function nested(i) {\n      var result = [];\n\n      for (var y = 0; y < i; y++) {\n        for (var x = 0; x < i; x++) {\n          result.push({\n            isCorrect: false,\n            isSelected: false,\n            x: x,\n            y: y,\n            style: {\n              animation: "",\n              \'background-color\': "#662cf3"\n            },\n            id: x + "_" + y\n          });\n        }\n      }\n\n      return result;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/pages/VisualMemory.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/pages/VisualMemory.vue\n\n\n\nVisualMemoryvue_type_script_lang_js.render = render\n\n/* harmony default export */ var VisualMemory = __webpack_exports__["default"] = (VisualMemoryvue_type_script_lang_js);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvVmlzdWFsTWVtb3J5LnZ1ZT84ODkzIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9WaXN1YWxNZW1vcnkudnVlP2U4ZTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1Zpc3VhbE1lbW9yeS52dWU/MjY5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFYSxXQUFNOzs7QUFDSixXQUFNLG9CO0FBQXFCLE9BQW9DLEVBQXBDO0FBQUE7QUFBQTs7OztBQUNlLE9BQW9DLEVBQXBDO0FBQUE7QUFBQTs7OzhCQUUzQywrQ0FBcUMsSUFBckMsRUFBcUM7QUFBakMsV0FBTTtBQUEyQixDQUFyQyxFQUFtQixlQUFuQixFQUFnQztBQUFBO0FBQWhDLEM7OzhCQUNBLCtDQUE0RCxHQUE1RCxFQUE0RDtBQUF6RCxXQUFNO0FBQW1ELENBQTVELEVBQWdCLDBDQUFoQixFQUF3RDtBQUFBO0FBQXhELEM7Ozs7OztBQUtLLE9BQTJELEVBQTNEO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUNFLFdBQU07OztBQU9ULFdBQU07Ozs7OztBQUdOLFdBQU07OzsrQkFLaEIsK0NBRU0sS0FGTixFQUVNO0FBRkQsV0FBTTtBQUVMLENBRk4sRUFBb0IsSUFBcEIsRUFBb0I7QUFBQTtBQUFwQixDOzs7Ozs7O3lEQTNCSiwrQ0E4QmMsc0JBOUJkLEVBOEJjLElBOUJkLEVBOEJjOzBEQTdCVjtBQUFBLGFBeUJNLENBekJOLCtDQXlCTSxLQXpCTixjQXlCTSxDQXhCSiwrQ0F1Qk0sS0F2Qk4sY0F1Qk0sQ0F0Qk8sZUFBTyxnQkFBVSxlLG9EQUE1QiwrQ0FLTSxLQUxOLGNBS00sQ0FKSiwrQ0FBa0osS0FBbEosRUFBa0o7QUFBN0ksaUJBQU0sdUJBQXVJO0FBQS9HLGFBQThELEVBQTlEO0FBQUE7QUFBQSxTQUErRztBQUEvQyxXQUFHLEVBQUUsV0FBTSxnQkFBb0M7QUFBbEIsaUJBQVMsRUFBQztBQUFRLE9BQWxKLEUsSUFBQSxFOztB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QTtBQUVWLHNCQUFVLEVBQUMsS0FGRDtBQUdWLGFBQUMsRUFBQyxDQUhRO0FBSVYsYUFBQyxFQUFDLENBSlE7QUFLVixpQkFBSyxFQUFDO0FBQUMsdUJBQVMsRUFBQyxFQUFYO0FBQWMsa0NBQW1CO0FBQWpDLGFBTEk7QUFNVixjQUFFLEVBQUMsQ0FBQyxHQUFDLEdBQUYsR0FBTTtBQU5DLFdBQVo7QUFRRjtBQUNGOztBQUNBLGFBQU8sTUFBUDtBQUNGO0FBOUdNO0FBeEJLLENBQWYsRTs7QUMvQzBLLEM7O0FDQWpHO0FBQ1Y7QUFDTDtBQUMxRCxtQ0FBTSxVQUFVLE1BQU07O0FBRVAscUgiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8bWFpbi1sYXlvdXQ+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlYWN0aW9uLWdhbWUtd3JhcHBlclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz0nY29udGFpbmVyIG5vc2VsZWN0JyBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlWSg1MHB4KTtcIj5cclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwic3RhdGU9PWdhbWVTdGF0ZS5CZWZvcmVHYW1lU3RhcnRcIiBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlWSg1MHB4KTtcIj5cclxuICAgICAgICAgICAgICA8aW1nIGNsYXNzPSdjZW50ZXIgZ2FtZS1pY29uLXNpemUnIHN0eWxlPVwiZmlsdGVyOiBkcm9wLXNoYWRvdygycHggNHB4IDZweCBibGFjaykgYnJpZ2h0bmVzcygxMCk7XCIgOnNyYz1cIkljb25zLnZpc3VhbF9ncmlkX2ljb25cIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlxyXG4gICAgICAgICAgICAgIDxoMSBjbGFzcz0naGVhZGVyJz5WaXN1YWwgTWVtb3J5PC9oMT5cclxuICAgICAgICAgICAgICA8cCBjbGFzcz0nZm9udCc+TWVtb3JpemUgYW5kIHJlY3JlYXRlIHRoZSBwYXR0ZXJucyBzaG93bjwvcD5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ2FtZS1zdGFydC1idG5cIiB2LW9uOmNsaWNrPVwib25TdGFydEJ1dHRvbkNsaWNrXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj5QbGF5PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkFmdGVyR2FtZVN0YXJ0XCI+XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIm1heC13aWR0aDo0NTBweDttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvO1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZpc3VhbC1tZW1vcnktY29udGFpbmVyXCI+IFxyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNxdWFyZVwiIHYtZm9yPVwic3F1YXJlIGluIGdyaWREYXRhXCIgOmtleT1zcXVhcmUuaWQgOnN0eWxlPVwie3dpZHRoOigxMDAvTWF0aC5zcXJ0KGdyaWREYXRhLmxlbmd0aCkpKyclJywgaGVpZ2h0OigxMDAvTWF0aC5zcXJ0KGdyaWREYXRhLmxlbmd0aCkpKyclJyx0b3A6KDEwMC9NYXRoLnNxcnQoZ3JpZERhdGEubGVuZ3RoKSkqc3F1YXJlLnkrJyUnLGxlZnQ6KDEwMC9NYXRoLnNxcnQoZ3JpZERhdGEubGVuZ3RoKSkqc3F1YXJlLngrJyUnfVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2aXN1YWwtYnV0dG9uLXN0eWxlXCIgOnN0eWxlPVwic3F1YXJlLnN0eWxlXCIgdi1vbjpjbGljaz1cInRpbGVDbGlja2VkKHNxdWFyZSlcIiA+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PiAgXHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJ0aXRsZVwiPkxldmVsOiB7e3RoaXMubGV2ZWx9fSZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO0xpdmVzOiB7e3RoaXMudG90YWxMaXZlc319PC9oMT5cclxuICAgICAgICAgICAgPC9kaXY+IFxyXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzdGF0ZT09Z2FtZVN0YXRlLkdhbWVPdmVyXCI+XHJcbiAgICAgICAgICAgICAgPGgxIGNsYXNzPSdoZWFkZXInPllvdSBnb3QgdG8gbGV2ZWwge3t0aGlzLmxldmVsfX08L2gxPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnYW1lLXN0YXJ0LWJ0blwiIHYtb246Y2xpY2s9XCJvblN0YXJ0QnV0dG9uQ2xpY2tcIiBkcmFnZ2FibGU9XCJmYWxzZVwiPlJldHJ5PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PiAgICAgXHJcbiAgICAgICAgICA8L2Rpdj4gICAgICAgIFxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyXCI+XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9tYWluLWxheW91dD5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1haW5MYXlvdXQgZnJvbSAnLi4vbGF5b3V0cy9NYWluLnZ1ZSdcclxuXHJcbmNvbnN0IGdhbWVTdGF0ZT17XHJcbiAgQmVmb3JlR2FtZVN0YXJ0OjEsXHJcbiAgQWZ0ZXJHYW1lU3RhcnQ6MixcclxuICBHYW1lT3ZlcjozXHJcbn1cclxuXHJcbmNvbnN0IHRpbGVTdGF0ZT17XHJcbiAgU2hvd2luZ1RvVXNlcjoxLFxyXG4gIFdhaXRpbmdGb3JVc2VyVG9HdWVzczoyXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICBNYWluTGF5b3V0XHJcbiAgfSxcclxuICBtb3VudGVkKCl7XHJcblxyXG4gIH0sXHJcbiAgZGF0YSgpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2FtZVN0YXRlOmdhbWVTdGF0ZSxcclxuICAgICAgc3RhdGU6Z2FtZVN0YXRlLkJlZm9yZUdhbWVTdGFydCxcclxuICAgICAgdGlsZVN0YXRlOnRpbGVTdGF0ZS5TaG93aW5nVG9Vc2VyLFxyXG4gICAgICBncmlkRGF0YTpbXSxcclxuICAgICAgbGV2ZWw6MCxcclxuICAgICAgdGlsZUNvdW50OjMsXHJcbiAgICAgIHRvdGFsTGl2ZXM6MyxcclxuICAgICAgcm91bmRMaXZlczozLFxyXG4gICAgICB0aW1lb3V0MVJlZjpudWxsLFxyXG4gICAgICB0aW1lb3V0MlJlZjpudWxsLFxyXG4gICAgICBncmlkU2l6ZUxldmVsczpbMyw0LDQsNCw1LDUsNSw1LDUsNSw1LDUsNSw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw4LDgsOCw4LDgsOCw4LDgsOCw4LDgsOCw4LDgsOCw4LDgsOCw4LDgsOCw4LDgsOCw4LDgsOCw4LDgsOCw4LDgsOCw4LCw4LDgsOCw4XVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICB9LCAgXHJcbiAgbWV0aG9kczp7XHJcbiAgICBvblN0YXJ0QnV0dG9uQ2xpY2soKXtcclxuICAgICAgdGhpcy50aWxlU3RhdGU9dGlsZVN0YXRlLlNob3dpbmdUb1VzZXIsXHJcbiAgICAgIHRoaXMubGV2ZWw9MFxyXG4gICAgICB0aGlzLnRpbGVDb3VudD0zXHJcbiAgICAgIHRoaXMudG90YWxMaXZlcz0zXHJcbiAgICAgIHRoaXMucm91bmRMaXZlcz0zXHJcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5BZnRlckdhbWVTdGFydDtcclxuICAgICAgdGhpcy5ncmlkRGF0YSA9IHRoaXMubmVzdGVkKHRoaXMuZ3JpZFNpemVMZXZlbHNbdGhpcy5sZXZlbF0pXHJcbiAgICAgIHRoaXMucmVuZGVyUm91bmQoKVxyXG4gICAgfSxcclxuICAgIGlzR2FtZUNvbXBsZXRlZCgpe1xyXG4gICAgICB2YXIgd29uID0gdHJ1ZTtcclxuICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmdyaWREYXRhLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIGxldCB0aWxlID0gdGhpcy5ncmlkRGF0YVtpXTtcclxuICAgICAgICBpZih0aWxlLmlzQ29ycmVjdCAmJiAhdGlsZS5pc1NlbGVjdGVkKXtcclxuICAgICAgICAgIHdvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB3b247XHJcbiAgICB9LFxyXG4gICAgdGlsZUNsaWNrZWQodGlsZU9iail7XHJcbiAgICAgIGlmKHRoaXMudGlsZVN0YXRlID09IHRpbGVTdGF0ZS5XYWl0aW5nRm9yVXNlclRvR3Vlc3Mpe1xyXG4gICAgICAgIGlmKHRpbGVPYmouaXNDb3JyZWN0KXtcclxuICAgICAgICAgIHRpbGVPYmouaXNTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICB0aWxlT2JqLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9XCJ3aGl0ZVwiO1xyXG4gICAgICAgICAgdGlsZU9iai5zdHlsZVtcImFuaW1hdGlvblwiXSA9XCJ0cmFuc2l0aW9uLWNvcnJlY3QgLjNzXCI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICB0aGlzLnJvdW5kTGl2ZXMgPSB0aGlzLnJvdW5kTGl2ZXMgLSAxO1xyXG4gICAgICAgICAgdGlsZU9iai5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPVwiIzQ4NDg0OFwiO1xyXG4gICAgICAgICAgdGlsZU9iai5zdHlsZVtcImFuaW1hdGlvblwiXSA9XCJ0cmFuc2l0aW9uLWluY29ycmVjdCAuM3NcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMucm91bmRMaXZlcyA9PSAwKXtcclxuICAgICAgICAgIHRoaXMudGlsZVN0YXRlID0gdGlsZVN0YXRlLlNob3dpbmdUb1VzZXJcclxuICAgICAgICAgIHRoaXMudG90YWxMaXZlcyA9IHRoaXMudG90YWxMaXZlcyAtIDFcclxuICAgICAgICAgIHRoaXMudGltZW91dDJSZWYgPSBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUm91bmQoKTtcclxuICAgICAgICAgIH0sMTAwMClcclxuICAgICAgICAgIFxyXG4gICAgICAgIH1lbHNlIGlmKHRoaXMuaXNHYW1lQ29tcGxldGVkKCkpe1xyXG4gICAgICAgICAgdGhpcy50aWxlQ291bnQgPSB0aGlzLnRpbGVDb3VudCArIDFcclxuICAgICAgICAgIHRoaXMubGV2ZWwgKz0gMTtcclxuICAgICAgICAgIHRoaXMudGlsZVN0YXRlID0gdGlsZVN0YXRlLlNob3dpbmdUb1VzZXJcclxuICAgICAgICAgIHRoaXMudGltZW91dDFSZWYgPSBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUm91bmQoKTtcclxuICAgICAgICAgIH0sMTAwMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMudG90YWxMaXZlcyA9PSAwKXtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdhbWVTdGF0ZS5HYW1lT3ZlclxyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dDFSZWYpXHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0MlJlZilcclxuICAgICAgICB9XHJcbiAgICAgIH0gXHJcbiAgICB9LFxyXG4gICAgcmVuZGVyUm91bmQoKXtcclxuICAgICAgXHJcbiAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5ncmlkRGF0YS5sZW5ndGg7aSsrKXtcclxuICAgICAgICBsZXQgdGlsZSA9IHRoaXMuZ3JpZERhdGFbaV07XHJcblxyXG4gICAgICAgIGlmKHRpbGUuc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID09IFwid2hpdGVcIil7XHJcbiAgICAgICAgICB0aWxlLnN0eWxlW1wiYW5pbWF0aW9uXCJdID1cInRyYW5zaXRpb24td2hpdGUtZGVmYXVsdCAuM3NcIjtcclxuICAgICAgICAgIHRpbGUuc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID1cIiM2NjJjZjNcIjtcclxuICAgICAgICB9ZWxzZSBpZih0aWxlLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9PSBcIiM0ODQ4NDhcIil7XHJcbiAgICAgICAgICB0aWxlLnN0eWxlW1wiYW5pbWF0aW9uXCJdID1cInRyYW5zaXRpb24tYmxhY2stZGVmYXVsdCAuM3NcIjtcclxuICAgICAgICAgIHRpbGUuc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID1cIiM2NjJjZjNcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgIHRoaXMuZ3JpZERhdGEgPSB0aGlzLm5lc3RlZCh0aGlzLmdyaWRTaXplTGV2ZWxzW3RoaXMubGV2ZWxdKVxyXG4gICAgICAgIHRoaXMucm91bmRMaXZlcyA9IDM7XHJcbiAgICAgICAgdmFyIHNlZW5UaWxlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnRpbGVTdGF0ZSA9IHRpbGVTdGF0ZS5TaG93aW5nVG9Vc2VyO1xyXG4gICAgICAgIHdoaWxlKHNlZW5UaWxlcy5zaXplIDwgdGhpcy50aWxlQ291bnQpe1xyXG4gICAgICAgICAgdmFyIHNlbGVjdGVkVGlsZSA9IHRoaXMuZ3JpZERhdGFbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnRoaXMuZ3JpZERhdGEubGVuZ3RoKV07XHJcbiAgICAgICAgICBzZWxlY3RlZFRpbGUuaXNDb3JyZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgIHNlbGVjdGVkVGlsZS5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPVwid2hpdGVcIjtcclxuICAgICAgICAgIHNlbGVjdGVkVGlsZS5zdHlsZVtcImFuaW1hdGlvblwiXSA9XCJ0cmFuc2l0aW9uLWNvcnJlY3QgLjNzXCI7XHJcbiAgICAgICAgICBzZWVuVGlsZXMuYWRkKHNlbGVjdGVkVGlsZS5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgLy8gc2V0IGFsbCB0aWxlcyB0byBwdXJwbGVcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmdyaWREYXRhLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy5ncmlkRGF0YVtpXTtcclxuICAgICAgICAgICAgICBpZih0aWxlLmlzQ29ycmVjdCl7XHJcbiAgICAgICAgICAgICAgICB0aWxlLnN0eWxlW1wiYW5pbWF0aW9uXCJdID1cInRyYW5zaXRpb24td2hpdGUtZGVmYXVsdCAuM3NcIjtcclxuICAgICAgICAgICAgICAgIHRpbGUuc3R5bGVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID1cIiM2NjJjZjNcIjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50aWxlU3RhdGUgPSB0aWxlU3RhdGUuV2FpdGluZ0ZvclVzZXJUb0d1ZXNzOyAgICAgICAgICBcclxuICAgICAgICB9LCAyMDAwICsgKHRoaXMubGV2ZWwqNDAwKSlcclxuICAgICAgfSwyMDAwKTtcclxuICAgIH0sXHJcbiAgICBuZXN0ZWQoaSl7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXVxyXG4gICAgICBmb3IodmFyIHkgPSAwO3k8aTt5Kyspe1xyXG4gICAgICAgIGZvcih2YXIgeCA9IDA7eDxpO3grKyl7XHJcbiAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgIGlzQ29ycmVjdDpmYWxzZSxcclxuICAgICAgICAgICAgaXNTZWxlY3RlZDpmYWxzZSxcclxuICAgICAgICAgICAgeDp4LFxyXG4gICAgICAgICAgICB5OnksXHJcbiAgICAgICAgICAgIHN0eWxlOnthbmltYXRpb246XCJcIiwnYmFja2dyb3VuZC1jb2xvcic6XCIjNjYyY2YzXCJ9LFxyXG4gICAgICAgICAgICBpZDp4K1wiX1wiK3lcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cmVmLS05LTAhLi9WaXN1YWxNZW1vcnkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3JlZi0tOS0wIS4vVmlzdWFsTWVtb3J5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vVmlzdWFsTWVtb3J5LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yZWUwMGUxZlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1Zpc3VhbE1lbW9yeS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vVmlzdWFsTWVtb3J5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 5 modules\nvar vue_esm_bundler = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./src/routes.js\nvar routes = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./src/icons.js\n/* harmony default export */ var icons = ({\n  cursor_icon: "data:image/png;base64,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",\n  type_icon: "data:image/png;base64,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",\n  hearing_icon: "data:image/png;base64,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",\n  letter_icon: "data:image/png;base64,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",\n  logo: "data:image/png;base64,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",\n  math_icon: "data:image/png;base64,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",\n  number_icon: "data:image/png;base64,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",\n  trace_icon: "data:image/png;base64,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",\n  visual_grid_icon: "data:image/png;base64,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"\n});\n/** TODO: Replace these with SVG images. Can compress this down to a few KB instead of 70. **/\n// CONCATENATED MODULE: ./src/main.js\n\n\n\nvar SimpleRouterApp = {\n  data: function data() {\n    return {\n      currentRoute: window.location.pathname\n    };\n  },\n  computed: {\n    ViewComponent: function ViewComponent() {\n      var matchingPage = routes["a" /* default */][this.currentRoute] || \'404\';\n      return __webpack_require__(7)("./".concat(matchingPage, ".vue"))["default"];\n    }\n  },\n  render: function render() {\n    return Object(vue_esm_bundler["g" /* h */])(this.ViewComponent);\n  },\n  created: function created() {\n    var _this = this;\n\n    window.addEventListener(\'popstate\', function () {\n      _this.currentRoute = window.location.pathname;\n    });\n  }\n};\nvar app = Object(vue_esm_bundler["b" /* createApp */])(SimpleRouterApp);\napp.config.globalProperties.Icons = icons;\napp.mount(\'#app\');\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaWNvbnMuanM/Yjc1ZiIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbImN1cnNvcl9pY29uIiwidHlwZV9pY29uIiwiaGVhcmluZ19pY29uIiwibGV0dGVyX2ljb24iLCJsb2dvIiwibWF0aF9pY29uIiwibnVtYmVyX2ljb24iLCJ0cmFjZV9pY29uIiwidmlzdWFsX2dyaWRfaWNvbiIsIlNpbXBsZVJvdXRlckFwcCIsImRhdGEiLCJjdXJyZW50Um91dGUiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiY29tcHV0ZWQiLCJWaWV3Q29tcG9uZW50IiwibWF0Y2hpbmdQYWdlIiwicm91dGVzIiwicmVxdWlyZSIsInJlbmRlciIsImgiLCJjcmVhdGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFwcCIsImNyZWF0ZUFwcCIsImNvbmZpZyIsImdsb2JhbFByb3BlcnRpZXMiLCJJY29ucyIsIm1vdW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWU7QUFDWEEsYUFBVyxFQUFDLHd4UEFERDtBQUVYQyxXQUFTLEVBQUMsNCtRQUZDO0FBR1hDLGNBQVksRUFBQyw0aVhBSEY7QUFJWEMsYUFBVyxFQUFDLHc5UUFKRDtBQUtYQyxNQUFJLEVBQUMsZ29YQUxNO0FBTVhDLFdBQVMsRUFBQyx3aU9BTkM7QUFPWEMsYUFBVyxFQUFDLHdrUUFQRDtBQVFYQyxZQUFVLEVBQUMsd29TQVJBO0FBU1hDLGtCQUFnQixFQUFDO0FBVE4sQ0FBZjtBQVdBLDhGOztBQ1hBO0FBQ0E7QUFDQTtBQUNBLElBQU1DLGVBQWUsR0FBRztBQUN0QkMsTUFBSSxFQUFFO0FBQUEsV0FBTztBQUNYQyxrQkFBWSxFQUFFQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDO0FBRG5CLEtBQVA7QUFBQSxHQURnQjtBQUt0QkMsVUFBUSxFQUFFO0FBQ1JDLGlCQURRLDJCQUNTO0FBQ2YsVUFBTUMsWUFBWSxHQUFHQyx5QkFBTSxDQUFDLEtBQUtQLFlBQU4sQ0FBTixJQUE2QixLQUFsRDtBQUNBLGFBQU9RLHVCQUFRLFlBQVdGLFlBQVosVUFBUCxXQUFQO0FBQ0Q7QUFKTyxHQUxZO0FBWXRCRyxRQVpzQixvQkFZWjtBQUNSLFdBQU9DLG9DQUFDLENBQUMsS0FBS0wsYUFBTixDQUFSO0FBQ0QsR0FkcUI7QUFnQnRCTSxTQWhCc0IscUJBZ0JYO0FBQUE7O0FBQ1RWLFVBQU0sQ0FBQ1csZ0JBQVAsQ0FBd0IsVUFBeEIsRUFBb0MsWUFBTTtBQUN4QyxXQUFJLENBQUNaLFlBQUwsR0FBb0JDLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsUUFBcEM7QUFDRCxLQUZEO0FBR0Q7QUFwQnFCLENBQXhCO0FBeUJBLElBQUlVLEdBQUcsR0FBR0MsNENBQVMsQ0FBQ2hCLGVBQUQsQ0FBbkI7QUFDQWUsR0FBRyxDQUFDRSxNQUFKLENBQVdDLGdCQUFYLENBQTRCQyxLQUE1QixHQUFvQ0EsS0FBcEM7QUFDQUosR0FBRyxDQUFDSyxLQUFKLENBQVUsTUFBViIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcbiAgICBjdXJzb3JfaWNvbjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBWkFBQUFHUUNBTUFBQUMzWWNiK0FBQUFkVkJNVkVWSGNFdzRPMUUzUEU4NFBGQTdQMVU0UEZBNFBGQTFQRkU0TzFBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNVBWQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTNQRkE0UEZBNFBGQTRQRkE0UEZDMnNPdnNBQUFBSm5SU1RsTUFDQXp5QS96M0dLRFZ3NzAzcmVJUzZENkpjKzdjUlNQUUtWekpUWDlWSHJhU01HcGptWkRpZTRBQUFCWlVTVVJCVkJnWjdjQ0plcHZJdGdYZ0JWUUJZcDRub1hGWTcvK0k5MzdKNmU3WXNSTmIxRVpnNjhlNktLVXN5N1p0Nzl3TTVja1B0OTJtcnBPc2NyVjJuU3BKNmsyM0RmMmlISnF6Wjl1MlpTbWw4Q1JBMmFsM2FQdG1LRS94dG5iNEFVNjlqVS9sMEp6Ymc1ZmFDaytHV09uaG5PL0wyN0hMTk8vZ1p0M1IzKzN6YzVzcVBFMlQ5dm4rVXNUYmpGUHBhaHNYbDMzZXAzaTZpMHJQKy9KMDNGUTBLT3VPcDNJOHB3cFBuNkc4ZkNqaW9IWXB3SzNEZURkRUhwNCtxQjlPWVplNEZPUWtYVmdNdllXbnY3RHpNcTR6bHpOd3NrMWNSaGFlM21XUHA4NXhOV2VqM1dwYmpEYWVmcWVzOFpid0laSlRZeXM4L1VmWlhsTjBmQnkzSzNMUHh0TVBkdHNVZ2NzSGM4SmQxTnA0T3VTN1k4WkZ5STVsN2lsOFovWjU4RGRjRHJmenIyY0wzMVhhRkdIR2hjbkNZdlR3SGJWWGYrTndnWnhOV0o3eDNVUzdMbk81VkZsWFJCYStENnZ4TTVlTDVpWitZK043U0lmUTVScUVlNFV2ejJyTGpxdXhMVk1MWDVuZGxsdXVpZDVlV2h0ZmxkMlhJZGZHT1Y1N0MxK1IxVitPTGxjb2k2OHR2cDdESmM2NFVzbHg4UEMxV1BzNDBWeXY1RGphK0VMeVcrSnkxWFI5aS9CVnRFWG1jdlhjemU2QXJ5QzlKdndhOUhhd3NYWjJjM1Q1ZGNTUmhUV3p6a1hDTHlYYkhTeXNscmNQK09XRWc0ZDFzbk0vNHhlVW5TSWJLOVNXVzM1TmJsQWVzRGIyR0ZmOHNqSy9zYkFxaDkzRzVSZm0xcVhDZXFoejdQQ0xxL3dlYTZHR2plYVhwNU05MXNFdStEMVVPdy9MWnpjaHZ3czN6aTBzbkZjbS9FYTZxNmV3WUtvdktuNHJTZEVyTEpiVnhBNi9HU2ZPc1ZUMnNIWDUvV3ozQ290a2xUVy9wYnIwc0VCV1VmR2JxdndlaTlQR0xyOHJyY01JeTZMeWp0OWExeWdzaUQway9PYnF3Y1ppcEdYQ2I2L2FIYkFRWHBIeGliejFXQUxWM2h3K2tlUXh4d0tjajVwUFB3VjdQTng1eTZkLzZHNlBCNHMyZlByRlpzQkQ1VFdmZnFXVFBSNm9xZm4wU2pYaVVheHh3NmZmT0tQQ1E5aGp4NmMzdUNNZXdkNTNmSHFUM21OKzF0ang2UjE2d096R2prL3Z5Z2JNck5udzZRL3FBYlBLYXo3OWllNUd6Q2lxK2ZSbmV0dGdOdWNObi80cU9HTW01eTJmUHVEWVl4YUhtRThmNG51WWdYZlNmUHFZd29ZNHU2ejQ5RkU3QzhMc29lYlRoN2tYQlZGcTNQRHBFNUk5UkVVMW56NURkeU1FdFZzK2ZZN2VOaEJqeFh6NnRPTVpRcXpDNWRPbjZac0hFWFpaOGVrTzJjV0dBR3VvK1hTWHpXakJPTlZzK1hTbklGSXdyWTlkaXNqODVZaHJ5b2dQTU13ckhNclllY3R4MkZHR2U3SmdsRjFXbExGTnNTRG5nREtxQzR4cUVnb1pzU1RXeGFHTUpJZEJka2doc1kxRmFXUEswS0VIWTFSQklkVVpDek1rbE9Ic0ZBeFJBNFhvSXNYQ3BMNm1qR1JRTU9POG9aRHRHWXZUYkNna2lHREVJZGFVVVpVMkZrZWRYTXB3VGg0TXNIY09oUng3TEZEZlVVaHlzVEhkdUtHUTVLcXdSQmROSWR0Y1lhbzJkaWxEK3lrV0tRMHB4TDJsbU1ndUt3cXBSeXhVVGluT29EQk52cVVROTZTd1VPcEdLVnNQazNnK3BkUTlGaXV0S09XRUtheDlSaUZ1aWVXeVNrMHBJeVk0QjVTeVNiRmdoNEJTdGg3dVpoZVU0bzVZTW11b0tFUVhOdTdWSkpRU1k5a09QcVVrSSs2VUhpbWxQbVBaMUZoVGlCdDd1TS9WcFpTZHdzS2xoVXNoMlJWM2FSTktDWG9zWHI2bEVIM3NjWStDWWdhRnhWTTdoMEtxVXVIejhveFM0Z05Xb04xU1NoRGgwNnliU3lISmlGVzRWQlNpaXhTZnRVOG94RDE1V0FVNzFCVFNOUXFmYzRoZEN1a2FyRVNUVWNyTnc2ZFlsNFJDbk1MR1d0d29KV2tVUHFPUE5ZVUVQVmFqclNuRnQvRUo5aVdqa0tyRWlsd29wUnJ4Q2YyUlF2UXh4WXFrSWFVYzhYRjI2VktJTTJKVmNrcHhCM3hZRzFLS3I3QXE2WTFTT2dzZlpKV1U0aDZ3TWxGTklickVCN1ZiQ3RFbDFpYmR1UlRTSGZBeEphVjBDcXR6RGlqRUxSVStJdTBvcE5vcnJJNVZWaFFTdFBpSWdWTDhGQ3ZVeHBveXNncyt3QW9wcEc0VTFtaElLRVBIQi94ZDQxSklrV0tWVXQrbGpIcVB2L01wWkJ0aHBmS0VNclR2NFcraWpETGNFbXVsVGk1bGRBMytadWRTeHJISGFua1poUlFwL3F6dEtDTzVZc1V1bWpLMkVmN3NtbEdFRzN0WXN5MWx1QmNiZjVMNkxrVWtEVll0cnlqamVNQ2ZOQnVLY0c4V1ZrMmRLQ01iRmQ1bkZ3NUYxRDFXN3J5aGpKT045NTFEeWlpeGR0YUZNdW9XN3hzeWl0amFXTDArcEFoOXdic09QbVhrK0FMMkRrVUVDdS9KTnhUaDR5czQrSlRSNEIzMmppS3FBNzZFc2FZSUgrOW9qNVRnN214OENlbkpwWVRxZ0RlcEpxT0VvTVZFY1lSRnlEdUt1T0pOZGtFSjFkWENSQXdqTElIYU9aUVFLN3pGQ3lnaGJqRVZHZVJZZ2piUUZKQzBlRXZqVWtDOVY1aUsxRUdPSmJoV0ZPQmM4UVpWVUlBKzJaaU1wQTV5TElCOXBBRHQ0dzFXUndGZGcrbElVZ2M1RmlEU0ZMRHA4YnVSQXB3Q0J2Q0hJTUlDbkNnZ0cvQzdHd1ZzZXhqQW44Skk0ZUZVUmZQY2s4SnJka0x6bkF0TTRQK0VrY0xEWFZ5YUYvUjRiYVNBMElZSi9FY1k0ZUhTa09iVkkxNDcwVHluZ1JIOFZ4amgwZFNZMFRobnAvQ1MzZEU4SDJid1AwR09SL05PTkM4KzRLWGNvWEZKQ3pQNGl5REhnNmxtUStPMk9WNHFYUnAzZ1NIOGhRNXlQSmkxMHpRdEcvQlNyR2xhNk1FUS9rb0hPUjRzQ21pYVBxWDRWVi9UdUViQkVMNFVSSGl3c3FKcHh4Ni9HakthNW5zd2hhK0VrY0pESFk2YWh0VU5mcUZPTGcxTGNoakQxOEpJNGFHR2hJYnAwc0ovdkpDR3VVVUtZL2liTU1KRDJiR21ZYjZILytRZERRc2ltTVBmaFJFZUtrcG9XTkRqUDllRVpsV2xEWFA0aGlESFF4V2FabVU1L3FVS2wyWWRXeGpFdHdRNUh1bXdvVm42YXVFZlhreXprcXVDUVh5TERuSTgwa0REVGluK0VRVTBTc2MyVE9LYmRKRGpnYXdqelFvOC9HTmYwNmdzaDFGOG13NGlQRkJQczZvVy95aGRtcVJ2TUl2dkNTT0ZoN0ZPTkd0VStDbTkwYWprQUxQNHJqQlNlSmkycGxHRndrLzlrVVpkWUJqZnBjTUlEMk9YRGswS0xmeVViMmpTRnFieEQ4SUlEOU1mYVZKbTQ2ZDlSWU9xQnFieFQ0SWNqMkpkTTVyVTR3ZnJRcE5PRmt6akh3VTVIc1h6YWRJZVA2UUZEZHFjWVJ6L1NBYzVIa1NOTlEwcThNTWhwa0dsRGVQNFp6ckk4U0QyeWFVNUlYNDRiMmxPMk1NOC9vVU9JanhJMU5HY0NqL2tHWTF4QndqZ1h3VVJIbVRuMEp3REFLZzl6ZkZiQ09EZmhaSENRM2dkelJrQndDNXBUTDJIQkg1QUdDazh4T0RTbUIwQXBEZWE0dDVTU09CSGhCRWVJNlF4TVFCNFI1clM1UkRCRHdralBFUlUwWlFPQUE0ZERYRUtDeUw0TVVHT2h5aG9TbVlEYURNYTBoMGdneCtqZ3h5UGNPaG9TTlVENkRYTmNLOFF3Zy9TUVk0SFVBTU5jUnBBTlRRa3RDQ0VINldESEEvZ3hUVER2UUpxb0NGblNPSEhCUkhtcDNLWFJyZ0ZvRXFhY1lJWWZrSVlLY3pPTzJtYW9IM0FPdEdJSklVWWZrWVlZWDc1aGtZRUNsWk1FOXlMZ2hoK1NoaGhkdW5Pb1FtYkZQYVdKb1FlNVBCendnaXpPNGMwb2U1aDF6UWcyeXZJNFNjRk9lYW15b3dHSkJGc2h3YmNQQWppWndVNTV1WWROYWRMR25nMFlOTW9DT0puNlNESDNQWVpwOHYyT05PQW5RVkovRFFkNUppWmlqVW55NjVvT0YwUVFSVHZFRVNZV1Y5eHNxckV3TW1jRXJKNGp6QlNtRmZCeVp3ZFNrNmxqeTFrOFM1aHBEQXJLK0ZVVG9FVHA4b0dDT05kZEJoaFhudVhFN2szK0p4SXh6YUU4VTVoaEZtcG1CTnBIeUVueWlKSTQ3MkNITFBLRTA0VVk4dUpDb2pqM1lJY2M3SUxUblJFeDJscUQrSjROeDNrbU5ONXkybU8ySENhQWZKNFB4M2ttSkYxNFRRaGFrNXlWSkRIS1lJSU0rcVBuQ1JFelNuY00yYkFTY0lJTXhveVRoRWk0UVQ2WkdNR25DYU1GR1p6OERVbkNKRnhndnFNT1hDaU1NSjh4ZzBuQ0ZEeGZrNXBZdzZjS293d0cvdms4bjRCWE43djJHTVduQ3pJTVp2emh2Y0xvSG0zN0dwaEZwd3V5REdibmN1N2JhRjV0K3FLZVhBNkhlU1lTK253YmdGYzNpOXVNUXNhb0lNYzgyaTN2RjhBaC9mVFY0VTUwQVFkUkpoRjRmQitBU3BPc08weEJ4cWhqMmZNSU84NFFZQ0VVK3hzeklBR09FazhlSkJuM3poRmlJUlRKR2ZNZ0pObFhkR2ttSUhhMTV3aVJNMUpZZ1Y1bk1hdHcwdWtNSXREekVsQ2JEaUpiaUNQVXpqYjA3N0ZUS3hyeFVsQ2RKeW1TeUdPOTZ1T1plNHB6S1VQT00wUlcwNjBnemplSy9IM3ZZMzVXRHVYMHh3UmNxTGtER204VDFmMG5vVTV0UlVuaXVGekl1MURHdS9naHRlRGhYa3BueE5wSHdXblNrWUk0NmRWZm01aGRoR25jbThvT2RuUmhpeCtpcTdxM1JrUFlHODVsVk5nNEdUWlJVRVVQOEdwNDZ1SGh5ZzVXYlZEdytuQ0hxTDRjY2x0dFBFWWJjTEpxZ3ZPbk03WjJaREVqd3NpUEloMWN6bFpkb1hINlhTWFF4SS9yaXB0UEVhVGNMcHNEOXZoZExyd0lJaWZFTGQ0Q0MvV25DNXBZTmMwb0dvVTVQQVRzcjNDSTF3ekdsQkhzTGMwSVU0aGg1K2dieWtlb0Q5cUdsRDNzR0lhc1ZjUXd6OXcrY3FteHdPVW1pWnNiRmduR3JGSklZYnYwRTVYUkJsZjJWbVlYYlNsRVFHZ1NwcXhneGkreVUyT2wxWmh4MWNDRDNOTEN4cWhmVUFOTk1QcElZVnZxRHAvN3dGQVgvRWxQV0JtcXFscGhGc0FxcUVoc1FVaC9FMFNsbm1LbjN5K0VsdVlWK3JURFBjQzRPelNESGNQSVh6SjNmakRHZi9LWGI1VTVaaVYyanMwdzJrQXRCbk4wT0VCTXZnck45amxCNFgvMkNGZk9XRldka2REbkI3QW9hTWgxUTR5K0I4M3Z2WXBYbEFYdnBMMW1GTkpVeW9iZ0hla0tkc0lJdmlQNUJTbEZsN3JPNzVTWWtZSGg2WnNBQ0QxYVlvK1FRUi8ycFNld2h2U2dxOXNQY3ducGpGSEFMQjNOR1l6UWdKSnR6cnVVN3dqVC9oU05XQTJvMHRqZGdDZzlwckcrQjRFc05xY2NyenY0UE1sMTdjeGt6U2dPU01BSUs5b1RESllNTzlZOXZnVDYrTHdwYnJCVE1xSzVod0FBT2N0elRtMk1NL0dYNXhEdnVRVU5tYlJkelNud2c5dFRIT2NpNDM1MlR1SEx3Vm56TUV1SEpvVDRvZTBvRUdiSGcvUWJQaFNkbEdZUWJPaFFRVitVQmVhVkZpWW4rZHJ2dURHTGVSNU41Y0c3ZkhUUHFOQnpoa1BjTTM0MG1hRXZIMUdrMXI4bEhjMEtjUUR0RnUrcEU4cHBMVXhUY3BzL05RZmFkUWVEN0J6K0ZKd2hqRHJTcU9PRm41S1R6U3FUakcvcU9aTHpzV0dySDVMbzNZSy8xTzZORWtYQ3ZQek5WK0tEeEJsN1doV28vQS9ZMDJqa2dqekcxMitsRFVLa3M0WmpjcGEvT01jMGlqWFR6RzdkTXRYYmpZa3hUVHI2T0VmYVV5emtnSHp1L0NWNUF4Qm82WlpoWTEvcUoxRG8zVGNZblpwelpmMERuTFNEUTBiRlA0MUpEU3J1bUIrQlYvcGJJalphWnFWUlBoUDFOR3c4SXpadFM1ZjBnT2tuQk1hRnZiNGp4ZlN0SjJOdVZrK1h6a3FDUEZkR25iejhJdkNvV0diWEdGdWU1ZXZOSkN4cjJtWUxpMzhZc2hvMmluRjNBNGhYN2xaa0pBZWFkcW13YS82RFUzTFJvV1oyYVhMbCtvekJGaVhqS1lkZS96S2lqVk5DMVBNN2J6aFMyNEpBZWVRcHVuQ3hndWxTOVAwRlhOTFQzeEpod2NZbCs0Y21wWU5lQ21xYUZ6dFlXWnFuL0NsYklCeDBZYkdiWE84WkcxcDNnbHphMk8rNU1ZZURFdFBtc2JGSGw0cGFKNlRZMmJxVXZHbFRRT3pWTzdTdUtwVWVHV2tnQkJ6aTdaOHlkbFpNQ3FOYVY0OTRqVTdvWG5WRlRPemJwb3ZoV2NZdGFlQW9NVnZUaFRRSFRDenNlWkwyVlhCb0hSRDg5d1RmdGU0TksvYVdaaVhGMnUrNEJRZURDb29JQm53Tzd1amdDN0h6QzRWLzZPemNKZmJNT2ZzVUVEWDRuZXFvQURubEdKZWJjZC8xZjdRV3pESWppbkE5Ulhla0RzVVVJK1lseXBjL3FDM1JYNkFna2xEUlFIT2dMZDRJUVZvLzRCNVJRNUpWc2ZMT1lWaGg0QVNrZ1BlWXU4b3dSMFVacVZpc3ZKSHo0SnhPNGNTZklVM1JSa2xoQzNtTldiRkdSS2lMVVZjOGJiMlNCR2xoWG0xRUdHZE5DVzRCN3pOTGwxS3FIdDhCV3JjVU1RTjc4azdpcmpoSy9COGluQnp2TWZ6S2NLTnNIN1drRkJFcVBBZWRjMG9Ja2l4ZXUyUk1rcTg3eHhTeGdWcloxMWNpcWg3dk04cUhJclk5Rmk1TnFHTVc0by9HRGNVNFo2d2NpZktxRWFGUC9CQ3lxZ2JyTnBaVThheHhSOWRLc3FJTGF5WUNpbEQ3Mno4MGJtampPU3FzRjVYQ3VraS9FWGhVc2F4eDJvZGFzcHdpeFIvRVNXVVVaVTJWc29xWE1yWU5QZ2J5NmVRSU1KSzVUVmx1RGNQZjlWUWlMdExzVXFwNzFKR1BlRHY3SkJDc2x4aGpZYUVNblI4d0Fmc0tjVlBzVUp0ckNranV5cDhnTnBTaUI2eFFoZUhRcllIZkVpcEtXUnJZWFhPQVlVNEpUNG0zVkpLaWJXeGQ1VFNIZkF4MXNXaGtPcUFkVkg1aGtMY0t6NnFQVktLYjJGVjBodWxiRDE4bEgzTktNUVpzU1pxckNqRUdmRnhmVXdoK3VoaFJleUFVbUliSDJkZEV3cXBTcXpJUlZOSTF1QXoyaU9GNk9DTTFUaGtsT0tuK0pRaG9SQzN3R3JjS0NXSjhDbktPMm9LNlJxc1JPTlF5aW5GSjQwMXBkeFNySUo5cEpRdXdtZlpONWRDa3IzQ0NxaExSU0hPTHNXblJSdEtpVnVzUUx1bGxQQ01PK3cwaFRoWEM0dG43eW9LeVVvYmR6aHNLYVZyc1hoNVJ5RTZibkdYZ1dKMkNndm5uVndLU1FhRnU5Z3hwVlJuTE55WVVJanIyN2hUbEZGS2pHVnJmVTBoV1lON1dUdUtHYkZrYXFBVXZjUDlEaUdsYkd3c1dCdFF5amJGL2F3aG94QjNwN0JZVmtrcFZZTXB2Sk5ESWNrWmk5WFhGS0lMVEJNRkZPTGVVaXlWVHlsQmkybnNNcU9RZXNSQ05TNkZKS1BDUkFmZnBRdzNQbUNSMG81QzlDbkZaRTFOSWRrVmkxUnFDZ2tpaGNtc3NxS1E0eGtMZE41UVNMMVhNRUQ1bWpKMGFXRjViaTVsdUtjVVJ2UUpoWFFSRm1lc0tVT0haeGl5cnlpa1NMRXdhYXdwWXpQQ21KMUxHVm1PWmJHdUNXVlVPd3ZHZURHRnhEWVdwVDlTU0h5QVFVMUhHZTRlUzJLWEZXVjBFVXl5cmdsbGJEd3N5SGxMR2M0QXM3ekNvWXdDeTVFV0xtVVVOc3hTZlV3WnptWTU2b295NGhTbXFYekxwenR0V3dqWTEzeTZTeklxQ0ZCbHhhYzdPTHNVSWp4ZjgrblRYTCtGa0Q3azAyZnBNSUtZcU9QVDUrak4zb0tjcHViVHAyUVhHNExVVVBIcEU5eGRDbEgyamsrZmNFc2g3SERqMDRjZGJZanJqM3o2b0szQ0RQSkE4K2tqT2crejJIZWFUMyszT1dNbSs0M20wOTlzY3N4bVNQajBGNXRSWVQ3N2lrOS9WTzh0ekdsMCtQUUh5ZFhHdkVhWFQrOXlMalptcGtiTnAvZVVGdWEzMTN4NjJ3NFBNV1I4ZW9OVDRrR0dXdlBwdGVSaTRWR0dUdlBwcGZwcTQzSEdMWjllMk94dFBGSVQ4T2tYbTlIQ1k1MlBmUHJYSmxkNHRON24wLzlzejFnQXIrRFREN0dIUmJCM0xwL0lRbUVockV1aStkMjVwWVhGVVB0TzgzdkxTaHRMTW03NW5lbnVhbU5abWxEejIzTER2WTJsT2Q4eWZsT09IMWxZSHUreTRiZVU3Rm9za2owRy9JYTJZNHFGc3FMWTVYY1R0d3FMcFE2bml0K0tVNlJZTk91U2FINGJ1aHRzTEYwZU92d21xampDQ25pN2hOK0IzdXdPV0FVMUJBNi9QRGNjTGF5RWlrNEp2N2o2ZE1hS2VKZXR5eTlNQi9zVXEyTG5ONGRmVm5LS0ZGWkdwY09XWDVNT3hsUmhmWlIzNGxkVUZhM0NTbzFielM5R2J4dXNtRmNrTHI4UU45dWxXRFY3akRQTkwwSW5mb1BWODY3SGlsOUNGZzgydm9LK0REUlh6d25MVnVGclVGSFJjZVc2M2RuRzE1RTJ0NFFybHB5aUZGK0s4aHEvNGtwbGZwVGl5N0hzOGVoeWhaeTRTZkZGRFozbXlyamIwY2JYWlpXZHd4Vnh1cXVIcisxUWhwbm1LdWhzV3g3dzVhbjJFdGVhaStmVzhmV0E3K0d3OXpzdW03dTVEUWVGYjhOcmlxM0x4ZEpkMFhqNFh0TG9jc3k0U05WeEY2WDRmdXpEZUtvMWw2YStqYTJONzBuWjdTWGdrcmhoMmFjSzM1ZUNhdnlLQytIZWNvVW5ISzV4NG1nK2xPc2svdldBcDU5VWUvVTNtY3NIY2JQT0h3NEtUNy9xaDFOUU81eGRWUWVub1ZWNCtvM3F4MTI4elRSbm83TnRYSTR0bnQ2akR2bHdPdGFhTTlEMXNSaHlUK0hwejlLK0tmMGcwNVNVaGJleTZXMDhmWWpsOWZuMUZGUVVrWVduYTlSN0ZwNCt3MHE5ZGl6Q2pFWmx4OTNZZXJhRnAzc29aZG45dmdnckdsQ0Z4YjYxTGFYd05ObGgzTVZkVmptdXEva3AyblVkcDlvY2QrTUJUNGJaZlhNdC9HQlRKMG1XVlk3amFyNUp1MDVWWlZsUzE1dkFMeTVOYndPQXdwTUlsZlpSczcrV3UrTG14OGRqK1ArQ0lOZ0cveS84ZjhkajdOK0szZVc2YjZMZXh1cjhINExoczI2YnBIenVBQUFBQUVsRlRrU3VRbUNDXCIsXG4gICAgdHlwZV9pY29uOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFaQUFBQUdRQ0FNQUFBQzNZY2IrQUFBQWVGQk1WRVZIY0V3NE8xQTNQVkE0TzFFNE8xQTFQRkU0UEZCQ1JGQTRQRkE0UEZBNFBGQTRQRkE0UEZBM1BFODRQRkE0UEZBNE8wODVPMUE0UEZBNFBGQTRQRkE0UEZBM1BWQTNQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTNQRkE0UEZBNFBGQTRQRkE0UEZBQ2FBTFRBQUFBSjNSU1RsTUFvQjRJU1JuK0E5WEg4T3IyRGMzZTJCT3AraVRrUmpPNlhiRnhVenJCaEdkN2pDdEJrNW12VHpoZUFBQVlia2xFUVZSNDJ1MWRXYnVpT0JBTlc5Z0N5S2JzSUtqNS8vOXdIdnIyWE8yN0NLUkt3M0llcDcvUmEwNHF0VmNSc2lpWXBxbHBtdWNaSnowLzkxRm0rOVloU0YySFVjb2NOdzBPbG05blNsL214OEh3UEUzVFROTWtPekNZMEVKRFRZWkxmcjRXZHNBb2Z3NG5zS1ByT2I4TWlXcUUzczRMR0xSUUhlcnFmTXY4Tk9ZekVLZCtwcHlyK3BTRU95dWlDSWRMMWZXUjczSlJVTWVQK3E2NkRPRitxak1mcWZCVWxkZk1jaWlIZzJzVjE3STY3YUl5bFF5anp0dW9DUmlIQjJXSEptcnplcGVVMFJqeWEyT2xqSEk4c05UUCtuelE5c04rQnE4dWk0UExPQ1libkhQS09YZGNLeXJyblpQZjJOQjd5MkhJWER3WVlNeXhlOTNiVC81YlIwTy9wZnd0U0svSDNVMTVKTU16anIzRjN3Zm10N1d4QzhyZmh5bzV0ZzNqYjRiVHRIV3ljMEtJZWpsbkxwY0Nibkd1alcyL1hkNHBWeXd1RDVpbGRLZnQybDJoM2pjcDVWS0J1azJyRzV1a0kra2lpM0haUUNsbGg2d2NOa2ZIcWZYZG1Fc0s2dnI5cGp4RzdhaTRqSEtKUVZtcUhMZENTWmhuakM4QU5LczJZSEpweWRubmk0RmRodXNXRXk4cEYwUUg1NXphWGJKZVNyU2hiUGpTd0xLMVVxSU5YY0g0QXVFV2ViTEdFRWxYdUpRdkUybVJyODFYMUtvb1hTb2RuSE1lRk5XcUFvLzFMWWo1b2tHRDIyazlRWkxXWlh6cG9NdzZxK3N3ZGJ1QThsV0Erdm55M3kzdGtqRytHdEJpNFNFdWJlaFR2aXE0cmJwZ1NveXE0YXREdGxnVDJLc1ZkMzE4Y09yMjlTSlZTVkxhZkoxZ2RyazhlOHZUSTVldWxCQk8zY1VsUzlUV1luekZZSWR5U2JrUzh4UTVsSzhianJLY3ZMdVpXMnVuZzNOT2cyb3A2cVBuMjREVExzRUE5bzRaM3dwWWNaRmV0eHRsUVBsMllPVnlkOGVaUSsveVRTRnRCNGtaMFM2Und6Y0dwN2pJeTBkdU03NDkyTEtXYjJuYlVoK2ZDTTVTZHZScVcxTWY5NUVVQ1ozRXBJajVaaEUzdFd6bTFjV25mTXZ3ajFJcEVpOFArTVlSeUpSdkQ4dVVieDZPUEVVcFJ1dnVmSERPYjNLb2RqTzVzWjBNempubmhSU3EvVlRRbllvUCs5ZVdJQ0ovc25jaVBobXgzczVJZmRocHVDT0VIdkwzOG5FSmRoWWVLVW1yblErNUdISDA5MFd2ZEdzbjRCdUhSSCtUMDY1Vi9uNzYzNEhwT3grU3hScXJuUS9KRk1rYmJDMTk1K01YdUM5bjVMTHI4MTlGNU5YK3lHN3ZQbVBFZjZrZXFYYytuc2UxWGxpTmN0cmpKU1BRdkt5UGVvOG5qa1Ayb3Z5SVd1eG5QUTdLUzRxeHcrdWUveGlMOWdWNWRxL2M4N1hqY1Vhdmp0ZjIrcEpKUVpRT09kQm9WcnVCTlFuWWJWWjdnbkFxZk5UUWI3SWJ2Rkk1aU5wZVlES0RFVHgzUk92ai9YeG5LUFlia2p1aTdRYnZQTGlsdHh1OFV1R2dJN2dqNXNYZUZjaGMyRFc4T3pKRVNCVzhyaUlQSWl5cnZnQ3ZqRGQ2clA3YXN5RVBralBTSzhCNmJTa1JMRnVxaGttMHpJTFR3ZjZoUnpTRnJzdkVCOUU2ckljZ0JmVVB2UXhMb1VlU1RjdExzSkk5TkFQMFJreTArVDZPZFAzRWFNYTkwNEpaV21hTzVzUzIwbzJUREJXc2NFU1FRekZ5UXF2QjhpV2NwMzVFKzdVMjBLOVZJeXdGNHBRU3psczFyMWd0azA0UG9rYThGbTNDVHlIbDJNSUJiUVpDMmtGY1FOM0MrL3ZrSEtOVG9nVzFmWUFRU29JVk11R3hJdVVRSFVKQ3RBSHA4VTM0SnlNV21SeDBJaWxxdENpakkyeHAxV2d4WG5hVmRqYWVlVU5qeEJmVTY0YUM5cWNGRWc4aUR2RW1GVjdGUWpzVjJvTVZuK1hsZzJoNGVwMEsxUVVOZVBzL0xLbFhQcWg0UDl3V2VMUTB2Qm5WVEplWkQ2TGxhRThEN2VkZnhRdmVHS3lJeUEwVlQzbW1zKytpaHpjMFBKQjlLYUJab1dXQTRtanVvOVhoemNFNlM3OTlJOFFyUWt0bk5vUW1lR1UvOWdLMi9WN1ErcjdqbWJXTUxWclpEODBYc0o3R1BLTTVJKzZzOVR3MVhwMWl0SWlkV29pVjVYUEcvR3A0a3hSVG5Td0NIWjVYM0U0T01tSmFHZGVGYkdiMEdyUkgyN3BNZmJUVUNDOHBjQ0VMd1JIdjFaNGFoOWM2TkovUWFaZXpKeE12NnB0T25ISTJvTFhtVUhzNTYrWXdMZjlwQldrYW5qNXpTN0lnZEdpRXVKVWtBcEtGU3lJa3hJc2VaWlB5dG1nbXI2T1RSZUdDWm1peENRR1VCQzhib0pqTElpUkV6T2FPN2xEUVNydzB5T0wyWHAvUTlEb2RyVTBULy8xL2d6d2kwcUk5My83WTIzbkdrMUp6Y1lTUUU5cjd6VVltSVVJMEFYR3FCUktDMXcxT20zRlppQnhQbzRka2dValFmQUMzRzNVajBFenY0R0l1a1JDU1k0V1I0bEhOdVVjMEpkWXVVa0FJQ1JXc0l4azF2QW10M01LdXlVS0JOcVU0SGpHVjhZU2x3bGk1VkQ2STJXT0ppSFY4K3VWWVpqZk5oc1VTUWd3c0xVTDdaODk0Z3RVK2xIWmt3ZWl3REsybmZZZFljZmY1MVdGeXdFWjd5SCtQYUlWWW1kdmd1R2creUFXckp1aUo1WXUxVllyZHRHVVRZbDZ4bk1OZmM3a2Vsamx4U01qQ2dkYXNmL1hlRVVncmw4NEhYazRpU040UUpMQzl4Uk5DRXFTUTBtOHBDVlZCc3U1cXNnSlVTSHE5K1ZtSllDMldVdGJBaDRsMlhYODBRRDJrekpTamtsVUFhKzY5OHVKWE1qNXI2eUFrUkJwTDg5T0ZOWkZLV2UyRXJBUTFVaTcxaDZpUzF5S2x4YlMxRUdJaURVYUt2bGZyQm80VEVxMUdRQWhKY0JvVTB1U0ZxY0tnTXRkRENNRVpXdnI5REZtY1NaZjA2cTJJRCtLaERDMk52N1d6TkF3bmhGb1hzaXFjVU40czY3dmtuWTRTNVczSnlvQVM5ZjEydVRSR1ZmR2l1bk5HV2xvWXZzRjNzOE04akxpaUl4emxOWTB5UzhjOEUybld2NFo4bFBrV1h5K3VpZkZpMFVaWW93KzMwWFlOZlUwM0tVb1B6K0ZyZ1JhR2plVUluNUJ4bTJSQnZFSkdUSXloYnM2WHVtc1B3OFpTeEgvOEpMdWYzVjVoWTRjSWVwMStHVzVSSTNnOGdiQ1BQbldDbXYrS3FJQ0prYVg0VXRhSjBWWFlpZnRoRTkvcncwdTBpSGVHTDgzNVl2Z2lsTnczNHJYVldqVFJ3WHBOYWhLaDlJQmVIMDlyUU1pOUhNV0RXTnJFQUxUOW9sUllDZjdBLzF0cEN6L3prU29BcFlxbVB1bVhPNjhhUGF2Q1B5aVBsWVFJS3hxQ0d1YTVubkJUNHV4bGdVejQ4aHo2VUZNS253cGhRTjA1WVhsZzQyNGpDNVRYNWU0OStKTGJoeGVsQmpma3dMcHpQTDFWaWp2Y1NZelQzUDMzcU0zSkMxR0Q5L0EwQTZZRXVpVmczdFpUUDNFL2QrOVEzZjFEK09JOFdBK3RSZHo2UGxjTXJVSXlMQS9OdkNma25YTlRWT2hIaGQ3VkhoalFXNmJ3ZHVkSVF3aDg5L2hkYnJVR2JrZUo4ZFpGeWtNSWVQdDQ4Nm5Wb1FkZXBuZ1JESGtJSVFOMHhEZkJDbVRGVjdJRlFqUm92ZjUvZlE3MFRLaFUzUVFoSkFHT04vMi9tM1hJZ00wRnNnMUNOT0NYSmZ0clpnSEg5MjJ5RVVLZ2I3TDcxeFNDN1VSeExwc2hSQU4ycUQrMHVnYmJGWC9WTmtNSTlCSzdqMHFIRUxTKzRZQzdPMGN1UW9CN2VENnFDdFVJOGtOTGJVdUVhS0I1aTQ5UnZnTmtHd3IyaUJuSkNJRnRYM2MvQWllQTJVS0dIUU9YalJEWTZVa3FJWVNZRldaNTBlb0pNU0RISittRUVLSUI5dDRHRmRrYUlTUUhGSkV6Y09DRVhZWHl0dXFwdmh3ZlVRL2hlRUxDb1Q1T3g2VStxVUtHQ0tCM0dCRkNpQUgzZ1NKbFVlR2xVeHIvRUR6Q0w5cVRPWklRdFMzOFlEb09maE9WUjRHYkJEZ1UwU0tFRUJYTXlITGEyVGN0UE43ODcrTUZySG1vNy9xWmtEcWEvM1l3NjFiTlQrSEFkUys3SGlFa2dYTC9xVDlibzZ1OTlmTnBGc2tZUW9aTVJMbFNkcmpPempyRFpYT2RoQkF5UUJXMHNObFIza1J4Zmp1cnN6ZUNFT0Uxa015ZjdVS0JaWFBaa1JEekFwYUNuUHRnRGMzdmQ2SXdSaEFpWGhaQTNibTFsa1lCZUtkTktIcnAzQ0JXK0N4MGM5OVgveE1oQmtSWndPeXhYaGNnMDVlMWhKaFFic2pjdkszNWRGUmJNSUtRRUtMMmtzMk5WQnRYR084d2pnalJnUHFCMHJtR28vSFV5b3ZHUEZrS2hDcWNQVHNWS01kSEc1Tm9CZERyTjdjUzY2bUFwTGsyZ2hDUVhCR2JPM2ZDQXdwcFdTSFJZR3F5c3JrSzhXbHpZL3d3amZ0SFFqU1FoZlN6QjA4QTlmQUVBL0ZBYXJMYzJTTm1qczgrK1RxTTg5VERNOEN6TWJ1eDNvVFp3eFBVeEFPUnRkdnM3cHlISktpVFJZKzRuU3RqYkN4THE4dHJOQjNaL1Z0SFp6Y09HeG1FWGsrUHhJRDRIR3QrKzVyL0VDeE8xRWNZbmpraDJ1dUY2blFrRHptbVluNDJGMEtKcFJVNWdTU0Q1NGRMMC92MzRqbXRHT0gzKzBGaHpmeHNMa1FQajV1RERBRnFCQW9iN242Rk95SllqRUdJY1ZlcElGQlVOamdnT2d6QVVSZnF0YnkvSHFmM0VISy9KOUFYeWVhQ0hLVzRvMDZGdW5OV1JJZ21ya1ZZRHpCMEpoVXFiSGcvSWVZZElWU0VFRklKVzZ6c1JvU0xzZ1M3YzFZa0ljUXN4QTlUUENQc2lwVXFya2xDeUVYMDBhS0YrSEtsbnBCZFF2NFBhUW1Ib0lob1JqMHd5QzRobnlFdFg1Z1EwUUNRYUtuaXFpU0VhSjB3SVlMbDI1bEpkZ201OXc0TFVVTEVncjFNdVBsZ1hSSWlQRmVwSVVKMkFlMDlza3ZJWXh4R0xIWFpFQ0ZDRCtMTkIydVRFS0lmeEFnUmlZaXgwaU83aFB4citncjE4RFJFNVArRzZNNVpuWVNRUWNSd3RZbEFmaXFGMkoyek9na2g1TXplUklnRDBTNjFQZ2tSSkVUZ2Y2WVEyNHpXSnlHSlRVVUlFVkhxY1c3dUV2SUZQWHVmMldzUHU0UjhpZmhhWW1hdldNQllmR2ZrMmlURXUxRXhRc1JDSitscGw1REhEeE1jQnRlSUJoY2pjNWVRZTRpT3hSQU92OVBqTGlFUDRYZFhsQkRSaklvZjdoSnk1NldMMWx4bjRpbmM4eTRobnhwZGRMTUl6Y1NMSElKaGw1RC9mVUxSRW5oYUVPRVJYTEd5UzhqZlQ0STRUSUJDdVdxWGtEK294U3NYcjg4N3lrYThlOTR1SVlRUW9vblB4R0E5UkxHMTBLUjMrbjRKTWF6NzRONThpTjl0N3B5ZnRwUmhKNnJ1Z3B0TzlSNUNCdmZlVTU2djBRR2FBNTBTWklLNWM1Ny9hQjN1QzF1TmR4RHlzSGtzbS84eE41aUdIUU9BRU83UG44dDA3d2M1dDF4L3dMSCtkNVRWcjRTb3RUNGQxZmsrdmpxL3BlMEkxTkxtUVV4UmZteGRub1NIYWxnV1dJL3dzMXM5bGhDMXpYeHJPb0w3QTVpL1I4QUEyVXFWSHFIYW9pOXo5ZnF6SjVNZHFuSHpzblRmZ2JCUDVoTFNnVXk1Q21xb3dRSFJYQkV4bjRZS3hzM0xVa0dHVWZwejB3a0RTRmMwUHd5VHQ1ditoTm1UQTU1M25iNW1YdGFIa1RQWDVJV1pPbVo1WU1ObnJOa2lvank3VzltWTRUTVF1emZwN0czVFFFdWphQU0zbm9tMmN3bXBuK1hJUnMzTGdwZzFNbnZLclFjMGRwRXFnQVBNMk56YnBUM1RoNGNSaEhnUWIvaGNqVzRlZ1paNHhTM2tpTDlvYnNGRDJQMmV0bFRDRVUrVytMd3NkN2JKRzBKdHJXQWRnUnlDT1R2cTYxWE5MN1ZNNCtabGllWk91VC9iNGpYQk51SXduVUNPaVcxbWo0blZUbjM2NDVOekhUVXZLeFNibDVVcXg5a1ZUUnJjbU5pQmdBNVNGc2ptaHJyeXZXNTNyc2s0eDlEb1p0L1RPSWdxWTM3RXV1UmdKNmdSeUZIajFCYW8wakpEbys3NnduNUUwZXJlMk5DSnByZVJQUjNadGJ5b29VREJud3Ezd3NzQzFVaWNVOEdOa3VZM21CTHROV2RDN0s4R1hGQlUvS21VZ1B0QUMzMkJoSHpyS25UQWRSWHRIeHNCY0NPSllteU5rTkFHUEw3cWo2Y011TWJ3d1VUZEJDRWw1QkxJUDJicUNYSXBXSkZzaXhEUWpXck9SeTRZY20wZTZ6YTFOcy9ySVFVaysrdFNBWDdtUStCcC9ZUWNRZGNJZjhSbnpZNkRmdXFXVnEvZVlzaWoreHQ3cWx6SVQzVk8yeUVFOXVUK0xpZUdYdCtkYllhUXBBQmQ2K3orZlZ1R0FwUVFYbTJFRUMySFBiZi9GOXlIVjFDaWVSQnVnNURCaGlYay9IOE1wMlNnSHh5MzVoWUkwVnBZUHVqbkFIM1lyZUFRdmJsTElPU1V3cDZhKytrd0FHMGorZlFPbFhBRGhBQnIzdnZpbWpBQy91d2dYejhoVlF4OGFPMW41c2RzWVpVSWo5RkNXdElRRWxyQWZQRDd3VEU1OEhNb1VBTDRuVDk4K3NSOVJkb2h2L3NIMVh3dElTMEZQckwwdnFxODlxSHBicUQwdW5IMlhlY09kdzhGWmZmLzRQZkpLelY2QUgxaUR6c213Z3o2NHdIRzBrek9EYmpsNndoUm9EWElQMnU4ZWdiOStWWU44WVlreFd5cHg5WG80QUlTbHc4M09IZkJSZVFLWVBxYSthU1htdDIwRjJuMEF2eTREbzhiRkFkd200Rzd1cmlJYUJOVE5mNXIxSWpXcGVESFZUdzJ6b0tzR1B0WFM0a1A5ZlVLb1d1R3B0SGhWVzc4NzR6d0VseUpjQ3J1SFdyS1ZNWDFrcnp0MlFFL3JDOTdvMnI0N3hCZUxVS0lOckZtekRaZVFVZ04vNzV6KzkrcnBObndYOEt2NG8vREpHdkc2VjdoSFlZOS9QUE92N2JvOXdpRU9MVzQrcHp5RGpldk1MTE1DME00cWZPWHE2UWpFRUliQUlQR0hXbjVVbHE4UktON0JjSkpIYjVtV2IwVVEwVEU5YnFwUjRjeFQwUVFkUy9odzZ4UWJ1NDM5dm9WNFl1NHI1S1ZJVVRRNkp4OXQrcnV5REJFNUt5dGpCQU1YZnY5c2xUUFJ4R1JlbDE4bkJ5TUYrdmJDSVBaWWhEQ3J1R2ErRURSNkR4V3ZqWFhNWHhEZ1daOEtaR2puTkVQdG8vUllId1pWVmFrMTlXR29xaVE3NC9JUTNtek9Ndk4xUkJ5UmhHUUh3Zm8xeTdLMXpYSld2aW9iWlFEK25GOWJWTGdmRis1RXROWDZ5bk9HNkwrR0ZabUtGOFlES3ZndzlRdG5BdDdlMmxjK2ZkdlhCSU1CZWQwMk9XWHIwU1N5VFY0aDFxZTRoRFMvR3owbUIyT1d1ZjJDcnpESk9OSUt2YTN3RUNEODUyMFhMNkFsRGdLOXZjRnoxcUw5SzNXNHZWNmd2Umc4WnYzcXlGeFFGSmMxNlVUMGlQeDRmeGVMV1ZrT0dxZEI4ZGw4M0dLa1FqSm5yak5KWkphcDlHaXZVTVRTYmx5K215UHdlQWppVWk2NkpCV2g4VEhpSHhSajZUVzBjZlNvRVo1a1ZRclo4KzNHTlJZMW9SYmVrdmxRME83cFNNbXZta0tsblRhcDZVU2NnbXdCT1Eyb3RUeVNMRyt2VjJvdng0cVdBSXlxamxXd3dvUjhMUmVwbDdIQ21MeHVCaVZUYTJ3Q09IS0lrVUVlTVRNL1EwZFY0dHMybGlFeFBvQytUQTdyQWVMamkwakxDbWFYbCtnZDRnVmNKM1FPeDZpaVFoZlh0UVhjcXp4dnpidjJIb2NEVTFJdWJPMG1pRHpZcUU5NE4zN2N6R2NLd3Q3dE1JYjJsRk15TnBwV0psRHpwMWw2WFZUeHp1SktTV2RXQVZCbk5QTVdCSWhHcDQ2TGFaRWt0QVMrcStkZndFUTVVVXpPTjFwSGR5SUl0SXNLS1NsdW5qS2RLS1RuR1BGMHpocmwwTUlua2FmUEpiRlFJc1hjSDh4MmR3TG12bFBwN2ZOVkFFYUk3ZUZoTFMwRE85U1RuKzN2UnZhOVFpcVJVUjlUVHpqZjFZbTRvVG1vdkpvRWRuY0JNM2twZGtzdythTUpyQk92Z0IvM1dzZHJOOC9NNXV0K21naTRpOUFSQzVvUDMvMnpOWWNUVVRvV1hvdFlselJkT2pzaWlnUHpUdmtydlMxdmpwYXJJSXBzOHR2YWp4SHRaQ2NEelhDQzVyTTk4TzBGbzBRS25mN3VvbjNYTWNpa1FvVnp6V3lwRGEwRXJTOHJWanprcGFqUFZxeHpIcGR3OHZiQ2lhRWpCN1BYNWRZcncrQmxBOFdJWGk5OHB5em03eTF2bWpsdE9KVEZMd1M3ZEdTZHl6TkVjOEZFUS9qcVdpRnJYRWthUWxLaU9halU0aGhWVWVzM2dqdWRuSVNVbUsxcjNFYm9ycFpLN0dDYkRTVFVxOFBCN3hIR3NTeU5CVXNaeVNXY2lJaldpSUliTG9lbmhFbzQwUkdQVUI3RU1ES095cTB6RUF2WFRZM3hBcGlVUXZRcXNRYThNRFRpMlI4WUt3RytYRFJJZDluQXkwUVgwam1IUTVZWmMyMEFEWHkwV3JBNDF3cVBqdzBrOUtIclE5RXF5MmxCNmxxZlU5WVBxRURmZkZDdEpTL1RJV01ZWXZsRTdiUVQ3TTVZS2tSeDVJSEI2eGJGOEZiaytZRnJ6Si85YkJScW13UWkwdFhqaFNuVk5NOHUvdlp6Z3FaWUkyd0NKVjRQOTBaZkNob1pZRkRzeC92ZEU4clEreFFxdjM5Z0tlSHNEQkQyc2RnUCtLSldUamNNV0ZtN3V4bkxJVkMvei9ZYzk0UGVRcnd1OFhVMjM3S2NnV3poMkwzRDhjcWRQc2wxWm0xdlRNeUR0YUxJdG1WdFRNeWlvK1hGZFZVaDUyUkVYeThNRDJOTndwbFJYeTh0UG03MnQyUkp3aXExOWFjNlRzanZ5TE5YMTI5b2JQOTFIK0cwNzI4bXNiVTkxajh6dzdJTzFZM210VnVhdjNFeC9rOU5ScTV1MVB5N1h2MXRxRjUrZTZQZktmUHUvZlY5T2YrenNpL09PVHZySTZ0OXRxZ0wvN2dlNnVWTDN1YS9SOCszdDJEZE1wMkZ1N2pWKzhmaHpBb093OS96VjFiaXFaSm85MnArSU5Da2twKzc3dzc3Wnh6M2tzenZVWHI5ckpmem1ScUtUYXJyVHNrVkxJMWphYSs3VVI3YkhXeWpkSzVaQnRXSkN5cjVCdHROTncyMjYzQWxKT01JeW1NOHJCTlB0SlcwakhFbnI3SnlKWmRTYnRjUUt1TDdTVjJvMFRpNFpHbTJtK3MrTUdSZmVPeTFxVWJzbitwbjh1L0pQNlNiVVZJcUZNc1lwK1cwVzZqellwYTU0WHNMVFZ6ZXdOQ3dySnFNVnRMelZPLyt1TGY0THFnOVgvRU5EcC8xWkVVS3JIejhZT1RXTjlXL0d5bDE5b2tDNE1aNW10dGFvK2JLbHdjSDRRUTA3aXUxQmRNbGtqSFI5blc2cnpFMk5iSmdtSDA2YXFVTzNQYmtDd2FuaDZ0aDVJNFZZNWs4VER5YkIyWksrb1dDNGhjamNvbGxzMEtoSVJsNVhLVitiLzJWdDFhU3hjUHZ6MTVaRDBJTDdkRkIxUFM2eWtrcTRJWjZ0RmlYWGRYcVZkR0J5R0VtRjZWTFRMQjZ4U1hGZEx4Qnd2c3VJcnR5aVByaFZiNmJFR2NVTWZxUXJKdXFPZkdYWWdSSEx0MnFaTFZ3MHk2SWxnQUpTd291ZzNROFVkS0trWDJrVnZNdXVXcVNUWUQ0OWpiRXB0YzFPOTFnMndMNGFrc0pJMXhPZG01RHNuMm9LbjZWY0xPcThOTlR6eXlUWmhlVXNyVjU4NmFjdkJNc21XWVIwV2FrQXE3WGJaTnhsK2pxNHRTOWw1RG1NWk9HdVhxenNXbmI2Slk3cnZNTHNwU1g5bVVrVHN1alpWZjdZUHplaVh2SEpvK1QzWTJ2cE9Ub1RwSDlpdW5vc1dwSFoyclpELzZuemxSNi95YXZjWVlqZzlGbjlmR0xodFBYY2JoV0NvTnNxQ2t6YTI4RE41KzJpTjlSbU9vdTJ1RFl3OVR0N25tOVdCbyt6bFBJOFV6a3FxRkxpRnlzMVpQREc4blk2WktNVFVQakJVbmE2dEUwOHhkYVlpeVFnaFI5WE5rdVE1akxLYlRITDZZTWNleGlyYmF2VDV3ZU1teGE2UEdDb0kwZFIzbkozSm96SmpqdUdrYUhLeEdhVHQ5MkI4b1ZJRUpoL3BZNWVXNXYwVkZsbVZaMHpTTmJkdDIwelJObG1WWm9WejdjNWxYeDNxSlZ0Ui9sTk5HcVVwWmtyQUFBQUFBU1VWT1JLNUNZSUk9XCIsXG4gICAgaGVhcmluZ19pY29uOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFaQUFBQUdRQ0FNQUFBQzNZY2IrQUFBQWgxQk1WRVZIY0V3NFBGQTRQRkE0TzFFNFBGQTRPMUEzUEU4MlBGRVlKMGc0UEZBNFBGQTRQRkE0UEZCQlExQTRQRkE1UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBM1BGQTRQRkE0UEZBNE8xQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkNVaHEzK0FBQUFMSFJTVGxNQTkvNEkxWjhOR0FINzZPTHVBL0lTME1randkc3ByaDY2TUc0M1IzVmxUWDJua29TTG1WOUNXVk8wUFJ5dms2WUFBQ0dLU1VSQlZCZ1o3Y0FIWXVMS2dnWFFLeFVvbDNJZzU4emQvL3BtM204amdVUGJvQ28zMkJ3OEZpbWxFTUt5N1A1b00xN01lMG5jeVhQZkN3elhOY0xBOS9OT25QVG1xL0ZtMUxjdFN3Z2hwY1NUQmxKRWRwVVcyODE0VVNaNWFQSnpZWjZVaS9GbTIwOHJPN0lrbmhRUlVkVS83c2ZyUSt5NXZJSHJ4YjM1Ykhmc3A1SEVVeXRPVkd6M2cxV1plR3pMREpKeU5kZ2Zpd2hQTjVGUmZ6OWVIRHFCU1hXOCtMQVlUUHVSeE5NMXBIM2NMT2RaYmxBOTA4aXorWEkzdFBIMFJjVm1rY1crWVZLZjBJOTdxMTBoOFBRSjZ6Z3VjOC9nTndpOVRqa2VDang5eUpvdTR0QncrVzFjSTBoV0l3dFBiemhTVE5jKy93bC9NYktrZzZlYXRPelJLdWEvWThUTG8yMDVlUHFQbFk2V21jRi9MTXhtdzlUQ1UzV2M5VHplQmU4d1B0b1N2NW5WMzNVN3ZCOUczSjMwQlg2cmFMVEtQSk4zeGZTeTVkVEdMK1NrazNrbjVCMEtPNzFCSDcvTmNCbDdMdStVR2NTcm9jRHZJVVpkenpCNXgwekRuNDhFZm9kbzF6UDRBTXplVHVMSEUrazQ1c05JQnJiQVQyYWw0NFNQeEV3R3FjQlBKWXBCeGdkamhyMUpJZkFUaVdKd01QaUF2SEtUT3ZocG5HcFNlaVlmazMvWTJQaFp4SzcwWFQ0dS96QzE4SU1jMTc3TGgyYm02eUYraW5UcEdYeDBwdEdaVmZnSm9vbHY4a2N3azUyRkIrZUliYy9najJHV1E0RkhKdm9ybnorS3Q2d0VIcGE5eS9qajlIWTJIcE4xN0hyOGVVeHZNYlR3Z05KeHdwL0pTQWFWZ3dkalRjdkE1RS9sZFVjQ0Q2V2FkUXorWUVZK2xuZ2NzajhQVGY1c1FiZkFvNUM3anNzZnovWDNlQWlPdGVMdkVDeHRCM2ZQR3ZYNFd4amxWdURPMldQZjVPOFJiMnlKT3lhTFZjQmZ4VjhWRW5kTGJPY2hmNW13UE9KZWlWMWk4UGRKZGhKM1NReHlrNzlSUHJaeGg4UXE0TzlrQnQwQ2R5Y3RYZjVXcHBzTmNWL2tOamI1bThWYmlUdGliWHorY3ZuT2NuQXZvckhQWHkrWVZiZ1Q5dExqRTdrdWNBOWt1Zzc1OUovREVYZWdmekQ1OUQ5bXNzYy8xMC80ZE9MR08veGp3NXhQRFRmZjRaODY1bnc2Wi9wNy9Edk9OdWZUSzhIVXdUOGlwaDArdlJHT0pQNEpzWS81OUE1amluOUI3R00rdmN2ZDQvdUpmY3luRDdnYmZEZG5HdlBwUTk0RzMyemI0ZFBIekh5SGIzWE0rZlEzYnJ6SE54cm1mUG83TjluaTIvUnpQbjBxNitON09QMkVUMS9RS3h4OGg2cmswNWQwYlh3RGUrSHk2V3VXRnJTenhnR2Z2bW9tb0puWTVIejZNbmNnb1pVenpmbDBCWDhIcllZNW42NWh4bE5vbENaOHVvNmJiS0dOS0UwK1hjbnM5YUdKV0xsOHVwcTd0cUdGR0FSOHVvRTNzS0NCMk9WOHVrbG5LcUNjM0NZbW4yNlREQ1ZVSytZR3RmQzY5Mk9lVTQreWdtTDJLcVFlTS90K3BET1RXaGdyQWFXc2NVQTlrZ2ozdytrbjFDT1lRQ1ZuNUZPVEtlNkptSVRVdzk5Q0lhdG5Vbys1aGJ1U2x0VEQ3TmxRUnE2b1NkREhmWEYyUHZVSWx4S0t5QjAxY1pjUjdrdzBkNm1IdjVOUW85K2hKa2tmZDJmVW9TYlowSUVLMWR5bEhzSFl3dDJSQzRONmhBc2JDbGl6a0pvY0N0eWhJamFwaHordzBONjBZMUlQZnlKeGp3WXVOVW1PRW0ybHBVRTkzSG1FdXhSbDFNUmRSMmpKR2dmVUpKL2lUaDJwUzdpUmFPZVltTlREV0VqY0tibW1Mb21OVnV3dWRja0wzSzBvb0M0TEJ5MkluVWROM0RIdWx4aTcxR1dLMnpuOWpMcDBMTnl4S3FNdWlZMmJpUlYxTWFhNFoySVRVQk4zWmVGV1c1KzZ6SEhmcWpsMThhZTRVWFNnTG40ZjkwMU9jMnJpbGpadU16R295MHppemtVcmw1cDRHOXdrOWFtSm1SUU83dDB4b1NidW9jQXRsaVkxTVhjU2QwL09RbW9TakNXdWQvU295N3pDQTBnVDZwSU5jVFd4TnFpSlA4VkRtQVRVeEYxR3VKS3o4Nm1KdTdEeEVLek1wQ2J4VnVJNlZlbFNrM2lMQnpIeXFNdmF4bFhFeEtjbTRkTENvMWhURjM4a2NZMmlkS21IbVJSNEdHbE9YZVlXcmlBR0hqVUpCZzRlaGpPaExzRVVWeWdPSnZWd2V4RWVTTlNqTGoxOG5UVXdxRWs0eFNOeHRpWTFNWGI0c2pTakxuT0poeEt0cVVzczhFVmlURjJNQ2c5bTZGTVRjK0RnYTlLRW1yaGpQSnBvYVZDVHVNTFhqS2xMTFBGdytoazFDY2NTWHhIRjFDVFlTendjTVFpb2g1bWwrSW9kZGVsR2VFQnBhVklQYjRJdkVEMXFrbThsSHRIR3B4NXVXZUZ6STRPYUxDTThwS2hyVUk5OGo4OTFxVWt5ZFBDWXRqNzFjTHMyUGpQMHFJY3hjUENnNU1xZ0h2RUluM0NXQnJVd0R3VWVsdTFSRDNNVjRlL1MyS1FXL2dRUGJPSlNqMlRvNEs4bUhyVnc1elllV1VJOWpJSEEzMFJ6bHpxWS9nZ1BiUnRRajBPRnZ4bDFxSVd4Rm5ob2NrRTl2S25FeDZ4VlNDM3lBZyt1MzZFZUN3c2Y2MmZVWTR4SEp3YlVJMC94c1oxSExSSUxqODRwZXRUQ0hUajRTTlUxcWNVUjMwemF3ODF5bnNXNUZ4cGUzT3V1SmtNTDdUaTdrRnBrRGo1eTdGQ0xyb1B2NGtncFJvczQ0QnRHM0ozWVVqcTRWZFUxcWNVSUg3Qm0xQ0tvOEQwY1lRL0hoOERrUjR6RGVHZ0wzR2lhVTR1dWcvZWxQZXJnemdTK2hUMGM5d0ord3UwTmlramlGdEhDb0E1QmhYZkprVWNkc2hUZlFCU2pkWWRmWVNTcmFTVnhnMk5NTFNaNGw3V2tEc0ZFUUR2Ukg1Yyt2OHJOdS9zSTE1UExrRHFVRXUreE0rb3dUNkdkUFRrRUpxOWdkcnBUQzFkTE01TWErQ25lNFl3TWFwRHZKRFFUeDdYdjhrcHVaejNFMVNZQk5RZ25lSWRjVVFOM1lVR3phSllidklHUmJDeGN5VHBRQTdlTGQ0aVlHc1JiYURiTURON0c5QllwcmpRMHFVR253RnRUYWhDdW9KY3pkZGxDTm5Sd25RVTE4RFo0YTAzMXpLU0FWdFlnNEFkTTF3ai9NQXlYSDhsM0ZxNGlBNnBuTENSZXMzeXFGdzZnazB3WElkL2pCbm1jbEt2QjVEL2pWZmVRZER5RDd3cG5FYTR5TWFoZVV1QzFLZFV6TXdzYWlXR1A3d2c3Mlh3OHFnVE9pT0ZrMGV1RUp0K3hLSENOcUVmMThqMWVXMUM5Y0F1TnhEYmpXMEcybkJZU2I4bHFOQ3R6azIrWTh3SlhrRk9QeW9VemlVdFdUUFc2MEVnZU03N2hsWU9od0FjY2tVNVhDZDh3dWdXK3pva1dWTTZjVjdoMERLbWNuMEtqWWNMWGpIS1RDdnhWTkZ6R2ZDM3NGdmc2dWUxUXVlU0lTMk9EeWcyZ1VaR1lmQ1diVkFLZmNhTGhNdWNyNGJ6QTExa3psNnA1RzF3cVhhcVcyZERIemx4ZUNtYVJ3RmRJYTFzYXZHUXNiSHpkTUtOcTVpTEN1U0tuY2lNSmZSWW1MeVVqaWE5eXJJbkhTOEhBd3BjNWc0Q0ttYjBDNXpZZUZUTzdOclNSazVEblRLTmI0U3JIMk9XRnp0SEJsMVVIazRybEl3Y051VENvbUgrRU5zNnh3M09tUDdOeEpic01lYUZYNE9zMlBoVnpCd0lOTzZOaXhqS0NObFhYNEJtM003RndOYm55ZVdFaDhHWFczS1ZpWFJ1TlkwekZzaUcwaVdZZXo1aWRQZDduV0haa1NRZnZFNE9jNTRJOXZ1N29VN0dzUUdQalU2MWdMS0NMTTRwNXp0dmpIZFp3TTE2dTUrdkZham5lN0ljUjNySUdQcy9GQmI1dTVWSXQ3K2pnUkM0TnF0VkxvWTI5TUhqRzJPQU5zUjEzRXo4MCtSODM5UEprUGg3WmVDMGFlenkzRVBpeXFrTzF6SW5BaVQwM3FaUS9rZEJGVG5PZWNXY0NyOWk3Ymg2NHZHQUdlYm1KOEVxMUNIbkcyK1ByZGxSc0VlRmttRkFwdDdTZ2pkMTFlV1psNFZJMGlRT1g3M0NEdzA3Z2d0UFBURGJjMHNLWGlSN1Z5bXljN0h3cTVSMmhqZHdIUEhPd2NlbDRDRTErd0RUV05pNDRJNTluL0QyK3JxQmFRWW9YenRpZ1N1NGErdGdseitSSEIyZGt0ZlQ0VjUyZHdJVkJ3SVk3ai9CbFltVlNxYW5FSDlHYVN2a1Z0SEgyTGh2aHpNSVpPVHk0L0lTN3NoMmNFWE9leWZjT3Zpek5xZFJTNG8vaVFKWE1DZlNSU3piY2VZb3pjcFR3YzBZNUZEZ3o5Tmt3MWhHK3loR0RrQ3IxQlA3WWRxaFM0a0FmV2JLUjd5VE9iSE4raFptTUpNNU1ERGFTSTc2dU9GQWx6OElmKzRBS0JWdG9KQStzR1dzYlo0NEp2eWc1U2pTc2pJMXdiT0hMeE1halNnWCtSd3hNS3JRUVVDRWFqVmVMd2NqQ0pXZk5XbWVFTTl1TVgyV1doWU9hczNIWk9CVDRPcnRMbFhiNG4yaEZoZksrQXdYU1JTY3dYSyt6S25EQjJidDhFU3d0TklyTTVKY1pYUnVOS21QRDIwdDhtYlBQcWRBSy8xT1ZWR2dnb0lDOUNQa2ZNK3lOQk01RmEvNWhKaFVhWWhYeU5hTmNyeGVMYm1Md0RXTWdVQk1ETnN4VmhLOFRDNFBxOVBBLy9ZVHE5QW9vSUNZdVg3ait6TVlaeDE0YS9NOWg1S0N4ODAxZU1PTnhaWW4vV01WbTdmR1ZQRVdqbjdOeFNIR0ZZVXgxQXZ6UDBhTXl4ZzRxMkYyZUtTc0haOFNvMjRtN0c1enJaN3pneGpzTFo2cUY0ZkxDMmtITjdyTGhEM0dOWlVoMUtnQ1FleXJqemxPb1VIUjRMaGtLL0pVMUMzZ3VtUGR4U1c3bklTOXNVUk1UbDQyTndCWHMyS1F5VXdBUVl5cVQ3NkZFMGVHRllCTGhMK1FvNXJsOEVPR05hT2J4M01GQ2JSaXpzWWh3aloxQlpXWUFFSzJwaXJHT29FU2E4SUxwTGxOOHpGNjRQSlB2OFI1NzV2R011ME10bmJQUnMzR1ZIcFdaQTRCOW9DcnhFV3BFYTc1aXJDdDhxSi94VEw3RCsreVp4NGJaaTNBaVppNXJmb1dyREFPcUVnTkFGVk9SY0NtZ2hDUDNQbDhKVmpZK0lLY0JHOTVHNGdQMkttVERHNkcyOTFseis3ak9rcXA0Rm9EVW94cG1YRUdWYU9EemxXQnA0MzNXekdTamErTkRSV3l5RnM1UUd5WnM3SENkS3FZaVFRR2djS21HTVlFNjFpYm5LOEV5d3J2c2tvM09WdUpEY3VheVp2WUVUb29ERzB0Y1IrNm9TRGdDNUphS1pBSUtpV05wOEpJeHR2Q2VJbWRqRWVFdnFweU51TUNKUFdkampTdlpCNnBoVEFDNW9ScG1IMnFKc2NGTDNsVGlMV2ZFaGovRlg0M1p5S2M0c2Rac2RIR3RyVUVsakNVZ3gxUmpBZVZHdnNrTGNZRzN4SmlOYklpL09wcXNlUVBVVmlackphNWxMMXlxNE00QnNhQVNmZ1QxdHBuTEN3Y2JiNGcxRzEwYmZ5VUMxb3dWYWt1WHRSNnV0dTFRQlRPVEVDVlZNQ1lTclltcTM3Y2xHazVSaHJ6UXRmR2FOV2ZObmVFVEpSdHppWk5aeUZxR3ExbkxrQ3AwSW9pRUt2UnN0SFljekxOc3ZiTnhwbHFIUEdlT0pWNnhEcXdGQTN4aXdFWnA0V1FRc0piZ2V2Mk1LdVFGckp3S2VIdUp0dlpKU0pKK2Q0c3o2VHJrdWM0UnIxZ1phLzRPbjlpelVVWTRHUVNzOVhBOU9mQ29nRCtFRlZLQnRZMjJwam4vY09OeGhVYTFEbm5HTFN0Y3NoTFdPaU44WXNQR29jTEpPR0N0eFBVYysrQ3lQWDhFMjJSN25aRkVXd2ZXZ3JLUGh0MDFlTWFiNEpLVnNCWnY4WWtCRzRjS0o3T1F0VGx1c2ZQWW5yZEhud29zQmRvYWVteTQyUkNOS0RQWk1KTWhMbGdKYS9FV241aXhVVm80V2Jxc2RYRUxNWGZabXJmQmlPMWxRN1EyQ1hrdU9hSmhoenhqckN5Y3N4TFc0aTArc1dUTlhhTzJZbU9CbXhRQld3c0cyTEMxY0l6Mk5pRXY5UG9PYXNlUVorS1J4QmtyWVMzZTRoTkwxb3dsVHV3NUcyUGNac25Xd2huR2JNdnRwV2p2NlBGU1dValVKaUViNXRyR0dTdGhMZDdpRXdQV3ZBbE9paDRiZTl4RytHd3JYR0hCdHJ3TlZDajVTdGRHVFhSNUpwOUtOS3lFdFhpTFQvUUR2bkN6RkNmYm1EVnppQnZ0RExaa3JERm5TKzdjZ2dyYm5LK3NMSnpJWTg0elhSc05LMkV0M3VJVFlzMFgzZ0MxbmNkYWtPSkdzbVJMN2h3OXR1UU5vY1krNXlWaklIRWl4aUViM2xTaVppV3N4VnQ4d2tuWFB2K1RqeXVjaUpuTFdxZkNqWnlqejNiTUVnbGJXa0VSWjlyakpXK0RFNmZvOGN6YVFzMUtXSXUzK0l4amIrWjVrSFJIRm1wVmw0MHl3cTJzSlZ2cUlXWTd2ZzFWWkxIZ3BmeUlFN0h4MlBEN3FGa0phL0VXbnhOVmYxaFVFbzEreHNiTXdxMmNmc0oyZXVpd25SM1VjYXlKejNOdUdlR2tLTmt3Wnc1T3JJUzFlSXNiT0ZPUE5YY3FjVE14WVRzOTVHeWxKNkdTbkhaNExoamd4Tm41Yk1RU0oxYkNXcnpGRGV5RnlWcmVSd3ZGZ2EzMGtMTU5vNDkycEJCQzRzd3VOM2ttN3VNa0xVMDJkaml4RXRiaUxhN245RHRzSEZLMHNmSFlSZ2FmTFpnckM2MUVvL0ZxZHJRbEdoT2ZaNEtad0F0bjRyRlI0c1JLV0l1M3VKNFlzK0hPTExSaGQxMjJrTUZqQzNrZnJWUXp6eVREN3RaQ1l4RHdURExFeVRCaHc3UHd3a3BZaTdlNFhwV3drVy9SempSbkN4a0MzaTRjVzJnalhZZjhqNXRNSXRURXltVWpHQXU4c0xvR0d5TzhzQkxXNGkydTVreGNOc29VN1ZnTGc3ZkxZUEIydlFLdHpBSys4R2NSYW5iR000Y0NKenVQalJWZVdBbHI4UlpYaXpJMmdyRkFTLzBPYjVmQTVjMjhpVUFyR1d2QldLQTI4dGp3ZGhJdjBwaU5CQytzaExYT0NGZWJHR3pFVzdRMk0zZ3JNNEhMbXdVYnRCT3k0UTFRczlac21Hc2JMMlRYWmMxTDhZZlZZODJiNEZwRG53MWpIYUcxY2NpYkpUQjRNN05NMFVySU05NEFKMDQvWnFNenhNa2taQzNjNFErclpNMHNDMXpIbXZPTXYzUFFWcHFZdkpXWklPVHQzSTFFR3o3UEdVT2NXRE0yekluQWl6Umd6VmpoRDdGbXcrMVd1TW9nNUptc1FtdXJrTGZMRUxDRnBFQWJKYytaYzRtVFlZZU5kWVNUSG10bXo4SC95STNKTTBGY3JqYUZrQkpmNEd4em5na0dhRzBiczRVTVB0dVlDYlN3TkhndTJEaDRVYzNaNktRNFdiTFJxZkJINGZFMUkxc2VMWWxQVmFYTGhwa1VhTXRhbTJ3aGc4ODIvRDVhS09ZR3o3aTlDaS9FMkdCajZPREZuZzEvaEQvc2t1L0lWME9KVDFpemdHZUNDZHFTdTV4dFpNalp5bHlpaGY0NjVCbHZncE50aDQyQnhJdVVqV0NNUDhRazRIdVNQZjdPbXVROFYwWm9xNXF6bFI0NmJNVWRvUTE3YkxEaHppTzhxT1pzZEFWZXlJQTFZNFVYeFlIdjhzZjRHN0h2OEp3L1JGdGlFckNWSG1LMkUwZG9ReTU1cGpQQ0N6a3pXT3RZT01sWWM5ZDRJVFkrMytWTzhERTVpbmxoaHRhS2pPMzBrTENsR1ZxSlNqYU1HVjQ0RTQ4MXc4YkpuRFZ6anBOb0Z2QmQrUlFma2RzT0w1UTIyaEl6bDYyWVBmVFlrdDlISzBYT3hscmd4VDVuSThYSmlvMkR3RW0wRFBnZU55dndnYUhQQzBtQjF0S0E3WmdsNW16Sm1LTVZ1V1pqYnVQRk1HR2pqNU1CRzcwSUo0NllCSHhQTU1iN2hpRXYrQ09KdG1TWExibHpyTmlXUDBVYnpwU05Nc1dMdE1mR0VTZDdOcklVWnlhaHlYY2tCZDdoREVOZU1HWVdXaHV5TFdPTk1WdnJXV2dqRFZuTCtuaGhsV3lNY0xKbEkwdHhybGg1b2N0WFRHK0R0K1RXNXdWallhTTFrYkN0Y0lVTlcvTUdFaTFVT1d2SkVDL2tuSTBwVHJac1pDa3V5UDVnSHVkK1lQQ011eEI0VFl3NnZCQXVLclEzWUd2QkRDTzIxeXZRUXVXemx2WHhJaXJabU9Ka3kwYVc0aldSYmpmalJSYXkwU3Z3aXBqR3ZCQ3VLN1NYK213dEdLRFA5c0taaGRzVkJtdTlBaStxQXh0VG5Help5Rks4cjk5MVdldU1jRW1PRWw0dzVnWGFFMnVYclhrYjJHelBqSSs0bWR5emNVanhvdWl4TWNMSmxvMHN4ZnVjZnM2YXY4TUYyYzk0d1N3TEtERHkyWjYzaHhXeVBYZGw0MVp5eWNiY3hvdCt3c1lRSjNzMnNoUWZpRXJXakFFdTJIT1hGdzRGRkxEbkx0dnpSN0J5S2hCc0pXNWt4YXk1SzRrWHg1Z05HeWNETm5vMlBoQjFXVFBIT0NlV0JpOGNLcWd3OGFpQVA0UklxRUlaNFVZVGx6VnZncE9kejVwbjRXVEZSaW54Z2FqTHhoam5oZ0V2OUNxb1VQUk1LcEFYRUNXVjJFdmNwUExaaUk4NEdSdXN4UlpPdXF5NVhYd2tLbGt6QmpnMzU0VXNoUkpqbHlwMExJZ0ZsZWhFdU1tTURmTmc0MFcwWm1NdWNKS3hGaTd4a1RSbXpkdmh6SlRuM0t3UEZaeGhRaFhNREpCanFqSERUYnBzQkFPYzlIdHNMQVZlU0krMVlJRDNSZW1DamM0SVorWTg0MlpIS0JFdHFZUTdCK1NHYW9RRmJsR3laaVlGVGtZZE5qWVNMMUkydkIzZUVzVnh1dXp4VE5aSEkvTFpjSk10bEpDam5FcTRTMEJ1cWNoYzRBWnIxb3dsVHF4eHlGcDRkUEJpejBZK3hCdjJvT3k0UEdkMkl6U21CbXRtdm9NYTBaeHFHQk1BZlpkcUdIdmNZTXBhM3NkSjBXTWpxWEN5WkNPTzhGbzA4L2hLT0pab3JGeld3cVVGSmVRdXBCcmhDRURxVVEwenEzQTlxK1FMY3lYd3docUViS3dpblBSWWN3OE9YaEU3ajYvRlI1dzVtRHd4NHdwS09DS21JbUVCb0lxcFNEREREZEtNZjVRMlR0S01EVzhrOGFMeVdETldlSzNLK0ZxNEVqZ1RzK2F1b2NpWXFnUUNnTjJqSW1ZeXhQV2NZaDZRekFZUlRzVFlaYU5YNEdRWHNoWnU4RnBoOExYOGlETld6cG83Z1JwVlNGVTZBQkROcVlxN3dDMUVmekxwQzRsYTFHSERuRms0V2J1c0JVTzhJdmQ4TFJ3NE9KUDZyTGtqcUZGU21RTUFXRE1xMDVrNlVHREFNL0VSSjFXSGpRU3ZPWDJYbDR3Rkx2Ujkxb3dobEpnYVZHWUpBSEpuVXBtdWpmWmt3b2E3dHZIQzJYaHNqUEZHbGZHQ044T2x2cythTVlRS1VXWlNtVDMrY3d5b2pMOFJhTTNtbVh5UEUzdnVzdWIyOFlZMUM5a3c4Z2xlNmZ1c0dVTW80SXdEcWxQaFAvMkU2aHhTdEZhd1lYUnRuT3h6TmhJSGIxWGRrQytNZURFU2VLWHZzMllNb1VBUlU1M0F3WC9Ta3VxRUE0RzJSTUJhUHNKSnRERFltT0Vkc2xqbExrbUcyWElVNFkyK3o1b3hSSHZXS3FRNlBmeFB0S0pDZVlIV1NwNkVpd2dubzVnTnI4QjdISHMwWHM4WHMwMC93anY2UG12R0VPMk5PbFJvaGYrUkF5cGtyZ1RhMmh2OHcwejZPTEVYQmh0ZGlmZEp5NjVzUytKZGZaODFZNGpXN0xWTGhmYjRZKzlSb2JDUHRxSTUvL0QzRWllam5BMWppMXYwZmRhTUlWcmJlMVFweFIvSG1DcjEwSllUVFdLUzdBMGxUdXl1eVVZWjRSWjlueldqajdiUzBxUkNuc0FmeFlGSzdkQmVOQnBNdGhJMU9RM1ljRGNDdHpqNnJCa1ZXaEliS3RVVCtDTmFtRlRJOUNNb0Y4MTVwcGZpSmlPUE5jTkNPMDZSVUttWnhJdUJRWlhjcFlSaVR0OWpJeHhZdU1uZVl5MTAwSTZZVVNsekpQRmltbE1wZndqRjVJQm5EZ1Z1TXdoWTg5RlMzNk5TWG9xVGZrYWxqRzRFdGVTU0RXOGljQk14ZDFtTDBWSkp0WG8yVHFJNTFmSjNVRXZ1V0hQTEZMZnB4MndjME03VXBWb3JDeWR5R1ZJcHQweWhsRk40UFBFM0VnMXhITXdtUjRHdm1IaHNqTkZLMUtGaUc0bmF6cWRhd1FCS09WR1hMNHkxalVaLzdnZWgxMW1tK0p3OWQ5bW8wTXJNcFZyKzBFRnRHRk94ckErbG5IN0MvekhqbzRQYXRPT1NwR21zYlh4cW1yT1JPR2lqNzFPeFhvR0czYU5xTXdHMStnZkQvWCtIQWcxNzd2TEZLc0lucWpuUHpOQ0dNM2VwMk5yR21WVkl4VHBIQ2JXczZYSzkzT0hjUHVkSnNKUDRLN25QMlRDR2FHUHZVekYzSUhCbTUxRzFSUVRkbkpuQldsemdiNXlpNUpuTVFndjJnYXJsVzV3ck9sVE5tMHBvWnExNTVtRGpMNktsd1lZeEZyaWRHSGhVN1ZEZ25DaGRxdGFMb0ptMWNIbG1HZUZEWXVMeFRGWTR1RjIvUjlYY2xZVUxZNE9xbVJ2b052RjR4bHZhK01nbTU1bGdJbkE3YXhaU05XL2o0TUl3b0hLNURjMzZDYytZM3FMQysyWTV6eDBLdEREc1VEVXpPZUtTU0tqZUFwcUppY2N6WnJCTzhRNTdGZkNjdnhHNFhiUndxZHpjeGlzcnFoY2VvWmxZR3p4blpIc0xyeDNuSVMrVUtXNG5qd2FWQzhZU3I0eW9ucGs1MEt6djg1WGVTRHFvT1U2L0cvQlNaNFFXb3BMcTVWTzhadmxVTDlnNDBHd1Q4clZ5UEtyc3lQcC9VVHFaZTN6RjM2Q05IZFV6c3hSdkxLaEJYRUczcGNzM3pEQXV1K3YxT2pQNGhyRzIwRUxVb1hyR3dzRWJJNFBxQlRNQjNib3VyK0NXTnRwWVVUM1QyK0V0SzZZRzhSRzZXVjJEWDlmcG80MStTUFhNT01WYmNra053a1VFM2V4RndLK0twMmpES3FtQjI1VjR5em1HMUNDZlFqZVpyZ0orVGJaRks3dUFHb1Fidk1mT3FJSFpyYUNidEFjNXY2THNTN1JSWlNZMThDdTh4NXBSQjJNam9aMFlaUzQvRTY0TEI2M01RdW93ZC9BZVoraFJBek5Mb1o5akwxMytYV2NTb1oxaFFpMDJlRjk2b0JZRGdlOXdMRU9YSHpIOFpZcVd4TXFsRGthRjkxbGpnenJrQmI2RjNNMTlnKzh3UTM4eFJGdHkycUVXWFh6a0dGT0x0WVB2WVkwV2lXL3dnaGwwZXNzUjJyTzcxTUxZNGlOMjE2UU94aERmeEJIRmJsbG1IYzhsWFNQdzh6anJqcmUyUkh0aTQxT0xUT0lqY3VKUml5VENONnI2bzgxNE5oc1BKcnZwYUJoQmpiUkhQUVlPUHRUUHFJVTV3S01UQTROYTVBVStKcFlodGVnVWVIQ3BUejNXRnY1aTJxRVd4Z0tQelZsUWoyQXE4UmQyejZRVytRZ1ByZTlTajE2S3Z4b0UxTUlzQlI2WXpLaUhPN1B3Vi8zWXBCYitSdUp4VGFoSlBNUW5WZ2IxT0JSNFdGVk9QWXhWaEU4TWZlb1JqQzA4S0xFeXFFZG5oTStJT1RYSmhuaFF4NXg2R0dzYm54cVoxTU5ZUm5oSVVkZWdIdm5Pd1djYzBhTW0zbEhpRWUxODZ1R1dGYjVnUjEyNkVSNVFXcnJVdzVzNCtBS1pVQk4zNnVEeERFTHFZU1lWdm1SZ1VwTkU0T0gwTTJvU0R2QTFka0pkeG5nMDFveTZ4QlcrUmd4Q2FoSlVlQ3p5MktFbTdnUmZsZmFvUzFmZ29VUnJhbUltTnI1S1REeHFFazd4U09RMG9DYmhIbDlYbE5URVBkaDRJQ0toTHFXRnJ4TWJuNW9FQXp5UWdVdE52QzJ1a1I2b2labjE4VEFxajdwMEkxekQyZmpVeEZqaVlheXBpejkwY0JYN1lGS1RlSXNIc1EycGlibUljS1ZwYmxLVGRZU0hJSG9tTlltSHVKYTFOcWlINmU4bEhvQWNCTlFrWEVhNDJyQkRYY29VRHlCTnFJblo2K01HTTVONm1PRkc0TzVaeTRDYWVHTUxONmdTNmhLbnVIdmJtSnE0WllxYjdFeHFZczRrN3B5OU1LaUp2NUc0aVZWU2w2Q1BPemYxcVluUnRYQ2pvVWROekJMM3JacWIxTVRiNGxaaVNWM01LZTZaM0puVXhKM2hkbFhQcENZZGdUdVdadFFsaVhBN3NmT29pVHVUdUZ0aVRGMkNFZHF3RnlFMThmdTRXNFZQVGR3bDJoa20xTVJZVzdoWGMrcVNwV2pIR25qVUpKL2lUbzBNYXVMdkpWcXF1Z2IxY09jVjdsSVVVeE56RWFFdFo1UlRFMitDdXpSMnFZZVpEQ1ZhRStPQWVwaUhQdTVRdjBOTi9KMkVBckxyVWc5ekxIQi8xZ2IxTUJZUmxDaDhhaElQSGR5YmFVNDl6RjRmaXV3RGFyS0tjR2VpdVVrdHpNNFV5aXdONnVGdEhkd1ZNZkdwUnpBVFVNWXVxWWQ1c0hCWGlnUDFjTXNLNmpqYm1IcTRPOXdUYXh4UWozZ0lsY1RHcHg0ZEczZWtuMUNQY0FlMTdGVklQWmE0SDlIU3BSNUxDMnJKb3FRZVllZCs1QUgxbUVkUVRSNFRQdDBvU2FIQkxqZjVkQXQvS3FHQkhBZDh1a0U0aTZDRjNYWDVkRFdqbTBLVEl1UFR0ZHplRU5vTVl6NWR4K3pzQmZUWjVueTZpamV3b0pIY0JYeTZnckdNb0pVMTQ5TVYxaEgwY3FvMW43N3NZRUc3NG1EeTZVdk1ST0liSEJPWFQxOFIyL2dXKzlqbDArYzZmWHlUWFc3eTZUT2RyWVB2c3ZQNTlJbk9WT0w3N0FNKy9WVytFL2hPMDVCUGYrRnZMSHdyWjJUdzZVUGh4TUkzazFPWFR4OHdCd0xmYisveTZWM21EUC9FeGpQNTlGWTR3RCt5eVYwK3ZlWlBCUDZWWGV6eTZWSytzZkR2N0JNK1hlanNMUHhMMjR4UFp6cFRnWC9LNmZmNFZPdHNKZjYxb3N1blA4eWs3K0NmYyt3bG4vNm50SEVYckpuTEozSWxjU2ZFd0RmNTJ4bGpnYnNoZDdITFg4MzBCaGJ1eVRReCtZdTU4Y1RDZmRuMlhQNWFSbTl2NGQ3MDF4NS9xYkE3RkxnLzlxRERYOG1mcGJoTDFqVGhMNVJNSTl3cE1Td04vamJ6Vk9KdXlXb1Y4RmNKbHhIdW1wajRKbjhOTjk1WnVIZmJYc2pmd1F6S0lSNkF2ZlQ1RzVpZFdZV0hJSGRaeUIvUDZFMEZIb1FjTG56K2NQNmlqOGZoMklQRTVROW1KcnNJRDhVNnJrUCtXUDVpS1BGZ1pMUkorRE81MlQ2U2VEelNYdkFuQ3BhcHhHTnlwb25MSDhaTlJuaGc5c3AzK1lNWTNpekNRN09tcGVmeWgzRDk3aFlQejk0Y0F2NEVwbGR1TER3K3h5bkdtY3VIRi9iR3FjVFBJSWZMbUkvTmpKZDlDejlIdEYzN2ZHRCtZaGpoUjVIMmFCN3dRWG5kWVlRZlIxclRuc0VIRkpiYnlNSFB0SXROUGhnMzJWdjR1Y1FnRGswK0RET01KelorTktjYVo1N0xoK0I2eWFEQ2p5ZlRTWm03dkh0R1hrNHEvQTdWdmh1YnZHdEdaNzJySFB3YTltaVZHTHhiYnJ3YTJRNStsV2c0T0hpOFMwRnZOb3p3NnppaW1pNXlsL2NtWDA5VEM3K1R0TkpCeG50aVpJUENrdmpGSEdmVURYZ25qTzVXT3ZqMW5HcFMrcUhMZjhsMFEzKytxZkQwaDB3bjNZNW44Tjh3RFMvdWJpb0hUK2VLelNMSlE1UGZMY2l6eFM2VmVIcERGdnZaUFBGTWZodlhTK2JqYWVyZzZRT3lPbTRXdmR6bE4zRHp3MnB6dENXZS9pNHFSb051NXBuVXljdldnMjFoT1hqNkFrZll4WEd5eUFMcVlIclpZak1zYklHbkt6Z2lzdFBwc3VkUkthKzNuS2EySlJ3ODNVQktZUlc3VlMrZ0FrRnZ0VStGa0JKUHJWWFQyVHoyZ3RBd1hKTlhNRjNYQ01PZ2MxanVLd2RQYWxuRmFMS2NaNTNjOXowdkNFUEROZmtPMHpYQ0lQQTgzODg3Mlh3NUdSVUNUL3JJcUJpTzlwdkJiTFdlbDczL2wvMi81UDlsLzYvMy84cjVlalViYlBhallXSGg0ZndmQmc3QWhxQlo4QzRBQUFBQVNVVk9SSzVDWUlJPVwiLFxuICAgIGxldHRlcl9pY29uOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFYa0FBQUY1Q0FNQUFBQk4zYW9QQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJ3WVdsdWRDNXVaWFFnTkM0d0xqRTNNMjZmWXdBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBSEpRVEZSRlIzQk1OenhQUEQ1Uk9EMVBOenhRT0R4UU9EeFFPRHhRT0R4UU9EeFFPRHhRT0RsUE9EdFFPRDVRT0R4UU9EeFFOenRRT0R4UU9EeFFPRHhRT0R4UU9EeFFPRHhRT0R0UU9EeFFPRHhRT0R4UU9EeFFOejFQT0R4UU9EeFFPRHhRT0R4UU9EeFFOenhRT0R4UE9EeFFPRHhRRk5XeTVBQUFBQ1YwVWs1VEFDb1BDUEQ4ZjhEZ1FOQURNU0JmOWhWUG9PdXd5WTl2MlpobU9SdFg1b2UzU0NWM3A0dnJ2ZFFBQUJndFNVUkJWQmdaN2NDSlFxUEtGZ1hRbmFLS1lwNENDWmtuOS8vLzRudnRGZFR1ekJ5VWFCWWVRZWc0U21WWnZNam43cXlzcXFEMjFtT2RHcFBxOGRxcmc4cVdNM2VlTCtJc1U4cHhRangxNVdUeEtQTHp1VHNySzA4YlhxSzlxcHk1ODl4ZmpQYVpnNmQ3aE10b04zZG4yOHJUdkZucUJiWnc1M20weE5NdFZKUzR4YmJ5TkR0SnZXcGJ1S3ZJd2RNVndtaGVWTjQ0TlpTUmpyMXFsb3djUEowUmp1YkYyaGlLTThZcjVuczhIZUZrY1Q0TDJLdGdrdTh6QjAvdjFHaDNlS2tOZTJmcWw0Ty9WM2o2dzRtU21WM3p5M2gya2tRT2ZyMTlVZ1Jqd3k5bDFrR1J4Q0YrTVpVWG5qYjhCa2JYc3p6RXJ4UTYwYVRtdDZvM2tSUGlsMUg3cERUOGR1TXlHU244SXZGdVVxVWNCRk5OOHIyRFg4R0pwcVhINFREZTFsM2dGL0JudGViQTZIcTJjL0NqT1htWkdnNlEwZHRjNGFkeTRyazFISzVxbmpuNGdWUzBDVGh3Z1JzNStHR2N4U2JnOEtXVkcrRkhHVzJDbEE5QkI0Y1Jmb3pzVUtkOEdHazlYZUpIVUVuTkJ4T3NIRHk4ekM5VFBoeFQraGtlbXZKbkhoL1NlckpRZUZoT05BbjRxRXl3aVVJOEpuV29VajR3SFV3VkhwRnZVejY0MVBwNE5PRnl3NTlnN2NZaEhrbTJzb1kvZ3RudUZCN0hZckxtaitITm9oQ1BJWnNIS1g4U084L3dDS0pTODJjeDR5TEc0SVc3bWo5UTRHUGdscHMxZjZUVXpVSU1sMXFVL0tHTWVmRWRETlh5RVBEbk1zRlVZWmoyaGVhUHRwNHRNVVRSMXZDSE05VUNnK1BzYXY0QzQ1V0RZY21tS1grRjlUVERrTVFielY5aVBCdGhPS0lYelY4anRUc014YTVLK1p2VUNZWWhNZnhseGxNSDMwKzVLWDhkUFZuaXV5MG5tci9SeXdqZmEvK1M4bmV5UHI1VFZQSFhDbGI0UHRHYXY1aTN3amNKRjJ2K2F1c2MzOExaQmZ6bHhqbStRWmdIL1BYMENsOHZEL2hFUGNWWFczbDhJcWtQK0ZvcnphZFg2UnhmS013OVByMUo4eEJmeGNrRFByWEdPM3lSY0JmdzZZTjFqcSt4Q1BqMFNaM2pLMFJyUG4xbUFoLzlpOVo4K2tjVm9XK3g1ZE1SWll4K1pZWGgwekV6aFQ0NXJ1YlRjVE1IUFpxUCtYU0NjVVAwSnRkOE9tbWRvQysrNGRNWmRSNmlGMUhGcDdNQ1AwUVA0cGVVVCtmWkVlUmxFODJuQzB5aElNMlphajVkbExxUXRrdjVkSVUwZ2F5b3BqVGpmYjkxU21tMUgwTFFma3R4MjJqMDdYeExhYVljUWM2eU1KUzJ6dkg5d3VtWTB2UkdRWW82YUlxYlpSaUFyRFNVTnA1RHlpS2d1TnJISU93MHhkVWp5RmlXRkdjbUNERUlCZVZ0SFVnSU41UVhSQmlJZUUxNUd3Y0NkbXVLTXdjTXh0eFEzSGdWb3JPb3BqeWJZVEF5UzNIR1J1Z3FLOW1EQllZanpNY1VsODR5ZEJQT05lWE5RZ3hJVmxEZWVCV2lrMFZBZWVzWWc3S3JLYy9HNkNLYnBCU1hIaHdNaXBxbGxMY0pjYjl3dGFZOE84TEFSRFhsclhlNDM5SlMzbmp1WUdnTzdFRVE0MjRiUTNrMncrQ29nUExNQnZmeTJZUHhDZ1BrRzhyemRyaVBzdXpCQ3dhcFlBL0tHUGR3RGlubHJTTU1VdVJSM25ydTRBNVJ4UjRjTUV6T3dWQ2VqWEU3TlVrcHoyWVlxS2lpT0pNZVF0ek1EOWlESFlZcW5HcktxNWU0VlRhalBGTmtHS3lsWlE5bUlXN2tlNVRuN1RCZ0swMTVxWS9icUpMeTBvbkNnRGtsZTdETmNKTWtwYng2Z1VFYmpTbFB6M0dMcktZODQ0WVlOcGZ5ak4zakJnZjJZQjFpNEZSRmVlTTVyamVxS1M5ZFllakNWVXB4eG81d0xXZVRVbDZKNFZ1K1VKNmVPN2pTSXFBOGI0RUhrSHVVWjJOY1IyMVN5bk1kUEFBMU14U1hUbkdkS0tDOEtzSkRXSGlVVnl0Y3c5bFFYanJGZzlnWXl0dmdHbkZBY1dhN3g0UElQTXBiTDNHRk9lV05FenlNM0ZEZUFaYzVsdkplRkI1SFNYbFZqSXR5UTNrUkhraTBwcmp4SEJlVmxMZkJBd21kRGVWdGw3akFUeW11eG1PSktvcno4aEJuT1RORGFUckJZM0VPbXVKbUdjNkthb29yTXp5WXZhVzRlb0d6cHByU3ZEekVvNWxyU2pPdWd6UGlrdUptQ2cvSDJWSmNwWERHenFPMDJzZmpDU05EY1N1Y3BpYVVaaVo0U0J1S0swT2N0SzhvTGRqaklXVTFwYVVSVGdtVGxOSVNERmZzLzErRTQ1S1UwaVk0eFNrcGJhdHd6TlMrVWZnV3ZsdFl0clNkSkJIK3Npd3B6ZHZqaE1oUTJoNUhhYjV4OGVWVVVtcit5NXRFK0NSZlUxZzZ4d2tUU3BzNE9DWmh3OE1YaXd2TlV6eFg0VjFXR01veVc0V2pWRTFod1FoSFdiWnlmS1hZOGl3OXhUdmZvN0I2Z2FOeUN0TUhoV01pdnJQNFFxN21KVjZPUmpnemxLV25PS3FnTUx2SFVRVS9pUEZWZkkvWG1DaThpVDNLTWtXR0kvWWVaWTNuSVk1Ui9HaUNyNkVLWGltSThHWk9ZVldFSXhKTldSYkhUZm1SVnZnS2tlYlZkSVEzbHJKMGpuODVoYUVvdmNOeEhqOUo4QVVpelJ2b0NQOVphTXFhS1B3akNpaHJodU55ZmhhZ2Y1SG12enhyWGRlMWxrY2tlT1ZNS012RytFY3lwcWc2eG5FbC8rS2pid24vVnVZS3JUZ3BOZjhTNGRXaXBpaTl3OS9VekZCVWd1TmkvcTFBenhKK0Zrd1YvcFo0L01SVCtNTnhVNHJhaFBqTHlGTFVkb25qSnZ5SFFxOThmdUw1T01yMytGR0pWNk9Lb215SXYreldsS1IzT0VIekh5NzZwRFEvbWlpY29DYjhLTUdycWFZa0UrTXo1MEJKcHNod1hNS0dac05EbjBwKzRQazRJOWQ4cHhYK1VKYWlwdmdzZTZHa2VvY1RBalp5ajQwYy9abnlnMERockVqem5ZdFh2cUdrTFQ2TGF3cEtKd3JIUld4NGNOa28wWnRJODEyZ2NFR3MyZEl4WGhXVXBKZjRKRGNVdE43amhJSU5GekZiTWZvUzhGMmdjRkdrMlNyd0t2TW9hWVZQWnBRMHhRbUtMUVVVYkV6UWs0VHZBb1VySkd6b0tmNHpwNlFaUGdvRENncHdpc3RHQWNCblE2TW5IdDlGdUlybGYyeU1OMHRMUVhXR0QwWVVwSGM0eFdQREJ3Q1BqUVM5U1BqT3hYVmkvdUhsYUlXck1lV3NmWHd3cGFDWmd4TnlOZ0w4TVdValFDOHNXd0d1NVpLY0tIeVF2UmlLMFZOODhFSTU5UUtuV0RZUy9LSFlpdEFEbis4aVhFdnBJTUpudVVjeFpoYWlGYTRwNStEZ2hKZ05yZkNxWUtOQUR5eGJFMXd2d3QrY21hRVlHNk8xTUJSakk1d3lZYVBBZjN5MkZNVEZmQmVqay8yWVlnSWZyYW1oRkQzRktVcXpFZU5Od01ZVTRxWnNsZWpvUURIakJLMkNVc3gyaVZNU05pd2FDUnNleEZtMmZIVGtCSlJpWEFkdlZFVXBhWTZUQWpZU05KUm1JNGMwdGp4MHR0T1U4cExoVGVSUnlvdURVM3cyTk40VmJKUVE1clBsb2pNMW81UnFoRGZKbUVLTWc1TUtObHk4aTlpS0ljdGx5MGQzQzQ5QzFqN2V1Q2xsbUNsT2l0bUs4VUhBeGdTeUFyWWd3TmtZQ2xuaFAyRmhLTU5tT01sbG84UkhDUnNhc3RpeWtCQlZGT0k2ZUxYY1VvWmVoVGpKWThQSEo1cU5CSklpdGx4SUNBK2FNZ3FGVjFGRkdTOFpUa3JZOFBEWmhJMEFrbnkyZklqSUxHVlVHVjd0UElydzhoQW5XVGFtK0N4bUs0SWdueTBmTW5MSzBFdThtbXRLTUFWT2k5bFMrSXRsbzRBZ2x5MEZJU1ZsTFBDSDQxSkVIZUcwZ28wQ2YwdlkwQXB5WExZZ0pSNVR4QngvWkRPS2NIR2EwbXhFK0lkbVl3bzVMbHNRYzZDSUdmNkl0NVFRWkRndFlTUEF2MXcyUE1peGJIZ1FzNndvb2NJZm80b1NmSnpoc1pIZ1h6RmJQc1JNMlBBZ0prdzBCWXp4UitSUndFdUkwM3cydE1JUkpSc2x4TGhzUWM3eWhSSXlBUEExdXh1UGNFYkJ4Z1RINUd6RmtPS3lCVUdyTlFVc0FDQm5kK2xHNGJTWXJSaEhlV3k0a09LekZVR09VeGgybHdBSTUreXVpbkNHeTRiRmNTNGJHbEo4dG53SWl0YnNiZ1BBY2RtWlBqZzRRN09SNDdpWXJRUkNJclp5U05xd3V4S0FNMk5uVllZekVqYTBmNHBsdzBJS1d4TklValU3cXdHb2tsMmxLNXhqZVpNSVFqdzJBb2phc1RQdEFLcGlWMXVjRS9FMkJZUk0ySW9oeVhsaFYra2V5RHgyTkk1d1RzSGJhQVVaT1ZzSkpJV0xOVHRLRjBDbTJaR0xjNVRtamFZUXdsWUpVV3BqMkUyNkEyTERicW9senBueVZoNkVXRGEwZ3FoRndHN1NGYkJnUjZzUTUzaThtUThaVTdaY2lBcGR6VTdNSE1qWlRibkVPVDV2VjBCR3hKYUdyR1hGVHN3Qm1MT1Q5UXBubGJ4RERCa2VXd2xrSllaZG1BM2dzZ3RUWkRnblprdmI4enkyWE1oSTJQSndnenpHSmFGbEYyWUd6TmlGdDhCWkxsc0Z6dlBaOHZCWjRsNGo4U1A4eFdOcmlxc3B6U0xHQlNQTkRzd0xVTEtMVFlpek5Gc1JMdkRZU3ZDSjViVnNvdkJCd3BhT2NTMlhKSXNZNTIzWXhSYW8yRUVhNHF5RUxZdExFcllzUHJHOG5wNG92Tk5zQmJoU3pGZmFWVGhuR2JBREMxUzhuMW5odklDdEJKY296VmFNanl4djRmbG91WHpuNGpxV2I3U3JjRm80VDNtL3lrSEErNVU0TDJKTDQ3S0NyUUlmV2Q1bWdvYlNmT2ZqR2duZnhUZ2pMbm0vU3FIbTNkWSt6aXZZbXVDeWlDMnQ4SUhsalFvMEVyN1RFUzdMK2M3aXJHVE51MVVaUE41dG8zQ1c0cnNZVjdCc0pmakE4bFlGR2lYZjZRaVhSSnJ2WXB5VnZSamVxMXBpelhzRkM1dzNaY3ZpR2dsYkhqNnd2TmtFYjVUSGR6ckhlYm5tdXdJWCtHdmVxNG94NXAyTWl3czh0bkpjUmJQbDQ1M2w3WHk4OGZsUmduTVNmcUJqWERMaHZZSVJOTzlrOXpndlo4dkRkVnkyQ3J5enZKMm44TWJsUnpiR0thcmtSeTR1eXRhOFV4VWg1WDMwSEJlVWJMbTRUc3gzTVZxV0RZc1RsSjhYL01SRkkrQkhlb3JqcHBvZmxiakN5dkErd1FLRzk5a3FuQmZ6WFl3cmxXeTVhRmsyTE01UUpUL1FDbTlVd0UrQ0JQOUtQSDRTS0Z3aDNQSSt3UUtHOTdHNFlNSldnV3ZsYkhsb1dUWXN6a3I0Z1l1R0N2aVpMbng4bEJlYW4ra1kxd2hMM2lkWUlPVjk5QXBuS2MyV2o2dDViQ1ZvV0RZc3pzdjV6a05MQmZ5Ylp5ZHU0di9mZEdMNUR4M2hLcjdoZllJRk5POWtNNXlUc09YaGVsTzJMQnFXRFlzTFhMNkwwRklCYnhFb1hNV3BlYWNnd3BoM0drOGRuQkd3TmNYMUZOL0ZlR1Bac0xna1lNdkZPeFh3ZXFYQ2RWemVLeGhoelh2WkVVN3orVTdoQmdWYkU3eXhiRmhja3JCbDhaSExhN200MHNqanZhb1lIdStWdWc1T0t0Z3FjSXVJTGEzd0g4dUd4VVVlVy9na0NuaU5JTUtWMU16d1h0VVNOZTgyM3VNVXhYY1JiaEt3bGVDVnNteFlYRlN3aGI5TU5TL1JVMXd0OTNpM0trUEEreFU0eFdVcndHMFN0Z0w4eDdKaGNWSENsbysveEpabmFWZmhhdGtMNzFjcFZPeGdnUk04dGhMY1NMUGw0NVZsdytJaW55MGYvL0F0VC9KY2hldUZLODM3VlE0c082Z3lISld6cFJWdU5HR3J3Q3ZMaHNWRlBscytqb2dLelNPOFNZNmJMQzA3c0VESkxnNDR5ckpWNEZZeDMrR1ZaY1BpSXNWV2pPUDhpZVZIWHVsR3VOV1VYV3lCR2J1b0kzd0J5NGJGUlQ1Yk9DUEszZi9rdnNJZDRqVTdNQytBeXk3TUxFVC9MQnNXRi9sc2VPalJDN3N3TTJET1R1b2QrbWZac0xob3dvWkZmM1lwdXpBYklHYzNSWWJlV1RZc0xnclltS0EzbVdVbjVnQXMyTTE0RmFKdmxnMkxTM3kyRXZRbG5HcDJZdVpBekk2c1F0OHNHeGFYV0RZODlDYXk3Q1pkQVpsbU4yYUt2bGsyTEM3STJacWlMOHBOMlUyNkF6S1BIUm1GbmxrMkxNNkxOUnRhb1MrUng0N1NCYUFxZGxVNDZKZGx3K0tzeUdPclFGK2NHYnRLOTRBcTJaWGVvVitXRFl0emNzMldqdEdYaFdGWDJnR2NHVHZiTHRFcnk0YkZhYm5sQjFQMFJWWHNMQURndU94TVQ5RXJ5NGJubmpDeEhqOHEwWnNwdXlzQmhITjJadXdJZmJLOFZhRFFsNUhIN2pZQWtGUEF3VUdQTEc4VUtQUWxuQmwyTndjQVAyVm5wbzdRSTh2YlROQ2ZYVTBCUGdBc1BBcVlvVWVXTjlFSmVwTVZsSkFCd0NpZ0FPMmpQNVkzc2hINkVhN0dGS0JEQU5oYlNxalJIOHViSmVqRmNrc0pBZjdJQ29xWW9qZVd0eXZRaDdtaGhBSi9PQzVGZUh2MHhmSU9CZVNwTlVWTThXcWVVa0k2Y2RBVHk0YTJad1Q4eElXMGNFWVpQbDdsSGtYVVBucGkyYkE0SjU1Ni9DQ0hNTjlRaEk3eEtxb293c3d5OU1PeVlYR2VtdkNkVmhDVmJTbWp5dkJxdWFVTXZVTS9MQnNXbHlSOE40R29xYWFNUXVFL0JZVnNNL1RDc21GeFVjSjNNUVNOTElXNER2N2pwaFNTb0JlV0RZdkxYTFlLeUhFT2hqTE1Lc1IvVm1NS3FaZm9nMlhENGdvZUcxcEJ6Q0tna0xXUE41RkhLVFAwd2JKaGNZV0VyUVJTbkFtbFZDTzhjU3BLMFR2MHdMSmhjUTJQalJKU0ZtTktLVEkwWmhSakhjaXpiRmhjbzJERGc1U0tVb3lMVm1Jb1pUd1BJYzZ5WVhHTmhLMFlNdVlVczE2aE5USVVZL2NRWjltd3VJYlBsZzhSeXpYRkJBdTBISTlpOU1HQk5NdUd4VFZpdG54SWNDYUdZclpMdkNzb3B4NUJtbVhENGlwc1RTSEJyeW5HekVLOG0xT08yWVFRWnRtd3VJYlBsZ3NCV1dFb1JzL3h3WjZTUmhCbTJiQzRoczlXQWdINW1ITFdQajRLS01kWUI3SXNHeGJYbUxEbG83dGxTVUZCaG84bWxEU0hMTXVHeFRVOHRpSjBsMURTREova2hvS0NQVVJaTml5dTRQTWR1bHZXbExUQ0ovdWFnc3dFb2l3YkZsZXdiQVhvYmtKSk9zTW4yUXNGbWRxSEpNdUd4V1VKMzAzUjJTS2xwQktmT1FlS21pa0lzbXhZWEJScHZvdlJWV2dwYW82LytCNGxyZk1RY2l3YkZwZEVtdThDZEJYT05TV2xNZjZ5dHhSVlpwQmoyYkM0SU5mOHdFZFhlMHRSTnNSZjFNUlFVcHBBam1YRDRpemY4cU1TWFRrSFRWRnVpTDhsYTRwYU94QmoyUWo4MDVLSngwOTBqSzZpZ0tLMGozOUVBV1ZOSU1ieUxsTjA1V3dveThiNGgxTVlpaklMU0xHOFI0SE9ScHF5SmdyL1NqUkZtVkpCaU9VZENuVG1sSlExWG9YNFYxeFQxamlCRU12YmxlaHVSV0ZWaENQQ0dXV1o3UjR5TEc4MlJYZHhUVm1tVURnbXA3QjBHa0tFNVkyOENBSW1ockxHY3h3VjFoUVdqQ0RDOGliZVZFR0FYMU5ZdmNCeEcwcHpIVWl3dklHWFFJU2FHY295VzRYam9qR0ZyU05Jc0x5U0xwTVlNc0xjbzdCMGpoT2NrdEsya0JENVY0a2hhRmxTV2gzamhEQXhGR1pXZUZDSnByUUpUaHBWbE9abGVFaE9UWEVMbktRbWhzTFNUWWhIdEtHNExjN0lQVXFyRjNoQUk0b3pDYzdZYnlrdG5TazhIRlZTWExERUdZNnJLVzI5dzhOSk5NVnRISnl6cUNudUpjT0RpYTJoTk0vSGVUTkRjVGtlekRTbHVKY2x6dHRwaWdzVUhrcFVVZHc2eHdYT2x2STJlQ1RPaHVKTUdlT1NuUEowaEFleThDaHVQQTl4aWFvb2IrdmdjYnhRWGhYanNqbmxqVmQ0R0xtaHZFT0l5N0tBOG15TUIrR3NLVzhjNHdxT20xTGNlT3JnSVlTdW9Ud1hWNGtxeXF0R2VBZ0xqL0tDSmE3aXVKcmlqT3ZnQWFoWlNuRm1qaXRGQWVXTlIzZ0F1VWQ1TnNhMURpbmx2V0Q0bGkrVXArY2hyaldxMllNY1F4Zm1odUxNZG8vclRkbURZSW1CVzFhVU41Nkh1TjR5b0R6all1QU9sR2UyTVc2eE1wUVhMREJvMFpqeWRJS2JPQ1hsbVpuQ2tKWHNRZW5nTnY2YThyd2RCbXlsS2MvNHVGRTJNWlQza21Hd01rdDVab0tiTFFMSzA2c1FBK1ZNeDVRWDdIRXp0ZEdVRnlnTVZGUlJucDZIdUYwVXNBY0hESk55VThyYjduR0hjSnBTbnRsamtQWnJ5bHV2Y0JkbDJZTVhCd01VRnBSbnlpWHU0NjhwYjd6Q0FQbnNRZTNqWHE2aE9GTXVNVGpMZ1BLTTYrQmU4WmJ5OURURTBManNnVjNpYnVIT296dzd3c0JFTmVYcEJUcFFNL2JnNEdCWVpvYnlYSFFTV1VOeDlRaERFdVkxeFJtYm9aTndQcWE4QWtPU3ZWRGVlaFdpbTZ5Z3ZIU0g0UWhYWTRyVEc0V3U0b0R5YW9YQlVKYmlqQjJoT3orbE9IUEFZRXdOeFkzekVBSmNRM0YxaElISVVvb3pCNGpJWGd5bHBST0ZRWEFLeWlzVlJJUitRSEgxRG9PUXB4UVhSQkRpVE1lVVpvb01BN0RjR2tyejhoQlMxTXhRbXM1RGZMK3BwclIwb3lCbldWR2NWZmgySTB0eDJ6MGtMY1o4dWtyZ1E5WnF6YWNyakJNSWM2WmpQbDIyVVpDV3pWSStYVkpta0RleWZMcWdpdEdIWGMybnM3d2QrcEdNK1hURytLRFFrNm5tMDBucFpJbStPQk0rblZURTZNL3loVThuMkNYNk5MSjhPaXB3MEM4LzROTVI5UjU5VzNsOCtrZnRvMytyTlovKzR1WDRDdm1ZVDUvb1BNU1h5RFdmUHNwRGZKR1Y1bFBMclBCMXBwcFBiL1RVd1JjNnBIeDZOWFlWdnRRODVSTko3V2I0WXZtWVR6UlRoYThXN3RaOFdqbjRCbmx0K0x2cEhOOGpEL2lyZVhtSWIrSlgvTVhxUE1TM2lVcitXb0dQN3hUUCtFdHRZM3d2TlRQOGpXWU92cHZqcnZucjZFbUc3eGNtTlgrWjlTYkRJT1FCZnhWdm1tRVlRdDhhL2g3VnpzRlFoS01pNVc5UnhnZ3hITXBOK1N1TU54a0dKcWtOZjc0Z1VSZ2N2OVQ4NGRLdGp3RUtSNXN4ZnpSdnM4Y3dxWG5OSHl6SUZRWnJ0T1ZQWmNvb3hJQTVtN0hoRDJUR0I0VmhjMVkyNVkramJZN2hpMlpqL2pEcnpTakVBOGhXbGorS1hTazhoakRlclBsamFEY0w4VERDWFdENEl4aTd3R09KTng0Zm42bmRKUjdPcmx6endhMUwzOEVEaXVjMjVRUFQyOVVTajhtSkR6VWZsUW5tZXp5dWNEbEwrWkRNWkIvaW9ZWCtWaHMrR0tOTEg0OHZtOXN4SDRrWmJ4TUhQOEorYmpVZmh0N09ZL3dZbzdsTitSQ01uZTlEL0NCT1BLMzVBSUo1SE9LSENkVm16WUVidTB2OFNNdEROZVpRbVhGMWlQRmp4Zk90eDBGYWwvTTR4RSsyekdlMTRkQjRMM2tjNG9jTHM0VmJjVWhNc1BHWCtCVWN0U3BURHNVMldUcjRQY0pvNHFXRzM4eWs5V1NCWDJjLzM5YmE4TnVZY2IyZHgvaVYxR0phVkpyZllsd1Y4NFhDNzVWRitjUnFmakZ0SjZ0STRaY0xWYnpiV01NdmsxclhqMVdJSndCaEdFKzNtbDlBbC9NNERQSDAwWEkxcTlmYXNDZEdyNFBaS3NQVE1aay9uZGxnYkNqTWpBTTdtL29abms0TFl6OXhYNm8xcFpoMVZiaUp2d3p4ZEpHVGpmeVZXMVNhSGVtcWNGZitLTVBURFJ5VkxSZnpXVFhtWFhSUVRQMDRVMDZJcHp0bGkyUlQxanI5UC9NSGp6Si9wUCtuZzNJejk3TVFUektjL1dLM21oODJzNWV0cmY0STNsUi8yTzNMYkhPWXIzYUx2WU9uM2pncVc4YWphUEYvMFNoZVpzckJBL29mQkYxUFJoa0N2Vm9BQUFBQVNVVk9SSzVDWUlJPVwiLFxuICAgIGxvZ286XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVpBQUFBR1FDQU1BQUFDM1ljYitBQUFBaWxCTVZFVkhjRXlPQVArT0FQK09BUCtQQVArT0FQK09BUCtNQVArVUFQK09BUCtRQVArTEFQK09BUCtFQVArUEFQK09BUCtPQVArUEFQK1BBUCtPQVArT0FQK09BUCtPQVArT0FQK09BUCtPQVArT0FQK09BUCtPQVArT0FQK09BUCtPQVArT0FQK09BUCtPQVArT0FQK09BUCtPQVArT0FQK09BUCtPQVArT0FQK09BUCtPQVArT0FQK09BUDlFY0VVMkFBQUFMWFJTVGxNQS9rL3J3OGo3RUFya1BnWDJBcnJ4MVJVaTJ4d3ZWVW1aejNLZ3JtcEVlWWs2S0lGaWt1QmJOYWUxdnJqNWdxSy9BQUFoeEVsRVFWUjQydXhkNjRLaU9nd1d1U293Z0Z4RkJWQlVVZnYrcjNkMlp2ZnNGbXk1U2JBbytUM0wycVpKdm54SjA5bHNiS0xJem1ydlhsTC9IQjZDZkh1L2lhYTlNQ1RKV05pbWVMdHZOOEVoUFB2cHhkMnZIRm1aVFFJbnN1dnZrdnorb3dDTlE1WENhZnkzZ3U1NXN2TmRlZHE3WGtWWExNZFBCQjUxRnY1MmlCeEwwYWU5ZkY1V2ZoamNUUTA5TFlaNURVTGZtWGEwdTZoS0ZCaW9aK0dEU0owc3BiMDRVUmlJdld2amo2MEl3UzZhVEtXTm00ck4ycWo5bkhDYXNZNG5uVFJDVXVlakthRkJoRnNmenhNQ3Ewd3g1b0hKRDZTTjN5THg1bkUrNllRWXdWZnpEWThHbDIvSHVBam1xeW1ETElxVmJXME52VXcwZTV0TkVlV3ZiVGgrYnFCWEMyZHNmRWVkdERGVDVodGJRa3lJWk9iK2g2Y29xcnl6RVZOaVp2TG5tb2sxMzV3UWMySUhjK3N6TTQ3NEpDRW1SVnFFSDJjbFNubzhJWWJGVGk0ZkJZU1hWd094TFJ4L1RUK0dONXhmSlRRRzJmcldCNEF1S3pRMU5CTFIxdUdiMHlxNmRiYlJpSVJEcHZmT1ZxTHNSQW1OVERRaGUxdDErR3MwU2hHanQwUmMzbDFESXhYalBuKzd4TVFWMEtqbHZuK3JXTzRHUEJxNUdNa2JxU1FldlRxK0VkY2lmQlBPeWhQUm00amd2VUYwVDBVTnZZMW90OHZZYVpMRVFHOGwvTUVaYzZMb3JUbjBiaUxPeDJzZUFYcExPWTZ6SDBMWm1lK3BEeVNaMmZpQ3UrNWMwZHNLeDIzSGRyVkIzWjNRVzR1OUd4V1o0bHdsOU9ZaTVlTnBoVkI4RTMyQXJPY2pjVnRLb0tHUEVDTVpRejFSVFcrSVF4OGlYeTc3a1NSZW9BK1NFK3VFNDd2bWdoVlpJdE51NnlKSW42WVE2Y3B1blVTUGVQU0JZa1NNb2kwNS9raDlJTVR2bUdSUzFKeERueW9iOWdLSlB2WXVodWZJclMrWE5ZVkVKL1RSY21KTEkwcG9vQStYeFptbFFITFUwTWVMbHJBRHIvSkpIZDhTTU1ML3FqZHBVc1pQYUw4eTRiWDIvS1NLdjRHRWdXcTdhMDU2K0NmMjZ1WHBCemRwb1NDcjEvSW82V1FmWmErMWZLVStsaFBjZllTL0wrdzIvZlQwbk1JMXZxeTEwWi93RlptUDl5WjlNT2Exc2trZmpIbXRGOWhJTk9talNnYnYyVnBPOFp3cDlKdE9lTGRPaGtTLytzU1gxTXVRSmF1SkwybEUvZzdHL2E0bSsyaG1Jd014amVxRXJ4cUtPRXg5OERydGRGUEpoMmdQU3FiNllHT1JEdkQrS3B5MnVZMWswUGNWc2lrQmFXY2pIbXpLZnBrQ2VrdUJMZXE2OXJURGJjVUVUQkJWWWRyZjlpS0F0V3RORFhIZHdzZ1JLTERyOGNTWWROTUkwRVhFcVFMU1ZYaC9BbGp2RDdVY3FJQ3VpUXdKMUtINzZqK3dCMUNNU1c3SjdFZ0NGdGo3QnJ3eGxEVWJyKzZHTGZvQnNJdEhXYjhaZXdvMm40R3hVUWh6b0dWeWZLOGxYZVVHcFk4MVkrUHlWTERpd3IzSEFxSUNOekNEdGFjSGRCOHFWdlpKeGZ0Z0ZLL0EzQkFFSGN4RXVONTZmaDJ3R2pyUDNQWHVYNnVGQ3BkY1grNFp6cTJpZ01VcElXQU1FUmYwWThNN3NKcXR3ZVFnSFFldXh0REw1RXdIcm1sME4yTlN6a3hUS0FxY3d4SlluWThIdCtUTjgwdmV3YkhTWjBiMU1WdUM4YWphczJ2VzRSRFdRRzFrblZZTlY0bDd1cHNSTGlYa0dYNUNhQVZtSWxMeTNDL3o0R29FeVl4aDJjRVZSNk9uRUJiY3k0T0xGY3NLc2VDZWFYb3FQVXpnRGtySTlKeHVIUTc2Y2s5d1dpbmNXREpoeHJqY0dQUU5NcHpkR2hIckNvR0w2K2plMVRsNGNIMjhXK2FmcUZHUGNFNnI2NlZwT0FQaFJ2QnE1Z29PWU40NkhVYzlodE5IUEJ1QndKR3EzY3B5THB3VFhZL2pjUnFCcmJnTytNN0JiaFQ2Z0l5aGljNlNnWWoxTis5VTYrTFB2V3kzbS91WGZWOFg5WFRyc3B4N3UxM20vZnFxVmMrN0tuYzRFM0Vac2xlcExsVlZ2TnhlOEpyMjdjTTFqZWRQdC9qeWRCcXBlaHR4d1JzL0g1VTBqVi9ZZWUxVHd4YWNrOGdaSXJHQ3FyT3B1aGx4NnV3cGlib0hIdFhOdGlUM0k5Mno2amVMRG5CeHZXWC9OYUMxU203Vk1SYW9MUWJhT3U2bUVuVjVwZmN0TEFTdlFpVXJ1R3FwME00Und6WCtJRHJrbGFNYVA2bUY3WjlxVnRKYkRTRW5SUFM5Z2J0emJMUXlFUVdPNVJWcEIxTDE2OTlMa3RadDJ3VGNiVDBmSndrKzdhc0tYQ2k5dDRFamdIVmJDbTJneThkbS92cldocjFXR2k1RUNtU0s2UUhPb1dwQm9BQldBMml1Yzk2NFZHeWYxZWJtMFhnN1Rjb0lPQVd1bXRzOFBkYlBZT0JDbzBUMFZqUk4wRkFqKzFZOWlKVFk1b0taaU5iWVJDeTRUakZ5M2RiYXRGdEowQVNocUY3TDFIWmpQWDlXWUdwQ2NORGl0Q2RIenBhRlNlN1dRQ083dGtlYkU0bUpvZ1VIY0JweWpJQ2RQMFMzNEh3Um9xejl0VTFDejh2aVF5N1lEMXZMMVQ2THBzOGY3Y013NzVzNFBudGhuR3pGazlRVU1NQWhITE5aRkptRGVjMDF5ZmtyWHc5YnN6aWtqdkk3eU9velhYYVdDZC9XUmp6akFkdUcrLzgvK3MyVnJhTGpnOG9rWXFGQ0JUdWdVck1MQ21DTmxNUmNTQzV6QW9aQTRKaVUwQ3lxcmViNlM3a2htYzhKTjhya1VDaWZ2VHRKenhldzFvSnRFM2l5QklOWXhCZUJTblFSZDAzSlo5L0tpbEREbURmM3V0S0dRbG5KVVNsOEVmV3NnMVVpbXJUL3d6VlhheW5odjR1SzZ1QXI0cHkxTGVxT3pvbXBRZkdqWjMybTAvNjA3QTFKM1JjdW1JbHM2cWtndU5ZZnd1SFQzV0txY0swc0U4Zzd2dGJnZm11NTRJbHUxZmRmTDBWMlpFSDY2d1BZSWEyL213dldiRUdFRkpzV2NlR1hGRE5XV2llNWJOU0RXVnlLai9qbXBFTUxCbjFyUzRjeUdPRk1hbFVza01wU1dOK000ZUVXUlduWExqVHdjQTBhanBUQy9BYU5CRDNPMnBESGRKQzhsQ2RwdjZDUFJ0TUpQYW5XQXhjWUU3Tkp4NDFhY0VrYUFWVW9ZTkMzSmptMG9BekV1TlJwLzlDSW9WSnhWRWF1VE9NR1lqYmpob3NYOFVucDZ3WEtSTVRxWmMraE1DL3BNTXZyUmlHNnBCRTg3SkFxMDN1dFF4V284RlBXOG9DeGxZc2FyeFljVFp3N2NkRUZZUFpvSWlyR2wzTjVZNmEra0VtUzBNSWV5bmRVWGpzRUMra2tNS0h3YlFQSWI2aU1jNStieWdoaU5xOWJGeTUvOHdScjFhR2diK1hOWENnZXpTVFc3ZkZjb1UxWjlsYTFta3lxclU3V09pM2lFQXdWcGlqQlZkMTlWWUFLSWNTN3A3aDdiTmRhaWJHZmozc3VkSEdEUDJGYnFuRWpFVkJjLzZwWUtSU1NJTGtPL0xwY3U1a1QyTDBWcmh6VzhaNzFscU80dHBncVNlQk0yUUp0VHpwNFNML1UxRWJiWHQvQlBLc2hVNUUwMzdJRkZUTThNcU9SRGsxb0FRMzU0STUxZFVtN1pXK1BqbkVqSlo5bFYzSm5qWE93Y0VoYWlYcDNIV2gyRjdsdWk0Zm0xdGRGc0oyNTAxckVqZGI5ekVFZHlKQmg4bldOVmtrQTZuaWhuRlJNKzYxYlJERjN0N0FvYmtkcy9WWE1KVW1VYmdPWVc4bVVrYVVXRFBGT1NRWldOYUM0MnJ1c0tad01Ga0k2ek9MQ1VwajlrUDA0TnBtbHlHQWlDQVZEZUYweDFnLzgyRkpnZkY1UHpqZkRXWlFVeG9YWkk3OTZrZjJXalpWYVdybkRwTmlZRW9Bd0tOMWhZTUtoUHF4dFFKeldsbVROS3hoelhOYkdaYW5EcVBxSXdwNFlsWFIvTGJkZjY5YUJDcXI4YXJEdW4yTTlVRExTOWx1M0lzTXNGVHQwSFJUaU4zQ2pJQTBQeEs1U2tLeVFYaEQ3Mi8zRGRWRUlGbjlOTWs3cU1qRjdxVkhRTkRUMEpZM0hWQ0F1ZVhMMGJSR2VzaERzbi9Qa0ZMN0xrRnlzQVV0b1dOZUhZMTlCZUN6YnFxZHN1MWtJNWptd0RCNkw5VjF1Z3FjTkZLS0RUSUFoM1BPRDhGaFMyaVRaN3FTUWhLUVFISHgxdVkvb2MwMmdlQ1FORVd0QlVwNU5JL2FENi9JZ1VFYk00ZjRoZDZPTFF1WU53QWhRSStPaW5ENURQR2hVZWZReGJqRjdidTh3WVAxRlgyQVRDWnN4azN1SVllUXBmS2lxbnF6dDFiSEJUeW1FNjZTUVRXMm0vdHRFSUZqZmN0c2FnQm5hbFgwa2U2eCt4WXFGMkRVbEhFaEVXbTZFN3orRWFGV2V5RnJpUGQwS0V4YWk0OVhHUEszNkFNQlltaElIdSsvZlk2M3BLMUpDc2JDaWpBMExLZlR0YWJlcTVvUCtCMTFJU3hxdDF0ZC9RTVZPNnNNazc1dk9oSVdVYzNBNzFSdVFMRERBdDM4K2dCclI5NXNIZnE3RHV5NEFGdklJbm95QWRxRUdZQmo1Q1E4aS9iOFdSMjNzOGZsV0RNdUFGcklqTFlPRzNOWCtvYThMMm5LVVVPNlFrVjl1WEt1dnR4Q1ZlQWRFU3lnZmludVB1aGxrclZpakJFT1J2QXd1ZWIyRlVGNDZraWdqUlBzdmVCOEJzeEJLSDRWTDVlVzB5NnN0aEQ1Q1E5alhFVi85Q0hiVFcrMmJ3Q1RmTFZqWjFEVndXL1cxRnFKdTZiL05YTlZWNFB0SnBQOFZuWlcrelkvWWllZ3UybEFIdzFxSUhqYmNLcnljMWZPdVlWNGk2cHZsSlczdXd5d3dJOEFwZittc3Y4NUNpdk9QOGszSmZYSEVSS24zenRzZFZBaFpFUFZSc25Eajdzd2NmT0h0SnFmMmF5RjduRG5TVmpQM1ZsSUpzWGZHNnBuUzJoSjZOWHJKMFVsWmhWcmlBc1NmcVhxRmcybEgrb3NzWkluclEvcUduK3E4QklKajBtL0wrb1crQnFHRm81ZVUwNm9GTVg4Wjk0TFp0R21DNzlOQ29zS0IvTlBlb0FTRktFL3NGTzU3Y3RNZWhwZ2hiV3V4c1o3UC9zZFVhY0hxalZnZTNrTGt1UEFiK0QrZjA5WGl3QzFpZTBEUDA0Mjl4MEpaRDVMWGxuVDQvVi83MTdOR1dSaWdoY2lsdWMzWnY5OFdGVFIxSkRtdGZnZkRKQkExWXA3RS9oUUd5UzhLUEhCUTNBOCtYZzFwSVU3UlBKQlVhQVB3alRyUXNlODFybDkxQUhKL1UxTWJMYy9CTFB0aGFaRW9RMW1Ja3BUbnlwV3VKUlpHZitUZ2pZeC9Ta2lXQ1IzUmwxV0ZSRWNzNThqYUpzSmZSRkF0dVI4TGtmRVhFZVI5VkU0M0NDK2VoL2lma09pZFhwK3Erbk9WeXRFQTRsSUI4dUtlTm44NC82dEg0a1k3aVhsOHZyaXU2NTJUNi9xZzkySWg4ZnFlbkQzWGRTL25NQmRQR2lxZkJQT0J0ZnFQdTJ0ZFQxVUhva1FVUWFCY3RZcmdEYlJheS91LzN0bTJ0aVlZa3NGTXFEMzgzRjgzd1V6V3pHUXVheGoyTUc1QUNOT3VYOHQwTUoyc0lROGd0Q3Qxc0RtNTdGREd6dTZqSUVSQ0cwNUNqcFdJSElsNXRCSG42MTA1R0RlSUFobElBdHQ4OHVCWVlzVTQvRHdQSU1TV2FJSXoxNTJnaUpuNG83Tm1pRkhmTmVUZ3FMcThUSzY2WmJpTy9TNjg4NUlDQXlGaTVXSzFzTi9RcGJ3aE41U0F1SDlmSGhHZVdYSzRtUVBhcExkVlB2aUY4Q3RHR0FnUmJwelpPbmJoVFJiRlR2R3l1WjhsM21QMGkwMjdaN2hvajdlS0J3Q2s2Z2hKUmFwbEZMWEgwYVNNRXlXYTBuSStMMjE0QU9HbURjYTNBeVFjY1RuT0JMWjlvSTZRZ2NDYVo4S3FPQ0s1M2FSb09zYXlVWjBzdmo2aXlyZ1A0bHQ0dEc0MXUzZHhpKzRJYWZWZFBNa29KWXBLeStSbm12SDZsM2NHSWlYVE8xOExVeUYyS1NGbFdpNzRNbm14VlJGaXYvQ2xzZGhJaDhibFZCYU4veWN2bUY0cWx0ZmJWcXJZMXNIY2doSU9KZnZsYUVhcUNPRm1rOHc5WlBhYi9CZXNzREpLbC9kajFlQzF0YjNPNVQ1VzQwU3U5cVBFL1BtSnhIUENVYW1Pa0hLVU9ONlBPUWpNWkxSZndXTExyNUpJSFdLUC94d3Z0TmdhemFPOEozQlhrNTBlVjdPc3ZEelZiRFZOY1dKWjZYUTFxejVmbXMxV3h4UmNjNStLL084ci9wQnloME8wS2ZaV2F6WG9MVFhsR1hpUGx2NlF0dWRtMTVLMlA4bHdKSks0V09OYm5OYlRiMHFQbHdhQkVGU0JETy9UM25jb1dtQnRJdzZqaG9CdlVoSlkrUXNJNGZaZ2EzRjluUjFTQjZPQXlFSjJrZjhEQ05rQUJJSVQ5VFduT0xNeHpPT1RDYVR1WFNBNGFhVmdna05xTG1Kbmx2cU16NDhRaU1wcVRKRjU4UEVHeGhZaE1rWkVsZEtIM3pEcXRTYWpmaEQ4Vll4aml4RkNXWmF3YWZQbU5KaC9GU0VIdWR1TFZFNUZLaWJjLytBanBwczhQM0F4ZkM2RVJGUldVZlIzTGtLcWFvMGhWakhGK2xLUzMzbCtoR3lobmpzQ0hjWUdvU0ZhMG11alJxNzREQWdCVXFDZ1RGK2ZxMWQ2bVJKRlJJZmYzYitJRUdvaUNaRlFITVRLZDRoY1BkaTdrZXd5UmRPV3BIOFJJVlJ3S1pqQWJ5d1BKcFdVTytVODJTWkRVN2hQaXhDcXU5T1J1U1hLY1k4UDQwT3JSYjg4OUJnSTkrOGh4RDNUNTdkRE11dWg1MndvaG1BKy9DNTc5eEI1M0M4amhHNS9sak5yK21wUlh6STAxTkloSG9UOGt4b0RNUnovTllUUTFiMEhpUHpVN1BwUWtYYm1IYUtES00vYW0vMDFoTkNzSTJWSERmZklKVnVOdWN3RXVVMTBzWFV5L2xzSW9YbVRZZlNwYXRIYWhhSGtGc0J1ZWt3RnpnbE9IMmRyUW9nUGR5MllYblJndjEycEpoQVZsUWNjYkdvTUtMdm9GZURET1Nwc0hRaXhpeEVZUHZSUVlnc1krVkZxZ0FvTmxmQUxsSnFQNmRneG9iL3JYTmVuR0I4aDhhbXV6OEF3NThxcHUvaThWd0JtdnlZUXNCUExwQ1c5VjdpeWFGWGJEeVBraTA1OENkSStUSE85QjJXYThDc2xnYWlvTFBEa1JwWVd4QUc0OCtueTY2U1lheHNUSWZhMTY5WmFBclR0Z0xHdlM2anhpMFpLQWxFeTZtQTZVWmJ1eTVNU3pkeCtsRFdNOFJDU0RuOFV3a2dtRVo4bERvQnpseGRxUmwzSjdVM0FYOGxXdndhbGNEdmNWK3FyU0RLd2NSQmlEMmh6R3c2RXpsWmFzdklBcTJlMTF2V0Y0c1VRWEdybHNuRlFheUV3N1hhRHQ1UW45a2NRMG5CL0FwRVNXaTFZNDdvSHU4cHEwZHFSV3VpRWVCT29wYnRMM3N5bkx0OTZOTHZibkNPU0RmR1BEZjFzRmlsWGQ3cmJaYWNzTmYxTTFMcDNocXJCUmZpb3A2Z2hFZUs4YzR4N3ZBOGJmbC93aG1kRFpnMFh4Z3IzSEFzMWUyOXU2aENleUZGc0ZSa3FoOS9oMDFnNFJhdE91VXZIN2plR29yaTZ6NEZhZTB3dnE3eVBhd3lyT0xLdlFISEg2WFJ6NzNjNk8vQ1BWSzBvUFNzbnFCeDRLY21VNDBCWXlmazB6N0pzUFY5K2hCd1gzTXhjekh1SVczRFdDTUtQNVh5ZFpkbjhkT2I1T0luU29ldWFvRkltRGl4OWpaOXJGZGczOWFMelRUanBNTTVLTlQ5VnY2c1hPWFNBaUxITHU5VkpPaFYrTEt2cWR2TWlIM0I5aGRDUG02dVhBWkZsQjZwRXU5TndHaWYyOFdOWmZ0eEpJc3NPdzAxODllYlBPVWFoWEtlODdCdFliWG56c1o1OHlIZ1BUbGtrblVZY0l3eEwzV0NVa3A0N0pZTmlZT0ZST05HVkR6SGNMZkE2UEkrN2tBa2pBS1JlWXhSYmQ4ekwrak81emlCSk9kYVpNUnlYaWR5YUhUcE9DMFdnemlJVlNqdEMwSTBtWEQ1N3cxekxMS2x5VG4yM2xocmdzRnZSRWtiSGpqWERhZGpaZC9yMGdkanpETUsxM0pBaTVOVHRJaFRuSHF4SnAyT0d3Y0RndmJLRW9RKzd2bDFvd2wyUkViSE8yUXBpa2xDcVRzYXI0a04wT09aZHpoa0tCVTB3UVdyNjdOS3RGbEdZUEl3Y013aXNmMDhRQk9aaU9ZUDZCM2k4dmJQbHdneUM2emVZenNoOEpBZUNSZVpnVG5IYW9vblZvZldEdm9xOCtYYThuY3orUGR2dE1mb3Q3dmZvdU4xZXZtR3lqVzJqb0l4cTJhdEZyMnRpeGxqRUFRZndCdGhNS08zNTZyTG9NWjRCWEtZNGhCaE9oRVN0UWF6aWdhMzBZbDBDVWFsY25IamQ3N3graFVhdGdVVStjd0RxRzVyWVBEZWVFQ0VNT1NOMGJyS0x4UEozVVJsSTlFd0VhTmNwUkZwdnhqTWloSnBaUjRERjRXakRkaTZramxnRVpzQnNMc1hoYWU2ZUV5RlV6NWNEU3hWdXNWZ1hNd09SNHU4RTh0cVBkRUwvT1JIaTN2d2NEM1ptMEFhMlhZSTFhQ1NZTUlnVTdIRjRSb1RRU2dNVXBwdWhqVDY2eUIrUkpoYXlDWlRKaXA4VUlmVFV1am5FNVVWalVyWXVTZ2FSU0JseWo3clpkTWQ0Vm9UWUZsVUZBbkFDMEFEeTFhS0ZSelVPeVQ3ZlRsTm9QQ3RDcU9wQmdKMGJJMU9ORzRqekZnQUFSN21GNk82Z3VzSFk3TkdpZjRjRVM3d1gxaE80UUVqK3ZBaWg5bGo2dDVoRGlyT21DZE9memQxMXZ3WC9Ba0k2Q01SR0hOUjJIZWlTSWc3NkpMS3M1N1FmZ2ZTSEVFeUFYSmtTVVllQ2hXTndyRGYvUHlBRWNYaklqMU5rbzA1SDNQOGZiTWdJTEJETWVWSGZZL09RQjB0S3Nya0FsdWp2Q01ZNGpYZlQ2VFJDUW9nZGZiNXVHcWVSTE1pVFFIM3ozUUZ6Nzc3YlNsRkhyNUk1OFBBUlQ1enVMdk5SZUtIa0p5VUdRdUpxL3JKd1RGTFhuaG1POG5JbGtnbDFWLzRRL3hyY2tlcWJiN3VFK3RiNkNQMEpyVDZ5RzlNOUFSa0NRaG9aYjFMWFpobTN5dVFWcW9HUmQrNDdjSmFpdnBXRUVUQzQyQkpwc2F1Y0tVMTZ3MERJZlV5YkJQbkFsaDRhWVhBeEd1SUs1Q2ZRZ1RwaHR4Wm5jNm1MQ0Y4L3g0MVJySHhhK2E0MmhFdXFTL2lVRGxRc3hCS0czekZIR0RKUmdUbXVvQk5STnBlYTZCUndsRnUwYVJidThjZmVkL2F5K0lmWjQxV3NUb0NraEZHQ3UyOG5YcmhadStzN3ZvWE95TDExT042WDNENGtrSHN2cTZXbzNFcnV2VUpxRE42SHFJWVMrUnhUWGY5dWdQeHFVUS9Zdm02TmJidThNbXgrVlNUT0RLcFBFRFNEQzI0Q1N5Z2NjVFU5emQzaEl4c25JUWNUQmNmR0hERzM1QjBNZnNkbDl4bFVyZFUxUWNXNlczU2wzTFkzbDVmbFZzSUdueWliNjVwdE9jYUNXL2VkUkNnSUVRUzEyUkh2ZEdoUHhPbTNSZDR6WmpSZ1FaQmZiZ3J1WGV1YWY4ZDQ0eXZPQk9tbUxqQ1VKdVZaK3h1WngzMVZnUWRzZ2RDV2QrVmh2MzNkN21uUnRacUhHMHhYVFpWc21ZZlJxY3dxcEZpV2Jacko2YlRlbklhZkYzWldJamZWUkhjZ0N1cGpmYnk4TFUvNktiWlZGMlZ6bWNrblAwT3o3VVpKcTVkWFI5d2V3K1B1ZWtpaVk5YnNRaGg5ZjBaRTBieVNUZnVwY2hQc0hhc1pXN25BZmpzUnVMNFRlamV1dlQ0K1cwQnB5Y2dzVktPOXh4RWpFcEw3OXlXSUFzb3lmNDh1ajZSVnJ5UFo5WFlIaFdIOEM3N3U5V3hYVlZqSmVxaVU4eUYybFhDU2RRejFocUJmWjRLK1g0MEpYU2xCWDJEVXZxZjJUVU1TOGptUzBtVWFXQUZjTCtyNUVEK2xsU1E1WDNZL283Y2hhWmVIbmFOdkYya2M0QVUrUkFSeHViWFZ1QWVzcUgrd2NrRGpFa2JHTU0zcFZWZUdtOUdtMUJJVVZyNmlPMEYzcVZaOG5TaEtRSTJackxFM1ozekl2TDhlUTFwM0hxS2NVWnNpTHRrQUh5RE4yU3B2bG02dHlOWTZtR3pVdFVQS0VUT256bnhHQWdnUWZDbTdFbit2NmtLNFEvcXp1VVViNkMwWUZ4SlNUbjNWZGc0OXdaMHdQbWdReUZhb1JKQWVRVGJYUGoyV0FjYXVPbG1TbHM5d1FlRlJ2TU5yOTdHSzE1N045VnNjRlc5bDlJa1FPdmZCaERFRWJ2ZkVxL3RRN3dNTnE5U0pEVXFNMU8wUmVlMTFXZHhBdDRpSzNGNW8yQ2hyS3NwYklxNGo2c2xKZWZWZ0s2TmZoSERyRk41Rjk2QTNIUUJaOUpELytscEl0QytjRkFWNE9pdGU1YUxaS1p0RDk3dHB6ckVPZEVoZVBMSjd2R3l1bVJ0OUkrU09salhZajNzclZmeXhuTHlTNkRqUnNaUzRTc3V0dkE3eTA0T1F2QmxnRURiY1R3TWRtMlRHL2NSbnBQZzNqTldRdVFtVS9TT0V5Y1JhWjhtMWRLNW5rN2hyVlZyV2tsMzBvb3dHU2RVL1Frb21kU2o1YjFOTHl5YnhHVHhTTFdna0M5bld4QytnbktrdWhGQUNPY21pbWxxdXorMFYzVXN0cThuVkVPVjVydnRIQ1BXcnBWRzBnbWpab2JaazNxc2VQRXA3YzZmNFJwMDhaTlJsQUluMEFLUTFPcEhxV1kvSWRqbkdkM3M3SUFUZW5HT1VlbFRJb2UzRXVpYzlDMHBWQVVHL0dNSVJRdldDeUpnTWpwcTJaOTRwaklEeHlIcHpxVU02NkJzaGhjejVsQWFvbGYxUVFRaFdqODZTTVMzN3R4SUxBdVhLeFVJSUhRbVIrTnhIUFNaV09CK3gwZ1FSeVJ6MUNSRUhFVFFpaEFvWVNRWVZhb255eWs3ck9ORWtFYkhyUy9XTWtLSGZLMEtvaUxOa0t1TmEwOVlJVzFEY3VhWlZBK0hwWTd5SnRkc2ZRcGlobkdMYVpDMTUyOHV6RkM0NzBLUW55Vng0OEduU1c2dnFEeUZNYVlkWVdXNklKb0dJTTBDUm8ybFpNVmZlbUU1S21DdTNINFQ0azBTU0k3bzlPMDBuVlpvaXpUU3RTdzQydVBvanlOdytFT0pXek1oa29WSzFoNXIyUlJxOWMzV1o5VnJZbSt1eTZkeTk3ZXRHaUcvdm1VT2ZDdy9Cek5PMEs2RzBTbE9icmhSSGZTZXNTbGpNTkNQRWZXUGJINElqOU9xSzdINUtuY3FqcVcxdDRZRnQ2RXBydE5PSmtHM1NzQWtaOE9hS2ZVdVhsMm5pY2dQVllDM2RMRmtqM3ZMVjFvT1FYZkhTRUljbHB1V2U2bEpZSU5MVHJhN0Y2M2Z4dk93NzYrVTVtWTJPa09odGFONTVUR0tXTDEvWDdhdzJRUU5LY2wzTFMyYVNwNk43OCtYbHhUWkZRb2dkSHdmbG1YUFlpV1RZL1ZTYkZvZVJnYjlxQStoQ2toZmhSb3ZNY0ZoT29zNElvVTNRZisxZDZacXFPQkNOZ0lCQ0ZKQjlFeEFRUWQvLzllYmFjK2ViWG13SmFFR0FuUC9kaHB5a2xsT1ZSTGU0cUtpOUEvODRtZkJhS21oZ2dhZElKdHpwSHBqUk9qNlBLY3ptMS9TcmJOem9uS2FwbFZWcEdrZkpyb1dRangzcDNkSFdLU0RXTXJGQS8rNllsMHh3d3o3WUNNcVd1KzJsMXBadm52K3hmMzhsaEhDUlNLT3RUOUtXRHFEZWlqdGFhK1oyZCszbUpVTGFuK1lHQzNrN1BQZ0VscGUycUw3MzdXbTU0bkNFOEtmV3QxVmhXaFUvQWhieTkyeDBNT1htdG02UEsrSnlOUXdoSzYvOXRLOENGbk1TcUNhUHl3VERMd3M1NnFSVWZQSkxYYXJldkV0eTlDRUcyeUMzVGkvdHJ1RzJDRWxGVU42U0QwRHIxUmV5T1pra09RQ0dzeFhkcmkwR1hCaUV6WW1PNnhGNXNxOW5ncTRrMW03dlhUakNaK3ZoQXM1OXAxZm8zL2FZWG5kSjYvL0ZxVmNGUWNnVmZKbmFyRFdKVTRVb0kzNVNGS3h1ZTdzMWNpZENZSTRjL2hYVXlKLzhWYXJUVHVOL0RidlVVdmhlNzlVVHIzejRCNnQ5cWEwdi9yYlRQSnhXWU1zeTdzWUhWZ0MzU0tmWDhoVFRjdnlnK2JGWCtMWHJiN09mU1oyaVoxVnNINVBnRW1yLzRuSzVuSTYyazJabTEvdmdEYkR3L3hiZ2ptTkJHWmlpOXV4YW1pZEcxRXJ6S0RvR2dldEhrVlAxK1JlZGZ4SnVVWmJkSDBURFlLWERsbW91TmNBYzNBWkpsTzdqeVRaZ3cvSDBTUkFDRi9MeWZWNE1CTlFZVjhjcEVBS244dlo5QkJodWhkd3krdmt3NEw1KzE5TUR3bW1NdDFDbW5RK2xnRE1RWE04eHlRM1ltTlNVZGtKME9LMGl4SDBIVlFHR3ZncmxHd1J1TVc1ZWVBUDRCR2RIZmJvSmdkTzd4VmUrM0lSVGZUZFUrM1hBdWkxQkVlWlpiZ1RuMlJLYUNmR2htdDF2K3hlOVp3RTNNcE5hT2pDY1J4ZGZYWWNtWE1QRG10clFGK3g4T05rTDV5M2VEVXpTNnB1dndtTUxGbDJLOXN1RGsrR3EvTlNHdm5BcXIvc0dleXFEZFZMU0d2cm1GQnVzT3lNUm1GOVhxUXg5VGJpNmJZNHBkM0VCalVZTHJtNWI0UGVNRUM1TDRpc0tOd2hZSFVpUTNqVkdEaXdzWDlOSHlBN01Iamh2R3lOT3dBWkpYVFVYNnVxRW0vck9xcHdFdG13MHl2SjFCZXhMNjdmbXdSWlk1RUZaTmZjTTVpNnQ5eTRjZnlJRGZiVnVDNVdqcTIrWEpjQlV4bHFtQ0ZCMVd3QnRXNEk2djc0WEtBSlV5RnNETkQ1bGNFWG0yVU1ERWJaam5zMXNQM3ZGeHlBT0QwZHNibnNtV3hnbUJKR0RGWnZjSGdFV1hMRWFMaitjTTY2QW5jeHcrZUY4c1FGTnRLd05tK0Z1S0lFVDM3UEs1cmlUQTdHQnRRVTVZWlBjQWVJQWFyYkxRcTB4RlpNSDljT2FUVFFwd2tHT2lzbk1zUk5DR0tnVjBEeXd1U1pTc0FacnFqSFlaQk9BSDdBWWFqQ3IxWjRRRHRsMGhyY3NIV25Ed0lmMktxYkZQOFYrNkVPVW1HUDFxbWM0WXpRMGJHYTFmay9RY3pRQ2NtYTFmdVBEeDJNUTh1V2hJb1pQeU1maEF5R09SYitQL1BsNEo4UHdsazMvZzNnWG8vRlFzUkxpOTN4dzVFdERMQ2JHZjlWTHhqNFVobVcyUno3cmlSUTA4eHRyeHNOL3VOSnhhUElpTWlydVdORnlaRkk2TVRMK1FEMUppQmJrYkkvQTk1ZDBPczlqTDc2SXFNV0lKbUJEV3pZZkpWVUh3VDRTRW1IQlprdTlVbmduaFY0c2w1R0V5cHVoRlgraGVqeFA3ZFhwemlKZHV4WmpXZ2xCeG01eFptdFZVMzBudEY0c2pBODFvZjFoZ1dVVmR2a3pvaDI0dWk3R2JLbTFoU1lBK2JTVUdzbFJSdE1BNXkyQkVzRkJrNEhwenArUFFrSlRRalR6bE9TUTQwbnhnUlFqbUhGbm8rZ2FFK1BqVHNtNW5HbTRKUjVzTkVrWTh6eXh1MDhNTkZYRTh3dTNSQzlGRTRaNW1sbTM2Y1kzMGJSaFhHZTBTVmFoZ1NZUGJEZHpzVlk3RHFNWkVJTGtmQloyaXovTGFDNHdrc2xUVWlZR21oRVU2ekpwT3RUQVVORE00QWlUUFNhNmIyS001Z2ZKdVU2VGo5Q1IwVXhoZTVNVHVGU05Rek9HYmd2VDRxTTU2MmpteUxYSmFJNmlka1lMZ002RmszRHYvSVdUMERLZ1pQUVhTMFJYVjlCeWdLdUU2blo1N1dTaGhRSHIrWnBXMlZFNDZ4Z3RFRW9jSEtoejhPb2hpTkZpb1JobnVxNlRGMnZiVk5DeWtRWWxKUjVlTGQwS0lZeVdEbXh3eFdGOGQ2SVZzWUVZL2tKMlFsNGRqeFNWdnppTWhPLzd4SGJIeWVGRnIrRFkzbmdNcXhpOGtNVW5GcHYzWnhwOTZvZERiWlNWRmthcHpPYTh6WFlwMHJZWTRJcWhRNUpLQ3B0dTBnVEZ5b3Ztb0VMbGZrMXh6dGdrZDdaZVpoVzlYeGZlaDVGbFNpemI2STNNVG1xdjNML3NWa1QrNE5XSi9SRk9NVFplOUNwU2xuTEhRTmowWkVVc2hjRG5Va05pVS9udTlESGpqcTV3Mkd6NHZTbytUU05Yb3Jybk41dEQ0L3BjeGx3M3NNUFhNMnZMMmZreGNjUDYyZ2pDMnZPMFAvQzh0U0EwMXpwMGsyTnVPMXZMbUdLSjZSOWdzRHlvNHRhdEtnQUFBQUJKUlU1RXJrSmdnZz09XCIsXG4gICAgbWF0aF9pY29uOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFYVUFBQUYxQ0FNQUFBQWdJNHI2QUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzSUFBQTdDQVJVb1NvQUFBQUJtVUV4VVJVZHdUREE2VlRVNlRUbzlVRGc4VURjOFVEZzhVRGc4VURnN1VEZzhUemc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVT1lvNHVNQUFBQWhkRkpPVXdBQkJRb1FGaDRtTGpZL1RGWmdhbk42Z0lpUm1xT3V0OERKMGRuaTZ2RDIvTE9NS2lBQUFCUUNTVVJCVkhqYTdaM1hncXM0REVCdGVpZEE2TTMrLzUvY2g3bjM3a3dtQmJBRXRrR1BXMGptUkVpeUpFdUV5Qy9VTUUzTHNtMDNpTks4ck51dTY0ZGhuR2JPNW1rYytyNXJtekpQbzhDMWJjc3lUWU9TUzBURXRGM1BENklrTCt0dW1Qa25ZVU5YbDNrYWhZSHZPdGFGYjcwWWpoOGxlZGtzb2YyTC90aTNWWkZHZ1d0ZUlCZUw1Y2Q1dFluM0EvdW1LcExnVXZvRk91NG5aVDlPWXNDL29aL0d2a3I5UytmZk9FMC9LVWVPSVZPVkJwZWIvZTAzSFMrK2R4eFQrakwyblV2cC83ZmpYcGhWUGVQWXdvWTZqM3o3VW5sQ2lKK1U3Y0Qza3JHdDBzQTRPWElucm9hSjhUMkZUVU9kdU9kVmVCb2lPYzhsN2pVNm84SWJkcEQzL0VnWjd1SEpuS3ZseDlYSWo1YXB2Z1gyYVpqYjBiMmR1QXpDK2pMMlRtRnEzTFFadUR3eWRrV2dmNXhZN0J5eUxGRDR1UW8xMW5mRERzdUp5eWh6RTJ2cVdTMHZyZVZrempubnZMMzUrbVVuRFQ5dnVkVEN1a0szUTZ1WDl6T1hYZWErOEhVS0ZXK1QvTXkvS2lHNXE4bTUzNDU3cm83MHFhT0JuWEdpZXVaS1NadW96dDJTTlZaOFoyWllGYXVjS0RDQys4QVZGRGFVb2JLcFlEc2ZHVmRUMkZnbzZWYXBHZmRjVmVpY2N6NG02dFg2ektDY3Vkb3kxNnIxMHJocHo5V1hQdmVVaWx5YWllc2dyRkVubW5HS2dlc2lZNmxHWVp1R0hkZEorbGgrN05UT0o2NlozR1UvcTVwaHhiVVQxa1JTQnpQMnJXZGNReGt5UitJc2VqbHhQV1dxcFMxcFJ3UGoyc3FjU09sR3Jkdk1kWmFwY0tRTFpxaFhURnh2bWF0QU51eEJQWFB0cFkza3doNzEvQXd5M0NSS0VCakp5TThoY3lsTENFbWRmT0tua2NhVHc4cDQ1Y3hQSkswVXZVcEJ3ODhsUTNKOGZpRHVUd2FkczZrNDJyaWZ4bzlLNUZPdGpQRlRTbk1nZHJ2Z1o1WHVzSXFxYytmbmxmNmdKS1JiOGpOTEZ4NEN2V0tucHM2TzBIYW40bWVYeWIyZ0h4RkI3dXhTdmZwaXpqbWZ3d3Y2RWRtQjhIS2tXZ2VRemdYOUcvYWRYS3A5djFoL2o5dWRDL29CY1h1N1F5UmpseGZvQjZuUnNadjN5NmIvMG5iMHhPOXR2aWoveHA2alZwZG9PRnlNbjBtQ1dVdjEyd3Z3ODBNcVluK1MxMXg4ZHora3VoZjBOMkY3Z0JVelh1SExHMmxSWnN1WXQrbEMrelpzUjhnTkdQRVZ2bnp3cUFWOC9LalpmVVlNR1dOd1QzckZqUHNITW5aOWVkSUYwb042VkFyZmJqU213ZEdTZ0xkb3Nob3dJMk9tNE9FTHV4OS82OEVvd0YvZ0tRUHpxRVlJMzdmYnkzQi8wNE9QRUlZWUtpUGp3QnQxVmtneEZqZEZPQ3dCSmR1TkhENjdPOGh4cThxQ2o4eFlDZlBWSW9Ud0pTWnlpSStRYkU5QkluV0V5eGdOa1VVUWlzQU00REt3amRCYU44b3pDc0ZEMENueGhJeVpJWlRzQ25rbXpKc0lKY201RVBWYUFZSXVkTDVFRjhNeEtqV0Q0REltakRZdmRwUHBOajVORUJMWVlrZFVJMGI0U3ExY1F4SXRqQXBaSnFKWUNJYzNQc2syM2laRThGeURRQnJNd0dpdXE2V2JTNG5SemRacy95c3g3QXVYYjNXRmcxRWx1MjIyTHhqZnBwQndKbVdDa1dyZmVDWkJTSVJ5UGtnNEdaSGFHQTYxMm1SalVMcnI1a1RHTWFBMFFqQ2wyM0srRGtiN1N5M25ORXBwL2xZalJwaUdNY2FTVHJ6RmVLK25EZSsxalhITnJwSjEzaTFLVzM2LzNySmorUFV4SkxLS2l4RWs1MnZqTlJ0anhOR2R5Q3MzaEw5M1hoazlHaGlUWHdhWmwrR1kzZkVXTmNBWUxKVVFtU1ZFc0RIVHFrcWxoWEdQdDVaN0Q0NkZVY3hiRlQxaUJGSk05cVhjR0FXY05RMm5Oa1l0NHk3N3lpY3J4M2pCRi9zeUkwSlE5VjcrL2ZNK1JqVmg4YmtRNC9yMG5NdS8zWXhpWEtaZG5Hakh5QVgxS3V3MnN4R2E5SmR1aHFBSXVRQ1dLckZoSzhSSXRDOTd5U09NanlacUNNWTBzMFdWYXhNaHhUOEZpbEIzTWVJSTU2QzM3SzRJZEdLazhOSGp2S0RkMUNoUDZrci9LRHVDUTEwd1N0bEhlTWR1Nm15YXgyZ0ZHejRlVURGaTFrYWxqYmdPUWdUM3NYQ05NS0ZoU29oS0VzR25XL3VRN2wwdFpiV2pGSFVUSVhyOGNOY2RJUmt3aDBRdGNlRnQ3SWVoandqdFhxV2hHSFdFWXQ3N3UwcEdCditCbG1yUUtZWFBQYmJ2REx2ZDdmc3JTNG85Z3JjeDRhNHBtTVpXanpxR2Q2dmUyRm53V0ZYYVpxLzN5ZzVmd1p4ZU5wQlRIL3pOS2xWVWRVSk04SFptbHIvOE1QQW1tQ0VrYW9vUFhybnUzTDNTbkt3MEZLVk93WmVlamZHTE1BWTg4VFA0UkZVQjd6aDgxU05oZ1RkeDM0aTZBbDVtZURIdkVid3hvYlVVcGs2aDB6SGo4MUcrNERmdUFxS3llTkI1d0tjcE1QQ2pRV2txVGQyRWJnVjdXbEtDdmtldHNDdjlNakVlY0RIdldjbmVpR0dQU0NvMGUzMVFkdWpCeEU5YU5NeHlGNWV0a2pqQXl2NGs4V2pESHBIbW02RThkUUw4K2pNZk85M1lXVVFEQWM0R1pyOCtBUGFtQW90MGdFNDhXTXZlUHI3L0ZxeUJxWWdlQWx0Ylk0OHRLZ0ZzMU9ocVFoM1lvVDcycU9Td0NSaXFDWFVEZG9Ub3cxeFRDdnFidHJxb092U202SWNPRFIvU2JjZzVqbVNqZ0xhQ2pUK0RqQlF3TW1XVm93OTAySDFGYy81ZEg0MEs3d2RWWFh4SVpmL1JmUWphdGExNHJ2R1hRNFVNTkxydngxUElaUUxNSTNvSm5aRHNBR1RGTkZzWUhHejVuNERreDRudzgxUnl5RmF3YitrcHlQYVBmbUg4VWgxSFBlYnJxRVAyVm45ckVBSzhuekF2ZEtVbFA0eDZ6RmRTaDJ3RiszYVVBYXhUTDJ2MnNrcCtHUFdZcjZWT0xMajJyRytkZDNEemdZZHdTUzdBNmZoaDFIOFZiNVpzbXdqZzFQSmZNNUlCdHNDR0xWcDdHRXo4S09yV2IzeUxkbnpBcmRFcGpGZnYrM1pYdXFSc2wyMFBmRVRsMlpTcFJkUmRNR1Z2LzV4bUtOaW9DTFpnbEo3VGNESHFUdlpkVmtGL2FwNmJUZDVndTJIL2F3M0FaaGt1R0J2NVlxUGVDbm8vS3dFcm1BZlBJNUZsMUUyd01NK0hybWg4N0p0KzJYT0RULzJsR1YyNHU4bUJybXhBalNuOVZMWnpTdEVEN1dicVZ2YnlmVjVJblVLMWd0MWhDOVdqdHozb1JhYitidWYyMGoxbFVBNjErL004R0dmS3NuZTV4ckNDU041c291NlZiLzNXVXVwUVMxN25MMHdHVEN6NmFpRlBuR1ZsOCtrTDQxQVBzcXhvUHAzbUYrL2tneHF4OE9WT1BaaWZNSDJSOWxyMFhYR29MK3FyV0V5ZEFzMVlpTDhlQnZLc2w2Tm50S0crOEUvNWZEcDlmWFpZSGZ6SFJIL3FBWWhsYjU1a3VyY1dCTTBUVUlkUjBLOEtCRVJFTkh0clg4dnBPT3JUWnVvZ04vTUdCNm9zbUs4MGhsUFlIRVk5Q3paVEIwbkhqRDRoeEFZSUhOL041M3hHdmJMSVVkUTdqd2hRaDlqeE1rV0VFSURoQVhOTTExRHZnbC8vZUMvcVUvcnJDZXQyYUlmaTBlT1V3aFNTM2paN1BWTC9NMmZ2RU9xWlJRU3AyK0lyZmxoQkNFbUVIek5FZERIMWY3TU45NmMrWmM2eko2emNGdy9RT2xRU1FvVG5GTERTV25xMGFPSVhQd1krOVNHem5qOWhKWFdBTHBZYUl1TTRCTXNPZEVQcXZId0ZrS2xQcGZmeUNTdXBFMXM0NW1zaERrbkZnbVAwVU1iT084UHptcm9YUE1qUDB2cmp2dzJjUitwVGxYcnZmcmUxMU1YTEVTMGhobWh5WWZoUXR2T0M0TE81ejhCeUg5K2Y1QVNCOWZGdFdVMWRPQjNUQWR5ODJkZzN2UWYxUlRacVBYWFJGVjY5ZU45WFpaeU91aW1Xam1FRElaRllKTFI1aTREQzFLbWdwZzZFSkVMVWx6VjdhVVpkZENyWVNFZ3UxSy9hYlo3Um9ESjFJamJFWkNLa0ZIRU5jMmFla2pwSlJOSW9NeUcxU05EZmJiOXRweloxU3loNkpLUVJvTTVpY2xMcXhCZWozZ3E4S3kwNUxYV2hSQW9oM1hicWszZGk2aUpEUmdqcHQxUFB5WW1wR3dJT2xaQmg4Ly9jdVh0UUYrKzR3NkZPM0ZxRSt0YUFuNG5OYUZDZXVzQzZIVUttcmRScnNYRWt5bE1uVnJXZCtyeVIraGlUazFQZnZsT2RrSTNRV1dXZG5qb3BkNmN1dWp4VEIrcTMzUzFNNTUrZXV0UHQ3azFaWVo2ZGVqWnZwajV1aldHV1hWN1htUHIyMm9iSUtVbHNLNC95MUFYcWVDSVpnU2s2TTNVYURJZFFGMXQzcnpwMWtWRTlRamxIb1IweGlsT25JUk9oM29wVU5kelRVamRGeXMxaXRTU1JJWUpxVTZkQzR3WUpxVVNxMVFJRE05V21MalJha3hGU2lMd3FBc05obGFZdXRFYU56WVNrUXYwd2IrL0c2RXRkYkdUeUtOeHgxN2ducEM0NEhud1VIOStXMHAycFd6L2ExWStnVGdWM3l3eUVpblpTYjEzbXNKbTZ1SWhTRjBYV0UyS0s5cTlYcDZNdXV1S2tJK0k3Z1ZoNE11ckM2M3hhUW9qd0xQM2VQQmQxNFhrbExTRkVlSXJZdHVWcnFsS253blBCV1VNSVNZWHZUN2JlaWFnNzRxTjVLa0tJK0VhZ1RVczFGYVZ1aUsvZlpIZENTQ0ErUjJETEFsbEZxUU9zbXAxdmhCQUhZRkxKM1R3SmRUTVRuNlU1eFlRUUUyS3dZSEFTNmhBcnhNZUFFRUlncGlxMTFpbW9VNGdaYVYrbmVaQjVlYmRUVUE4aFVBMFdJVUJqZWdmdkJOUkJocTM5V1Y4TnNqbVZsVysrYmRIOGxwOEIyUERyMzhjd2hPTW5ILzB6eXpyOS9nOWVQUXhtUzFnSjk5cThiUVhiWXNPQXRIK1RTcjBxMjhGc1VQc3l4amJNWVBFM3JXQjZVTGZ1TUtEK1pBdGhkakNOc2FFMWRiQmRWWCswRTJqaFdHdHJUZDBHMnJRekFHWHAvenJVVkdmcUZHb0hZUVVaaFhMT3VhVXhkUk5xWTlMZms0MEx0ZmpxVlN1WUR0UXpLTlg4bXp4eG9IN0dPZFNXdWdlbG1mTmY3MmRCN2U5a3RhTXBkYmdWcDUzNUwzMEo5Y2dwMVpSNkJMWXl2UHdYWDBkZ3Ezd2JUMHZxZ0d0M0V3cDgxT1djODV1cElYVURicS8zL0g4bHdvWDdLZnRueWg1bjZ5V0FvUjVzK09oZlA3Z0x0UlNUczIrRFJxdzdHSFYrSjlxSmNZTmJwdjR0VzBWVHNEZm8reXVraTdnam5GTG0zeXd3NEJMeWYza0dmYVNDZy9QamNvc0h0dzJiczVUcUJUMkVZL08xVXVTZllhOEJuOXg3V2tFSDJ5L04rZU1saTlzTTkrUzVzRFNDVGpOQU5BOGpMOElKVXRsMWNxZytvUEY5M0JabzlZRFA1bmRiRytnQXkwdStxZnBqSjhVZGtqclRSdGxGWmpROGtmcWh5QmxCUHB3M3VsaDJxd1RsOHRpclpZK2dqMDkxaVJwblVDd0I0bEdBYjJnRms5U3FnN3E3SjNlSkV0RG44MUlMNmhrc2xOK2JwZHdKOUFQR1VBUG9IaXdUL3B1SkJXdGllSzErOUdpV0ROYkEvRzdUTWhMWWozalRDcWFLUkFPd2dYbVNvUEpoUGNmMnVRNnlpQVA4OWovdG9BRC9rRlJ0WlRkaTJLangrYng2bWdKL3lxajJVY2xwWVhHOHlKTUVQZlRIS0szc0tUQ04rZm1XQUx0aXdCK2tjanJHQlhhbHI4WkoweHV3aWVHTnd0RWpzSmZqdkhvQnd4K2hYeXAxMHpFUnRBWk9yd3FiRlB6M2JWVk54OWpRcnBUM0wyLzlSOUNHbldWcU9sUWpuYUJKbEM5citGWVAvZ3NIU2pZTWVPQ3F6dDdNRzcxQmY5aVd1UTRTSkdBeWFLdk91emVCaFFNZEx2Rkp4ZHlqRDQ3aGJabkhLTUUvcmxPd1dBcFBZWHdYUTFQd2dFbkZZbDdBNFEzdCt4TlpBLzh6cTVaN3REdStzNTAxd2Mrbm5Lbm1VRE40VmE4K0hOSUQrQjk2VU11aCtqMjhxbitxOEVDTktQaHhRRkFwSFdQQ0ExaFE0QWxIK0o4NlV1ZW9SRU1FVmYvY1cyN0QrMVBXT09xNFV2aW9jZEhLd0JqK1kzbWlqS3BIOEs4Nkt4WWtvMno0VjR3UHFpaTcyY0wvOGVPaUdhTXBncktyMGdxV3dydlNoWVZNQ2g4OGJoM1N2cmM0Q0FySGx0VVlhQUtmRmxDanQ5cEVjS1U4WC9xTHc0Y3hmRW9VcUc5RUUvd2YzaTlOaUJqSmlLRHM4aGZ6bkFyZXFzKzN4ZmtRaEJ6WW1vOC9LbXBNRUZTOTlSYWZFR2s4SHZpcUhTVW91cmFtN1JERHN2TzczSGtCNDhZeFZIM05WNGdSd3BqWmw1cTYxMk9vK2lwTkE3M2kvdStIbHpwNnhJZ2ExeWFnZkFUTExuVXhMMFI0dS9uYTlhODBSL2dTRXM5MU1BZUV2N2RhZlVaeEVQSUNjeUhyVVFtK3M1WnpQcTEzWkdhSzhEMzZVTTQ0aG5vWXVhZDhnNDY1S05Ham5NVThLMGRRc1JVSEpPUzh3Q2luc2djSVVlT1VianFNMnhXQ3NqY3k1Z1VRU3ZTYjd5RFNBQ042bExDWVJ4R2F2WDdPVlZzbEdZSUtqUElWOHl3VUQ3YjVwVWJvRitDc2xDNTZ4Q2haaWh4TmdnSERvY3FXZ0VINEkrZEk0QXVaR0NmVVNyTG9zV1F5MlJlc29IMk1wWUllSXFoNkoxWkx3T2pLa1d1dUEwWjhQS2VDOGJHTkVNck9FbFd1RFlTeTJWd0t4MmtZTmthaVloNUcxYXdEdU1tUGtYaVdaa2c3UldqMlloQ3ZNc1dvSjhveTE4SEVVQ21RVkpPSkVGcTFjcVJqRU80Y1F0VXBxZDhoZUhrcGNvOGhQSFN3KzBBbVFzNVhpcmtPQ0s1MFNzSGVZb1NrLzV4TFlHUEFaelJ3VmpwU0swVi9mSGNNL0l3RzN2dVFsdE5IYUFIVVVNWUkyTzhNRjlQUFp2TUdmWnpBcUtMcUppVjRjNXRkekJmVy9iTjZYbk54ZmU5SlVlWStZYlF2YUNSWWQ0Q2l5N1MvOGFSb0RWYkpGVCsrbEFxdDk4SElMN29IMU1jd1podG9JUzFtbllhNlZ5RHpOTkdJbk10RG1KV2tBWFRzRmg5NnBRWit4NHc3dEpxRVYvejRJUEVlRlpyZ3d2NFQraTU5SmpTOHd2WnZrdXhWaTR3dmJmOTNKTTMydTBSN0hWTC9RaS8yYkpXTkwrQ2NjODd1Kzk2QkNLOXNPK2U4MkxrcG5GNlJET2ZaN24wT0dFTStWWE9rK3plWFVCcWVPemt3M1E0WkFVS0Q5c3lhbmh6VFJrWHBtVXVwNFhFM0g5enFwTXdILzhqdVdCdmpBcHY4WWZyUnZiSFcvWHpIVkZZZDNwQnNKcWVMSUVzSnJsV2RMWUtjQ3hrbUlWRGpWRlc5TVpWa1VoLzEyOVA0MUQ2UzU2NnNleEtmT3JkU0xZVStoMDhkQ3JsbURWTWowdC9LZExGMHcxY052OUliTzJzQ0dhZFJtbnAzUWQ0ZFNXZHFSNTJ1RlNZMnlMdnlpWHFheGpKVEdSQ0p4VTUxakdXR3pKRjdZci9wNjVmOGJVTHAxdzVSTTlPcmpzM3VwZ29ySzQyZzBjZXB6bTJrd0tJblFnZ2hUcWFMZGU4TGhiWnVHMEdsZzVtWjZ0QWlLb2tkcTUvKzdST0hLQ2FHVjZpZElaaEwzeUFLU2xEUFRGMHZHaEpGeFV3VWpXYm1McldJc2tMZFRNWCtzQzczREtLeW1INmhXaFE1M0gyTHFDNldmMWNwaXB4S0Raai9jYXVxZUZYV2hBYlJScUpxVkFEODFNWVcwVW5zV1ByVDZ0U2tEdEZNcUJ1Vk1sK0duNnJFTlloK1FtMi9HS1Qxb2FHdEkvTS9DcC9MZUd4UzlmQy9JZ3Q4YTZWeXJHd2E3Z0hSWHFnVGw3MDBHai9VcVUvSktjUU9idlVvUmFSWWhNNUptQk5DaU9HRTkrRndEeHE1RmptVlVHbzRjWFZjOTh6Y3BLNUp5Um1GT2trMVRudjdWamFQZGVxZWsvaGY4ZUo3Tyt3SG5nMWRtZWdlSnk1S0JudFJWdTBTMWN4OW5VZStlU0gvNjF6OXVNQnVnTy91c2U5Y3lIL2FlTlB5VTdRTTJWamZBdHU4RE1zTHBmZlRhcGdBaTl4c25zWTZDNndMN1FleGd1VGV0TDF3M29CTlE5ZVU2VVY4dVlkMWd6aTcxOTJ3emNteXNhL0xQQW05aS9oNjlJNGZSRWxlMXYyMElreHB5anlOUXQrOWdJdFlldE95SGRlUGtxd29xK2E1OHM5ajM5WmxrYVZ4NERxMmJScjA0Z1lmN05pTzYzbCs0UHVlNjlpV2VxSEpmeW55UDZJWU0xUjFBQUFBQUVsRlRrU3VRbUNDXCIsXG4gICAgbnVtYmVyX2ljb246XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVhjQUFBRjNDQU1BQUFCcEh2dk1BQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQUZ6VWtkQ0FLN09IT2tBQUFBWmRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU1UY3picDlqQUFBQUNYQklXWE1BQUE3REFBQU93d0hIYjZoa0FBQUFlRkJNVkVWSGNFdzRQVkE4UGxBM1BGUTRQRkE0UEZBNFBGQTRPbEkzUEZBNFBFODRQRkE0UEZBMk4xQTRQRkEzUEZBNE8xQTRQRkE0UEZBNFBGQTVQbEE0UEU4NFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTNQRTg0TzFBNE8xQTRQRkE0UEZBM08xQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQzRUazNkQUFBQUozUlNUbE1BSFE4QlFJRDZFMCthNGY0RndPOHg5ZXFoQ1NSZ3NaSE4wdG5HYVRoeFNLb3JWN2w1UFlqRmkrQ3BBQUFXMjBsRVFWUVlHZTNBaDJLaVhMc0Y0RVhiNEtaM3hGN2l1djg3UE9lZitZWTBFeFZlRlJNZlBBQXJ5RTNUZFkxNFZlN3JkZGhNVzYzVEtGRytpaUt0MjJrenF5Yk8zRnNVcnV1YWVSNVllQnJFTW8xTi9MSXE5L1Y2MWthSy8vZzhMdEZOTlhIbW5yMklDemZIVXcvdVpsWHU2MnJXUmo0dmxlaHBtQjNtM3NLdzhIUTJxL0QyazJyV3BqNkhTSFN6V3p2bElzZlRTWmJoSFdZNlRSUmxKS21lWm1XYzQra3JsbVY0OVZTUnZrOXBhVGJmV0phRnAvY0N0M2h4ZG9yWE5LMjNHemZIMHo5QjhUS2Z6Q0plbldyWCs5WEd0UEFFRk41aDF5cmVpSy9EU1JrSCtPWE0xV0dtRlc5S3BkT3NOQ3o4WHJIVEpJcDM0Q2M2OHl6OFJua3hEeFh2cVQwc3pBQy9TbDdZZGN1N1M2dDU3T0xYeUYvMlZjcFJVRTN0RlFGK0EzYzdtU1ljRGFWRFo0RWZ6MWhPSThWeFNkSnNGZURuc2dMam9EbEt5YzdMTGZ4SXVlRmxLVWZMRCtlRmlSL0hLdVpWd2xIekcyZVI0MmN4eWwzSzBVc2FKOFlQNG01bktSOUMwam9GZm9qQTNpVStINFZxNXk1K2dEek9FajZXMmRhMThOankrS0Q1Y05SNjVlS0JXY1YrcHZpQWZGM2JPUjZWV2M0aVBxaWtQUlI0VFBZdTRnTkwwcm1KaDJNWmg1UVBUdTBXQVI2THV3cjVBN1Q3QWc4a2p5Y3Bmd1MxVzdsNEZPNXlwdmhUNk1uR3drTllyQ09mUDRlYWxUa2VRSm42L0ZuVUJHTVhGRFYvb05rcXg1amwyMUR4SjlKN3c4Sm9HWHZOSHlyS2JBc2paZThpL2xpcW5XT2NTdTN6Qi9PVDJzRG9XTzQrNVErbmRyR0ZrU25xaUQ5ZjQrVVlsVVdsK0J1MGN4ZmpFWGdOZjRsMFVtQXN6S1htcjZGbUM0eURXeWY4VGFZMnhxQlk4NWZSMnh4Mzl4THkxNGtjQTNmbVRma2JaUnZjVXo3WFBuOGp0VnZnZnZKbHdsOUtUV1BjUzc3a0w5WnVjQit1dzE5TnYrQWVqRnJ4ZDlNZWJzK29FLzV5dnQ3aTF0eEp3bDlQcFI1dUs1L3dpYVJhNEpiY0NaLytVREZ1eDVqdzZUL1JDcmRpMUFtZi9tbFh1QTIzVHZqVThSc2J0NUE3aWs5ditMTU5yaTlmOHVtRDBNQzFCWHMrZlZJWnVMSXk0ZE5ubVl1cjhsbytIYUZxRTFjVWh6NmZqa24yQWE3R1dQUHBDNmxuNFVyY0NaKytOSDNCZFpnSFBuMmpXZUFhZ21YRXArODBNYTdBMDN6NmxsOFpFTGRvK0hSQ2NzZ2h5eW9xUHAya3R3RkV1YlhpMDJtTmJVSFNQcUl3MVV6dXJvb29iVmRBVUpsU1d1cTVkMWZzS0UxTkFvaXhOY1ZOQXR5ZHRVMHBUZTBoeGRqNWxKWVlHSU9LNHFLVkJSSDVQcUkwTmNjb3hDbWwrYnNDRW9LdHByalF3ampzS1M0NnVCQlFoQlNYcmpBUzdvemkwakxBY0xXaXVJbUxrYkE4UlhGTmdjRkt5bXRmTUJhV3U2YThERU10VW9wVGRZN3hXR25LV3dZWXduTFhQcVg1VFl3UmNTZUs0dlFDUStUTGlPTFVFcU95YUNuT1h4dm96NHBuUHNYTlhJeEs0Q2lLUytjV2VuTW5pdkpzakV5dUtjNmZ4ZWpMV3FXVWwyRjB0b3J5YWhjOUdTSGw2UUxqVTFHZVhsbm81MEI1YWg5Z2ZCYWE4a0lEdmRncDVZVWJqRkIrb0R6bG9BOXpSM25wUE1BSVdmR004cUlGTG1lVkVlWHRESXpUTXFHOHpNTEZpaG5scFI1R3FnaDlpa3UzRmk2VTd5UEtXd2NZcXpLaU9GVVp1RkE4bzd4MGc5RnlLOHBMNXprdWtoOFU1ZTB4WWpIbCtXR0JpOFNhOG1ZNVJzdzZVSjdhNTdoQWtGRmU0bGtZczd5bHZLbUJDOWdKeGZtWmkxR3o1Z25sSFhBK2QwZDVlbVZoM0l5Szh2UUdaOXNtRktkcUV5TVhiRFhsWlRpWE1mTXBybDFnOVBMTXA3aG9oZk5ZWlVweHlzSDRXYmFtT0pYbE9FdXhvN3pXeFNPb2ZZclRub1V6NVBPVTRwU0hoMUMwRktjeUEyY3dLc3BiNDBHVWxLZFhGazZ5dklUaWRJd0hrVmNVcDJvWEp3VVo1VGs1SHNWR1VWeGI0QlRMU0NsdUZ1TmhtTFdpT01mQ0tRZUtpNVlCSHNkaVNuR3RnUk1NVFduK3pzQUR5WjJJNHBZNFlVbHhVWW1IVWpRVXB3MTh4M0tuRkZjRmVDaldQS0c0T2I2MWpTaE54WGcwRGNYTlhId2pueWhLYy9CdzdJalNVZy9mZUpsUzJ0VEY0NmtwVFUxTWZDbmZKeFNXYkMwOEhLdVlVbHF6d0plS2l0TFdCaDVRTUtlMGFCbmdLM1pLWWRyRFF5cDJsRllaK0VKZVU1aktYRHltYlVwaDJyWndYTkZTbUg3Qmd6TFdpc0lPT1k2YlU1aGZXM2hVSzAxaFV3UEhoUlRXR25oWStZVEMxQlpIeFlyQ3RuaGdyazloR1k1eUtLekNJN1BtaXJKU0UwZVlEV1dsTDNoc013cmI0b2hWUWxIK0ljZGo4MUxLeW5ERVFWSFVOTWFEY3llVXBRMThVc3dvS3RrSGVIQ1czVkpVc3NVbm5xYW9XWUdIWngxOFNsSVRDeDhFQjBWSnlSdy9RTno0bE5RVStLRFlVVlJvNGlkWUpwU2tQWHp3MGxKU3NzQVpuSTZCNnpKc3B3bzFTVFpoV0pjR3ptTzVNMHBLbkFEdkJITkZTVFhPc0dUSHhoWEZkY01QZEdiakxEWWwrV3NENzdnVFNtcGRuRmJ5bFkxck1Vdk5vNW9TWjdBeVNtcGl2RlBNS0VqTkE1ems4QTBiMTJFNkViOFVlVGpOVFNrbzhpeTg5UkpSVUdYZ0ZMUGlXemF1d3RiOFZtWGlCQ3ZZSnhSME1QR0c1VkJRV2xvNElkWjh4OFlWbUJWUGlUeWNVb1FVdERQd2hyV2pITFYyY1lMREQyeklNeHFlSWNZSndUeWxuRFRHRzRhaUhMM0M5K3lHSDlrUUYwYzhSeFRqQkhkSE9mNGNiMndwYUlKdkdSay9zeUV0am5pZUtNWUoyNVJ5TXJ3eG9aelV3RGZpak1mWUVHWTJQR0lhOGJNR3A2d3BaMnFoWTAwcHA4UVhiSHZwYUI1blExakk5MExIdHZHSDdWUjhiNGtUNHBSaVZJRk9vU2dtRFBBRmZzT0dySkp2UmJXQnR3eUhiMFVHVGxoU3poeWRMY1ZFTnI3Q2I5Z1FaV3Erc1RUeGtSSHlqUXdubURPS1dhTlRVMHh0NGl2OGhnMVJEbDlGTVk3SitDckNDZGFLWWxMOEU4d29wWDNCbC9oUnhJNE5VU0U3VXhQSGhYemw0UVEzOHluRTMrQS9SVXNoeVNISGwvaGU1RG5zMkJCbFZ2eFBpSzhZRVRzWlRsbHBDdkZML01kTEthUXA4RFcrazVsdzJMRWhMT01ma1lFdk9leEVPTVdzRThyd0ovalBQcUdNWklsdjhJM1FBT0N3WTBOYXh2OHA4YldZcjNCUzNGTElMTUJmRTBVWnN4emZZQ2VMOFQ4T096YkVaU1FyZkVlelkrSUV5M0lVUmZpdGdUL2NpakxVQzc3RHY2WkxBMzg1N05pUWw1RUd2aE95WStPa0lLVU1iZU9Qell3eUp2Z1dHWVZaYWFEanNHUGpDdW9NMzZyWnNYR2FsMUJFV3VLUFZVc1JiWUhMT096WXVBT0hIUnRuV0ZORTR1Q1BNcVVFZng3Z01nNDdOdTZnWnNmR0dXSk5DWDZXQTRDMTl5a2hMSEFoaHgwYmR4Q3lZK0FNdVVNUk93TUF6Sm9Tb2hLWGN0aXhjUWVhSFp3bG5sRkNFd09BVVZHQVg3bTRsTU9PamR1TDJRbHhubVZDQWRvRGdNMk1BbElQRjNQWXNYRjdHVHNPemxQc2ZBNFhsUUFRdHhTUTViaVl3NDZObTR2NUtzYVp0aEdIODVjV2dKZUl3MFVHTHVld1krUFd6SVlkalhPWmF3bzQ1QUJXUG9lYm93ZUhIUnUzRnZKVmliTVZGSkM1Z0ZWeXVGbUFIaHgyYk55V0VmSlZaT0o4anMvQmRnVVE3RGxZNUZub3dXSEh4aTJaeTRodmVMaEEzbkt3NlFiSWF3NDJjZEdIdzQ2Tm16SHRMT0piRlM1aGxSRUg4dE1GWUs0NVZMdXkwSWZEam8wcnM1MC82ckRoQjFNVEZ6SFdIRXJaRnN3WkIxSjFqbDRjZG14Y21jTXZhQk9Yc1R6Tm9Vb0xic3VCcGpINmNkaXhjV1VPajV2R3VGU2VjYWg5QURmaU1HcVBuaHgyYkZ5Wnc2TXlFNWQ3YVRuUUlZQ2hPRXpqb2llSEhSdFg1dkFJN2FHWGc4OWg2aHd4QjdMUmw4T09qU3R6ZUVSb294ZWo1VEJaamhXSHlTejA1YkJqNDhvY0hwV1o2R1BMWWFvY0pRZEpDL1Rtc0dQanlod2VwMlAwWUZVY1pKWmp6eUhVUGtkdkRqczJyc3poRjZJWVBXd1NEakUxVVhPSTJRYjlPZXpZdURLSFg0bGlYTTQ4S0E2Z1RhdzVRRFFQMEovRGpvM2JpTzJ5RHZsZUZPTnljY01CSWhNaEI5aTVHTUJoeDhZTm1Vdk50eHBjTHQ5SDdFKzVhTmhmdE1VUURqczJic3VMK0lhRHl4a3pEdUJpeXY0cURPS3dZK1BHekpCdkdMamNQR0ovQmxyMkZtMHdpTU9Palp1citDckQ1YXdaK3l1ZzJkc2V3empzMkxnNWM4cE9aT0p5aTRpOWJhRFoxOHpGTUE0N05tN1A0S3NsZWppd3R4Z3BlMUtlaFdFY2RtemNRYzFPaUI2TUtmdGFJR0pQbVl1QkhIWnMzSUhKVitqQkt0blhDeEwyb3owTTViQmo0eDVDZG1MMFlGVHN5WVppTDJwaVlpaUhIUnYzc0dSbmlUNjJLZnRad1djdnlSNkRPZXpZdUFlYkhRZDl2RXpaendxS3ZmaTdBaGNMZVI3Y1NNeU9neDV5SjJFL0swVHNSeTBEWENya2VYQXI3SVRvSWRic3lVYkVucVliWENya2VYQXI3SVM0WEQ1aFh3dG85blVJY0tHUTU4R3RzSlBoY3JIUHZtSm85cFhHdUZESTgrQWsyN1pMMjdZTmZDZkdDVFk3RGk1bXp0amJCaTE3bStGQ0ljK0Q3OWhPeUZkTjdaazRMdE00d1dQSHdjV1c3Sy9BbEwzNUpTNFQ4ano0a3BmeHM5RERaMlpGbHZoZXpZNk5TMjFhOW1lZ1lYL2F4VVZDbmdmSG1ZN21jYnJFQjJaRE1qTHhyWWFkR0plYUtQWm5ZTWIra2tPQVM0UThENDR4blloZmF3eThaVGI4bndyZnNkblJ1SkMxYXRtZjc2TGlBTk1YWENMa2VYREVNdUszb2hLdllzMi9QSHdqWkNmRGhkeU1BeVF1Smh4QTFTNXV3Z2g1VW8xLzRvai9pV0o4cWVRckQ1Y0p0aWtIMENZY0RwR3VjQXRseERPVStFL0VWeVcrNFBGVmhNdFk3bzVEdENibUhHVHQ0dnBxbnFmRVh6WGZ5SENVRi9HVmd3dk5GWWVZbWZBNGpJZXJ5M2lteU1BZlpzUTN3aEtmbUJYZjBDWXVrMGNjWkpkandXR21McTRzNDBmVDJuR1dqbE5QK1VHRnZ6eStFOVVHM3JJenZsUGlNc0dFdzZ4ekZCem9nT3ZLK042ME5QQ1BXV3ErWStPdmpCODBsZU40OXY4NFljVDNRbHpJVmh4bWtzTk5PRXo2Z211eStVNW80NzFseERjcS9HVk9lYmJJd0dYY25jOWhEZ0ZjeldIOEtzYzFaWHdWbGZqRW1QSU5FMytaVTU0cGluR2hlY1NCOWdIY2hnT2xKYTRxNHoraGdTUE1pSzlLL01lWThpeFJqQXNWSVllYUJ6QXJEdVR2REZ4VnhyOHlIR2Z6VllWL3pJcG5pR0pjS05nckR1UjdGdklKaDRybUFhN0puUEovTW53bFpLZkJLNGNuVlNZdVpNVlREaFV0Z056aFlFMkJxektuSkN0OHFlUXJ2R0dFL0ZhMHhNV0Ntb08xTVJETU9aaHlMRnlWT2VYVXhOZjRDdStVVTM0cGNneGM3aVhpWUxNQ3NEd09wd3hjVjZ3TmZJT3Y4SUZkOFNoZG11aWo0WEJyQTRDZGNMZ3F3RDN4RlQ0eHZTemlPMUcxak5IUG5BSW1Kb0NGcG9BdDdzaG1KOFJScHIxMG5Db01LOGR4dkJpOUdab0NuQUJBUEtXQXhzRDlsT3lFdUtiOGtIQTROYmNBRkNFRkpBN3VSN05UNDVyc2xnTFNMUUM0R1NVMEM5eUx3MWN4cnNpZEtBcG9iUURJRHhSUjU3aVBrcTlDWEpHMWlpZ2gzT0IvNWdrbDZKV0ZleWo1Um9rcmNpdUtXTHY0SDA5VGdyODJjUWNPMzlDNHBwSWlWSTAvRmcxRkpGdmNuRkh4TFJ0WFpMUVVFUzN4aDdHakRCM2d4cHlJYnptNHBnbGxhQTkvV0dzS09lQ21TczEzcHJnbU82S01kb08vbklReW9oaTNZNGQ4YjJyaWl2S2RUeGxOanIvS2xESlVadUpHU3MwUHBpYXV5Q3BUeXZEWCtNOUNVNGplNGlaS3pZOUNFOWRVN0NqRTMrTS8rWlJDL01yQTlaV2Fuemk0cW55WlVJai9nbjh5U2tsS0MxZG1hMzZpWTF4WE1hV1VKTWMvSmNYTUNseVZVZkV6eDhSMVdRZUsyYUVUVTg0ZTErUkUvS1F5Y0cyRm9wZ2xPbmxLTWJyQTFjUU5Qd2x0WEYyK281d1lyekxLMmVGYXZJZ2ZaVGF1enlvcFIrZDROYWNjdGNWMU9Qd29NM0FMeFpSeUtyeXhvYUNwaTJ1bytGNlVHYmlOZzZLY1BkNndwcFFUN1FQSXkvaGViZUpHWHFhVW8xWjR3Nm9wcUlraEx1TTdtWUZiTVdzS2FneThZVzBWNVNRSEU4S1dmRXZidUJscnBTbG80dUt0VFV0QmVnRlpIdDl5Y0VObVJVSEpQTUJiN3BxU3NoeVNUTTFYa1kxYjJpb0thbC93VHI3M0tjbUdwSnF2cGladUtkZVV0Q3Z3M2twVFV1TkNqczFYVXhPM1pOV1VwT29jNzIxQ2l0cERUc2pPMU1STkxTSktTa3Q4WUU0VUpla1lVbUoydEltYmN0ZUtrcVl4UHJES2xKTFVPb0NRakIwYnQxV21sT1N2YzN3VVR5bEtlNUJoc2xQanRvcUtvcElsUHNrelJWRnJBeUpLZGd6Y1ZEQlBLQ3FOOFZtWlVGUmFCcENROFo4S3Q3VnBLQ3NNOEptaEtXdG1RRUxFZjVhNExZZkNsampDeWloTExTRWdacWNKenhGRHlDYWxMRlhnR0kvQ0VoZkRlYnlRRFNFaGhlMHNIR08xRkxZT01KakRDOW1RVWZvVXRzUnhCd3BUSGdiTGVDRWJJb3dwaFVVYkhMZElLY3ZmR1JncTVJVnNTTWlkaE1MV09ZNHpLd3FMbGhncTVJVnNTRmhNS1N6YVdqZ3VtQ3ZLOG1jeEJncDVJUnNDekZwUjJHeURyOFFOcFRrNWh1R2xiQWg0U1NuTXIwMTh4YTBWaGJVTEM0UHdVamFHTTllVXBqMThiYXNwYlpKakVGN0t4bkFlcGZtVmdhOFZJYVZGS3d4aVg4ckVZTzZVMHFLOWhhOEZUa0pwYllCSGM2QTRIZU03aTVUaTluZ3dpNVRpSmhhK2xWR2FuMjd3VVBLMW9qUmw0M3VyaE5KVWJlS0JXRnROY1d1Y0VPd29UcS93UUl5SzRxSVhuT0w1bEtZeUF3OGptRWNVdHc1d1NoNVNYTEsxOENpTWh1SWl6OElwMXR5bnVOREZvM0FvcnpKd1d0RlEzaHdQd29nb0xwb0hPTTEwRW9yVEJSNUNYbEdjSDI1d2prVkRjZjRhRDJHcktDNWFCamhIN2lRVUYzbDRBTWJNcHpSL1Z1QThjVXQ1TXhQanQwOG9McGxiT0pPaktDNmFCeGk3UlVONU14Zm5LbHJLQ3pjWXVmeWdLQzd4Y0w0NTVTWDdIS05tMlpyeTFqbk81ODRvVDI4d2FzR2E4dElYWEdLcktNNmZXQmd6VDFIZXhNUWwzTFZQZVRGR0xHOHByNDF4RVd1bEtXOW1ZclFzaC9LU2c0bkx1SFZDZVV1TVZweFNuTjhzY0NtN3BienBCaU5sWm9yaWtuMk9TK1dIaE9MVUpNQTRlWnJ5WmdZdVY2U1UxNjR3U3NhYVY3QkZIM05GZVptTEViSzJDZVZWNk1YY1VWN3FXUmdmWTBaNWVvRitGaTNsN1Z5TXo1N3lrcVdGZm9LOW9qZzF4K2hzVXNxckN2UlY3Q2d2Y1RFMkZjWDVlbVdodDVXbXZFbUFjZGtxaWxPMWlmN2NpYUs0WklWUmNVT2YwdnhaakNFMk00cnpLd01qRWl3amlsTWxCZ2xLUlhIcEhDTVN6eWd2TXpGTVBxRTRmMWRnTkV4SFVWempZckFaNVMwRGpFV3NLUzVhWWJpVnByaHBqSkVJTW9wTG5CekQ1ZnVJNG1xTWhLMG9UYTBMU0RBeVJXblJDMGJCblZKY3U3SWd3YkpiaXB0YUdBT0g0cEpsRGhuV1BLRTBmNDRSaURYRlpRSEUxSXJTMmdKM0Ywd1VwYlVGNUJnN1Nrc20zdDN0TmFYcEZTVEZEWi9Pa000RFNMSzhsazhuSmJVTFdjRTg1ZE1wczQwRlllNUU4ZWw3ZWdWNXhZeFAzMHJtdUliRmxFL2ZVSFdPcTdBMW43N2tyMTFjeVRiaTAxZDJHMXhMN3ZEcEM4M0N3dFVZbWVMVEVYN3I0Wm8yTzhXbno5SVMxN1dZOHVtekV0Y1d0M3o2cU1UMWJUU2YzcHNIdUlFWDdmUHBsWEp5M0lTbmZUNzlrMHhjM01nMjVkTS9tWUdiOFJTZi9zb00zTkJDOGVsL0toYzNGVWQ4SWpNWE43WnFmZjUyU1diZzVsYU56OTlOVFF6Y2dUM2o3K2E0dUl0TnlOOXNudU5PaklxL1Z4bmdib3hNOFZmeWRZbDdjdXVFdjFIajRiN01mY3JmWjdmQXZRWGVsTC9OdXNEOVdTOE5mNVZrVW1BVUZvM1AzeU9wWFl4RVhDWDhMZlE4eDJnWUI4MWZJWm10TUNiNXR1RXZrTlliakV0Zzd4Ui9PajEzTFl5TVZVd1VmN1oyRldDRWduM2s4K2RLc2dJanRkcEYvS0ZVdXd3d1ZrRnhTUGtqSmV0VmpoRnp5NFkvVU9RVUZrWXRLREwrT00wcXgvZ3R0YzhmeEZlWmkwY1FMTmFwejU5Q3pVb1REOEtZei9oRDZEckc0N0RpV3ZNSFNLcVZpWWZpcmtMRlI2ZVhoWVVIWXhsT3hNZFdMU3c4b2tXV0tqNG9QNWx0OGFpc2JaWDZmRVJKc3pmd3VDeGpIaW8rbnZhd3lQSFE4bUkvNVlOSko3R0poNWNiQjgwSGtxeGZUUHdNbXl4U2ZBaCtNdk55L0J5clRDdU9uaC9ONWk1K2xOekx0T0s0UmVHeXNQRERXTWFxYmpsaVVUWGZCUGlCTExkd1dvNVV0UGFNQUQrVlpTdzFSMGl0WHdJTFA1b3huNldLSStKSGVtTGpGM0M5U1JOeEpIeGQ3V01MdjRPNVdGYWFJeEROYXMrdzhIc0VobjJZS3Q1WHRONXVUUHd5Vm01c3M1UjNvM2JMVFc3aGR6SzNtVTRVYjh4UDBuQlpXUGpWak8yazBZblBXMUhwZEwyTUF6eFpoZWVzbTRnM2tMUzd1b3h6UFAwVkdMRjMyS1UrcjBrMWsvbExrZVBwTGNzMDRuazJWYnlPdEhKV2hodmc2U2lybUs5VDMvY3B4dmQ5RlRvdk9aNU8yWlNUV2F2VHhPY3dLdEp0czk3Yk9aN09GQmgyNldTN1JrYysrMUJwRzY3cnBiZko4WFNwM0lpOWNubklkdE5VOFV4KzFNN1dFMmUrdFRjdW52b0xjcmZZTE94eWY2aXpLcHpxU1BFVFA5SHRiTGVlSFBaemJ4RVhoaGxZZUpKZ1dVR1Evei9UTkYzWEtEYng0c1ZlclZiMkl0NFVodUc2cG1ubWVSNEVnWVhIOEg5aXJWUllNTkU4WUFBQUFBQkpSVTVFcmtKZ2dnPT1cIixcbiAgICB0cmFjZV9pY29uOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFaQUFBQUdRQ0FNQUFBQzNZY2IrQUFBQWVGQk1WRVZIY0V3NFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTVPMDR4TjBzNFBGQTRQRkExTjFBNFBGQTRQRkE1UFZBNFBFODNQRTg0UEZBNE8xRTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTRQRkE0UEZBNFBGQTNQRkE0UEZBNFBGQTRQRkE0UEZBNFBFODRQRkE0UEZBNFBGQTNQRkE0UEZCaWtmZ1VBQUFBSjNSU1RsTUFMZnp3eGZucTlBMEJKTmdFTlo0SUhSZmxFYWpSVFQ3ZVZIdGp0MFNUc0lPK2EzUEtpbHZ1aGZzMUFBQWFaRWxFUVZRWUdlM0FCNWJhMkFKRjBTc0o1WVFDT2Njei94bisxZTYydjZzS2dRQTlHeWkybms1UzlTTXJUVWZEMmU2UTFhdDViejhZbDQ1cis5NDQzdmZtcXpvNzdHYkRVWnBhVWI5SzlHWlFrQjdYZFc4d0xqM0h0VG5QZGJ4eVBPalY2Mk1hNksxYlFkOGFiYk9OeDQyOFhyWWRXZjBnMU52ZG9zbDZ2aDg3Tm5leW5mRit2cDVFZXJ0VjNrOW50VWZIdkhxVzluTzlYU2xZckh1eGp4SCt1TGRlVkhwcktlbW51N21MWWM1OGwvWVR2VjBTYlZleHd4L2h4S3R0cExkR1NUK2Q5bXorck41MDFFLzA5bFUrcWNjK2Y0RS9YazBDdmYwdTdJK1dKWDlSdVZ6MEU3MzlLeHhtc2M5ZjVzZlpNTmViQW1zZDh5RGl0UlhvZTZ1MlBZOEg0ZzIybGI2cnNCZ3RQUjZPczB5TFVOOVF0Qjc0UENSL3NJNzB6ZVRXMHVlQmVVc3IxL2VSREZjZUQ4NmJEME45RDhWa1kvTU1OcE5DcjYrYXhpNVB3bzJuaVY1YnNZMTVLdkdzME9zS3RySE5rM0hqYmFMWFZFMzJQS1g5cE5McnlTZDdseWZsRHlhSlhrdWV6bTJlMlh3VTZvVkVtY09UYzdKSXI2TFlPcnlBY2x2b0pVd0dMcTloUDlIVEM5T2FGMUpiaVo1YWRmQjRLZDRoMGZQS0YzdGV6bjZZNkVuMU00Y1g1R1I5UGFOZ011WkZqU2VCbms2MDhYbFZ0cnVLOUZ6eXJjZEw4MmU1bmtoUnU3dzR2KzdyV1lTTG1HOGdUaE05aFdEdDhDMDRoMFNQTDR6bWZCdHpLOVNqbTQzNVB1enlxTWRXSGZobTFwVWVXRFMzK1diY3ZhV0h0U2o1aHVJMDBVUEtwdzdma2pOTjlJRDZtY3QzbFJWNk9OYWViNnhuNmJIa3d6SGZtak1KOVVoMkR0K2NzOVBqQ0E2OHNRNzFLR3FiTjl4VnJvZFE5SGo3WVZQb0FmUmozdjRUVy9ycjBwSzNYMkpMZjFsYTh2YWJjcVMvYWxUeTlzRTQxVjgwS25uN3hGdm9yMWw0dkgxUnB2cExoaDV2SnpoRC9SVUxqN2VUdkpIK2dxSEgyMm0yUDlRZnQvQjRhMVNtK3NOR0htOW5PQXY5VWFPU3Q3UEdsdjZndE9UdEFtK2tQeVl0ZWJzb3R2U0g5RXZlV2lndC9SRkZ6RnNydlVwL3dweTNsZ2E1ak11WHZMVzJER1hhenVXdE5YY3JzNUlaYjFjNWhqSnA0ZkYyRldja2c2d3hiMWR5VWhuVDMvTjJ0VjRpUS9LTXR4dlVnY3lZdXJ6ZFlocktoSVhEMjAyOFZBWkVKVzgzOGl4MXJwcGpodDk3SUE1bXpITjE3V0JqeGpwNElHdk1zQS9xVmpqRGtMalFBNGxLREptRjZsSTB4cEJ0cUVjeXc1QnhvUTRGY3d3WmhIb3NHd3paVk9wTXVNWVFKOVdER2JvWXNnN1ZsWVdESVhXdUJ4TnVNTVN6MUpFaXhwUklENmZ5TU1TTDFJbTh4aEI3cHdjMHRURWtDOVdGcllzaGcwS1BKeXdjREhGbjZrRGtZY3BNRDJsaVkwcXF1d1ViVE5ua2VreHpUS2xEM1d2aVk0aGo2VUV0WEF4eEo3cFRmNHdwV2FJSGxkUVlZanVSN3BKbm1PSkVlbGlWaHluTFVQZFlPSml5MVFQYjJSamlqM1NIYW84cGcwb1ByQmhqU2x6b1p1RUJZNDU2YUVPTU9ZUzZWZXBoeWx3UHJzYVVzcTliMVpqaVdYcHdJeGRUTm9sdU04R1lMTkdqeXpEbXFKc1VBMHp4S3oyOFlJd3B2VkMzMkxvWTRzNzBCSFlZczlNTklnZFQ5cFdlUU9CaGltL3Bhbm1HTVJNOWhZV0xLY3RRMTBvZFRGa2xlZzQxcHZpV3JwVFBNY1dMOUNSU0gxTjZnYTR6c1RGbG1laEpKRXVNbWVncTFSNVR5cjZleHhoVE5xR3VNWEV4WmFJbk1yTXh4QjNxQ3NFZVV6YUJua2dWWTBwY3FiMHR4Z3oxVkN5TW1hbTFJc2FVV2s4bXc1UjlycmEyTm9hVWtaNU02bU9JUFZOTFZZd3B5MURQNW9BcFhsL3RUREdsRFBSMDhnR203TlJLRVdPSU85RVRtdGtZc2cvVnhzVEZrRjZnSjVRUE1NUWVxb1ZrZ3lIMlFrOHA5VEZrRU9peW9ZMGhTejJwSmFZTWRWRyt3cEJ4WDAvSzhqR2tEbldKNVdISU90U3ptbUtJMDljbFN3d1pCM3BlZXd6SlFwMFgrWmpoanZURWpqWm11SmJPQ3RjWU1nLzB4UEk5aGt4MVZqSEFrRlJQclhBeG94ZnFuSkdQR1FjOXVRTm11SmJPV1dMR3VLL25Ga1krWnRRNm8vSXdZNnFudDhPUVNNMjJtREhJOWZTU0htYk0xQ2pvWVlTLzBBc1kyaGd4RDlYRThqQmludXNGNUJ1TThQdHFzc1lJUDlWTGlEeU1PS2hCR0dQRVdpOWlqUkYrb2RPR0dCRVhlaEdSaHhGRG5SUm1HTEVMOVNwbUdMSFVTZjBZRXdaNklSdE1HSVE2WmVSamdKL3FoUXhkRExCVG5iTEVoRHJYQ3drM21KRHBoTHpFaEVndnBmSXd3TzNycXdrbVRQVmlwallHVFBSRlVtTkFYT2pGRkQ0R1pQcWlQOGFBclY3T3hLWjdnMUNmcFQ3ZDIrUjZQWE82WjF2NmJFcjNIRXN2YU9IU3ZZTSs2OUc5T3RFTFNtcTY1K1g2S0xMcG5CUHBKUVVsM1V2MTBaYnViZldpZG5SdnBnK1NGWjBiRkhwUnhaak9aZnFnSDlPNW8xNVZ1S0J6ZzFDL1N4MjZOdGNMVzlFMU45THZkblROcy9UQ1JpNWRtK3AzYzdxV0pYcGxOVjJMRS8xZjVkSXh0OUpMQzhaMExkTC9EZW1ZTzlPTDI5bDBiS2ovTzlDeGZhVVhsenQwYksxZjhoNGRtK2psTFZ5NnRkSXYvVEhkV2lWNmZUWGRpdlZMNnRNcEw5STNrTHAweWk3MDA0eHVMUk45QStHU2J1MzBVMDJueWtMZnc1aE83ZldUUTZjbStpYTJObDJ5Qy8wcm9sTzlTdDlFRmRPcFZQK2EwS21odm9zd29sTkgvV3RObDJyZElacGxBMysrSGhhNlI3Qll6NzNCOG1pRnVrT1NiclBZVzAwWGlScGxkR21xZjgzcGtHL3Bka09QSDl4ZW9UdGtMaitVTTkxaDYvQ0R2eXJVeEhMcGpwM3BoMkJQbDFhV2JoUk1mWDRxRjRsdXRJajVaWm5yUnNXQlgrS0ZtaHpvMEZ3LzlNZDBhbC9vSnNrR3dGL3RCZ0MrcGR1TUhJQjRYZnVBdmRHTjVnRFU2ekdBdjFDRGZFQjNZdjFnT1hURzlZQXMxeTEyTmpqYnZxUjBBemlSYmhGNXdENU5wR3JyQUx0RU53Z3l3TnRXVXI2SWdYMmxCak82NCtiNng4aW1NNzFSQ1d4MWc0a1BiQlA5bzZxQlRhVWJySUJlb1I4bUx2Z2ozV0JuUXpsSzlBOXJETlJxa01kMEo5VS90blRHSG1uaGdUZlMxYUlTL0szK1U4eUJMTmUxa2pVd2lQU2ZyUTl4WDFlelBIQVcrazkvRCt4Q25aYjZkR2FxZjJSMFppa2xhMkN1cTAxdG1PZjZLWWpCSHVwYWxnZGVwSi9DR2ppRXVsSytCNmFoZmhxNkVPZHFzS1F6Yy8xalExZkt2cVM4Qnd4MXBXSU1YcXIvMjdxd3luV2x0UTNMUkw5WUhzU0ZyalIwb1pmcmx6d0RwbXBnK1hURkN5WEpveXZyVUZJNGNtQVQ2RG9IWUtmZkJEMXdVbDJuS3FFczlIL0pGRmpyU2pVdzBXK0NHUHhJRGFaMHBwSVUwSlZ4b0gva2MzQkd1a3BVd3FEUTcwWXVySEpkSTFtQ2U5UUhBM0FpWFNYMVlhNFBkalpNUXpYWTB4VkxVa3BIM0pGK0NCZkFTbGZaMmJBTzlidHdCZlpDMTRnOGlDdDlzTE5oSGVvSzRRYmNWQjlFUGd4eU5UamFkR1FoNlVoSDVvSCtzd0hiMGhXU1BUaVJQanE2c0V4MGhaa0xoMFFmV0E3c0ExM0I4bUdUNjZNbE1GU0RmRTlIanBMV2RDVFZUME1YMXJyQ3dvYWxQaWxLR0ZTNndncXc5RkdTZ1p2cUNqTWJ0dnFrOG1DakpwVkxONmFTYXJweDBDLzlNUXdxdFphc3dMUDAyUlQ4Vk8xRlBtVDZMUEloMHhWVzRCWDZMQU5TTlRuUWphV1U5T2pFdUs5ZndnejhWSzFGSmZRQ2ZWYjRzRlI3UzNCVGZURUhOMUpyaFE5TGZUR3hZUjJxUWVUU2lWcXFCblJpcXQrTWdFeXRIVjJZNnFzVmVKWGE2bnN3cVBURkZ0aUZhbXNLdnFVdklnZjJ1WnBzNlVSUDZvL3B3aURYYjVJOStKWGFxZ0ZMWHgxdG1LaXRoUXZMVUYra1BzeHp0UlNVc00vMVJWaURHNmxKMktNTFl5a3E2WUMvMEFkVDRLaVdLZzgyT3NIeUlFdlUwaElZNnF0OEFHV2hsbElmbHFHK1d0Z3dWYU9KVFFjOHlmTG93Q2JSQjZrRHEwVHRUSUNaVGtnMk1LalUwZ0RLWENkc2dhTmEyZ0VMblpBTUlBN1ZKT25SQVZkS0hlN25wL3FvaUNFdTFFcFNROW5YS1Z2d1U3VXpBZzQ2cGZCaEU2cWRPWGlCVGxrQ3FScjFQVHFRSzNXNTMxU2ZMY0VkcVpYK0dIcUJUaWxjT0tpZERIeExKODNCdHRSSzVjTlNKeDF0MktyWm1nNUVHdG5jTFM3MFdRb3MxY3JJaDBPb2t6WlFCbXFqS0dFUTZLUXBzRlVyVzNCVG5XVDVzRXJVS1BLNDMwaEQ3cmNMOVZreWdMRmEyUUZEblRZRkZtcGo1RU9XNktTRkQzV2lOdllRQnpvcDJVT2NxOW1SKzAwMDQyNERuYkFHVXJXeEFxL1NhU01mcG1walpzTkVwL1U5R0FScUlYSmdsZWkwSGJpV3p0aHd0NjEyM010UGRjTEloNTFheUIzSTFLQmZ3anhYQ3huNGxScXN3Qy9Vd3NLRm5Sb1VMcXgxeHREbVhnY2R1RmVkNjRTb2hGV2l5NFpnRDlVZzJVQmNxSVVZVm1weUJHWnFZUWVNMUdRUGNhSXpOdHdyVThhOStqb2wzOE9nMEdWTEtQdHFzZ00vMG1XV0RUTTFDWHlZcTRVYW5GeE5Nc0RTR1lISG5lYXF1WSs5MDJrSGNDSmRGTVN3cjlRa2NtR3J5M2JnUjJxMEFUL1FaV1BJMU9nSUhIWE9sRHZ0dGVJK2NhSFRGc0JSRjFrZVpLRWFEV0NqeS9Zd3FOVG9BQ3gwa1FVTTFTaDFZUm5xak1MbFBySG0zR2VyQnJrRHRTNmF1SEJVc3lXNGdTN3BlN0RLMVdqb3dsUVhUY0dyMUNqd29KZnJuQW4zR2F2SFhUYUptc3pCMFVVSElGS3ppUTFEWFRMeVlhcG1sZ09yWEpmRXNNblZyQVluMEZrcjd1SnB6ejJjVkkxMndFaVhER0NnTTFJSERycGtDeXpVTElnaERuUkI1TUF5VkxNaE1OUlpDNXQ3dUJwd2p6cFJvNUVQVTEzUUI2WTZveHJEUE5jRk5SRG9qQ1c0aFM0WXVuRFVHWWtESzUyVjFOeEZZKzdnUldvV2xUQlBkTjRPM0ZUbjFEQXVkRUVKYzUyekFMYTZZQWRFT21jRGZxQ3o4cEo3cU9RT001MlJEeUF1ZEY0UHhvWE9tWUFkNlR3TDJPcWNwSVNOTGxqQk9OUTVhMkNrODNiY1F3NjNHeFE2WndtK3BiUDZKV3h5blJQNHNOTjVhM0FqbmJVQ0FwMVh3bHBuVFd5WTZyeWk1QTV5dWQxUlp5MkFvODRhK2JEVWVSdm82YXd3aHJqU1dWTmdxTE5Td05KWmtROTFvdk5HM0VFMnR4dnByTVNCbGM2YUFVT2ROd1VxblJONXNNcDExc0tGdGM1YXdqalFXY2tZQnJuT3MzeHVKNS9iOVFLZHRRSTMxemsxVU9tOG9Rc1RuVE4wWWEzeklnZFdpYzVJU3Bqbk91OEFicUN6a3BJN3lPTjI3a1JuYllHRnpobERUeGRFSGl4RG5URUZGam92NlVGYzZRekxoME9vOHl6Z3FMTm1ObmZRbUR2NGljNForWERRR1JhdzB3WDVHRGE1enBpRG0raUNIZGlXenBqWU1ORUZZUWtyblJWekQ4WGM0NURvalA0WU5ybWFUY0cxZE1rU3hvV2FCUTdVdWlSeVlhb3pEa0JmbDZ6QURYVEdnYnRvenoyOFNHZUVHeGdYYXJhQmNhRkxGbUNQMUd3SVRIVFJBQVk2b3dlRFVKZE1nWkdhcFM3M3NOWGpMclhPMllHZnFsRy9oRTJ1UzNJSDFtcVdnVlBvb2d5STFLaHlZSzJMaGk1czFTempMbzdtM01VZTZvd0ltS3BSNnNCQmw2MGdWcU5nRFB0QUZ4MXRPS3JSRWJCMFVlUkRscWhKNm5LWFVpdnVzdzkweGdCNmFuUUVocnBzQ2xocVlqbVFKYm9vOVdFWnFra040MEFYSlRIc2N6V294dHduVnMxOTdLUE9XSUxkVjVNTTdFcVhMWHlZcVVFNGRHR215eW9QZXJrYVZCN01jMTAyQlNkUWd5MTMyaXZqVG1WZnpTWTJITlVraHJsYWlEeklFalZZQXBaYXlLQ3MxQ0QxNFJEcU1zdUdvMDRMWXU0MDE0RjdaV3BtZVpDRk9zMnlZYWNXOGhqMmxScnNZUkNxaFNFd1ZJT1pEUk8xRUk1aHBkTXk3cFZweDcwOFM0MnFHUGFWVHB1Q2I2bU5BemlSVG90Y1dLdU53SU5NRFRKdysycWpCcnV2VTBZdTkxcHJ4dDFXYXBhQkYrbWtmQUJ4b1RZV3dGYW43Y0MxMU1vYzNFcW54ZEFMMWNZT09PcVVtcnR0TmVSK1J6VWFBak9kRkhsUTUyb2pqR0dqay9JOXhKVmFtUUlMblRRQ1ptcGw1RUlXNnFzUjk1dG94UDMyaFpva0pheDBTcmh3WWFaMmxtRDNkVXJrd1NwWEt3c2YxanBwQ1Y2aFZpb0hCcm0rcUR6dU4xTHFjcitaR3RYZ0Z6cGxDWDVmN1F4ZE9PcVVvUXM3dGRQM1lKUHJoR0FNbTF6dExNRzM5TVhPNW42UlVvZjcrWVdhSElHWlRvbGhwWllpRCtwRUp5eUJWTzJFS3lncm5URHlZUnFxSFF0WTZndVBEdVN5UERxUUpXcGdlYkRLOWRVUTdJbGF5amNRRi9vcUdFT2NxS1VKc05VSlUyQ2t0dmJnRlBvb3FlbUFLMFVsSGZBdE5haGlHUGYxUmJpQ3NxKzJac0JRWHgyQnRkcktQWWhEZmRXRGNhSzJsc0JFSHkxY091QkovVEZkMkNScXNBYjdxQytpRXVhNTJxbzhXT21MZkFPT3BkWnFZS0V2TEJlbWFtM2hRcGJvZ3hWZGlLVnFRQ2RtYXREM1lhNHZKaTVzMVY0R2RxVFBMQWMyZ1ZvYnVuQUk5VmtHWHFHMndxQ0VPTmZ2SmpaZDZFbEpqMDdFaFJwa1FLclBWdUQwMWQ3UWhXbW9UN1kyYk5WZXY0UkJvRThpQnphNTJ0c0JSLzJtY09oRUxhbW1FL1pPRFJZK1pJaytTbDNJZElWK0NmdEtuK3lCdnRvTEQyQlA5TW5XaHAydWtKY3dEdlIvVTdxeGxMU21HMjZrMDRveGpQdjZJSy9CSCtrYUdiaERmVFFCbHJwRzVNQWcwRWM5Y0MxZEl3TW0rcVVvNmNaVTBwR09yQktkRks3QjN1a0R5NE5CcFd1a1FFOGZCQU53SWwybEJpYjZZR2hESGVvYVF4ZFdpWDdhMEpHanBKU09PQ09kVnBRd0x2Uzd0UTB6WGFjR2h2cmQwSWM2MTFVV1BxeHkvU2JvZ1dmcEtzRWVQRXYvR2RwMFpDRXBvQ3NETlpnQzYxRC9sN3F3ejNXZGtRK2JRTCtaQXd0ZEo5bUF1OUJ2Smk1a2lhNHpBamFKL3JXaEs1WWtlWFJscDlPaUVrcEx2MVFiOEllNlVyQUI5NmovMndJclhTdjFZVkRvbDJBUGpxVnJyWUJacUg4YzZVd2xTVDI2RWhjNktWd0R0WDdaMnRBTGRLMFU4Q1A5RkpYZ1JMcGFEVXhEL2JRRzFxR3VOWFJobjB0UzM2RXJYaWhKR1oyWjZyUmlBT3h5L1JDT3h1Q2x1dDdCaHF6UXY0ck1obVd1cTZVK2pCZjZ6OUdIZmFDckJTc2dLeVN0NmN4Yy85alNHZGZTYVNNSDNLbCtHSHJBVVRlb1ltRGYxeitLbmcyRFhOZExwb0EvMUE4N0h4anBCc0VBV0NVS1hEb3oxVDlHTnAxWjVUcHRDcEFOKzhWbzZnRlpybHRZWTJBd1M1Tm9zZ0ZLU3plcEFXKzlLUHFMekFWN3Bwc3NYR0ExNjlHZFZQK3dIRHJqcGpvdHFRRmN6L01CQ0hTYm9RL2dsNDROTUExMWs4SUI4RDNQQmFnVDNTU2MwakUzMFQvNlk3cXpEM1JhY0NqNWFWN29WcU1CUDQxbnVsV2V1ZnpIWHdhNjFUR21VN0YrQ1BaMGFLb0dZZXJ4ZzN2SWRidGl4YjgyL1ZBM1M0NE8venFHdWxsWWJlalNYRCtFY3pvMDdxdEpORG5NTjlrc1RYU1BaTEdyOS9WMGtlc3UxbXk1bVIrT2x1NlN1blFvMDcvV2RPbWdiK1JBbDZiNjE0Uk9wZm8ySW9jdUhmV3ZpRTV0Y24wWFl6cVY2ajhlWGZLSCtpYU9OcDBxOUorYVRubjZKdlowcXFlZlpuUnJIZW83bU5LdHJYNUtmVHBWOXZVTldEN2RxdlJUZjB5M2x2b0dsblFyMWk5NWoyN1pDNzI4eUtWYnRmNXZUY2Q2Z1Y1Y05hQmpVLzNmZ283WlE3MjRtVTNIaHZxL3lxRmo0MEl2TFIvUXRVaS9tZE8xcFY3YWdhN0ZvWDZ6bzJ0bHBCZVd1blJ0cXQrbERsMnI5Y0l5dW1aSCtsMC9wbk5EdmF6VXBXdURVTDlMVm5TdVYrbEZCUjZkeS9UUmxzN1pSNzJvclUzblp2b29vbnQrcGRjMHBudXBQdW5SdldXaUZ4Um1kSy9NOWNtVTdubVJYdERJcFhzSGZUYnk2ZDVLTDZpbWU2Nmx6L3BqREpqbzVTeHN1amNJOVZteXdvQkJwUmRUakRFZzAxY1RETEJuZWpFN1RKam9xNkRFQUtldmwxS01NY0R2NjRRbEp0U2hYa21OQ1Ztb0V4WStCbmlwWHNqQ3hRQTMxU245R0JNMmVpRXJUQmlFT2lYSk1HS21sekhFaUtWT0cyTEVvTkNMS0R5TUdPcTBQTWFJblY3RTFNWUVwMUNETlVhNGtWNkRqeEVITmJFOGpLaHp2WUI4aFJGT1gwMkNBVWI0bGw3QXdzV0llYWhHVzh6bzVYcCtHOHpZcWxubFlNWldUKzlvWTBha001YVlFUmQ2Y24wZk0ycWRFYVkrWnF6MTVOWVlZdW1jWW9BWnRxV25Gbm1ZMFF0MVRyakdrSG11WjdiSGtLbk9penpNOEJkNlloTVhNMnhMRnl3eHd4N3JpZlV3SkF0MWdlVmh5RFRVczlwaWlCUHBrbnlPSWVOQ1R5cHlNS1FPZGRFUVV3NTZVZ2RNR2VxeWNJTWg5a2hQcWU5aVNKeW9oWW1MSWZOY1R5am9ZWWc3VkJ0RmpDSDJRazlvWW1QSVBsRXJVMHlKS3oyZGNJOHBPN1dUeEppeTF0T1pZb3JiVjBzekYwUEdmVDBaeThjUWU2YTJpaGhUbG5veVMwelpKMnB0aXpFTFBSWEx4NVN0Mmt2Mm1MSUo5RVR5RWxQS1NsZVkrQmppVHZSRVpqYUd1RU5kb3hwZ2lwL3JlY1NZc2dsMWxRbkdIQkk5aXdQR1RIU2RaSTRwWlY5UEl2VXhaWi9vU2lNSFUybzlpUXhUUEV2WENqTk1zWWQ2Q3FtTktWbW9xMFVscHZRQ1BZRXF4aFRIMGcyMm1HSWY5UVJtTnFic1F0MmcyR05LMmRmREMySk02WVc2eVFSak1qMjhER01tdWxHTktaNmxCemZ5TVdVVDZFYVdoeWtyUGJnYVU3eEt0MG9PR0hQVVExdGd6RHJVelpJOXB1d3JQYkRDdzVTeTBCMkdEcWJNOU1CMk5vWTRJOTBqeVRERjdldHhlWmlTaGJwTGY0d3BXYTRIbGRTWVVrYTYwOFRGRUNmU2d4cTVtRExSdllJVnBteHlQYVlWcHRTaDdoYjVtRExUUTVyWW1KS3FBek1mUXdhRkhsQlJZb2cvVXhmeUdsTjJla0JUVEtsRGRhSWZZNGdmNmVIMFN3eUpJM1VrZFRCa2xlalJ6REhFU2RXVjVJQWh6a2dQWnVoaXlEcFVaNUk1aHV6MVlEWVkwc3ZWSWF2RWtKMGV5Z3hEeHBHNkZCNHhKQzcwUVBvT2hoelZzYldMR1dzOWtMV05FZlloVjhlcVBXYlkvZ094TVdPZXFITld6TnVOeHBZTVNCM2VidUtrTWlHWjhuYVRhU2dqa295M0c5U0pEQ2w2dkYydEY4Z1l5K0h0V3FrTW1qaThYY1ZieUtSd3g5dFZaakpzN2ZMV21yMldhZUdLdDlicVJNYmxHOTVhNmhYNkE0cVl0MVlHdWY0SUsrYXRoVExWSDJLVnZGMVVCdnBqUm1QZUxuQkcrb05Tajdlem5FcC8xS0xrN1F4L29UOHNkWGhyNUZiNjQ0WWViMDBXK2d0R1BtK25WZm9yaGlWdko3Z0wvU1dwdzlzWGZxVy9aakhtN1JObm9iOG50RHplUG5BcS9WV2ptTGZmbENQOVpWYkoyeTlsb0wvTzZ2SDJuMTZxQjFBTmVQdGhudXNoNUV1WE45eXMwb01JdDd5eEMvVTRqZzdmWERuUkl3bEhEdC9iU0E4bTdmR045Vkk5bktUbTI2b0RQYUJnNnZFdE9kTkVEeWxNUGI2aGNScnFVVmx6bTIvR25sdDZZUG1CYithUTZMSE54bndqNDJPdUJ4Y1dHNzZOWHFRblVLMDl2Z1ZubmVzcEpKYkhOeENub1o1RmxMbThPTCtPOUVUQ0dTOXVGdXE1cExYTDY2cFRQWjF3NHZDaXlrbW9aeFF0ZlY2UWswVjZVdUVvNXVXVW8xRFBxemlVdkJSdlhlaXBoZjBOTDJSVGhYcDJ5YkhIaStoTkFyMkNjT2Z6QXB4ZHFGZGhMWDJlbkpkWm9WNUhhUFY0YW5zcjFHc0pKaHVYSitWdUpvbGVUemlNZVVybE1OUnJxbVo3bXlkajc3ZVZYbGMrODNncTdpelJhK3Z2OWpaUHd0M3YrbnA5NFhEQVU0aUhpYjZIWUZnN1BEaW5IaWI2UHNKKzV2TEE3Q3dLOWIyRTFyVG44cGg2VXl2VU54UmFOUStvdGtKOVc5RnM3dk5BblBrMjB2Y1c5ZzgrRDhJNTlFTzlxUmd1QnpaL21UdFlEZ3U5L1NkTU01ZS95TS9TVUc4ZjlDZlp3T1l2Y0FmWnBCL3E3YXZRT25qOFllWEJDdlhXS0U5bjJjRGxqN0FIMlN6TjlYWkpHRTFqakl1blVhaTNscEpvdUY3Rk5tYU1WOU5oRk9ydFdzVnViOU8xL2E3UTI4Mks5RGpONXJITDNkeDRuazJQYWFHM0R1VHBkTzV4TTI4K1RSTzlkU3Vzck1WeHVxeDdZOCtsQmRlTGUvVnllbHhZVmFnM3MvSm9OTmtlc3ZrK0huc3V2OWhPR2UvbjJYbzdHVVc1bnRML0FFYytjWFdOeVB1ZkFBQUFBRWxGVGtTdVFtQ0NcIixcbiAgICB2aXN1YWxfZ3JpZF9pY29uOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFYa0FBQUY1Q0FNQUFBQk4zYW9QQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzQUFBQTdBQVdyV2lRa0FBQUIxVUV4VVJVZHdUUC8vL3pnNVR6ZzlUencrVVRjN1VEYzlUemcrVURjOFVEYzhUemc3VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzdVRGc4VHpnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURnOFVEZzhVRGc4VURjOFVEZzhVRGc4VURnOFVOQ042VWtBQUFBbWRGSk9Vd0FBQXdnUEZSc2dKU294T1VCSVQxZGZabTkzZjRlUG1LQ25zTGZBeWREWjRPYnI4UGI4TTRRbTh3QUFFM1ZKUkVGVWVOcnRuZGVDNHJ3T2dIMmNYa2lCaEVBcUtmYjdQK0s1Mkg5MkdRWVlTQ1RpRXQzdmh2bWlXTElxSVJJSU5RelR0Q3duaU5Lc0tKdW03Uzc5TUU2TVRlUFFYN3EycWNzaVM2UEFzU3pUTkF4S05sa3FodVY0ZnZpSDkyVmsvRGNaTDAxWlpHa1VCcDVyR1J1L2VYcHUrN3MwSzZybU12SzNaYnEwOVNsTEk5L2VRTDRscHA5a3Azbk12L052cWxNVys1dnl2NmJyZm5wcUxzUEVPSXhNdzZVcEVtK2ovNXk2bDU1NkJzWDhTaGk3bkZKM0EvekFsa1pGeTFHbFBVYWIzYjA1MTczZDRkd3hqaTZzT3g5QzE5eUkvOUYyUHlucW5uOU1MdlV4Mll3dUlXNXlhZ2ZHUHlxc2IwK0pvL1Y5eTR4T3I5eVBNT0NQWFJGcHlwNGEvckhqcTBxWCsvcEZHa3czS1JsZlhZWXk4YlN5dDg3dTJFeGNDR0hOTVhJMXNiZUd2eTh2WEJ4aGx5b0xkQUFmRnQzSUJaT3hLM2FLNjcwUmxSUGpBZ29icTBqZEE5OXcwbHBJN1A5Sms2b1pXakQ5dk9XQ1M1dXBkN2sxQXZHNWM4Nm5KdlBWQXUvbDdjU2xrTEU5ZU9wd3R3NmRKTnc1NTN6cTlvcmtFTTJrNDVKSkd5dHczRnRoT1hIcGhKV2hKYm0raDhXRlN5bjlNWkRZdnpmOFk4dGxGZGJtdnF5QlRQUFFURnhpR2R1OW5Hb2YxbEp6NTV6enFRN2x5M3ZZT1ZkQitreXlyS0VWQ3gyaGVlZTRyM1l5SFRuQnNlZkt5S1dReHRKYWFUdHhsYVJPNVhEdS9YTGthZ2tiVG80RXBuWFhjUVdsRmQ3SnNmT2VLeWxUWm9sODJwdEJ5UlVWeHM2aHVHRTArOUJ5ZFlXSmU2VjFUeU5YV3ZwQ3pNQzlYekd1dUxCR3dNSWNRMDJmNWxZRzRYSW0xbjdpV2tpL0YrdFc1ZVFqMTBTR1FxUU11WC9XQmp6blU3MFRCdnl1bWJoTzBpV0NnRThZMTB5R3ZRaDIxc3dtcnAyTXgvVTllL3M0Y2gzbHZMYWRkYzhUMTFOV1R0SDZEZGRXMm5oTjhEM1hXQzZyb2FlQjF1QTU3Nk8xSWpVdDExeUdWZERUU0h2d25JOXJIRGdiZU00NUgvY2ZCeDlmTnV5Y2N6NGVQZzErM0tEL0YwQkxQM3ZHYnhyL0QvMEhaNFlZMnhuL3pjUDVXTlNZYnU3a1NuNTlzSUcvRGRoL0JyM2ZiNmh2aEgyaytHOERmMDhhL05aeHA5NHczNU1TdTlyWU9yR044bDBwY0V2L2pHeTdRVDFFajVxYlRZZU44RU16bXlIZXFLSk40NSs1OVhqRklPRjJ4di9pMWlOcHZjNUoxOWVrRFZIUU85cVdHYnd1TlVZdGlIWGNEdm5mcmV3SjNyYzA5aHY0RjJUSzRLdFd0NlBtTmZUUURvNFAzeEhDTHV0TEQ2OVBIYXlWZFN0NDdhaDhiM1VKNGFOUXJJUzBzalpDdEdhdE1xSHZTWjQ5L0tWOHpPR3NySGxBc0s2RkVQMUdGc0lVL0FFdUo0NlJoT29FR1NTd1ExQ3FEdXE4c1JGYTZ0bVJDREpHNElUZzRGUXdZVXVLTVJlckZXYjhyNE9SWTh0QjBPOFFmaG83RUdFa1JZZ0REakhBRisxajlIYlhBclh6V2dqNVRWWXYvNll0bExrcElvMFBvQkZDdW1kYTdMclJGQ05jVXdnMXBNZkNNTEtMenh1VXFxWmVzS2xnS01NeTZtVi9wSFZFQ0pSTkI4SG1aWmdGUmpnd1g2TDBOTVp3dVdyaGxocWdlQkg5a2tKWEc2T3NhVWpGbXdkMlFNa05Mamh2Y295VWR5M2cyRTBUdzV5eGZINnRBVWN4K2tSQVFTbXJ1TXc5YjB5VUVzb3pFVkl3UE11NXhaYkdBY1BpOTRMdWEvSXgrby82ZVNZTnA3em1JQ1o0WWh4UWJOb2NwVGN4WEhraHpTdWVvckhwTU1PcEQxRjZjbmFpZ2ljVXBheWxlMzhDa1ZWZytGa25nUWU1bzF4ZVpvU29RZ3lMY3hGWDVRbFNkL1gwYnRiVHhBZ09UMGVoVjNZWUtBSHg2czNQUE1Fd3I1M2c2N1k5akw2TThiMUtCQXNqaElUYVZBRWlHY1pmWGJ1clI1QjY0VmZVbUJoWG1MZktiendNbFo5aTBjRVRHazhZU3Y5NlZOeklNVTc1a29ndjlobmxwSDg1aG9DU0Fyd0VFcEFuS09OalhvNGhtQ2dxbjBteFp0Z3NFTUkzMDZzanQzd01sVzhrMlNrZllDaDlaNzU0eXZNVlgvdnFncEtIZXkwNzVTQ29QS3RjV2NoYktJSDZsd0puS1laUG14QnBKTUpRK2xmU0VnWkd5TzRzMDQ1VmpQQk40NnoweW4ySndLUE1UbnJsSWx1dVptQkV1Y2lpdUJqVnJ5ZDlpT0RMZDBRdXdVZ01YbjZiUm1FZzNDVEdSREx5eGhvZGVSZ1ZocVVsR1huaUluZ1p2eVVuRU5MQTM3K3ovNGtuOXp4cmVBenNlZmpFUWJDdjMwZXJ5VUhlUU9oNWI1NTYxanY0Qzl4TjQ2c2M1S21QNEZzL3kwK1lSL2lQN0VoRUozLzNWU0I0bHVVVDc4YUZkNmRhVjA3eUNKbm82ZkY5a2lKVUhDU3lZZjg2ZmhCWUhEOVpjRktac3BKSG1EbHdlUml3UlRBckxwR1ZQSW5Bd3plUEYyUEEyOWVqSVM5NStCSE1ySHJnV0pyZ1JxWDFpTHprRVVwTEg5MWpJL0NBemNHVW1Ud0ZqMkU5Mmo0RjNpcjBvNjVOTHZMRWdWYjZCMVhzTHZSemhwVEtTZjR2ZlBERTZQMEtqQVE2U2xUL2VJUnM1QWwwekhLOE56YlBnRGJsNDA1KzhnRzBOdDdySUFDdmJ5b2tCditGMzRCMnRPOFYraVhBWmZ1ZDh6SjUvbmw1VmZHRER2MGdBQzhvdkpNQ2xKQzhrUUdIYjM3T1h2R0FqY205WEx1RTVJa0hITDZ0ZjVBSG50QTMzdXNDbEpFOGRINlVPVC9TN1IrNE1qd2ovMEhEK2ZyakNJR2Z1M0Y3amJWZ215VzZ1NDJ2VXBLSEhzQlMzYWErUVczNGc4WlhPY2tEUjFWR0c3T2FzcitmQXBDVVBIQmQ5MDBpdkVBOXkxNGtQOGRLenZnMzc1SUhEdDk4djJGUzBBdHNTOTY3dm9wT0huWVdSZmZOK2ZDd1BVcVJ5VC8rb1gvYlpDSHY5LzIzQXFROTZPZGtLRWFlV0dkQU0vZzlQUUxwVTk1TmViMU0vbDByK1JIeW9HMnk3SHJrRFlXOHdONmRmU3M1ZWREaTl1dDRaUUQ1Ly9wRVBmTEVCVHpwcjllMTd4blNLYVlNZWNqcEo5ZU5rbkMzTlBhZ0gwaDY4Z2FjMzMxVlNRODQxbVdLaUpya0lkY2ZuZjk2OUlEelNjK0dxdVJOdUd0KzQ4RW5BdG1qamhUNXlRUE9vdmgzbHdMTGVMR0hjeVVVSUcvQXphTDRDcHBSc0hxUHg3TnZGU0FQMkNiN1pXSnRxSGFzOGZFK0dXbklQMnNPQjJ1VC9kcFpEZll1ejQ4YlgxVWdEN2Z6cTdGZ0d3S2ZOWmdyUVI2czJ2b3JMd1hVZHN0T1QzNnpHdVRCeG5IOENTb2FRSk5KTzM5dUJaODg1QjBnLy90UDJ3N1V2UE9NcUU4ZUtuenpKeVBvd0xnMnJhVURlUnZHRzJrSVlQMWFTSFFnVDJHNkRBYkFxTTJaYWtFZWFuNnVSUWdoSWNSYkhEeWlCM2tDczBveGdISlNwOXlVbC96dnJXcnd2VFVKSVlSQzFQSDg2N3hTbmp6TWFMOGN5SjBmLzJXOTFTY1BNb0NsSklRWUFPNThZeEdOeUVQMHluY0VaSXZPOVRZRkRjaVRIY0FwWVlBa1lTdWlGM2xqdVdjNXVSQTF5b092R1hrYUxEYXlVMENJdGRpZHo0aG01SW01T0RFNDdRaHhsdjRuamEwZCtlV2JXS2FZa0dCeE9wZnFSNTVtQzA4S2xpNi93cFkyMFkvODRwZ2xPeXh1UmVsam9pTjVraXc3cEZtK2RGZmVqOFpYWGNqVFpkbHdWaXp0VGZ1eG4wc1g4c1JiZE5Lejg5S2tiazUxSmI4d2ZGTVJzc2hVVEpTb1RQNHBmM3VSWjFrdkk4OWlvaTk1bWk0cFIyME1zdVRObFVSajhzdUc5VGNtV1JEeTdFT3R5Wk5rUWZpbXNjaUNnRmx1NmsxK1NadHNZNVA1NzYxOXUvSDFCZkp2VWx5VlBBbm53MnNjTXJ0ZWpXVkVkL0lMWm1pM0hwbDlJYmkvMDEwcDhyL1hkYzlXK3NZbmMxMmpNU1ViZVJLeitVZjEzSC82WUpiNkV2SWZFa2p5dFBvOCtacHM1QW1oNVh6eXMwK2JlQ08vWUx4Y0d5eXdzTlpHM3BoOUQyMzkrVjdsc0RlMHQ3RHpreHV0dCtBbVZYdTZrL2ZtQndBYVowSDBZTW9NdmNrdm1hTGQyRXNpWm9Pck4va2xNN1lhYTFHVStDUUdlYlRBM0M4WDJDVkZmbzI1TENjVmFFeWV4a3N5c1kyeGJJbEpZK2xMZnRuODBIcHBCdnlnTC9sbE16NnJwVlVmbmE4cmVXZFJQVEU3TDY1MEtxaW01TThMdVMydTdydWQ4YThMK2QyeU9WZ3NYMTdSZWxQZXB3bjVwYU51MkdGNUZmY0FXOFV0QjNtNkI2amlkaGFTNTdXcEgzbC82WFNuS1FibzF2aytzRThMOHViaWFZZlREcUpEalptNmtWOCtwR01LUUxveVQ0WmU1QUdhdHljWHBCUDVlcjJGRHVRQmhzYVBCa3ozL2RVQWJnM0lRd3pRYnFFbVR1eDFJZyt4bEtVRW1yTEMvaVVHMVNmdlFjekF5c0hHWC80ZHM2SThlUXF5Y2lRbGhKQVFZQkkzK3h1elZKNzhEbVREWWdnM1Y3MlFsL3hiWTh3c21NMGdGaUdFZUNBYk5NWlFDL0pBNjlSR1NnZ2hMc3lFNlU0TDhrQVQ0MXZJNytlL0JabUtrMDlobGlTY1FDZENYMXoxeVpzOXBKYVNGR2JOeUhRMGZ2dmhzcE9uVVB0MVF0aDFoRjJvT25tb2xlQ2pBN3Z0Z2hXVzJ1UXRxSVVzWDJWS2NCdGVkbXFUMzBOdmVJRmJHMWhaS3BQM3dKWlMveTNDQnR2a3hST0Z5UnNIcUxWYjdHL1JBTnlhNjg1V2wzd0F0aTN6Mzd3SXdJMk5oYkxralNNWXBIOGJHdzI0TGFYUGphek01QU80cmNoWHhXRndDemg1YlNoS0hrNDdyd2RHSkhEYnFJZVVLa2sraFZQTzYwR1RIdVFHZGxkRjhuWVBSK2g2T28wQloyS3Y5eStvUTk0NEF1cm10MVhwY0N2WU9lODg5Y2lISFJ5Zjd5MEhnS2NZWnpsVmpieDFBbFQ1NytOcFhBNHAzb2ZKdi9sdjNpY2ZEWUIwYnVidXRaQksvOWl6bEpPOFhVTHFaV3NCRGVTNko2bGE1Qk5RT0RmWC9JaUJ2bFpYSmZKMkIwcitaaTZRQy9xL3MrTXM4aCtTZDhuRG5nZWpCZGpELzVQOG84U2dqT1NEQ1pSOCtTUDR6R0VQTTFNVjhyVG11RFl3dklEKy8zMUUxU0JQMHhFVXpPVGNQc0VGZnJXbDlSNzVEOHZMNUtHNTFEODAwand5MkhlYktFSGVPTUNxUE04bzZFanZ1K2VOb1FKNXY0Vjk3aGppUDRNZkZTQnY1TURQclIyc0xjdlhybVVBTTJzTFhkQVc2TnhUeDNzK1h3TDhGRmFhc3BNM1NtRHdOME1pdmtibGROQ1BTV1FuSDBNZmNvMlBXaWo3VitrclYyN3k0THJJVHZjdm1CSDBHNTcyVkdyeXdJNDI1OE9ESUM2RmZzVzg5V1FtSDRMejZBS1VmV3gzN3cyR3ZPVE5nb0VmdithamE4TUFUYjczcFNWUG93djQ2WnQrekluaXZKS1d2QTBQbzNNZXh1VVM2Ty9yZHJPZ1JPU2hyemNQYnZWZlY3WUcvR2tYUzFqeVNOc1VIa3Z3cE9rUTNJL2lVMDZKakFMdmJkeWV2SEFUMWQvMXBJUVdEeDQ4ZTlwUTQxYmdENXdLVXo3d0pyeDU1ZTNUZmhvamc3Y3IvVTQrOGdqbWxlZlBHN1VEQk1OeXRtUUQ3OVFNM3RYNHJVKzdnSDhtajJRanY1OFE5TS8rNWFFN2hPK3NsZXlrOStHZGE5Ny9xbjRHdkkzOWIxNmFOR0lnZUpTc2RINnZXRVlnUC9veWtRL2dYZXZuN1dOZkRoWENwOFlyUXlMeVp3UUFqZlBDZzFPRUJ3K3hQT0FqQkIrREgxNjV5VnN0d3BOclI1cFR2c2ZRdkpmK2ZDTkQ4S251TDlZVVVHaUdvZkxaZWs3VlZhKy9mdWIxbDhBQmJnaUJzMHdLcFRjTGhBK2VwUy9mSkRCTytrRUtwWTh1NnhxNUE4S0w1MmNKd05zWUh1V1l2cDZpOEJEaVpqS0VieWlHUjNtbjRPdFp5SWl2YUdkV1ZIa00zMkpJMzhuSzJSZ25QY3RFSjMvQStLdXI5NjR5TVlaWDJ3cWVHSVN2TitLY2o4bWJON2tTNC9VTG5oakUrSnQ1K2E0M0hXSmNvaTlDSndiakVVUGJ3bmQvaG5YRU9HOUVUZ3hhTlFiNDQ0eHJOSWFSSFdOaHEyK01QY1lwMzdydi94SXp4L2o0eEUwTW9rU3J4blNPcHFIRUVINnViQmNsWUlNUm9lV1ZPK2UzVUl3TVBHZXVtT1JkREkraW41a1FNakZNRGo4TEdiT2tKd3d0SytmZTJsRThTekVUZ3lHR2tuWGg3TitEa1orWnJ3aVlBUnVjYU1uOHo5dkJLTDRaOStKNWxobUd5dGNMVkl6dVVCSUZ3dVZJZkl5bytMZ29TbVVXR01wd0VNM0lGaXRtdlI5cUEwSlY3YlA1dWV2a1F4QlVudFVMQXlVMHhiaFRuOFFLMkdDa0FQdkZjUklMdzlHZFJJcFowaGhCdWNaOGVaakV3WEM0T29IQ054Z1hSZ2JpUllRWUZTZ0NoVy8yQ0pac2lFQThaNHo3VkNkTVhiY2xzR0paWjNqMDAxR1E4OGJBc0dNbDBCOUhRNFNqdmhQRXlFWUlLdCtDZmRBWTZScDJFaUl4YUZjSVhZQVJYSGpFUkxqa2paRUk0WnM5Zk9KdHlpRVBVb3ppcTFxQWs5NUQ4Q2dyMk54UGdIR1ZWVkxhRUZnNzRuNkQrcElubjBCL2x6aEZFZXBKRG4rR1doamRGTXBKYVVsaWpWU1RCcWNGY3RkdGFIL3g1TEd1aDhsMjFEKzNyZ2RUb251SFFqSWQ4YW9xak9QRzk3R2NNUHZjVVhybkZKSGFsdTY2cmNqZEZidWdJbXczeUhlajN2aVZ1dkZsdzN3SGZFandaWXZnM0hIa1A5TmxIVzF1L1kxOExOY1FiVzc5ZC9sY2tpZmUwRjhKKzJSSHdIYVp2VHBxUGp1dTZyQ0ZqTCtDTmRtSHM1cnBodjZQeG1jZnI2SFlQQnpPT1dmN3orZng2Vzd6NnptUFYybkNpRHFtKzFHejFwaXFTUE1Zem1XOVlxMncwUmw4dDJhVm5GL3FDNzROeVpyaUZMcUNyOWFldEd3V2VwclpZdjNPVWlQVDBMc2NqeUxVb05ORXV6cWNQaGRrS3BodTN1VmxMOG80TmhyV09oMzJ6VTZjNlFIVU8ra1RRQ3NkSXRLd0Vwd3hZQ0lHaFhQaEJqOG1Xa1J4MmtUQTRZTmhxWHlpYXFwQ0lxQlFMMWM4WkgvSkJSMDhTTXhVYWMrK2pRUWVhTzFWeW5KbnBTLzBYbTBqSDVRMHRBeXhLd0VLZlZ3cjZGK090UXc3YnYxQ09VUGI1eDZWZ0R5eFlzV0s3T3RZbHRYQzFNa1ZpaHlQbVVXSk5FSjNyU0tHbHRVQmtVdWNYSVVPQjlabE5wRk9kcVgwUjA1ZmhnYVJVSnhVYmdkenJHS2J5Q21HYzVBM25NRGExQ1h5Q3JWbG5SRENqaTRsVWdzTnExRTZONGVOWlVqa0Z5dXQ1YnJVc3FGS0RLS0V1R2s5eW1SWVU0Y29JNTQwYmc2clU5a1ArRnMzWnkrRm05T21qbExjQ1NHRW11SUhjNGJNSmtxS2ZXZ0dnZTFxYzNDSXN1S2tsYURobkw1VThKejVydmRSSVdCaHp1VWNLYzZkRUVLdElCT3J5WWUxZVdnVExjUXc0MUljSjdOS2JJUG9JOVEvWHFiVlR4MDJkY2VBYUNkdVduVnJoblRZMENsMVczMUh6R0IvYWxhS0t3ek5LUTFNb3E5WWZuVDhmRkJuckkreHJ6UDIvKzYyemk3L1pNL0pWR2VoWTFLeUNTR0VVbWRmZlVUenh6SjE2RWI5NW80VkYxMlBaM0xaMkxkRmJHMmM3NS82NGI2b1cvaWFXRGEwZGJFUE4reFBEeDRuVExKekF4ZldaSDF6eXBMUTNvNllWKzY0bGhmR0dZRERPVGFuTEE2OVRkZmZEREZZZHBBV2MrUEtZM3ZhaDQ1bEdwdXV6ei84Z3lRdnUzR2Fwb2t4eGg0WUFjWVlZOU0wVFdOYjVtbG9iY0RCUGdFMzJNWHBJUy9PVmQwMFRkTzAvMG5UTkUxVFYrY2lQNlR4TG5DTmpSWHVRZVI0ZmhBRWdlODV0bVZLU2Z2L2pkRURONHFGc3JvQUFBQUFTVVZPUks1Q1lJST1cIlxufVxuLyoqIFRPRE86IFJlcGxhY2UgdGhlc2Ugd2l0aCBTVkcgaW1hZ2VzLiBDYW4gY29tcHJlc3MgdGhpcyBkb3duIHRvIGEgZmV3IEtCIGluc3RlYWQgb2YgNzAuICoqLyIsImltcG9ydCB7IGNyZWF0ZUFwcCwgaCB9IGZyb20gJ3Z1ZSdcbmltcG9ydCByb3V0ZXMgZnJvbSAnLi9yb3V0ZXMnXG5pbXBvcnQgSWNvbnMgZnJvbSAnLi9pY29ucy5qcydcbmNvbnN0IFNpbXBsZVJvdXRlckFwcCA9IHtcbiAgZGF0YTogKCkgPT4gKHtcbiAgICBjdXJyZW50Um91dGU6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICB9KSxcblxuICBjb21wdXRlZDoge1xuICAgIFZpZXdDb21wb25lbnQgKCkge1xuICAgICAgY29uc3QgbWF0Y2hpbmdQYWdlID0gcm91dGVzW3RoaXMuY3VycmVudFJvdXRlXSB8fCAnNDA0J1xuICAgICAgcmV0dXJuIHJlcXVpcmUoYC4vcGFnZXMvJHttYXRjaGluZ1BhZ2V9LnZ1ZWApLmRlZmF1bHRcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gaCh0aGlzLlZpZXdDb21wb25lbnQpXG4gIH0sXG5cbiAgY3JlYXRlZCAoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50Um91dGUgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVcbiAgICB9KVxuICB9XG59XG5cblxuXG52YXIgYXBwID0gY3JlYXRlQXBwKFNpbXBsZVJvdXRlckFwcClcbmFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy5JY29ucyA9IEljb25zO1xuYXBwLm1vdW50KCcjYXBwJylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n')}]);